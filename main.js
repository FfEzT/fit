/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// main.ts
var main_exports = {};
__export(main_exports, {
  DEFAULT_LOCAL_STORE: () => DEFAULT_LOCAL_STORE,
  DEFAULT_REPOSITORY: () => DEFAULT_REPOSITORY,
  default: () => FitPlugin2
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// src/const.ts
var rootFitFolder = "_fit";
var conflictReportPath = rootFitFolder + "/report-conflict.md";
var conflictResolutionFolder = rootFitFolder + "/conflict/";
var basicTemplateConflict = "<<<---";

// node_modules/@octokit/core/node_modules/universal-user-agent/index.js
function getUserAgent() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && process.version !== void 0) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}

// node_modules/before-after-hook/lib/register.js
function register(state, name, method, options) {
  if (typeof method !== "function") {
    throw new Error("method for before hook must be a function");
  }
  if (!options) {
    options = {};
  }
  if (Array.isArray(name)) {
    return name.reverse().reduce((callback, name2) => {
      return register.bind(null, state, name2, callback, options);
    }, method)();
  }
  return Promise.resolve().then(() => {
    if (!state.registry[name]) {
      return method(options);
    }
    return state.registry[name].reduce((method2, registered) => {
      return registered.hook.bind(null, method2, options);
    }, method)();
  });
}

// node_modules/before-after-hook/lib/add.js
function addHook(state, kind, name, hook2) {
  const orig = hook2;
  if (!state.registry[name]) {
    state.registry[name] = [];
  }
  if (kind === "before") {
    hook2 = (method, options) => {
      return Promise.resolve().then(orig.bind(null, options)).then(method.bind(null, options));
    };
  }
  if (kind === "after") {
    hook2 = (method, options) => {
      let result;
      return Promise.resolve().then(method.bind(null, options)).then((result_) => {
        result = result_;
        return orig(result, options);
      }).then(() => {
        return result;
      });
    };
  }
  if (kind === "error") {
    hook2 = (method, options) => {
      return Promise.resolve().then(method.bind(null, options)).catch((error) => {
        return orig(error, options);
      });
    };
  }
  state.registry[name].push({
    hook: hook2,
    orig
  });
}

// node_modules/before-after-hook/lib/remove.js
function removeHook(state, name, method) {
  if (!state.registry[name]) {
    return;
  }
  const index = state.registry[name].map((registered) => {
    return registered.orig;
  }).indexOf(method);
  if (index === -1) {
    return;
  }
  state.registry[name].splice(index, 1);
}

// node_modules/before-after-hook/index.js
var bind = Function.bind;
var bindable = bind.bind(bind);
function bindApi(hook2, state, name) {
  const removeHookRef = bindable(removeHook, null).apply(
    null,
    name ? [state, name] : [state]
  );
  hook2.api = { remove: removeHookRef };
  hook2.remove = removeHookRef;
  ["before", "error", "after", "wrap"].forEach((kind) => {
    const args = name ? [state, kind, name] : [state, kind];
    hook2[kind] = hook2.api[kind] = bindable(addHook, null).apply(null, args);
  });
}
function Singular() {
  const singularHookName = Symbol("Singular");
  const singularHookState = {
    registry: {}
  };
  const singularHook = register.bind(null, singularHookState, singularHookName);
  bindApi(singularHook, singularHookState, singularHookName);
  return singularHook;
}
function Collection() {
  const state = {
    registry: {}
  };
  const hook2 = register.bind(null, state);
  bindApi(hook2, state);
  return hook2;
}
var before_after_hook_default = { Singular, Collection };

// node_modules/@octokit/endpoint/node_modules/universal-user-agent/index.js
function getUserAgent2() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && process.version !== void 0) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}

// node_modules/@octokit/endpoint/dist-bundle/index.js
var VERSION = "0.0.0-development";
var userAgent = `octokit-endpoint.js/${VERSION} ${getUserAgent2()}`;
var DEFAULTS = {
  method: "GET",
  baseUrl: "https://api.github.com",
  headers: {
    accept: "application/vnd.github.v3+json",
    "user-agent": userAgent
  },
  mediaType: {
    format: ""
  }
};
function lowercaseKeys(object) {
  if (!object) {
    return {};
  }
  return Object.keys(object).reduce((newObj, key) => {
    newObj[key.toLowerCase()] = object[key];
    return newObj;
  }, {});
}
function isPlainObject(value) {
  if (typeof value !== "object" || value === null)
    return false;
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
function mergeDeep(defaults, options) {
  const result = Object.assign({}, defaults);
  Object.keys(options).forEach((key) => {
    if (isPlainObject(options[key])) {
      if (!(key in defaults))
        Object.assign(result, { [key]: options[key] });
      else
        result[key] = mergeDeep(defaults[key], options[key]);
    } else {
      Object.assign(result, { [key]: options[key] });
    }
  });
  return result;
}
function removeUndefinedProperties(obj) {
  for (const key in obj) {
    if (obj[key] === void 0) {
      delete obj[key];
    }
  }
  return obj;
}
function merge(defaults, route, options) {
  var _a;
  if (typeof route === "string") {
    let [method, url] = route.split(" ");
    options = Object.assign(url ? { method, url } : { url: method }, options);
  } else {
    options = Object.assign({}, route);
  }
  options.headers = lowercaseKeys(options.headers);
  removeUndefinedProperties(options);
  removeUndefinedProperties(options.headers);
  const mergedOptions = mergeDeep(defaults || {}, options);
  if (options.url === "/graphql") {
    if (defaults && ((_a = defaults.mediaType.previews) == null ? void 0 : _a.length)) {
      mergedOptions.mediaType.previews = defaults.mediaType.previews.filter(
        (preview) => !mergedOptions.mediaType.previews.includes(preview)
      ).concat(mergedOptions.mediaType.previews);
    }
    mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview) => preview.replace(/-preview/, ""));
  }
  return mergedOptions;
}
function addQueryParameters(url, parameters) {
  const separator = /\?/.test(url) ? "&" : "?";
  const names = Object.keys(parameters);
  if (names.length === 0) {
    return url;
  }
  return url + separator + names.map((name) => {
    if (name === "q") {
      return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
    }
    return `${name}=${encodeURIComponent(parameters[name])}`;
  }).join("&");
}
var urlVariableRegex = /\{[^}]+\}/g;
function removeNonChars(variableName) {
  return variableName.replace(/^\W+|\W+$/g, "").split(/,/);
}
function extractUrlVariableNames(url) {
  const matches = url.match(urlVariableRegex);
  if (!matches) {
    return [];
  }
  return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
}
function omit(object, keysToOmit) {
  const result = { __proto__: null };
  for (const key of Object.keys(object)) {
    if (keysToOmit.indexOf(key) === -1) {
      result[key] = object[key];
    }
  }
  return result;
}
function encodeReserved(str) {
  return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
    if (!/%[0-9A-Fa-f]/.test(part)) {
      part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
    }
    return part;
  }).join("");
}
function encodeUnreserved(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
    return "%" + c.charCodeAt(0).toString(16).toUpperCase();
  });
}
function encodeValue(operator, value, key) {
  value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);
  if (key) {
    return encodeUnreserved(key) + "=" + value;
  } else {
    return value;
  }
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isKeyOperator(operator) {
  return operator === ";" || operator === "&" || operator === "?";
}
function getValues(context, operator, key, modifier) {
  var value = context[key], result = [];
  if (isDefined(value) && value !== "") {
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      value = value.toString();
      if (modifier && modifier !== "*") {
        value = value.substring(0, parseInt(modifier, 10));
      }
      result.push(
        encodeValue(operator, value, isKeyOperator(operator) ? key : "")
      );
    } else {
      if (modifier === "*") {
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            result.push(
              encodeValue(operator, value2, isKeyOperator(operator) ? key : "")
            );
          });
        } else {
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k])) {
              result.push(encodeValue(operator, value[k], k));
            }
          });
        }
      } else {
        const tmp = [];
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            tmp.push(encodeValue(operator, value2));
          });
        } else {
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k])) {
              tmp.push(encodeUnreserved(k));
              tmp.push(encodeValue(operator, value[k].toString()));
            }
          });
        }
        if (isKeyOperator(operator)) {
          result.push(encodeUnreserved(key) + "=" + tmp.join(","));
        } else if (tmp.length !== 0) {
          result.push(tmp.join(","));
        }
      }
    }
  } else {
    if (operator === ";") {
      if (isDefined(value)) {
        result.push(encodeUnreserved(key));
      }
    } else if (value === "" && (operator === "&" || operator === "?")) {
      result.push(encodeUnreserved(key) + "=");
    } else if (value === "") {
      result.push("");
    }
  }
  return result;
}
function parseUrl(template) {
  return {
    expand: expand.bind(null, template)
  };
}
function expand(template, context) {
  var operators = ["+", "#", ".", "/", ";", "?", "&"];
  template = template.replace(
    /\{([^\{\}]+)\}|([^\{\}]+)/g,
    function(_, expression, literal) {
      if (expression) {
        let operator = "";
        const values = [];
        if (operators.indexOf(expression.charAt(0)) !== -1) {
          operator = expression.charAt(0);
          expression = expression.substr(1);
        }
        expression.split(/,/g).forEach(function(variable) {
          var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
          values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
        });
        if (operator && operator !== "+") {
          var separator = ",";
          if (operator === "?") {
            separator = "&";
          } else if (operator !== "#") {
            separator = operator;
          }
          return (values.length !== 0 ? operator : "") + values.join(separator);
        } else {
          return values.join(",");
        }
      } else {
        return encodeReserved(literal);
      }
    }
  );
  if (template === "/") {
    return template;
  } else {
    return template.replace(/\/$/, "");
  }
}
function parse(options) {
  var _a;
  let method = options.method.toUpperCase();
  let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
  let headers = Object.assign({}, options.headers);
  let body;
  let parameters = omit(options, [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "mediaType"
  ]);
  const urlVariableNames = extractUrlVariableNames(url);
  url = parseUrl(url).expand(parameters);
  if (!/^http/.test(url)) {
    url = options.baseUrl + url;
  }
  const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
  const remainingParameters = omit(parameters, omittedParameters);
  const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
  if (!isBinaryRequest) {
    if (options.mediaType.format) {
      headers.accept = headers.accept.split(/,/).map(
        (format) => format.replace(
          /application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/,
          `application/vnd$1$2.${options.mediaType.format}`
        )
      ).join(",");
    }
    if (url.endsWith("/graphql")) {
      if ((_a = options.mediaType.previews) == null ? void 0 : _a.length) {
        const previewsFromAcceptHeader = headers.accept.match(/[\w-]+(?=-preview)/g) || [];
        headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
          const format = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
          return `application/vnd.github.${preview}-preview${format}`;
        }).join(",");
      }
    }
  }
  if (["GET", "HEAD"].includes(method)) {
    url = addQueryParameters(url, remainingParameters);
  } else {
    if ("data" in remainingParameters) {
      body = remainingParameters.data;
    } else {
      if (Object.keys(remainingParameters).length) {
        body = remainingParameters;
      }
    }
  }
  if (!headers["content-type"] && typeof body !== "undefined") {
    headers["content-type"] = "application/json; charset=utf-8";
  }
  if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
    body = "";
  }
  return Object.assign(
    { method, url, headers },
    typeof body !== "undefined" ? { body } : null,
    options.request ? { request: options.request } : null
  );
}
function endpointWithDefaults(defaults, route, options) {
  return parse(merge(defaults, route, options));
}
function withDefaults(oldDefaults, newDefaults) {
  const DEFAULTS2 = merge(oldDefaults, newDefaults);
  const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
  return Object.assign(endpoint2, {
    DEFAULTS: DEFAULTS2,
    defaults: withDefaults.bind(null, DEFAULTS2),
    merge: merge.bind(null, DEFAULTS2),
    parse
  });
}
var endpoint = withDefaults(null, DEFAULTS);

// node_modules/@octokit/request/node_modules/universal-user-agent/index.js
function getUserAgent3() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && process.version !== void 0) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}

// node_modules/@octokit/request/node_modules/@octokit/request-error/dist-src/index.js
var RequestError = class extends Error {
  constructor(message, statusCode, options) {
    super(message);
    __publicField(this, "name");
    /**
     * http status code
     */
    __publicField(this, "status");
    /**
     * Request options that lead to the error.
     */
    __publicField(this, "request");
    /**
     * Response object if a response was received
     */
    __publicField(this, "response");
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = "HttpError";
    this.status = statusCode;
    if ("response" in options) {
      this.response = options.response;
    }
    const requestCopy = Object.assign({}, options.request);
    if (options.request.headers.authorization) {
      requestCopy.headers = Object.assign({}, options.request.headers, {
        authorization: options.request.headers.authorization.replace(
          / .*$/,
          " [REDACTED]"
        )
      });
    }
    requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
    this.request = requestCopy;
  }
};

// node_modules/@octokit/request/dist-bundle/index.js
var VERSION2 = "0.0.0-development";
function isPlainObject2(value) {
  if (typeof value !== "object" || value === null)
    return false;
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
function getBufferResponse(response) {
  return response.arrayBuffer();
}
function fetchWrapper(requestOptions) {
  var _a, _b, _c;
  const log = requestOptions.request && requestOptions.request.log ? requestOptions.request.log : console;
  const parseSuccessResponseBody = ((_a = requestOptions.request) == null ? void 0 : _a.parseSuccessResponseBody) !== false;
  if (isPlainObject2(requestOptions.body) || Array.isArray(requestOptions.body)) {
    requestOptions.body = JSON.stringify(requestOptions.body);
  }
  let headers = {};
  let status;
  let url;
  let { fetch } = globalThis;
  if ((_b = requestOptions.request) == null ? void 0 : _b.fetch) {
    fetch = requestOptions.request.fetch;
  }
  if (!fetch) {
    throw new Error(
      "fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing"
    );
  }
  return fetch(requestOptions.url, {
    method: requestOptions.method,
    body: requestOptions.body,
    // Header values must be `string`
    headers: Object.fromEntries(
      Object.entries(requestOptions.headers).map(([name, value]) => [
        name,
        String(value)
      ])
    ),
    signal: (_c = requestOptions.request) == null ? void 0 : _c.signal,
    // duplex must be set if request.body is ReadableStream or Async Iterables.
    // See https://fetch.spec.whatwg.org/#dom-requestinit-duplex.
    ...requestOptions.body && { duplex: "half" }
  }).then(async (response) => {
    url = response.url;
    status = response.status;
    for (const keyAndValue of response.headers) {
      headers[keyAndValue[0]] = keyAndValue[1];
    }
    if ("deprecation" in headers) {
      const matches = headers.link && headers.link.match(/<([^>]+)>; rel="deprecation"/);
      const deprecationLink = matches && matches.pop();
      log.warn(
        `[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`
      );
    }
    if (status === 204 || status === 205) {
      return;
    }
    if (requestOptions.method === "HEAD") {
      if (status < 400) {
        return;
      }
      throw new RequestError(response.statusText, status, {
        response: {
          url,
          status,
          headers,
          data: void 0
        },
        request: requestOptions
      });
    }
    if (status === 304) {
      throw new RequestError("Not modified", status, {
        response: {
          url,
          status,
          headers,
          data: await getResponseData(response)
        },
        request: requestOptions
      });
    }
    if (status >= 400) {
      const data = await getResponseData(response);
      const error = new RequestError(toErrorMessage(data), status, {
        response: {
          url,
          status,
          headers,
          data
        },
        request: requestOptions
      });
      throw error;
    }
    return parseSuccessResponseBody ? await getResponseData(response) : response.body;
  }).then((data) => {
    return {
      status,
      url,
      headers,
      data
    };
  }).catch((error) => {
    if (error instanceof RequestError)
      throw error;
    else if (error.name === "AbortError")
      throw error;
    let message = error.message;
    if (error.name === "TypeError" && "cause" in error) {
      if (error.cause instanceof Error) {
        message = error.cause.message;
      } else if (typeof error.cause === "string") {
        message = error.cause;
      }
    }
    throw new RequestError(message, 500, {
      request: requestOptions
    });
  });
}
async function getResponseData(response) {
  const contentType = response.headers.get("content-type");
  if (/application\/json/.test(contentType)) {
    return response.json().catch(() => response.text()).catch(() => "");
  }
  if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) {
    return response.text();
  }
  return getBufferResponse(response);
}
function toErrorMessage(data) {
  if (typeof data === "string")
    return data;
  let suffix;
  if ("documentation_url" in data) {
    suffix = ` - ${data.documentation_url}`;
  } else {
    suffix = "";
  }
  if ("message" in data) {
    if (Array.isArray(data.errors)) {
      return `${data.message}: ${data.errors.map(JSON.stringify).join(", ")}${suffix}`;
    }
    return `${data.message}${suffix}`;
  }
  return `Unknown error: ${JSON.stringify(data)}`;
}
function withDefaults2(oldEndpoint, newDefaults) {
  const endpoint2 = oldEndpoint.defaults(newDefaults);
  const newApi = function(route, parameters) {
    const endpointOptions = endpoint2.merge(route, parameters);
    if (!endpointOptions.request || !endpointOptions.request.hook) {
      return fetchWrapper(endpoint2.parse(endpointOptions));
    }
    const request2 = (route2, parameters2) => {
      return fetchWrapper(
        endpoint2.parse(endpoint2.merge(route2, parameters2))
      );
    };
    Object.assign(request2, {
      endpoint: endpoint2,
      defaults: withDefaults2.bind(null, endpoint2)
    });
    return endpointOptions.request.hook(request2, endpointOptions);
  };
  return Object.assign(newApi, {
    endpoint: endpoint2,
    defaults: withDefaults2.bind(null, endpoint2)
  });
}
var request = withDefaults2(endpoint, {
  headers: {
    "user-agent": `octokit-request.js/${VERSION2} ${getUserAgent3()}`
  }
});

// node_modules/@octokit/graphql/node_modules/universal-user-agent/index.js
function getUserAgent4() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && process.version !== void 0) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}

// node_modules/@octokit/graphql/dist-bundle/index.js
var VERSION3 = "0.0.0-development";
function _buildMessageForResponseErrors(data) {
  return `Request failed due to following response errors:
` + data.errors.map((e) => ` - ${e.message}`).join("\n");
}
var GraphqlResponseError = class extends Error {
  constructor(request2, headers, response) {
    super(_buildMessageForResponseErrors(response));
    __publicField(this, "name", "GraphqlResponseError");
    __publicField(this, "errors");
    __publicField(this, "data");
    this.request = request2;
    this.headers = headers;
    this.response = response;
    this.errors = response.errors;
    this.data = response.data;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
};
var NON_VARIABLE_OPTIONS = [
  "method",
  "baseUrl",
  "url",
  "headers",
  "request",
  "query",
  "mediaType"
];
var FORBIDDEN_VARIABLE_OPTIONS = ["query", "method", "url"];
var GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
function graphql(request2, query, options) {
  if (options) {
    if (typeof query === "string" && "query" in options) {
      return Promise.reject(
        new Error(`[@octokit/graphql] "query" cannot be used as variable name`)
      );
    }
    for (const key in options) {
      if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key))
        continue;
      return Promise.reject(
        new Error(
          `[@octokit/graphql] "${key}" cannot be used as variable name`
        )
      );
    }
  }
  const parsedOptions = typeof query === "string" ? Object.assign({ query }, options) : query;
  const requestOptions = Object.keys(
    parsedOptions
  ).reduce((result, key) => {
    if (NON_VARIABLE_OPTIONS.includes(key)) {
      result[key] = parsedOptions[key];
      return result;
    }
    if (!result.variables) {
      result.variables = {};
    }
    result.variables[key] = parsedOptions[key];
    return result;
  }, {});
  const baseUrl = parsedOptions.baseUrl || request2.endpoint.DEFAULTS.baseUrl;
  if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
    requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
  }
  return request2(requestOptions).then((response) => {
    if (response.data.errors) {
      const headers = {};
      for (const key of Object.keys(response.headers)) {
        headers[key] = response.headers[key];
      }
      throw new GraphqlResponseError(
        requestOptions,
        headers,
        response.data
      );
    }
    return response.data.data;
  });
}
function withDefaults3(request2, newDefaults) {
  const newRequest = request2.defaults(newDefaults);
  const newApi = (query, options) => {
    return graphql(newRequest, query, options);
  };
  return Object.assign(newApi, {
    defaults: withDefaults3.bind(null, newRequest),
    endpoint: newRequest.endpoint
  });
}
var graphql2 = withDefaults3(request, {
  headers: {
    "user-agent": `octokit-graphql.js/${VERSION3} ${getUserAgent4()}`
  },
  method: "POST",
  url: "/graphql"
});
function withCustomRequest(customRequest) {
  return withDefaults3(customRequest, {
    method: "POST",
    url: "/graphql"
  });
}

// node_modules/@octokit/auth-token/dist-bundle/index.js
var REGEX_IS_INSTALLATION_LEGACY = /^v1\./;
var REGEX_IS_INSTALLATION = /^ghs_/;
var REGEX_IS_USER_TO_SERVER = /^ghu_/;
async function auth(token) {
  const isApp = token.split(/\./).length === 3;
  const isInstallation = REGEX_IS_INSTALLATION_LEGACY.test(token) || REGEX_IS_INSTALLATION.test(token);
  const isUserToServer = REGEX_IS_USER_TO_SERVER.test(token);
  const tokenType = isApp ? "app" : isInstallation ? "installation" : isUserToServer ? "user-to-server" : "oauth";
  return {
    type: "token",
    token,
    tokenType
  };
}
function withAuthorizationPrefix(token) {
  if (token.split(/\./).length === 3) {
    return `bearer ${token}`;
  }
  return `token ${token}`;
}
async function hook(token, request2, route, parameters) {
  const endpoint2 = request2.endpoint.merge(
    route,
    parameters
  );
  endpoint2.headers.authorization = withAuthorizationPrefix(token);
  return request2(endpoint2);
}
var createTokenAuth = function createTokenAuth2(token) {
  if (!token) {
    throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
  }
  if (typeof token !== "string") {
    throw new Error(
      "[@octokit/auth-token] Token passed to createTokenAuth is not a string"
    );
  }
  token = token.replace(/^(token|bearer) +/i, "");
  return Object.assign(auth.bind(null, token), {
    hook: hook.bind(null, token)
  });
};

// node_modules/@octokit/core/dist-src/version.js
var VERSION4 = "6.0.1";

// node_modules/@octokit/core/dist-src/index.js
var noop = () => {
};
var consoleWarn = console.warn.bind(console);
var consoleError = console.error.bind(console);
var userAgentTrail = `octokit-core.js/${VERSION4} ${getUserAgent()}`;
var Octokit = class {
  constructor(options = {}) {
    // assigned during constructor
    __publicField(this, "request");
    __publicField(this, "graphql");
    __publicField(this, "log");
    __publicField(this, "hook");
    // TODO: type `octokit.auth` based on passed options.authStrategy
    __publicField(this, "auth");
    const hook2 = new before_after_hook_default.Collection();
    const requestDefaults = {
      baseUrl: request.endpoint.DEFAULTS.baseUrl,
      headers: {},
      request: Object.assign({}, options.request, {
        // @ts-ignore internal usage only, no need to type
        hook: hook2.bind(null, "request")
      }),
      mediaType: {
        previews: [],
        format: ""
      }
    };
    requestDefaults.headers["user-agent"] = options.userAgent ? `${options.userAgent} ${userAgentTrail}` : userAgentTrail;
    if (options.baseUrl) {
      requestDefaults.baseUrl = options.baseUrl;
    }
    if (options.previews) {
      requestDefaults.mediaType.previews = options.previews;
    }
    if (options.timeZone) {
      requestDefaults.headers["time-zone"] = options.timeZone;
    }
    this.request = request.defaults(requestDefaults);
    this.graphql = withCustomRequest(this.request).defaults(requestDefaults);
    this.log = Object.assign(
      {
        debug: noop,
        info: noop,
        warn: consoleWarn,
        error: consoleError
      },
      options.log
    );
    this.hook = hook2;
    if (!options.authStrategy) {
      if (!options.auth) {
        this.auth = async () => ({
          type: "unauthenticated"
        });
      } else {
        const auth2 = createTokenAuth(options.auth);
        hook2.wrap("request", auth2.hook);
        this.auth = auth2;
      }
    } else {
      const { authStrategy, ...otherOptions } = options;
      const auth2 = authStrategy(
        Object.assign(
          {
            request: this.request,
            log: this.log,
            // we pass the current octokit instance as well as its constructor options
            // to allow for authentication strategies that return a new octokit instance
            // that shares the same internal state as the current one. The original
            // requirement for this was the "event-octokit" authentication strategy
            // of https://github.com/probot/octokit-auth-probot.
            octokit: this,
            octokitOptions: otherOptions
          },
          options.auth
        )
      );
      hook2.wrap("request", auth2.hook);
      this.auth = auth2;
    }
    const classConstructor = this.constructor;
    for (let i = 0; i < classConstructor.plugins.length; ++i) {
      Object.assign(this, classConstructor.plugins[i](this, options));
    }
  }
  static defaults(defaults) {
    const OctokitWithDefaults = class extends this {
      constructor(...args) {
        const options = args[0] || {};
        if (typeof defaults === "function") {
          super(defaults(options));
          return;
        }
        super(
          Object.assign(
            {},
            defaults,
            options,
            options.userAgent && defaults.userAgent ? {
              userAgent: `${options.userAgent} ${defaults.userAgent}`
            } : null
          )
        );
      }
    };
    return OctokitWithDefaults;
  }
  /**
   * Attach a plugin (or many) to your Octokit instance.
   *
   * @example
   * const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
   */
  static plugin(...newPlugins) {
    var _a;
    const currentPlugins = this.plugins;
    const NewOctokit = (_a = class extends this {
    }, __publicField(_a, "plugins", currentPlugins.concat(
      newPlugins.filter((plugin) => !currentPlugins.includes(plugin))
    )), _a);
    return NewOctokit;
  }
};
__publicField(Octokit, "VERSION", VERSION4);
__publicField(Octokit, "plugins", []);

// src/utils.ts
var import_obsidian = require("obsidian");

// node_modules/diff/libesm/diff/base.js
var Diff = class {
  diff(oldStr, newStr, options = {}) {
    let callback;
    if (typeof options === "function") {
      callback = options;
      options = {};
    } else if ("callback" in options) {
      callback = options.callback;
    }
    const oldString = this.castInput(oldStr, options);
    const newString = this.castInput(newStr, options);
    const oldTokens = this.removeEmpty(this.tokenize(oldString, options));
    const newTokens = this.removeEmpty(this.tokenize(newString, options));
    return this.diffWithOptionsObj(oldTokens, newTokens, options, callback);
  }
  diffWithOptionsObj(oldTokens, newTokens, options, callback) {
    var _a;
    const done = (value) => {
      value = this.postProcess(value, options);
      if (callback) {
        setTimeout(function() {
          callback(value);
        }, 0);
        return void 0;
      } else {
        return value;
      }
    };
    const newLen = newTokens.length, oldLen = oldTokens.length;
    let editLength = 1;
    let maxEditLength = newLen + oldLen;
    if (options.maxEditLength != null) {
      maxEditLength = Math.min(maxEditLength, options.maxEditLength);
    }
    const maxExecutionTime = (_a = options.timeout) !== null && _a !== void 0 ? _a : Infinity;
    const abortAfterTimestamp = Date.now() + maxExecutionTime;
    const bestPath = [{ oldPos: -1, lastComponent: void 0 }];
    let newPos = this.extractCommon(bestPath[0], newTokens, oldTokens, 0, options);
    if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
      return done(this.buildValues(bestPath[0].lastComponent, newTokens, oldTokens));
    }
    let minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity;
    const execEditLength = () => {
      for (let diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {
        let basePath;
        const removePath = bestPath[diagonalPath - 1], addPath = bestPath[diagonalPath + 1];
        if (removePath) {
          bestPath[diagonalPath - 1] = void 0;
        }
        let canAdd = false;
        if (addPath) {
          const addPathNewPos = addPath.oldPos - diagonalPath;
          canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;
        }
        const canRemove = removePath && removePath.oldPos + 1 < oldLen;
        if (!canAdd && !canRemove) {
          bestPath[diagonalPath] = void 0;
          continue;
        }
        if (!canRemove || canAdd && removePath.oldPos < addPath.oldPos) {
          basePath = this.addToPath(addPath, true, false, 0, options);
        } else {
          basePath = this.addToPath(removePath, false, true, 1, options);
        }
        newPos = this.extractCommon(basePath, newTokens, oldTokens, diagonalPath, options);
        if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
          return done(this.buildValues(basePath.lastComponent, newTokens, oldTokens)) || true;
        } else {
          bestPath[diagonalPath] = basePath;
          if (basePath.oldPos + 1 >= oldLen) {
            maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);
          }
          if (newPos + 1 >= newLen) {
            minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);
          }
        }
      }
      editLength++;
    };
    if (callback) {
      (function exec() {
        setTimeout(function() {
          if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {
            return callback(void 0);
          }
          if (!execEditLength()) {
            exec();
          }
        }, 0);
      })();
    } else {
      while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {
        const ret = execEditLength();
        if (ret) {
          return ret;
        }
      }
    }
  }
  addToPath(path, added, removed, oldPosInc, options) {
    const last = path.lastComponent;
    if (last && !options.oneChangePerToken && last.added === added && last.removed === removed) {
      return {
        oldPos: path.oldPos + oldPosInc,
        lastComponent: { count: last.count + 1, added, removed, previousComponent: last.previousComponent }
      };
    } else {
      return {
        oldPos: path.oldPos + oldPosInc,
        lastComponent: { count: 1, added, removed, previousComponent: last }
      };
    }
  }
  extractCommon(basePath, newTokens, oldTokens, diagonalPath, options) {
    const newLen = newTokens.length, oldLen = oldTokens.length;
    let oldPos = basePath.oldPos, newPos = oldPos - diagonalPath, commonCount = 0;
    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(oldTokens[oldPos + 1], newTokens[newPos + 1], options)) {
      newPos++;
      oldPos++;
      commonCount++;
      if (options.oneChangePerToken) {
        basePath.lastComponent = { count: 1, previousComponent: basePath.lastComponent, added: false, removed: false };
      }
    }
    if (commonCount && !options.oneChangePerToken) {
      basePath.lastComponent = { count: commonCount, previousComponent: basePath.lastComponent, added: false, removed: false };
    }
    basePath.oldPos = oldPos;
    return newPos;
  }
  equals(left, right, options) {
    if (options.comparator) {
      return options.comparator(left, right);
    } else {
      return left === right || !!options.ignoreCase && left.toLowerCase() === right.toLowerCase();
    }
  }
  removeEmpty(array) {
    const ret = [];
    for (let i = 0; i < array.length; i++) {
      if (array[i]) {
        ret.push(array[i]);
      }
    }
    return ret;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  castInput(value, options) {
    return value;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  tokenize(value, options) {
    return Array.from(value);
  }
  join(chars) {
    return chars.join("");
  }
  postProcess(changeObjects, options) {
    return changeObjects;
  }
  get useLongestToken() {
    return false;
  }
  buildValues(lastComponent, newTokens, oldTokens) {
    const components = [];
    let nextComponent;
    while (lastComponent) {
      components.push(lastComponent);
      nextComponent = lastComponent.previousComponent;
      delete lastComponent.previousComponent;
      lastComponent = nextComponent;
    }
    components.reverse();
    const componentLen = components.length;
    let componentPos = 0, newPos = 0, oldPos = 0;
    for (; componentPos < componentLen; componentPos++) {
      const component = components[componentPos];
      if (!component.removed) {
        if (!component.added && this.useLongestToken) {
          let value = newTokens.slice(newPos, newPos + component.count);
          value = value.map(function(value2, i) {
            const oldValue = oldTokens[oldPos + i];
            return oldValue.length > value2.length ? oldValue : value2;
          });
          component.value = this.join(value);
        } else {
          component.value = this.join(newTokens.slice(newPos, newPos + component.count));
        }
        newPos += component.count;
        if (!component.added) {
          oldPos += component.count;
        }
      } else {
        component.value = this.join(oldTokens.slice(oldPos, oldPos + component.count));
        oldPos += component.count;
      }
    }
    return components;
  }
};

// node_modules/diff/libesm/util/string.js
function longestCommonPrefix(str1, str2) {
  let i;
  for (i = 0; i < str1.length && i < str2.length; i++) {
    if (str1[i] != str2[i]) {
      return str1.slice(0, i);
    }
  }
  return str1.slice(0, i);
}
function longestCommonSuffix(str1, str2) {
  let i;
  if (!str1 || !str2 || str1[str1.length - 1] != str2[str2.length - 1]) {
    return "";
  }
  for (i = 0; i < str1.length && i < str2.length; i++) {
    if (str1[str1.length - (i + 1)] != str2[str2.length - (i + 1)]) {
      return str1.slice(-i);
    }
  }
  return str1.slice(-i);
}
function replacePrefix(string, oldPrefix, newPrefix) {
  if (string.slice(0, oldPrefix.length) != oldPrefix) {
    throw Error(`string ${JSON.stringify(string)} doesn't start with prefix ${JSON.stringify(oldPrefix)}; this is a bug`);
  }
  return newPrefix + string.slice(oldPrefix.length);
}
function replaceSuffix(string, oldSuffix, newSuffix) {
  if (!oldSuffix) {
    return string + newSuffix;
  }
  if (string.slice(-oldSuffix.length) != oldSuffix) {
    throw Error(`string ${JSON.stringify(string)} doesn't end with suffix ${JSON.stringify(oldSuffix)}; this is a bug`);
  }
  return string.slice(0, -oldSuffix.length) + newSuffix;
}
function removePrefix(string, oldPrefix) {
  return replacePrefix(string, oldPrefix, "");
}
function removeSuffix(string, oldSuffix) {
  return replaceSuffix(string, oldSuffix, "");
}
function maximumOverlap(string1, string2) {
  return string2.slice(0, overlapCount(string1, string2));
}
function overlapCount(a, b) {
  let startA = 0;
  if (a.length > b.length) {
    startA = a.length - b.length;
  }
  let endB = b.length;
  if (a.length < b.length) {
    endB = a.length;
  }
  const map = Array(endB);
  let k = 0;
  map[0] = 0;
  for (let j = 1; j < endB; j++) {
    if (b[j] == b[k]) {
      map[j] = map[k];
    } else {
      map[j] = k;
    }
    while (k > 0 && b[j] != b[k]) {
      k = map[k];
    }
    if (b[j] == b[k]) {
      k++;
    }
  }
  k = 0;
  for (let i = startA; i < a.length; i++) {
    while (k > 0 && a[i] != b[k]) {
      k = map[k];
    }
    if (a[i] == b[k]) {
      k++;
    }
  }
  return k;
}
function trailingWs(string) {
  let i;
  for (i = string.length - 1; i >= 0; i--) {
    if (!string[i].match(/\s/)) {
      break;
    }
  }
  return string.substring(i + 1);
}
function leadingWs(string) {
  const match = string.match(/^\s*/);
  return match ? match[0] : "";
}

// node_modules/diff/libesm/diff/word.js
var extendedWordChars = "a-zA-Z0-9_\\u{C0}-\\u{FF}\\u{D8}-\\u{F6}\\u{F8}-\\u{2C6}\\u{2C8}-\\u{2D7}\\u{2DE}-\\u{2FF}\\u{1E00}-\\u{1EFF}";
var tokenizeIncludingWhitespace = new RegExp(`[${extendedWordChars}]+|\\s+|[^${extendedWordChars}]`, "ug");
var WordDiff = class extends Diff {
  equals(left, right, options) {
    if (options.ignoreCase) {
      left = left.toLowerCase();
      right = right.toLowerCase();
    }
    return left.trim() === right.trim();
  }
  tokenize(value, options = {}) {
    let parts;
    if (options.intlSegmenter) {
      const segmenter = options.intlSegmenter;
      if (segmenter.resolvedOptions().granularity != "word") {
        throw new Error('The segmenter passed must have a granularity of "word"');
      }
      parts = Array.from(segmenter.segment(value), (segment) => segment.segment);
    } else {
      parts = value.match(tokenizeIncludingWhitespace) || [];
    }
    const tokens = [];
    let prevPart = null;
    parts.forEach((part) => {
      if (/\s/.test(part)) {
        if (prevPart == null) {
          tokens.push(part);
        } else {
          tokens.push(tokens.pop() + part);
        }
      } else if (prevPart != null && /\s/.test(prevPart)) {
        if (tokens[tokens.length - 1] == prevPart) {
          tokens.push(tokens.pop() + part);
        } else {
          tokens.push(prevPart + part);
        }
      } else {
        tokens.push(part);
      }
      prevPart = part;
    });
    return tokens;
  }
  join(tokens) {
    return tokens.map((token, i) => {
      if (i == 0) {
        return token;
      } else {
        return token.replace(/^\s+/, "");
      }
    }).join("");
  }
  postProcess(changes, options) {
    if (!changes || options.oneChangePerToken) {
      return changes;
    }
    let lastKeep = null;
    let insertion = null;
    let deletion = null;
    changes.forEach((change) => {
      if (change.added) {
        insertion = change;
      } else if (change.removed) {
        deletion = change;
      } else {
        if (insertion || deletion) {
          dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, change);
        }
        lastKeep = change;
        insertion = null;
        deletion = null;
      }
    });
    if (insertion || deletion) {
      dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, null);
    }
    return changes;
  }
};
var wordDiff = new WordDiff();
function diffWords(oldStr, newStr, options) {
  if ((options === null || options === void 0 ? void 0 : options.ignoreWhitespace) != null && !options.ignoreWhitespace) {
    return diffWordsWithSpace(oldStr, newStr, options);
  }
  return wordDiff.diff(oldStr, newStr, options);
}
function dedupeWhitespaceInChangeObjects(startKeep, deletion, insertion, endKeep) {
  if (deletion && insertion) {
    const oldWsPrefix = leadingWs(deletion.value);
    const oldWsSuffix = trailingWs(deletion.value);
    const newWsPrefix = leadingWs(insertion.value);
    const newWsSuffix = trailingWs(insertion.value);
    if (startKeep) {
      const commonWsPrefix = longestCommonPrefix(oldWsPrefix, newWsPrefix);
      startKeep.value = replaceSuffix(startKeep.value, newWsPrefix, commonWsPrefix);
      deletion.value = removePrefix(deletion.value, commonWsPrefix);
      insertion.value = removePrefix(insertion.value, commonWsPrefix);
    }
    if (endKeep) {
      const commonWsSuffix = longestCommonSuffix(oldWsSuffix, newWsSuffix);
      endKeep.value = replacePrefix(endKeep.value, newWsSuffix, commonWsSuffix);
      deletion.value = removeSuffix(deletion.value, commonWsSuffix);
      insertion.value = removeSuffix(insertion.value, commonWsSuffix);
    }
  } else if (insertion) {
    if (startKeep) {
      const ws = leadingWs(insertion.value);
      insertion.value = insertion.value.substring(ws.length);
    }
    if (endKeep) {
      const ws = leadingWs(endKeep.value);
      endKeep.value = endKeep.value.substring(ws.length);
    }
  } else if (startKeep && endKeep) {
    const newWsFull = leadingWs(endKeep.value), delWsStart = leadingWs(deletion.value), delWsEnd = trailingWs(deletion.value);
    const newWsStart = longestCommonPrefix(newWsFull, delWsStart);
    deletion.value = removePrefix(deletion.value, newWsStart);
    const newWsEnd = longestCommonSuffix(removePrefix(newWsFull, newWsStart), delWsEnd);
    deletion.value = removeSuffix(deletion.value, newWsEnd);
    endKeep.value = replacePrefix(endKeep.value, newWsFull, newWsEnd);
    startKeep.value = replaceSuffix(startKeep.value, newWsFull, newWsFull.slice(0, newWsFull.length - newWsEnd.length));
  } else if (endKeep) {
    const endKeepWsPrefix = leadingWs(endKeep.value);
    const deletionWsSuffix = trailingWs(deletion.value);
    const overlap = maximumOverlap(deletionWsSuffix, endKeepWsPrefix);
    deletion.value = removeSuffix(deletion.value, overlap);
  } else if (startKeep) {
    const startKeepWsSuffix = trailingWs(startKeep.value);
    const deletionWsPrefix = leadingWs(deletion.value);
    const overlap = maximumOverlap(startKeepWsSuffix, deletionWsPrefix);
    deletion.value = removePrefix(deletion.value, overlap);
  }
}
var WordsWithSpaceDiff = class extends Diff {
  tokenize(value) {
    const regex = new RegExp(`(\\r?\\n)|[${extendedWordChars}]+|[^\\S\\n\\r]+|[^${extendedWordChars}]`, "ug");
    return value.match(regex) || [];
  }
};
var wordsWithSpaceDiff = new WordsWithSpaceDiff();
function diffWordsWithSpace(oldStr, newStr, options) {
  return wordsWithSpaceDiff.diff(oldStr, newStr, options);
}

// src/utils.ts
function getValueOrNull(obj, key) {
  return obj.hasOwnProperty(key) ? obj[key] : null;
}
function compareSha(currentShaMap, storedShaMap, env) {
  const determineStatus = (currentSha, storedSha) => {
    if (currentSha && storedSha && currentSha !== storedSha) {
      return env === "local" ? "changed" : "MODIFIED";
    } else if (currentSha && !storedSha) {
      return env === "local" ? "created" : "ADDED";
    } else if (!currentSha && storedSha) {
      return env === "local" ? "deleted" : "REMOVED";
    }
    return null;
  };
  return Object.keys({ ...currentShaMap, ...storedShaMap }).flatMap((path) => {
    const [currentSha, storedSha] = [getValueOrNull(currentShaMap, path), getValueOrNull(storedShaMap, path)];
    const status = determineStatus(currentSha, storedSha);
    if (status) {
      return [{
        path,
        status,
        currentSha: currentSha != null ? currentSha : void 0,
        extension: extractExtension(path)
      }];
    }
    return [];
  });
}
var RECOGNIZED_TXT_EXT = ["txt", "md"];
function extractExtension(path) {
  var _a;
  return (_a = path.match(/[^.]+$/)) == null ? void 0 : _a[0];
}
function isBinaryFile(path) {
  const extension = extractExtension(path);
  const isTxt = extension && RECOGNIZED_TXT_EXT.includes(extension);
  return !isTxt;
}
function removeLineEndingsFromBase64String(content) {
  return content.replace(/\r?\n|\r|\n/g, "");
}
function showFileOpsRecord(records) {
  if (records.length === 0 || records.every((r) => r.ops.length === 0)) {
    return;
  }
  const fileOpsNotice = new import_obsidian.Notice("", 0);
  records.map((recordSet) => {
    if (recordSet.ops.length === 0) {
      return;
    }
    const heading = fileOpsNotice.noticeEl.createEl("span", {
      cls: "file-changes-heading"
    });
    heading.setText(`${recordSet.heading}
`);
    const fileChanges = {
      created: [],
      changed: [],
      deleted: []
    };
    for (const op of recordSet.ops) {
      fileChanges[op.status].push(op.path);
    }
    for (const [changeType, paths] of Object.entries(fileChanges)) {
      if (paths.length === 0) {
        continue;
      }
      const heading2 = fileOpsNotice.noticeEl.createEl("span");
      heading2.setText(`${changeType.charAt(0).toUpperCase() + changeType.slice(1)}
`);
      heading2.addClass(`file-changes-subheading`);
      for (const path of paths) {
        const listItem = fileOpsNotice.noticeEl.createEl("li", {
          cls: "file-update-row"
        });
        listItem.setText(`${path}`);
        listItem.addClass(`file-${changeType}`);
      }
    }
  });
}
function showUnappliedConflicts(clashedFiles) {
  if (clashedFiles.length === 0) {
    return;
  }
  const localStatusMap = {
    created: "create",
    changed: "change",
    deleted: "delete"
  };
  const remoteStatusMap = {
    ADDED: "create",
    MODIFIED: "change",
    REMOVED: "delete"
  };
  const conflictNotice = new import_obsidian.Notice("", 0);
  const heading = conflictNotice.noticeEl.createEl("span");
  heading.setText(`Change conflicts:
`);
  heading.addClass(`file-changes-subheading`);
  const conflictStatus = conflictNotice.noticeEl.createDiv({
    cls: "file-conflict-row"
  });
  conflictStatus.createDiv().setText("Local");
  conflictStatus.createDiv().setText("Remote");
  for (const clash of clashedFiles) {
    const conflictItem = conflictNotice.noticeEl.createDiv({
      cls: "file-conflict-row"
    });
    conflictItem.createDiv({
      cls: `file-conflict-${localStatusMap[clash.localStatus]}`
    });
    conflictItem.createDiv("div").setText(clash.path);
    conflictItem.createDiv({
      cls: `file-conflict-${remoteStatusMap[clash.remoteStatus]}`
    });
  }
  const footer = conflictNotice.noticeEl.createDiv({
    cls: "file-conflict-row"
  });
  footer.setText("Note:");
  footer.style.fontWeight = "bold";
  conflictNotice.noticeEl.createEl("li", { cls: "file-conflict-note" }).setText(`Remote changes in ${conflictResolutionFolder}`);
  conflictNotice.noticeEl.createEl("li", { cls: "file-conflict-note" }).setText(`${conflictResolutionFolder} folder is overwritten on conflict, copy needed changes outside ${conflictResolutionFolder}.`);
}
function difference(setA, setB) {
  return new Set([...setA].filter((x) => !setB.has(x)));
}
function getDiffText(oldContent, newContent) {
  let result = "";
  const diff = diffWords(oldContent, newContent);
  const hasChanges = diff.some((part) => part.added || part.removed);
  if (!hasChanges) {
    return basicTemplateConflict + "No differences found";
  }
  let currentLine = "";
  let hasLineChanges = false;
  for (let part of diff) {
    let text;
    if (part.removed) {
      text = `<span style="color:rgb(223, 73, 73)">${part.value}</span>`;
    } else if (part.added) {
      text = `<span style="color:rgb(0, 176, 80)">${part.value}</span>`;
    } else {
      text = part.value;
    }
    const lines = text.split("\n");
    currentLine += lines[0];
    if (part.added || part.removed) {
      hasLineChanges = true;
    }
    for (let i = 1; i < lines.length; i++) {
      if (hasLineChanges) {
        result += currentLine + "\n";
      }
      currentLine = lines[i];
      hasLineChanges = part.added || part.removed;
    }
  }
  if (hasLineChanges && currentLine) {
    result += currentLine + "\n";
  }
  return result;
}

// src/fit.ts
var import_obsidian2 = require("obsidian");
var OctokitHttpError = class extends Error {
  constructor(message, status, source) {
    super(message);
    this.name = "HttpError";
    this.status = status;
    this.source = source;
  }
};
var Fit = class {
  constructor(repo, vaultOps) {
    this.loadSettings(repo);
    this.vaultOps = vaultOps;
    this.headers = {
      // Hack to disable caching which leads to inconsistency for
      // read after write https://github.com/octokit/octokit.js/issues/890
      "If-None-Match": "",
      "X-GitHub-Api-Version": "2022-11-28"
    };
  }
  loadSettings(repo) {
    const { settings, localStore } = repo;
    this.repo = settings.repo;
    this.owner = settings.owner;
    this.branch = settings.branch;
    this.excludes = settings.excludes;
    this.syncPath = settings.syncPath;
    this.deviceName = settings.deviceName;
    this.octokit = new Octokit({ auth: settings.pat });
    this.localSha = localStore.localSha;
    this.lastFetchedCommitSha = localStore.lastFetchedCommitSha;
    this.lastFetchedRemoteSha = localStore.lastFetchedRemoteSha;
  }
  async fileSha1(fileContent) {
    const enc = new TextEncoder();
    const hashBuf = await crypto.subtle.digest("SHA-1", enc.encode(fileContent));
    const hashArray = Array.from(new Uint8Array(hashBuf));
    const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
    return hashHex;
  }
  async computeFileLocalSha(path) {
    const fullPath = this.syncPath + path;
    let content;
    const file = await this.vaultOps.getTFile(fullPath);
    if (file) {
      if (RECOGNIZED_TXT_EXT.includes(file.extension)) {
        content = await this.vaultOps.vault.read(file);
      } else {
        content = (0, import_obsidian2.arrayBufferToBase64)(await this.vaultOps.vault.readBinary(file));
      }
    } else {
      const extension = extractExtension(path);
      if (!extension || !RECOGNIZED_TXT_EXT.includes(extension)) {
        content = (0, import_obsidian2.arrayBufferToBase64)(
          await this.vaultOps.vault.adapter.readBinary(fullPath)
        );
      } else {
        content = await this.vaultOps.vault.adapter.read(fullPath);
      }
    }
    return await this.fileSha1(path + content);
  }
  async computeLocalSha() {
    const allPaths = await this.vaultOps.getFilesInVault();
    const paths = [];
    for (let path of allPaths) {
      let isExcluded = path.startsWith(rootFitFolder) || !path.startsWith(this.syncPath) || this.excludes.contains(path) || this.excludes.some(
        (exclude) => path.startsWith(exclude) && !this.syncPath.startsWith(exclude)
        // NOTE if one syncPath nested in another syncPath
      );
      const result2 = path.replace(this.syncPath, "");
      if (!isExcluded)
        paths.push(result2);
    }
    const asyncCompute = paths.map(
      async (path) => {
        const sha = await this.computeFileLocalSha(path);
        return [path, sha];
      }
    );
    const computed = await Promise.all(asyncCompute);
    const result = computed.filter((el) => !!el[1]);
    return Object.fromEntries(result);
  }
  async remoteUpdated() {
    const remoteCommitSha = await this.getRef();
    return { remoteCommitSha, updated: remoteCommitSha !== this.lastFetchedCommitSha };
  }
  async getLocalChanges(currentLocalSha) {
    if (!currentLocalSha) {
      currentLocalSha = await this.computeLocalSha();
    }
    const localChanges = compareSha(currentLocalSha, this.localSha, "local");
    return localChanges;
  }
  async getRemoteChanges(remoteTreeSha) {
    const remoteChanges = compareSha(remoteTreeSha, this.lastFetchedRemoteSha, "remote");
    return remoteChanges;
  }
  getClashedChanges(localChanges, remoteChanges) {
    const localChangePaths = localChanges.map(
      (c) => c.path.replace(this.syncPath, "")
    );
    const remoteChangePaths = remoteChanges.map((c) => c.path);
    const clashedFiles = localChangePaths.map(
      (path, localIndex) => {
        const remoteIndex = remoteChangePaths.indexOf(path);
        if (remoteIndex !== -1) {
          return { path, localIndex, remoteIndex };
        }
        return null;
      }
    ).filter(Boolean);
    return clashedFiles.map(
      ({ path, localIndex, remoteIndex }) => {
        return {
          path,
          localStatus: localChanges[localIndex].status,
          remoteStatus: remoteChanges[remoteIndex].status
        };
      }
    );
  }
  async getRepos() {
    const allRepos = [];
    let page = 1;
    const perPage = 100;
    try {
      let hasMorePages = true;
      while (hasMorePages) {
        const { data: response } = await this.octokit.request(
          `GET /user/repos`,
          {
            affiliation: "owner",
            headers: this.headers,
            per_page: perPage,
            // Number of repositories to import per page (up to 100)
            page
          }
        );
        allRepos.push(...response.map((r) => r.name));
        if (response.length < perPage) {
          hasMorePages = false;
        }
        page++;
      }
      return allRepos;
    } catch (error) {
      throw new OctokitHttpError(error.message, error.status, "getRepos");
    }
  }
  async getBranches() {
    try {
      const { data: response } = await this.octokit.request(
        `GET /repos/{owner}/{repo}/branches`,
        {
          owner: this.owner,
          repo: this.repo,
          headers: this.headers
        }
      );
      return response.map((r) => r.name);
    } catch (error) {
      throw new OctokitHttpError(error.message, error.status, "getRepos");
    }
  }
  // Get the sha of the latest commit in the default branch (set by user in setting)
  async getRef(ref = `heads/${this.branch}`) {
    try {
      const { data: response } = await this.octokit.request(
        `GET /repos/{owner}/{repo}/git/ref/{ref}`,
        {
          owner: this.owner,
          repo: this.repo,
          ref,
          headers: this.headers
        }
      );
      return response.object.sha;
    } catch (error) {
      throw new OctokitHttpError(error.message, error.status, "getRef");
    }
  }
  // ref Can be a commit SHA, branch name (heads/BRANCH_NAME), or tag name (tags/TAG_NAME),
  // refers to https://git-scm.com/book/en/v2/Git-Internals-Git-References
  async getCommitTreeSha(ref) {
    const { data: commit } = await this.octokit.request(
      `GET /repos/{owner}/{repo}/commits/{ref}`,
      {
        owner: this.owner,
        repo: this.repo,
        ref,
        headers: this.headers
      }
    );
    return commit.commit.tree.sha;
  }
  async getTree(tree_sha) {
    const { data: tree } = await this.octokit.request(
      `GET /repos/{owner}/{repo}/git/trees/{tree_sha}`,
      {
        owner: this.owner,
        repo: this.repo,
        tree_sha,
        recursive: "true",
        headers: this.headers
      }
    );
    return tree.tree;
  }
  // get the remote tree sha in the format compatible with local store
  async getRemoteTreeSha(tree_sha) {
    const remoteTree = await this.getTree(tree_sha);
    const remoteSha = Object.fromEntries(remoteTree.map((node) => {
      if (node.type == "blob") {
        if (!node.path || !node.sha) {
          throw new Error("Path or sha not found for blob node in remote");
        }
        if (node.path.startsWith(conflictResolutionFolder)) {
          return null;
        }
        return [node.path, node.sha];
      }
      return null;
    }).filter(Boolean));
    return remoteSha;
  }
  async createBlob(content, encoding) {
    const { data: blob } = await this.octokit.request(
      `POST /repos/{owner}/{repo}/git/blobs`,
      {
        owner: this.owner,
        repo: this.repo,
        content,
        encoding,
        headers: this.headers
      }
    );
    return blob.sha;
  }
  async createTreeNodeFromFile({ path, status, extension }, remoteTree) {
    if (status === "deleted") {
      if (remoteTree.every((node) => node.path !== path)) {
        return null;
      }
      return {
        path,
        mode: "100644",
        type: "blob",
        sha: null
      };
    }
    const fullPath = this.syncPath + path;
    let encoding;
    let content;
    if (extension && !RECOGNIZED_TXT_EXT.includes(extension)) {
      encoding = "base64";
      const fileArrayBuf = await this.vaultOps.vault.adapter.readBinary(fullPath);
      const uint8Array = new Uint8Array(fileArrayBuf);
      let binaryString = "";
      for (let i = 0; i < uint8Array.length; i++) {
        binaryString += String.fromCharCode(uint8Array[i]);
      }
      content = btoa(binaryString);
    } else {
      encoding = "utf-8";
      content = await this.vaultOps.vault.adapter.read(fullPath);
    }
    const blobSha = await this.createBlob(content, encoding);
    if (remoteTree.some((node) => node.path === path && node.sha === blobSha)) {
      return null;
    }
    return {
      path,
      mode: "100644",
      type: "blob",
      sha: blobSha
    };
  }
  async createTree(treeNodes, base_tree_sha) {
    const { data: newTree } = await this.octokit.request(
      `POST /repos/{owner}/{repo}/git/trees`,
      {
        owner: this.owner,
        repo: this.repo,
        tree: treeNodes,
        base_tree: base_tree_sha,
        headers: this.headers
      }
    );
    return newTree.sha;
  }
  async createCommit(treeSha, parentSha) {
    const message = `Commit from ${this.deviceName} on ${new Date().toLocaleString()}`;
    const { data: createdCommit } = await this.octokit.request(
      `POST /repos/{owner}/{repo}/git/commits`,
      {
        owner: this.owner,
        repo: this.repo,
        message,
        tree: treeSha,
        parents: [parentSha],
        headers: this.headers
      }
    );
    return createdCommit.sha;
  }
  async updateRef(sha, ref = `heads/${this.branch}`) {
    const { data: updatedRef } = await this.octokit.request(
      `PATCH /repos/{owner}/{repo}/git/refs/{ref}`,
      {
        owner: this.owner,
        repo: this.repo,
        ref,
        sha,
        headers: this.headers
      }
    );
    return updatedRef.object.sha;
  }
  async getBlob(file_sha) {
    const { data: blob } = await this.octokit.request(
      `GET /repos/{owner}/{repo}/git/blobs/{file_sha}`,
      {
        owner: this.owner,
        repo: this.repo,
        file_sha,
        headers: this.headers
      }
    );
    return blob.content;
  }
  getAddToLocal(addToLocal_) {
    const basepath = this.syncPath;
    const addToLocal = structuredClone(addToLocal_);
    return addToLocal.map(
      ({ path, content }) => {
        return {
          path: basepath + path,
          content
        };
      }
    ).filter(
      (file) => {
        const excludes = this.excludes;
        if (!excludes.length)
          return true;
        return excludes.some(
          (exclude) => !file.path.startsWith(exclude) || this.syncPath.startsWith(exclude)
          // NOTE if one syncPath nested in another syncPath
        );
      }
    );
  }
  getDeleteFromLocal(deleteFromLocal_) {
    const basepath = this.syncPath;
    const deleteFromLocal = structuredClone(deleteFromLocal_);
    return deleteFromLocal.map(
      (path) => basepath + path
    ).filter(
      (path) => {
        const excludes = this.excludes;
        if (!excludes.length)
          return true;
        return excludes.some(
          (exclude) => !path.startsWith(exclude) || this.syncPath.startsWith(exclude)
          // NOTE if one syncPath nested in another syncPath
        );
      }
    );
  }
};

// src/fitNotice.ts
var import_obsidian3 = require("obsidian");
var FitNotice = class {
  constructor(addClasses = [], initialMessage, duration = 0, muted = false) {
    this.muted = muted;
    this.classes = ["fit-notice"];
    if (initialMessage && !this.muted) {
      this.show(initialMessage, addClasses, duration);
    } else {
      this.classes = [...this.classes, ...addClasses];
    }
  }
  mute() {
    this.muted = true;
    if (this.notice) {
      this.notice.hide();
    }
  }
  unmute() {
    this.muted = false;
  }
  show(initialMessage, addClasses = [], duration = 0) {
    if (!this.notice && !this.muted) {
      const message = initialMessage && initialMessage.length > 0 ? initialMessage : " ";
      this.notice = new import_obsidian3.Notice(message, duration);
      this.notice.noticeEl.addClasses([...this.classes, ...addClasses]);
    }
  }
  updateClasses(addClasses = [], removeClasses = []) {
    if (this.muted) {
      return;
    }
    this.classes = this.classes.filter((c) => !removeClasses.includes(c));
    if (this.notice) {
      this.notice.noticeEl.removeClasses(removeClasses);
      this.notice.noticeEl.addClasses(addClasses);
    }
    this.classes = [...this.classes, ...addClasses];
  }
  // allows error display to override muted
  setMessage(message, isError) {
    if (isError) {
      if (!this.notice) {
        this.notice = new import_obsidian3.Notice(message, 0);
        this.notice.noticeEl.addClasses(["fit-notice", "error"]);
      } else {
        this.notice.setMessage(message);
      }
    } else {
      if (this.notice && !this.muted) {
        this.notice.setMessage(message);
      }
    }
  }
  remove(finalClass, duration = 5e3) {
    var _a, _b, _c;
    if (this.muted) {
      return;
    }
    (_a = this.notice) == null ? void 0 : _a.noticeEl.removeClasses(this.classes.filter((c) => c !== "fit-notice"));
    if (finalClass) {
      (_b = this.notice) == null ? void 0 : _b.noticeEl.addClass(finalClass);
    } else {
      (_c = this.notice) == null ? void 0 : _c.noticeEl.addClass("done");
    }
    setTimeout(() => {
      var _a2;
      return (_a2 = this.notice) == null ? void 0 : _a2.hide();
    }, duration);
  }
};

// src/fitSetting.ts
var import_obsidian4 = require("obsidian");
var FitSettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    // patSetting: Setting;
    // ownerSetting: Setting;
    // repoSetting: Setting;
    // branchSetting: Setting;
    // syncPathSetting: Setting;
    // existingRepos: Array<string>;
    // existingBranches: Array<string>;
    // repoLink: string;
    // syncPath: string;
    this.currentSyncIndex = 0;
    this.getLatestLink = () => {
      const currentSetting = this.getCurrentSyncSetting();
      const { owner, repo, branch } = currentSetting;
      if (owner.length > 0 && repo.length > 0 && branch.length > 0) {
        return `https://github.com/${owner}/${repo}/tree/${branch}`;
      }
      return "";
    };
    this.localConfigBlock = () => {
      const { containerEl } = this;
      new import_obsidian4.Setting(containerEl).setHeading().setName("Local configurations");
      new import_obsidian4.Setting(containerEl).setName("Auto sync").setDesc(`Automatically sync your vault when remote has updates. (Muted: sync in the background without displaying notices, except for file changes and conflicts notice)`).addDropdown((dropdown) => {
        dropdown.addOption("off", "Off").addOption("muted", "Muted").addOption("remind", "Remind only").addOption("on", "On").setValue(this.plugin.storage.autoSync ? this.plugin.storage.autoSync : "off").onChange(async (value) => {
          this.plugin.storage.autoSync = value;
          checkIntervalSlider.settingEl.addClass(value === "off" ? "clear" : "restore");
          checkIntervalSlider.settingEl.removeClass(value === "off" ? "restore" : "clear");
          await this.plugin.saveSettings();
        });
      });
      const checkIntervalSlider = new import_obsidian4.Setting(containerEl).setName("Auto check interval").setDesc(`Automatically check for remote changes in the background every ${this.plugin.storage.checkEveryXMinutes} minutes.`).addSlider(
        (slider) => slider.setLimits(1, 60, 1).setValue(this.plugin.storage.checkEveryXMinutes).setDynamicTooltip().onChange(async (value) => {
          this.plugin.storage.checkEveryXMinutes = value;
          await this.plugin.saveSettings();
          checkIntervalSlider.setDesc(`Automatically check for remote changes in the background every ${value} minutes.`);
        })
      );
      if (this.plugin.storage.autoSync === "off") {
        checkIntervalSlider.settingEl.addClass("clear");
      }
    };
    this.noticeConfigBlock = () => {
      const { containerEl } = this;
      const selectedCol = "var(--interactive-accent)";
      const selectedTxtCol = "var(--text-on-accent)";
      const unselectedColor = "var(--interactive-normal)";
      const unselectedTxtCol = "var(--text-normal)";
      const stateTextMap = (notifyConflicts, notifyChanges) => {
        if (notifyConflicts && notifyChanges) {
          return "Displaying file changes and conflicts ";
        } else if (!notifyConflicts && notifyChanges) {
          return "Displaying file changes ";
        } else if (notifyConflicts && !notifyChanges) {
          return "Displaying change conflicts ";
        } else {
          return "No notice displayed ";
        }
      };
      const noticeDisplay = new import_obsidian4.Setting(containerEl).setName("Notice display").setDesc(`${stateTextMap(this.plugin.storage.notifyConflicts, this.plugin.storage.notifyChanges)} after sync.`).addButton((button) => {
        button.setButtonText("Change conflicts");
        button.onClick(async () => {
          const notifyConflicts = !this.plugin.storage.notifyConflicts;
          this.plugin.storage.notifyConflicts = notifyConflicts;
          await this.plugin.saveSettings();
          button.buttonEl.setCssStyles({
            "background": notifyConflicts ? selectedCol : unselectedColor,
            "color": notifyConflicts ? selectedTxtCol : unselectedTxtCol
          });
          noticeDisplay.setDesc(`${stateTextMap(notifyConflicts, this.plugin.storage.notifyChanges)} after sync.`);
        });
        button.buttonEl.setCssStyles({
          "background": this.plugin.storage.notifyConflicts ? selectedCol : unselectedColor,
          "color": this.plugin.storage.notifyConflicts ? selectedTxtCol : unselectedTxtCol
        });
      }).addButton((button) => {
        button.setButtonText("File changes");
        button.onClick(async () => {
          const notifyChanges = !this.plugin.storage.notifyChanges;
          this.plugin.storage.notifyChanges = notifyChanges;
          await this.plugin.saveSettings();
          button.buttonEl.setCssStyles({
            "background": notifyChanges ? selectedCol : unselectedColor,
            "color": notifyChanges ? selectedTxtCol : unselectedTxtCol
          });
          noticeDisplay.setDesc(`${stateTextMap(this.plugin.storage.notifyConflicts, notifyChanges)} after sync.`);
        });
        button.buttonEl.setCssStyles({
          "background": this.plugin.storage.notifyChanges ? selectedCol : unselectedColor,
          "color": this.plugin.storage.notifyChanges ? selectedTxtCol : unselectedTxtCol
        });
      });
    };
    this.counterRepoBlock = () => {
      const { containerEl } = this;
      new import_obsidian4.Setting(containerEl).setName("Manage repositories").setDesc("Add or remove repository configurations").addButton((button) => button.setButtonText("Add Repository").setCta().onClick(async () => {
        this.plugin.storage.repo.push(DEFAULT_REPOSITORY);
        await this.plugin.saveSettings();
        await this.display();
      })).addButton((button) => button.setButtonText("Remove Repository").setWarning().setDisabled(this.plugin.storage.repo.length <= 1).onClick(async () => {
        if (this.plugin.storage.repo.length > 1) {
          this.plugin.storage.repo.splice(this.currentSyncIndex, 1);
          if (this.currentSyncIndex >= this.plugin.storage.repo.length) {
            this.currentSyncIndex = this.plugin.storage.repo.length - 1;
          }
          await this.plugin.saveSettings();
          await this.display();
        }
      }));
      new import_obsidian4.Setting(containerEl).setName("Current repository").setDesc("Select which repository configuration to edit").addDropdown((dropdown) => {
        this.plugin.storage.repo.forEach((_, index) => {
          dropdown.addOption(index.toString(), `Repository ${index + 1}`);
        });
        dropdown.setValue(this.currentSyncIndex.toString());
        dropdown.onChange(async (value) => {
          this.currentSyncIndex = parseInt(value);
          await this.plugin.saveSettings();
          await this.display();
        });
      });
    };
    this.resetBlock = () => {
      const { containerEl } = this;
      new import_obsidian4.Setting(containerEl).setName("Reset settings").setDesc("Remove Sync storage or Settings").addButton((button) => button.setButtonText("Reset storage").setWarning().onClick(async () => {
        for (let storage of this.plugin.storage.repo) {
          storage.localStore = DEFAULT_LOCAL_STORE;
        }
        await this.plugin.saveSettings();
        await this.display();
      })).addButton((button) => button.setButtonText("Reset Settings").setWarning().onClick(async () => {
        this.plugin.storage.repo = [DEFAULT_REPOSITORY];
        await this.plugin.saveSettings();
        await this.display();
      }));
    };
    this.plugin = plugin;
  }
  getCurrentSyncSetting() {
    return this.plugin.storage.repo[this.currentSyncIndex].settings;
  }
  async githubUserInfoBlock() {
    const { containerEl } = this;
    const currentSetting = this.getCurrentSyncSetting();
    const allItems = await this.plugin.vaultOps.getAllInVault();
    const allPaths = [...allItems.folders, ...allItems.files];
    const { folders, files } = allItems;
    new import_obsidian4.Setting(containerEl).setHeading().setName(`GitHub user info (Repository ${this.currentSyncIndex + 1})`);
    new import_obsidian4.Setting(containerEl).setName("Github username").setDesc("Enter your name on Github").addText((text) => text.setPlaceholder("GitHub username").setValue(currentSetting.owner).onChange(async (value) => {
      currentSetting.owner = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Github personal access token").setDesc("Remember to give it access for reading and writing to the storage repo.").addText((text) => text.setPlaceholder("GitHub personal access token").setValue(currentSetting.pat).onChange(async (value) => {
      currentSetting.pat = value;
      await this.plugin.saveSettings();
    })).addExtraButton((button) => button.setIcon("external-link").setTooltip("Create a token").onClick(async () => {
      window.open("https://github.com/settings/tokens/new", "_blank");
    }));
    new import_obsidian4.Setting(containerEl).setName("Device name").setDesc("Sign commit message with this device name.").addText((text) => text.setPlaceholder("Device name").setValue(currentSetting.deviceName).onChange(async (value) => {
      currentSetting.deviceName = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Repository name").setDesc("Select a repo.").addText((text) => text.setPlaceholder("Repository").setValue(currentSetting.repo).onChange(async (value) => {
      currentSetting.repo = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Branch name").setDesc("Select a branch.").addText((text) => text.setPlaceholder("Branch").setValue(currentSetting.branch).onChange(async (value) => {
      currentSetting.branch = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Sync path").setDesc("Select a local path to sync with the repo. If the field is empty, the entire vault will be synced.").addText(async (text) => {
      var _a;
      text.setPlaceholder("Enter folder path").setValue(currentSetting.syncPath || "").onChange(async (value) => {
        if (!folders2.contains(value))
          return;
        currentSetting.syncPath = value;
        await this.plugin.saveSettings();
      });
      const dataList = document.createElement("datalist");
      dataList.id = `folder-suggestions`;
      const otherSyncPath = /* @__PURE__ */ new Set();
      this.plugin.storage.repo.forEach(
        (el, i) => {
          if (i == this.currentSyncIndex)
            return;
          otherSyncPath.add(
            el.settings.syncPath
          );
        }
      );
      const allFolders = new Set(
        await this.plugin.vaultOps.getFoldersInVault()
      );
      const folders2 = Array.from(
        difference(allFolders, otherSyncPath)
      );
      for (let i in folders2) {
        const folder = folders2[i];
        const option = document.createElement("option");
        option.value = folder;
        dataList.appendChild(option);
      }
      text.inputEl.setAttribute("list", `folder-suggestions`);
      (_a = text.inputEl.parentElement) == null ? void 0 : _a.appendChild(dataList);
    });
    new import_obsidian4.Setting(containerEl).setName("View your vault on GitHub").addExtraButton(
      (button) => button.setTooltip("Open on GitHub").setIcon("external-link").onClick(() => {
        const link = this.getLatestLink();
        console.log(`opening ${link}`);
        window.open(link);
      })
    ).descEl.addClass("link-desc");
    new import_obsidian4.Setting(containerEl).setName("Excluded files/folders").setDesc("Files or folders within sync path that will not be synced").addButton((button) => button.setButtonText("Add exclusion").setCta().onClick(async () => {
      if (!currentSetting.excludes) {
        currentSetting.excludes = [];
      }
      currentSetting.excludes.push("");
      await this.plugin.saveSettings();
      await this.display();
    }));
    for (let index_ in currentSetting.excludes) {
      const index = Number(index_);
      const exclude = currentSetting.excludes[index];
      new import_obsidian4.Setting(containerEl).setName(`Exclusion ${index + 1}`).addText((text) => {
        var _a;
        text.setPlaceholder("path/to/exclude").setValue(exclude).onChange(async (value) => {
          if (!folders.contains(value) && !files.contains(value))
            return;
          currentSetting.excludes[index] = value;
          await this.plugin.saveSettings();
        });
        const dataList = document.createElement("datalist");
        dataList.id = `exclude-suggestions-${index}`;
        let filteredPaths = allPaths;
        if (currentSetting.syncPath) {
          filteredPaths = allPaths.filter(
            (path) => path.startsWith(currentSetting.syncPath + "/") || path === currentSetting.syncPath
          );
        }
        filteredPaths.forEach((path) => {
          const option = document.createElement("option");
          option.value = path;
          dataList.appendChild(option);
        });
        text.inputEl.setAttribute("list", `exclude-suggestions-${index}`);
        (_a = text.inputEl.parentElement) == null ? void 0 : _a.appendChild(dataList);
      }).addButton((button) => button.setIcon("trash").setTooltip("Remove this exclusion").onClick(async () => {
        currentSetting.excludes.splice(index, 1);
        await this.plugin.saveSettings();
        await this.display();
      }));
    }
  }
  async getItemsInSyncPath() {
    const currentSetting = this.getCurrentSyncSetting();
    if (!currentSetting.syncPath)
      return [];
    try {
      const syncPath = currentSetting.syncPath;
      const allItems = [];
      const all = await this.plugin.vaultOps.getAllInVault();
      for (const file in all) {
        if (syncPath == "" || file.startsWith(syncPath + "/") || file === syncPath) {
          allItems.push(file);
        }
      }
      return allItems.sort();
    } catch (error) {
      console.error("Error getting items in sync path:", error);
      return [];
    }
  }
  importExport() {
    const { containerEl } = this;
    new import_obsidian4.Setting(containerEl).setName("Import/Export settings").setDesc("Backup or restore your plugin configuration").setHeading();
    const textAreaContainer = containerEl.createDiv("import-export-container");
    const textArea = textAreaContainer.createEl("textarea", {
      attr: {
        placeholder: "Configuration JSON will appear here...",
        rows: "10",
        style: "width: 100%; font-family: monospace;"
      },
      cls: "import-export-textarea"
    });
    new import_obsidian4.Setting(containerEl).addButton((button) => button.setButtonText("Export to Text Field").setCta().onClick(async () => {
      this.exportToTextField(textArea);
    })).addButton((button) => button.setButtonText("Import from Text Field").setWarning().onClick(async () => {
      await this.importFromTextField(textArea);
    })).addButton((button) => button.setButtonText("Clear Field").setIcon("trash").onClick(() => {
      textArea.value = "";
    }));
  }
  exportToTextField(textArea) {
    try {
      const result = structuredClone(this.plugin.storage);
      for (let i in result.repo) {
        delete result.repo[i].localStore;
      }
      const settingsJson = JSON.stringify(result, null, 4);
      textArea.value = settingsJson;
      textArea.focus();
      textArea.select();
    } catch (error) {
      console.error("Error exporting settings:", error);
      new import_obsidian4.Notice("Error exporting configuration", 3e3);
    }
  }
  async importFromTextField(textArea) {
    try {
      const jsonContent = textArea.value.trim();
      if (!jsonContent) {
        new import_obsidian4.Notice("Text field is empty", 3e3);
        return;
      }
      const importedSettings = JSON.parse(jsonContent);
      if (this.validateImportedSettings(importedSettings)) {
        for (let repo of importedSettings.repo) {
          repo.localStore = DEFAULT_LOCAL_STORE;
        }
        this.plugin.storage = importedSettings;
        await this.plugin.saveSettings();
        new import_obsidian4.Notice("Settings imported successfully!", 3e3);
        await this.display();
      } else {
        new import_obsidian4.Notice("Invalid settings format in text field", 4e3);
      }
    } catch (error) {
      console.error("Error importing settings from text field:", error);
      new import_obsidian4.Notice("Error parsing JSON configuration", 4e3);
    }
  }
  validateImportedSettings(settings) {
    return settings && typeof settings === "object" && Array.isArray(settings.repo) && settings.repo.length > 0 && settings.repo[0].settings && typeof settings.repo[0].settings === "object" && "syncPath" in settings.repo[0].settings;
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    this.localConfigBlock();
    this.noticeConfigBlock();
    containerEl.createEl("hr");
    await this.importExport();
    containerEl.createEl("hr");
    this.counterRepoBlock();
    containerEl.createEl("hr");
    this.resetBlock();
    containerEl.createEl("hr");
    await this.githubUserInfoBlock();
  }
};

// src/fitSync.ts
var import_obsidian5 = require("obsidian");

// src/fitPull.ts
var FitPull = class {
  constructor(fit) {
    this.fit = fit;
  }
  async performPrePullChecks(localChanges) {
    const { remoteCommitSha, updated } = await this.fit.remoteUpdated();
    if (!updated) {
      return { status: "localCopyUpToDate", remoteUpdate: null };
    }
    if (!localChanges) {
      localChanges = await this.fit.getLocalChanges();
    }
    const remoteTreeSha = await this.fit.getRemoteTreeSha(remoteCommitSha);
    const remoteChanges = await this.fit.getRemoteChanges(remoteTreeSha);
    const clashedFiles = this.fit.getClashedChanges(localChanges, remoteChanges);
    const prePullCheckStatus = remoteChanges.length > 0 ? clashedFiles.length > 0 ? "localChangesClashWithRemoteChanges" : "remoteChangesCanBeMerged" : "noRemoteChangesDetected";
    return {
      status: prePullCheckStatus,
      remoteUpdate: {
        remoteChanges,
        remoteTreeSha,
        latestRemoteCommitSha: remoteCommitSha,
        clashedFiles
      }
    };
  }
  // Get changes from remote, pathShaMap is coupled to the Fit plugin design
  async getRemoteNonDeletionChangesContent(pathShaMap) {
    const remoteChanges = Object.entries(pathShaMap).map(async ([path, file_sha]) => {
      const content = await this.fit.getBlob(file_sha);
      return { path, content };
    });
    return await Promise.all(remoteChanges);
  }
  async prepareChangesToExecute(remoteChanges) {
    const deleteFromLocal = remoteChanges.filter((c) => c.status == "REMOVED").map((c) => c.path);
    const changesToProcess = remoteChanges.filter((c) => c.status != "REMOVED").reduce(
      (acc, change) => {
        acc[change.path] = change.currentSha;
        return acc;
      },
      {}
    );
    const addToLocal = await this.getRemoteNonDeletionChangesContent(changesToProcess);
    return { addToLocal, deleteFromLocal };
  }
  async pullRemoteToLocal(remoteUpdate, saveLocalStoreCallback) {
    const { remoteChanges, remoteTreeSha, latestRemoteCommitSha } = remoteUpdate;
    let { addToLocal, deleteFromLocal } = await this.prepareChangesToExecute(remoteChanges);
    const basepath = this.fit.syncPath;
    addToLocal = this.fit.getAddToLocal(addToLocal);
    deleteFromLocal = this.fit.getDeleteFromLocal(deleteFromLocal);
    const fileOpsRecord = await this.fit.vaultOps.updateLocalFiles(
      addToLocal,
      deleteFromLocal
    );
    await saveLocalStoreCallback(
      basepath,
      {
        lastFetchedRemoteSha: remoteTreeSha,
        lastFetchedCommitSha: latestRemoteCommitSha,
        localSha: await this.fit.computeLocalSha()
      }
    );
    return fileOpsRecord;
  }
};

// src/fitPush.ts
var FitPush = class {
  constructor(fit) {
    this.fit = fit;
  }
  async createCommitFromLocalUpdate(localUpdate, remoteTree) {
    const { localChanges, parentCommitSha } = localUpdate;
    const pushedChanges = [];
    const treeNodes = (await Promise.all(localChanges.map(async (f, i) => {
      const node = await this.fit.createTreeNodeFromFile(f, remoteTree);
      if (node) {
        pushedChanges.push(localChanges[i]);
        return node;
      }
    }))).filter(Boolean);
    console.log(treeNodes);
    if (treeNodes.length === 0) {
      return null;
    }
    const latestRemoteCommitTreeSha = await this.fit.getCommitTreeSha(parentCommitSha);
    const createdTreeSha = await this.fit.createTree(treeNodes, latestRemoteCommitTreeSha);
    const createdCommitSha = await this.fit.createCommit(createdTreeSha, parentCommitSha);
    return { createdCommitSha, pushedChanges };
  }
  async pushChangedFilesToRemote(localUpdate) {
    if (localUpdate.localChanges.length == 0) {
      return null;
    }
    const remoteTree = await this.fit.getTree(localUpdate.parentCommitSha);
    const createCommitResult = await this.createCommitFromLocalUpdate(localUpdate, remoteTree);
    if (!createCommitResult) {
      return null;
    }
    const { createdCommitSha, pushedChanges } = createCommitResult;
    const updatedRefSha = await this.fit.updateRef(createdCommitSha);
    const updatedRemoteTreeSha = await this.fit.getRemoteTreeSha(updatedRefSha);
    return {
      pushedChanges,
      lastFetchedRemoteSha: updatedRemoteTreeSha,
      lastFetchedCommitSha: createdCommitSha
    };
  }
};

// src/fitSync.ts
var FitSync = class {
  constructor(fit, vaultOps, saveLocalStoreCallback) {
    this.fit = fit;
    this.fitPull = new FitPull(fit);
    this.fitPush = new FitPush(fit);
    this.vaultOps = vaultOps;
    this.saveLocalStoreCallback = saveLocalStoreCallback;
  }
  async performPreSyncChecks() {
    const currentLocalSha = await this.fit.computeLocalSha();
    const localChanges = await this.fit.getLocalChanges(currentLocalSha);
    const { remoteCommitSha, updated: remoteUpdated } = await this.fit.remoteUpdated();
    if (localChanges.length === 0 && !remoteUpdated) {
      return { status: "inSync" };
    }
    const remoteTreeSha = await this.fit.getRemoteTreeSha(remoteCommitSha);
    const remoteChanges = await this.fit.getRemoteChanges(remoteTreeSha);
    let clashes = [];
    let status;
    if (localChanges.length > 0 && !remoteUpdated) {
      status = "onlyLocalChanged";
    } else if (remoteUpdated && localChanges.length === 0 && remoteChanges.length === 0) {
      status = "onlyRemoteCommitShaChanged";
    } else if (localChanges.length === 0 && remoteUpdated) {
      status = "onlyRemoteChanged";
    } else {
      clashes = this.fit.getClashedChanges(localChanges, remoteChanges);
      if (clashes.length === 0) {
        status = "localAndRemoteChangesCompatible";
      } else {
        status = "localAndRemoteChangesClashed";
      }
    }
    return {
      status,
      remoteUpdate: {
        remoteChanges,
        remoteTreeSha,
        latestRemoteCommitSha: remoteCommitSha,
        clashedFiles: clashes
      },
      localChanges,
      localTreeSha: currentLocalSha
    };
  }
  generateConflictReport(path, localContent, remoteContent) {
    const detectedExtension = extractExtension(path);
    let resolutionStrategy = "utf-8";
    if (detectedExtension && !RECOGNIZED_TXT_EXT.includes(detectedExtension))
      resolutionStrategy = "binary";
    return {
      path,
      resolutionStrategy,
      localContent,
      remoteContent
    };
  }
  async handleBinaryConflict(path, localContent, remoteContent) {
    const conflictPath = this.fit.syncPath + path;
    const conflictResolutionPath = conflictResolutionFolder + conflictPath;
    const excludes = this.fit.excludes;
    let isExcluded = false;
    if (excludes.length) {
      isExcluded = excludes.some((el) => conflictResolutionPath.startsWith(el));
    }
    if (isExcluded)
      return null;
    await Promise.all([
      this.fit.vaultOps.writeToLocal(conflictPath, remoteContent),
      this.fit.vaultOps.writeToLocal(conflictResolutionPath, localContent)
    ]);
    return {
      path: conflictResolutionPath,
      status: "created"
    };
  }
  async handleUTF8Conflict(path, localContent, remoteContent) {
    const conflictPath = this.fit.syncPath + path;
    const conflictResolutionPath = conflictResolutionFolder + conflictPath;
    const excludes = this.fit.excludes;
    let isExcluded = false;
    if (excludes.length) {
      isExcluded = excludes.some((el) => conflictResolutionPath.startsWith(el));
    }
    if (isExcluded)
      return null;
    await Promise.all([
      this.fit.vaultOps.writeToLocal(conflictPath, remoteContent),
      this.fit.vaultOps.writeToLocal(conflictResolutionPath, localContent)
    ]);
    return {
      path: conflictResolutionPath,
      status: "created"
    };
  }
  async handleLocalDeletionConflict(path, remoteContent) {
    const conflictResolutionPath = this.fit.syncPath + path;
    const excludes = this.fit.excludes;
    let isExcluded = false;
    if (excludes.length) {
      isExcluded = excludes.some((el) => conflictResolutionPath.startsWith(el));
    }
    if (isExcluded)
      return null;
    await this.fit.vaultOps.writeToLocal(conflictResolutionPath, remoteContent);
    return {
      path: conflictResolutionPath,
      status: "created"
    };
  }
  async resolveFileConflict(clash, latestRemoteFileSha) {
    if (clash.localStatus === "deleted" && clash.remoteStatus === "REMOVED") {
      return { path: clash.path, noDiff: true };
    } else if (clash.localStatus === "deleted") {
      const remoteContent2 = await this.fit.getBlob(latestRemoteFileSha);
      const fileOp = await this.handleLocalDeletionConflict(clash.path, remoteContent2);
      if (!fileOp)
        return null;
      return { path: clash.path, noDiff: false, fileOp };
    }
    const path = this.fit.syncPath + clash.path;
    const localFileContent = (0, import_obsidian5.arrayBufferToBase64)(
      await this.fit.vaultOps.vault.adapter.readBinary(path)
    );
    if (!latestRemoteFileSha)
      return { path: clash.path, noDiff: false };
    const remoteContent = await this.fit.getBlob(latestRemoteFileSha);
    if (removeLineEndingsFromBase64String(remoteContent) !== removeLineEndingsFromBase64String(localFileContent)) {
      const report = this.generateConflictReport(clash.path, localFileContent, remoteContent);
      let fileOp;
      if (report.resolutionStrategy === "binary") {
        fileOp = await this.handleBinaryConflict(clash.path, report.localContent, report.remoteContent);
      } else {
        fileOp = await this.handleUTF8Conflict(clash.path, report.localContent, report.remoteContent);
      }
      if (!fileOp)
        return null;
      return { path: clash.path, noDiff: false, fileOp };
    }
    return { path: clash.path, noDiff: true };
  }
  async resolveConflicts(clashedFiles, latestRemoteTreeSha) {
    const fileResolutions = await Promise.all(
      clashedFiles.map(
        async (clash) => {
          return await this.resolveFileConflict(clash, latestRemoteTreeSha[clash.path]);
        }
      )
    );
    const unresolvedFiles = fileResolutions.map((res, i) => {
      if (!(res == null ? void 0 : res.noDiff)) {
        return clashedFiles[i];
      }
      return null;
    }).filter(Boolean);
    return {
      noConflict: fileResolutions.every((res) => res == null ? void 0 : res.noDiff),
      unresolvedFiles,
      fileOpsRecord: fileResolutions.map((r) => r == null ? void 0 : r.fileOp).filter(Boolean)
    };
  }
  async syncCompatibleChanges(localUpdate, remoteUpdate, syncNotice) {
    let { addToLocal, deleteFromLocal } = await this.fitPull.prepareChangesToExecute(
      remoteUpdate.remoteChanges
    );
    syncNotice.setMessage("Uploading local changes");
    const remoteTree = await this.fit.getTree(localUpdate.parentCommitSha);
    const createCommitResult = await this.fitPush.createCommitFromLocalUpdate(localUpdate, remoteTree);
    let latestRemoteTreeSha;
    let latestCommitSha;
    let pushedChanges;
    if (createCommitResult) {
      const { createdCommitSha } = createCommitResult;
      const latestRefSha = await this.fit.updateRef(createdCommitSha);
      latestRemoteTreeSha = await this.fit.getRemoteTreeSha(latestRefSha);
      latestCommitSha = createdCommitSha;
      pushedChanges = createCommitResult.pushedChanges;
    } else {
      latestRemoteTreeSha = remoteUpdate.remoteTreeSha;
      latestCommitSha = remoteUpdate.latestRemoteCommitSha;
      pushedChanges = [];
    }
    syncNotice.setMessage("Writing remote changes to local");
    const basepath = this.fit.syncPath;
    addToLocal = this.fit.getAddToLocal(addToLocal);
    deleteFromLocal = this.fit.getDeleteFromLocal(deleteFromLocal);
    const localFileOpsRecord = await this.vaultOps.updateLocalFiles(addToLocal, deleteFromLocal);
    await this.saveLocalStoreCallback(
      basepath,
      {
        lastFetchedRemoteSha: latestRemoteTreeSha,
        lastFetchedCommitSha: latestCommitSha,
        localSha: await this.fit.computeLocalSha()
      }
    );
    syncNotice.setMessage("Sync successful");
    return { localOps: localFileOpsRecord, remoteOps: pushedChanges };
  }
  async syncWithConflicts(localChanges, remoteUpdate, syncNotice) {
    const { latestRemoteCommitSha, clashedFiles, remoteTreeSha: latestRemoteTreeSha } = remoteUpdate;
    const { noConflict, unresolvedFiles, fileOpsRecord } = await this.resolveConflicts(clashedFiles, latestRemoteTreeSha);
    let localChangesToPush;
    let remoteChangesToWrite;
    if (noConflict) {
      remoteChangesToWrite = remoteUpdate.remoteChanges.filter((c) => !localChanges.some((l) => l.path === c.path));
      localChangesToPush = localChanges.filter((c) => !remoteUpdate.remoteChanges.some((r) => r.path === c.path));
    } else {
      syncNotice.setMessage(`Change conflicts detected`);
      remoteChangesToWrite = remoteUpdate.remoteChanges.filter((c) => !unresolvedFiles.some((l) => l.path === c.path));
      localChangesToPush = localChanges;
    }
    let { addToLocal, deleteFromLocal } = await this.fitPull.prepareChangesToExecute(remoteChangesToWrite);
    const syncLocalUpdate = {
      localChanges: localChangesToPush,
      parentCommitSha: latestRemoteCommitSha
    };
    const pushResult = await this.fitPush.pushChangedFilesToRemote(syncLocalUpdate);
    let pushedChanges;
    let lastFetchedCommitSha;
    let lastFetchedRemoteSha;
    if (pushResult) {
      pushedChanges = pushResult.pushedChanges;
      lastFetchedCommitSha = pushResult.lastFetchedCommitSha;
      lastFetchedRemoteSha = pushResult.lastFetchedRemoteSha;
    } else {
      pushedChanges = [];
      lastFetchedCommitSha = remoteUpdate.latestRemoteCommitSha;
      lastFetchedRemoteSha = remoteUpdate.remoteTreeSha;
    }
    const basepath = this.fit.syncPath;
    addToLocal = this.fit.getAddToLocal(addToLocal);
    deleteFromLocal = this.fit.getDeleteFromLocal(deleteFromLocal);
    const localFileOpsRecord = await this.vaultOps.updateLocalFiles(
      addToLocal,
      deleteFromLocal
    );
    await this.saveLocalStoreCallback(
      basepath,
      {
        lastFetchedRemoteSha,
        lastFetchedCommitSha,
        localSha: await this.fit.computeLocalSha()
      }
    );
    const ops = localFileOpsRecord.concat(fileOpsRecord);
    if (unresolvedFiles.length === 0) {
      syncNotice.setMessage(`Sync successful`);
    } else if (unresolvedFiles.some((f) => f.remoteStatus !== "REMOVED")) {
      syncNotice.setMessage(`Synced with remote, unresolved conflicts written to ${conflictResolutionFolder}`);
    } else {
      syncNotice.setMessage(`Synced with remote, ignored remote deletion of locally changed files`);
    }
    return { unresolvedFiles, localOps: ops, remoteOps: pushedChanges };
  }
  async unresolvedChangesConflicts() {
    return await this.vaultOps.vault.adapter.exists(conflictResolutionFolder);
  }
  async sync(syncNotice) {
    syncNotice.setMessage("Performing pre sync checks.");
    if (await this.unresolvedChangesConflicts()) {
      syncNotice.setMessage(`There are unresolved files: pls, resolve files in: ${conflictResolutionFolder}.`);
      return;
    }
    const preSyncCheckResult = await this.performPreSyncChecks();
    if (preSyncCheckResult.status === "inSync") {
      syncNotice.setMessage("Sync successful");
      return;
    }
    if (preSyncCheckResult.status === "onlyRemoteCommitShaChanged") {
      const { latestRemoteCommitSha } = preSyncCheckResult.remoteUpdate;
      await this.saveLocalStoreCallback(
        this.fit.syncPath,
        { lastFetchedCommitSha: latestRemoteCommitSha }
      );
      syncNotice.setMessage("Sync successful");
      return;
    }
    const remoteUpdate = preSyncCheckResult.remoteUpdate;
    if (preSyncCheckResult.status === "onlyRemoteChanged") {
      const fileOpsRecord = await this.fitPull.pullRemoteToLocal(
        remoteUpdate,
        this.saveLocalStoreCallback
      );
      syncNotice.setMessage("Sync successful");
      return {
        ops: [{ heading: "Local file updates:", ops: fileOpsRecord }],
        clash: []
        // basepath: this.fit.syncPath
      };
    }
    const { localChanges, localTreeSha } = preSyncCheckResult;
    const localUpdate = {
      localChanges,
      parentCommitSha: remoteUpdate.latestRemoteCommitSha
    };
    if (preSyncCheckResult.status === "onlyLocalChanged") {
      syncNotice.setMessage("Uploading local changes");
      const pushResult = await this.fitPush.pushChangedFilesToRemote(localUpdate);
      syncNotice.setMessage("Sync successful");
      if (pushResult) {
        await this.saveLocalStoreCallback(
          this.fit.syncPath,
          {
            localSha: localTreeSha,
            lastFetchedRemoteSha: pushResult.lastFetchedRemoteSha,
            lastFetchedCommitSha: pushResult.lastFetchedCommitSha
          }
        );
        return {
          ops: [{ heading: "Local file updates:", ops: pushResult.pushedChanges }],
          clash: []
          // basepath: this.fit.syncPath
        };
      }
      return;
    }
    if (preSyncCheckResult.status === "localAndRemoteChangesCompatible") {
      const { localOps, remoteOps } = await this.syncCompatibleChanges(
        localUpdate,
        remoteUpdate,
        syncNotice
      );
      return {
        ops: [
          { heading: "Local file updates:", ops: localOps },
          { heading: "Remote file updates:", ops: remoteOps }
        ],
        clash: []
        // basepath: this.fit.syncPath
      };
    }
    if (preSyncCheckResult.status === "localAndRemoteChangesClashed") {
      const conflictResolutionResult = await this.syncWithConflicts(
        localUpdate.localChanges,
        remoteUpdate,
        syncNotice
      );
      if (conflictResolutionResult) {
        const { unresolvedFiles, localOps, remoteOps } = conflictResolutionResult;
        return {
          ops: [
            { heading: "Local file updates:", ops: localOps },
            { heading: "Remote file updates:", ops: remoteOps }
          ],
          clash: unresolvedFiles
          // basepath: this.fit.syncPath
        };
      }
    }
  }
};

// src/vaultOps.ts
var import_obsidian6 = require("obsidian");
var VaultOperations = class {
  constructor(vault) {
    this.vault = vault;
  }
  async getTFile(path) {
    const file = this.vault.getAbstractFileByPath(path);
    if (file && file instanceof import_obsidian6.TFile) {
      return file;
    } else {
      return null;
    }
  }
  async deleteFromLocal(path) {
    const isExists = await this.vault.adapter.exists(path);
    if (!isExists) {
      console.error(`Attempting to read ${path} from local drive but not successful:
                the file doesn't exists`);
      return null;
    }
    await this.vault.adapter.remove(path);
    return { path, status: "deleted" };
  }
  // if checking a folder, require including the last / in the path param
  async ensureFolderExists(path) {
    var _a;
    const folderPath = ((_a = path.match(/^(.*)\//)) == null ? void 0 : _a[1]) || "";
    if (folderPath == "") {
      return false;
    }
    const parts = folderPath.split("/");
    let currentPath = "";
    for (const part of parts) {
      currentPath += part + "/";
      try {
        const isExists = await this.vault.adapter.exists(currentPath, true);
        if (isExists)
          continue;
        await this.vault.adapter.mkdir(currentPath);
      } catch (e) {
        return false;
      }
    }
    return true;
  }
  async writeToLocal(path, content) {
    const file = await this.vault.adapter.exists(path);
    if (file) {
      await this.vault.adapter.writeBinary(path, (0, import_obsidian6.base64ToArrayBuffer)(content));
      return { path, status: "changed" };
    } else {
      await this.ensureFolderExists(path);
      await this.vault.adapter.writeBinary(path, (0, import_obsidian6.base64ToArrayBuffer)(content));
      return { path, status: "created" };
    }
  }
  async updateLocalFiles(addToLocal, deleteFromLocal) {
    const writeOperations = addToLocal.map(async ({ path, content }) => {
      return await this.writeToLocal(path, content);
    });
    const deletionOperations = deleteFromLocal.map(async (path) => {
      return await this.deleteFromLocal(path);
    });
    const fileOps = await Promise.all([...writeOperations, ...deletionOperations]);
    return fileOps;
  }
  // TODO хотя нигде не используется, мб удалить надо
  async createCopyInDir(path, copyDir = conflictResolutionFolder) {
    const file = await this.vault.adapter.exists(path);
    if (file) {
      const copyPath = copyDir + path;
      const copy = await this.vault.adapter.readBinary(path);
      await this.ensureFolderExists(copyPath);
      await this.vault.adapter.writeBinary(copyPath, copy);
      await this.vault.adapter.writeBinary(copyPath, copy);
    } else {
      throw new Error(`Attempting to create copy of ${path} from local drive as TFile but not successful,
            file is of type ${typeof file}.`);
    }
  }
  async getAllInObsidian() {
    const rootPath = this.vault.configDir;
    const folders = [rootPath + "/"];
    const files = [];
    const traverseDirectory = async (path) => {
      let items;
      try {
        items = await this.vault.adapter.list(path);
      } catch (error) {
        return null;
      }
      for (const folder of items.folders) {
        await traverseDirectory(folder);
        let folderPath = folder.startsWith("/") ? folder.slice(1) : folder;
        folderPath = folderPath === "" ? "" : `${folderPath}/`;
        folders.push(folderPath);
      }
      for (const file of items.files) {
        let filePath = file.startsWith("/") ? file.slice(1) : file;
        files.push(filePath);
      }
    };
    await traverseDirectory(rootPath);
    return { folders, files };
  }
  async getAllInVault() {
    const all = this.vault.getAllLoadedFiles();
    const folders = [];
    const files = [];
    for (let file of all) {
      if (file instanceof import_obsidian6.TFolder) {
        let path = file.path.startsWith("/") ? file.path.slice(1) : file.path;
        path = path == "" ? "" : `${path}/`;
        folders.push(path);
      } else if (file instanceof import_obsidian6.TFile) {
        const path = file.path.startsWith("/") ? file.path.slice(1) : file.path;
        files.push(path);
      }
    }
    const obsidianItems = await this.getAllInObsidian();
    const [obsidianFiles, obsidianFolders] = [obsidianItems.files, obsidianItems.folders];
    folders.push(...obsidianFolders);
    files.push(...obsidianFiles);
    return { folders, files };
  }
  async getFoldersInVault() {
    const { folders } = await this.getAllInVault();
    return folders;
  }
  async getFilesInVault() {
    const { files } = await this.getAllInVault();
    return files;
  }
};

// main.ts
var DEFAULT_LOCAL_STORE = {
  localSha: {},
  lastFetchedCommitSha: null,
  lastFetchedRemoteSha: {}
};
var DEFAULT_REPOSITORY = {
  settings: {
    pat: "",
    owner: "",
    avatarUrl: "",
    repo: "",
    branch: "",
    syncPath: "",
    deviceName: "",
    excludes: []
  },
  localStore: { ...DEFAULT_LOCAL_STORE }
};
var DEFAULT_SETTINGS = {
  repo: [DEFAULT_REPOSITORY],
  checkEveryXMinutes: 5,
  autoSync: "off",
  notifyChanges: true,
  notifyConflicts: true
};
var FitPlugin2 = class extends import_obsidian7.Plugin {
  constructor() {
    super(...arguments);
    // localStore: LocalStores
    this.fits = [];
    this.fitSync = [];
    // use of arrow functions to ensure this refers to the FitPlugin class
    this.saveLocalStoreCallback = async (path, localStore) => {
      const i = this.storage.repo.findIndex(
        (storage, _) => storage.settings.syncPath === path
      );
      if (i < 0) {
        return;
      }
      await this.loadSettings();
      this.storage.repo[i].localStore = {
        ...this.storage.repo[i].localStore,
        ...localStore
      };
      await this.saveSettings();
    };
    this.sync = async (syncNotice) => {
      if (!this.checkSettingsConfigured()) {
        return;
      }
      for (let i_ in this.fitSync) {
        let i = Number(i_);
        const fitSync = this.fitSync[i];
        const syncRecords = await fitSync.sync(syncNotice);
        if (!syncRecords)
          continue;
        let { ops, clash } = syncRecords;
        const basepath = this.storage.repo[i].settings.syncPath;
        clash = clash.map(
          (el) => {
            return {
              ...el,
              path: basepath + el.path
            };
          }
        );
        if (this.storage.notifyConflicts)
          showUnappliedConflicts(clash);
        if (this.storage.notifyChanges)
          showFileOpsRecord(ops);
      }
    };
    // wrapper to convert error to notice, return true if error is caught
    this.catchErrorAndNotify = async (func, notice, ...args) => {
      try {
        const result = await func(notice, ...args);
        return result;
      } catch (error) {
        if (error instanceof OctokitHttpError) {
          console.log("error.status");
          console.log(error.status);
          switch (error.source) {
            case "getTree":
            case "getRef":
              console.error("Caught error from getRef: ", error.message);
              if (error.status === 404) {
                notice.setMessage("Failed to get ref, make sure your repo name and branch name are set correctly.", true);
                return true;
              }
              notice.setMessage("Unknown error in getting ref, refers to console for details.", true);
              return true;
            case "getCommitTreeSha":
            case "getRemoteTreeSha":
            case "createBlob":
            case "createTreeNodeFromFile":
            case "createCommit":
            case "updateRef":
            case "getBlob":
          }
          return true;
        }
        console.error("Caught unknown error: ", error);
        notice.setMessage("Unable to sync, if you are not connected to the internet, turn off auto sync.", true);
        return true;
      }
    };
  }
  // if settings not configured, open settings to let user quickly setup
  // Note: this is not a stable feature and might be disabled at any point in the future
  openPluginSettings() {
    const appWithSetting = this.app;
    appWithSetting.setting.open();
    appWithSetting.setting.openTabById("fit");
  }
  async checkSettingsConfigured() {
    const actionItems = [];
    const settings = this.storage.repo;
    const folders = await this.vaultOps.getFoldersInVault();
    const setSyncPath = /* @__PURE__ */ new Set();
    for (let i_ in settings) {
      const i = Number(i_);
      const currentSetting = settings[i].settings;
      if (currentSetting.pat === "") {
        actionItems.push(`provide GitHub personal access token for repository: ${i + 1}`);
      }
      if (currentSetting.owner === "") {
        actionItems.push(`enter your Github nickname for repository: ${i + 1}`);
      }
      if (currentSetting.repo === "") {
        actionItems.push(`enter a repository to sync: ${i + 1}`);
      }
      if (currentSetting.branch === "") {
        actionItems.push(`enter a branch to sync: ${i + 1}`);
      }
      if (!folders.contains(currentSetting.syncPath)) {
        actionItems.push(`enter a directory (syncPath): ${i + 1}`);
      }
      for (let exlude of currentSetting.excludes) {
        if (exlude.startsWith(currentSetting.syncPath)) {
          continue;
        }
        actionItems.push(`enter a proper exlude (in syncPath) for repository: ${i + 1}`);
        break;
      }
      setSyncPath.add(currentSetting.syncPath);
    }
    if (setSyncPath.size != settings.length) {
      actionItems.push("Remove duplicate syncPaths");
    }
    if (actionItems.length > 0) {
      const initialMessage = "Settings not configured, please complete the following action items:\n" + actionItems.join("\n");
      const settingsNotice = new FitNotice(["static"], initialMessage);
      settingsNotice.remove("static");
      return false;
    }
    return true;
  }
  async getDiff() {
    if (!this.vaultOps.vault.getFolderByPath(rootFitFolder)) {
      new FitNotice(
        ["static"],
        "It's seems the folder doesn't exist"
      );
      return;
    }
    const files = await this.vaultOps.getFilesInVault();
    const conflictFiles = files.filter(
      (el) => el.startsWith(conflictResolutionFolder)
    );
    const conflictStatuses = await this.getConflictStatus(conflictFiles);
    const text = await this.getTextByConflictStatuses(conflictStatuses);
    await this.vaultOps.vault.adapter.write(conflictReportPath, text);
    this.app.workspace.getLeaf(true).openFile(
      this.vaultOps.vault.getFileByPath(conflictReportPath)
    );
  }
  loadRibbonIcons() {
    this.fitSyncRibbonIconEl = this.addRibbonIcon("github", "Fit Sync", async (evt) => {
      if (this.syncing || this.autoSyncing) {
        return;
      }
      this.syncing = true;
      this.fitSyncRibbonIconEl.addClass("animate-icon");
      const syncNotice = new FitNotice(["loading"], "Initiating sync");
      const errorCaught = await this.catchErrorAndNotify(this.sync, syncNotice);
      this.fitSyncRibbonIconEl.removeClass("animate-icon");
      if (errorCaught === true) {
        syncNotice.remove("error");
        this.syncing = false;
        return;
      }
      syncNotice.remove("done");
      this.syncing = false;
    });
    this.fitSyncRibbonIconEl.addClass("fit-sync-ribbon-el");
    this.addRibbonIcon(
      "git-compare-arrows",
      "Fit: show diff",
      async () => {
        const res = await this.getDiff();
      }
    );
  }
  async autoSync() {
    if (this.syncing || this.autoSyncing) {
      return;
    }
    this.autoSyncing = true;
    const syncNotice = new FitNotice(
      ["loading"],
      "Auto syncing",
      0,
      this.storage.autoSync === "muted"
    );
    const errorCaught = await this.catchErrorAndNotify(this.sync, syncNotice);
    if (errorCaught === true) {
      syncNotice.remove("error");
    } else {
      syncNotice.remove();
    }
    this.autoSyncing = false;
  }
  async autoUpdate() {
    if (!(this.storage.autoSync === "off") && !this.syncing && !this.autoSyncing && await this.checkSettingsConfigured()) {
      if (this.storage.autoSync === "on" || this.storage.autoSync === "muted") {
        await this.autoSync();
      } else if (this.storage.autoSync === "remind") {
        for (let fit of this.fits) {
          const { updated } = await fit.remoteUpdated();
          if (updated) {
            const initialMessage = "Remote update detected, please pull the latest changes.";
            const intervalNotice = new FitNotice(["static"], initialMessage);
            intervalNotice.remove("static");
          }
        }
      }
    }
  }
  async startOrUpdateAutoSyncInterval() {
    if (this.autoSyncIntervalId !== null) {
      window.clearInterval(this.autoSyncIntervalId);
      this.autoSyncIntervalId = null;
    }
    this.autoSyncIntervalId = window.setInterval(async () => {
      await this.autoUpdate();
    }, this.storage.checkEveryXMinutes * 60 * 1e3);
  }
  async onload() {
    await this.loadSettings();
    this.vaultOps = new VaultOperations(this.app.vault);
    const excludes = this.getExcludes();
    for (let repo_ of this.storage.repo) {
      let repo = structuredClone(repo_);
      for (let exclude of excludes) {
        if (exclude === repo.settings.syncPath)
          continue;
        repo.settings.excludes.push(exclude);
      }
      const fit = new Fit(repo, this.vaultOps);
      this.fits.push(fit);
      this.fitSync.push(
        new FitSync(fit, this.vaultOps, this.saveLocalStoreCallback)
      );
    }
    this.syncing = false;
    this.autoSyncing = false;
    this.settingTab = new FitSettingTab(this.app, this);
    this.loadRibbonIcons();
    this.addSettingTab(new FitSettingTab(this.app, this));
    await this.startOrUpdateAutoSyncInterval();
  }
  onunload() {
    if (this.autoSyncIntervalId !== null) {
      window.clearInterval(this.autoSyncIntervalId);
      this.autoSyncIntervalId = null;
    }
  }
  async loadSettings() {
    const userSetting = await this.loadData();
    const settings = Object.assign({}, DEFAULT_SETTINGS, userSetting);
    const settingsObj = Object.keys(DEFAULT_SETTINGS).reduce(
      (obj, key) => {
        if (settings.hasOwnProperty(key)) {
          if (key == "checkEveryXMinutes") {
            obj[key] = Number(settings[key]);
          } else if (key === "notifyChanges" || key === "notifyConflicts") {
            obj[key] = Boolean(settings[key]);
          } else {
            obj[key] = settings[key];
          }
        }
        return obj;
      },
      {}
    );
    this.storage = settingsObj;
  }
  // allow saving of local stores property, passed in properties will override existing stored value
  async saveSettings() {
    const data = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    const result = { ...data, ...this.storage };
    await this.saveData(result);
    const excludes = this.getExcludes();
    for (let i in this.fits) {
      let repo = structuredClone(this.storage.repo[i]);
      for (let exclude of excludes) {
        if (exclude === repo.settings.syncPath)
          continue;
        repo.settings.excludes.push(exclude);
      }
      this.fits[i].loadSettings(repo);
    }
    this.startOrUpdateAutoSyncInterval();
  }
  getExcludes() {
    const excludes = [];
    for (let repo of this.storage.repo) {
      const path = repo.settings.syncPath;
      if (path)
        excludes.push(path);
    }
    return excludes;
  }
  async getConflictStatus(conflictFiles) {
    const res = [];
    for (let file of conflictFiles) {
      let newFile = file.slice(conflictResolutionFolder.length);
      const isDeleted = !await this.vaultOps.vault.adapter.exists(newFile);
      const isBinary = isBinaryFile(file);
      res.push({
        oldFilePath: file,
        newFilePath: newFile,
        isDeleted,
        isBinary
      });
    }
    return res;
  }
  async getTextByConflictStatuses(statuses) {
    let result = "";
    const templateStart = "start of the: ";
    const templateEnd = "end of the: ";
    for (let status of statuses) {
      result += basicTemplateConflict + templateStart + status.newFilePath + "\n";
      if (status.isDeleted) {
        result += "local:  changed\n";
        result += "remote: deleted";
      } else if (status.isBinary) {
        result += "both file was modified:";
        result += `	old: ${status.oldFilePath}`;
        result += `	new: ${status.newFilePath}`;
      } else {
        result += getDiffText(
          await this.vaultOps.vault.adapter.read(status.oldFilePath),
          await this.vaultOps.vault.adapter.read(status.newFilePath)
        );
      }
      result += "\n";
      result += basicTemplateConflict + templateEnd + status.newFilePath + "\n";
      result += "\n\n\n";
    }
    return result;
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyIsICJzcmMvY29uc3QudHMiLCAibm9kZV9tb2R1bGVzL0BvY3Rva2l0L2NvcmUvbm9kZV9tb2R1bGVzL3VuaXZlcnNhbC11c2VyLWFnZW50L2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9iZWZvcmUtYWZ0ZXItaG9vay9saWIvcmVnaXN0ZXIuanMiLCAibm9kZV9tb2R1bGVzL2JlZm9yZS1hZnRlci1ob29rL2xpYi9hZGQuanMiLCAibm9kZV9tb2R1bGVzL2JlZm9yZS1hZnRlci1ob29rL2xpYi9yZW1vdmUuanMiLCAibm9kZV9tb2R1bGVzL2JlZm9yZS1hZnRlci1ob29rL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ab2N0b2tpdC9lbmRwb2ludC9ub2RlX21vZHVsZXMvdW5pdmVyc2FsLXVzZXItYWdlbnQvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BvY3Rva2l0L2VuZHBvaW50L2Rpc3QtYnVuZGxlL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ab2N0b2tpdC9yZXF1ZXN0L25vZGVfbW9kdWxlcy91bml2ZXJzYWwtdXNlci1hZ2VudC9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQG9jdG9raXQvcmVxdWVzdC9ub2RlX21vZHVsZXMvQG9jdG9raXQvcmVxdWVzdC1lcnJvci9kaXN0LXNyYy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQG9jdG9raXQvcmVxdWVzdC9kaXN0LWJ1bmRsZS9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQG9jdG9raXQvZ3JhcGhxbC9ub2RlX21vZHVsZXMvdW5pdmVyc2FsLXVzZXItYWdlbnQvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BvY3Rva2l0L2dyYXBocWwvZGlzdC1idW5kbGUvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BvY3Rva2l0L2F1dGgtdG9rZW4vZGlzdC1idW5kbGUvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BvY3Rva2l0L2NvcmUvZGlzdC1zcmMvdmVyc2lvbi5qcyIsICJub2RlX21vZHVsZXMvQG9jdG9raXQvY29yZS9kaXN0LXNyYy9pbmRleC5qcyIsICJzcmMvdXRpbHMudHMiLCAibm9kZV9tb2R1bGVzL2RpZmYvbGliZXNtL2RpZmYvYmFzZS5qcyIsICJub2RlX21vZHVsZXMvZGlmZi9saWJlc20vdXRpbC9zdHJpbmcuanMiLCAibm9kZV9tb2R1bGVzL2RpZmYvbGliZXNtL2RpZmYvd29yZC5qcyIsICJzcmMvZml0LnRzIiwgInNyYy9maXROb3RpY2UudHMiLCAic3JjL2ZpdFNldHRpbmcudHMiLCAic3JjL2ZpdFN5bmMudHMiLCAic3JjL2ZpdFB1bGwudHMiLCAic3JjL2ZpdFB1c2gudHMiLCAic3JjL3ZhdWx0T3BzLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgeyBub3JtYWxpemVQYXRoLCBQbHVnaW4sIFNldHRpbmdUYWIsIFRGaWxlIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgYmFzaWNUZW1wbGF0ZUNvbmZsaWN0LCBjb25mbGljdFJlcG9ydFBhdGgsIGNvbmZsaWN0UmVzb2x1dGlvbkZvbGRlciwgcm9vdEZpdEZvbGRlciB9IGZyb20gJ3NyYy9jb25zdCc7XG5pbXBvcnQgeyBGaXQsIE9jdG9raXRIdHRwRXJyb3IgfSBmcm9tICdzcmMvZml0JztcbmltcG9ydCBGaXROb3RpY2UgZnJvbSAnc3JjL2ZpdE5vdGljZSc7XG5pbXBvcnQgRml0U2V0dGluZ1RhYiBmcm9tICdzcmMvZml0U2V0dGluZyc7XG5pbXBvcnQgeyBGaXRTeW5jIH0gZnJvbSAnc3JjL2ZpdFN5bmMnO1xuaW1wb3J0IHsgZ2V0RGlmZlRleHQsIGlzQmluYXJ5RmlsZSwgc2hvd0ZpbGVPcHNSZWNvcmQsIHNob3dVbmFwcGxpZWRDb25mbGljdHMgfSBmcm9tICdzcmMvdXRpbHMnO1xuaW1wb3J0IHsgVmF1bHRPcGVyYXRpb25zIH0gZnJvbSAnc3JjL3ZhdWx0T3BzJztcblxudHlwZSBDb25mbGljdFN0YXR1cyA9IHtcbiAgICBvbGRGaWxlUGF0aDogc3RyaW5nLFxuICAgIG5ld0ZpbGVQYXRoOiBzdHJpbmcsXG4gICAgaXNEZWxldGVkOiBib29sZWFuLFxuICAgIGlzQmluYXJ5OiBib29sZWFuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3luY1NldHRpbmcge1xuICAgIHBhdDogc3RyaW5nO1xuICAgIG93bmVyOiBzdHJpbmc7XG4gICAgYXZhdGFyVXJsOiBzdHJpbmc7XG4gICAgcmVwbzogc3RyaW5nO1xuICAgIGJyYW5jaDogc3RyaW5nO1xuICAgIHN5bmNQYXRoOiBzdHJpbmc7XG4gICAgZGV2aWNlTmFtZTogc3RyaW5nO1xuICAgIGV4Y2x1ZGVzOiBzdHJpbmdbXVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIExvY2FsU3RvcmVzIHtcbiAgICBsb2NhbFNoYTogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICAgIGxhc3RGZXRjaGVkQ29tbWl0U2hhOiBzdHJpbmcgfCBudWxsXG4gICAgbGFzdEZldGNoZWRSZW1vdGVTaGE6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZXBvc2l0b3J5IHtcbiAgICBzZXR0aW5nczogU3luY1NldHRpbmdcbiAgICBsb2NhbFN0b3JlOiBMb2NhbFN0b3Jlc1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpdFN0b3JhZ2Uge1xuICAgIHJlcG86IFJlcG9zaXRvcnlbXVxuXG4gICAgY2hlY2tFdmVyeVhNaW51dGVzOiBudW1iZXI7XG4gICAgYXV0b1N5bmM6IFwib25cIiB8IFwib2ZmXCIgfCBcIm11dGVkXCIgfCBcInJlbWluZFwiO1xuICAgIG5vdGlmeUNoYW5nZXM6IGJvb2xlYW47XG4gICAgbm90aWZ5Q29uZmxpY3RzOiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9MT0NBTF9TVE9SRTogTG9jYWxTdG9yZXMgPSB7XG4gICAgbG9jYWxTaGE6IHt9LFxuICAgIGxhc3RGZXRjaGVkQ29tbWl0U2hhOiBudWxsLFxuICAgIGxhc3RGZXRjaGVkUmVtb3RlU2hhOiB7fVxufVxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9SRVBPU0lUT1JZID0ge1xuICAgIHNldHRpbmdzOiB7XG4gICAgICAgIHBhdDogXCJcIixcbiAgICAgICAgb3duZXI6IFwiXCIsXG4gICAgICAgIGF2YXRhclVybDogXCJcIixcbiAgICAgICAgcmVwbzogXCJcIixcbiAgICAgICAgYnJhbmNoOiBcIlwiLFxuICAgICAgICBzeW5jUGF0aDogXCJcIixcbiAgICAgICAgZGV2aWNlTmFtZTogXCJcIixcbiAgICAgICAgZXhjbHVkZXM6IFtdXG4gICAgfSxcbiAgICBsb2NhbFN0b3JlOiB7Li4uREVGQVVMVF9MT0NBTF9TVE9SRX1cbn1cblxuXG5jb25zdCBERUZBVUxUX1NFVFRJTkdTOiBGaXRTdG9yYWdlID0ge1xuICAgIHJlcG86IFtERUZBVUxUX1JFUE9TSVRPUlldLFxuICAgIGNoZWNrRXZlcnlYTWludXRlczogNSxcbiAgICBhdXRvU3luYzogXCJvZmZcIixcbiAgICBub3RpZnlDaGFuZ2VzOiB0cnVlLFxuICAgIG5vdGlmeUNvbmZsaWN0czogdHJ1ZSxcbn1cblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaXRQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xuICAgIHN0b3JhZ2U6IEZpdFN0b3JhZ2U7XG5cbiAgICBzZXR0aW5nVGFiOiBGaXRTZXR0aW5nVGFiXG4gICAgLy8gbG9jYWxTdG9yZTogTG9jYWxTdG9yZXNcblxuICAgIGZpdHM6IEZpdFtdID0gW107XG4gICAgZml0U3luYzogRml0U3luY1tdID0gW11cblxuICAgIHZhdWx0T3BzOiBWYXVsdE9wZXJhdGlvbnM7XG4gICAgYXV0b1N5bmNpbmc6IGJvb2xlYW5cbiAgICBzeW5jaW5nOiBib29sZWFuXG4gICAgYXV0b1N5bmNJbnRlcnZhbElkOiBudW1iZXIgfCBudWxsXG4gICAgZml0UHVsbFJpYmJvbkljb25FbDogSFRNTEVsZW1lbnRcbiAgICBmaXRQdXNoUmliYm9uSWNvbkVsOiBIVE1MRWxlbWVudFxuICAgIGZpdFN5bmNSaWJib25JY29uRWw6IEhUTUxFbGVtZW50XG5cbiAgICAvLyBpZiBzZXR0aW5ncyBub3QgY29uZmlndXJlZCwgb3BlbiBzZXR0aW5ncyB0byBsZXQgdXNlciBxdWlja2x5IHNldHVwXG4gICAgLy8gTm90ZTogdGhpcyBpcyBub3QgYSBzdGFibGUgZmVhdHVyZSBhbmQgbWlnaHQgYmUgZGlzYWJsZWQgYXQgYW55IHBvaW50IGluIHRoZSBmdXR1cmVcbiAgICBvcGVuUGx1Z2luU2V0dGluZ3MoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGNvbnN0IGFwcFdpdGhTZXR0aW5nID0gdGhpcy5hcHAgYXMgYW55IGFzIHtcbiAgICAgICAgICAgIHNldHRpbmc6IHtcbiAgICAgICAgICAgICAgICBvcGVuKCk6IHZvaWQ7XG4gICAgICAgICAgICAgICAgb3BlblRhYkJ5SWQoaWQ6IHN0cmluZyk6IFNldHRpbmdUYWIgfCBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFwcFdpdGhTZXR0aW5nLnNldHRpbmcub3BlbigpXG4gICAgICAgIGFwcFdpdGhTZXR0aW5nLnNldHRpbmcub3BlblRhYkJ5SWQoXCJmaXRcIilcbiAgICB9XG5cbiAgICBhc3luYyBjaGVja1NldHRpbmdzQ29uZmlndXJlZCgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgY29uc3QgYWN0aW9uSXRlbXM6IEFycmF5PHN0cmluZz4gPSBbXVxuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IHRoaXMuc3RvcmFnZS5yZXBvO1xuXG4gICAgICAgIGNvbnN0IGZvbGRlcnMgPSBhd2FpdCB0aGlzLnZhdWx0T3BzLmdldEZvbGRlcnNJblZhdWx0KClcbiAgICAgICAgY29uc3Qgc2V0U3luY1BhdGggPSBuZXcgU2V0KClcblxuICAgICAgICBmb3IgKGxldCBpXyBpbiBzZXR0aW5ncykge1xuICAgICAgICAgICAgY29uc3QgaSA9IE51bWJlcihpXylcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTZXR0aW5nID0gc2V0dGluZ3NbaV0uc2V0dGluZ3NcblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRTZXR0aW5nLnBhdCA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgIGFjdGlvbkl0ZW1zLnB1c2goYHByb3ZpZGUgR2l0SHViIHBlcnNvbmFsIGFjY2VzcyB0b2tlbiBmb3IgcmVwb3NpdG9yeTogJHtpKzF9YClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50U2V0dGluZy5vd25lciA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgIGFjdGlvbkl0ZW1zLnB1c2goYGVudGVyIHlvdXIgR2l0aHViIG5pY2tuYW1lIGZvciByZXBvc2l0b3J5OiAke2krMX1gKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRTZXR0aW5nLnJlcG8gPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25JdGVtcy5wdXNoKGBlbnRlciBhIHJlcG9zaXRvcnkgdG8gc3luYzogJHtpKzF9YClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50U2V0dGluZy5icmFuY2ggPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25JdGVtcy5wdXNoKGBlbnRlciBhIGJyYW5jaCB0byBzeW5jOiAke2krMX1gKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCAhZm9sZGVycy5jb250YWlucyhjdXJyZW50U2V0dGluZy5zeW5jUGF0aCkgKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uSXRlbXMucHVzaChgZW50ZXIgYSBkaXJlY3RvcnkgKHN5bmNQYXRoKTogJHtpKzF9YClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGV4bHVkZSBvZiBjdXJyZW50U2V0dGluZy5leGNsdWRlcykge1xuICAgICAgICAgICAgICAgIGlmIChleGx1ZGUuc3RhcnRzV2l0aChjdXJyZW50U2V0dGluZy5zeW5jUGF0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWN0aW9uSXRlbXMucHVzaChgZW50ZXIgYSBwcm9wZXIgZXhsdWRlIChpbiBzeW5jUGF0aCkgZm9yIHJlcG9zaXRvcnk6ICR7aSsxfWApXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2V0U3luY1BhdGguYWRkKGN1cnJlbnRTZXR0aW5nLnN5bmNQYXRoKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNldFN5bmNQYXRoLnNpemUgIT0gc2V0dGluZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBhY3Rpb25JdGVtcy5wdXNoKFwiUmVtb3ZlIGR1cGxpY2F0ZSBzeW5jUGF0aHNcIilcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKGFjdGlvbkl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxNZXNzYWdlID0gXCJTZXR0aW5ncyBub3QgY29uZmlndXJlZCwgcGxlYXNlIGNvbXBsZXRlIHRoZSBmb2xsb3dpbmcgYWN0aW9uIGl0ZW1zOlxcblwiICsgYWN0aW9uSXRlbXMuam9pbihcIlxcblwiKVxuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NOb3RpY2UgPSBuZXcgRml0Tm90aWNlKFtcInN0YXRpY1wiXSwgaW5pdGlhbE1lc3NhZ2UpXG4gICAgICAgICAgICAvLyB0aGlzLm9wZW5QbHVnaW5TZXR0aW5ncygpXG4gICAgICAgICAgICBzZXR0aW5nc05vdGljZS5yZW1vdmUoXCJzdGF0aWNcIilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhpcy5maXQubG9hZFNldHRpbmdzKGN1cnJlbnRTZXR0aW5nKVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIHVzZSBvZiBhcnJvdyBmdW5jdGlvbnMgdG8gZW5zdXJlIHRoaXMgcmVmZXJzIHRvIHRoZSBGaXRQbHVnaW4gY2xhc3NcbiAgICBzYXZlTG9jYWxTdG9yZUNhbGxiYWNrID0gYXN5bmMgKHBhdGg6IHN0cmluZywgbG9jYWxTdG9yZTogUGFydGlhbDxMb2NhbFN0b3Jlcz4pOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICAgICAgY29uc3QgaSA9IHRoaXMuc3RvcmFnZS5yZXBvLmZpbmRJbmRleChcbiAgICAgICAgICAgIChzdG9yYWdlLCBfKSA9PiBzdG9yYWdlLnNldHRpbmdzLnN5bmNQYXRoID09PSBwYXRoXG4gICAgICAgIClcblxuICAgICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgICAgIC8vIFRPRE8gc2hvdyBlcnJvclxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpXG5cbiAgICAgICAgdGhpcy5zdG9yYWdlLnJlcG9baV0ubG9jYWxTdG9yZSA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuc3RvcmFnZS5yZXBvW2ldLmxvY2FsU3RvcmUsXG4gICAgICAgICAgICAuLi5sb2NhbFN0b3JlXG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCB0aGlzLnNhdmVTZXR0aW5ncygpXG4gICAgfVxuXG4gICAgc3luYyA9IGFzeW5jIChzeW5jTm90aWNlOiBGaXROb3RpY2UpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrU2V0dGluZ3NDb25maWd1cmVkKCkpIHsgcmV0dXJuIH1cbiAgICAgICAgLy8gYXdhaXQgdGhpcy5sb2FkTG9jYWxTdG9yZSgpXG4gICAgICAgIGZvciAobGV0IGlfIGluIHRoaXMuZml0U3luYykge1xuICAgICAgICAgICAgbGV0IGkgPSBOdW1iZXIoaV8pXG4gICAgICAgICAgICBjb25zdCBmaXRTeW5jID0gdGhpcy5maXRTeW5jW2ldXG5cbiAgICAgICAgICAgIGNvbnN0IHN5bmNSZWNvcmRzID0gYXdhaXQgZml0U3luYy5zeW5jKHN5bmNOb3RpY2UpXG4gICAgICAgICAgICBpZiAoIXN5bmNSZWNvcmRzKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgICAgIGxldCB7IG9wcywgY2xhc2ggfSA9IHN5bmNSZWNvcmRzXG4gICAgICAgICAgICBjb25zdCBiYXNlcGF0aCA9IHRoaXMuc3RvcmFnZS5yZXBvW2ldLnNldHRpbmdzLnN5bmNQYXRoXG4gICAgICAgICAgICBjbGFzaCA9IGNsYXNoLm1hcChcbiAgICAgICAgICAgICAgICBlbCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5lbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGJhc2VwYXRoICsgZWwucGF0aFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RvcmFnZS5ub3RpZnlDb25mbGljdHMpXG4gICAgICAgICAgICAgICAgc2hvd1VuYXBwbGllZENvbmZsaWN0cyhjbGFzaClcblxuICAgICAgICAgICAgaWYgKHRoaXMuc3RvcmFnZS5ub3RpZnlDaGFuZ2VzKVxuICAgICAgICAgICAgICAgIHNob3dGaWxlT3BzUmVjb3JkKG9wcylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHdyYXBwZXIgdG8gY29udmVydCBlcnJvciB0byBub3RpY2UsIHJldHVybiB0cnVlIGlmIGVycm9yIGlzIGNhdWdodFxuICAgIGNhdGNoRXJyb3JBbmROb3RpZnkgPSBhc3luYyA8UCBleHRlbmRzIHVua25vd25bXSwgUj4oZnVuYzogKG5vdGljZTogRml0Tm90aWNlLCAuLi5hcmdzOiBQKSA9PiBQcm9taXNlPFI+LCBub3RpY2U6IEZpdE5vdGljZSwgLi4uYXJnczogUCk6IFByb21pc2U8UiB8IHRydWU+ID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZ1bmMobm90aWNlLCAuLi5hcmdzKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgT2N0b2tpdEh0dHBFcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZXJyb3Iuc3RhdHVzXCIpXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3Iuc3RhdHVzKVxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZXJyb3Iuc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2dldFRyZWUnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdnZXRSZWYnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkNhdWdodCBlcnJvciBmcm9tIGdldFJlZjogXCIsIGVycm9yLm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3Iuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RpY2Uuc2V0TWVzc2FnZShcIkZhaWxlZCB0byBnZXQgcmVmLCBtYWtlIHN1cmUgeW91ciByZXBvIG5hbWUgYW5kIGJyYW5jaCBuYW1lIGFyZSBzZXQgY29ycmVjdGx5LlwiLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RpY2Uuc2V0TWVzc2FnZShcIlVua25vd24gZXJyb3IgaW4gZ2V0dGluZyByZWYsIHJlZmVycyB0byBjb25zb2xlIGZvciBkZXRhaWxzLlwiLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZ2V0Q29tbWl0VHJlZVNoYSc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2dldFJlbW90ZVRyZWVTaGEnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdjcmVhdGVCbG9iJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY3JlYXRlVHJlZU5vZGVGcm9tRmlsZSc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NyZWF0ZUNvbW1pdCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3VwZGF0ZVJlZic6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2dldEJsb2InOlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkNhdWdodCB1bmtub3duIGVycm9yOiBcIiwgZXJyb3IpXG4gICAgICAgICAgICBub3RpY2Uuc2V0TWVzc2FnZShcIlVuYWJsZSB0byBzeW5jLCBpZiB5b3UgYXJlIG5vdCBjb25uZWN0ZWQgdG8gdGhlIGludGVybmV0LCB0dXJuIG9mZiBhdXRvIHN5bmMuXCIsIHRydWUpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0RGlmZigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhdWx0T3BzLnZhdWx0LmdldEZvbGRlckJ5UGF0aChyb290Rml0Rm9sZGVyKSkge1xuICAgICAgICAgICAgbmV3IEZpdE5vdGljZShcbiAgICAgICAgICAgICAgICBbXCJzdGF0aWNcIl0sXG4gICAgICAgICAgICAgICAgXCJJdCdzIHNlZW1zIHRoZSBmb2xkZXIgZG9lc24ndCBleGlzdFwiXG4gICAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZpbGVzID0gYXdhaXQgdGhpcy52YXVsdE9wcy5nZXRGaWxlc0luVmF1bHQoKVxuICAgICAgICBjb25zdCBjb25mbGljdEZpbGVzID0gZmlsZXMuZmlsdGVyKFxuICAgICAgICAgICAgZWwgPT4gZWwuc3RhcnRzV2l0aChjb25mbGljdFJlc29sdXRpb25Gb2xkZXIpXG4gICAgICAgIClcblxuICAgICAgICBjb25zdCBjb25mbGljdFN0YXR1c2VzID0gYXdhaXQgdGhpcy5nZXRDb25mbGljdFN0YXR1cyhjb25mbGljdEZpbGVzKVxuICAgICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgdGhpcy5nZXRUZXh0QnlDb25mbGljdFN0YXR1c2VzKGNvbmZsaWN0U3RhdHVzZXMpXG5cbiAgICAgICAgLy8gTk9URSB0byB3b3JrYXJvdW5kIEVycm9yOiBGaWxlIGV4aXN0c1xuICAgICAgICBhd2FpdCB0aGlzLnZhdWx0T3BzLnZhdWx0LmFkYXB0ZXIud3JpdGUoY29uZmxpY3RSZXBvcnRQYXRoLCB0ZXh0KVxuXG4gICAgICAgIHRoaXMuYXBwLndvcmtzcGFjZS5nZXRMZWFmKHRydWUpLm9wZW5GaWxlKFxuICAgICAgICAgICAgdGhpcy52YXVsdE9wcy52YXVsdC5nZXRGaWxlQnlQYXRoKGNvbmZsaWN0UmVwb3J0UGF0aCkgYXMgVEZpbGVcbiAgICAgICAgKVxuICAgIH1cblxuICAgIGxvYWRSaWJib25JY29ucygpIHtcbiAgICAgICAgLy8gUHVsbCBmcm9tIHJlbW90ZSB0aGVuIFB1c2ggdG8gcmVtb3RlIGlmIG5vIGNsYXNoaW5nIGNoYW5nZXMgZGV0ZWN0ZWQgZHVyaW5nIHB1bGxcbiAgICAgICAgdGhpcy5maXRTeW5jUmliYm9uSWNvbkVsID0gdGhpcy5hZGRSaWJib25JY29uKCdnaXRodWInLCAnRml0IFN5bmMnLCBhc3luYyAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5zeW5jaW5nIHx8IHRoaXMuYXV0b1N5bmNpbmcpIHsgcmV0dXJuIH1cbiAgICAgICAgICAgIHRoaXMuc3luY2luZyA9IHRydWVcbiAgICAgICAgICAgIHRoaXMuZml0U3luY1JpYmJvbkljb25FbC5hZGRDbGFzcygnYW5pbWF0ZS1pY29uJyk7XG4gICAgICAgICAgICBjb25zdCBzeW5jTm90aWNlID0gbmV3IEZpdE5vdGljZShbXCJsb2FkaW5nXCJdLCBcIkluaXRpYXRpbmcgc3luY1wiKTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yQ2F1Z2h0ID0gYXdhaXQgdGhpcy5jYXRjaEVycm9yQW5kTm90aWZ5KHRoaXMuc3luYywgc3luY05vdGljZSk7XG4gICAgICAgICAgICB0aGlzLmZpdFN5bmNSaWJib25JY29uRWwucmVtb3ZlQ2xhc3MoJ2FuaW1hdGUtaWNvbicpO1xuICAgICAgICAgICAgaWYgKGVycm9yQ2F1Z2h0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgc3luY05vdGljZS5yZW1vdmUoXCJlcnJvclwiKVxuICAgICAgICAgICAgICAgIHRoaXMuc3luY2luZyA9IGZhbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzeW5jTm90aWNlLnJlbW92ZShcImRvbmVcIilcbiAgICAgICAgICAgIHRoaXMuc3luY2luZyA9IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZpdFN5bmNSaWJib25JY29uRWwuYWRkQ2xhc3MoJ2ZpdC1zeW5jLXJpYmJvbi1lbCcpO1xuXG4gICAgICAgIHRoaXMuYWRkUmliYm9uSWNvbihcbiAgICAgICAgICAgIFwiZ2l0LWNvbXBhcmUtYXJyb3dzXCIsXG4gICAgICAgICAgICBcIkZpdDogc2hvdyBkaWZmXCIsXG4gICAgICAgICAgICBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5nZXREaWZmKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgIH1cblxuICAgIGFzeW5jIGF1dG9TeW5jKCkge1xuICAgICAgICBpZiAodGhpcy5zeW5jaW5nIHx8IHRoaXMuYXV0b1N5bmNpbmcpIHsgcmV0dXJuIH1cbiAgICAgICAgdGhpcy5hdXRvU3luY2luZyA9IHRydWVcbiAgICAgICAgY29uc3Qgc3luY05vdGljZSA9IG5ldyBGaXROb3RpY2UoXG4gICAgICAgICAgICBbXCJsb2FkaW5nXCJdLFxuICAgICAgICAgICAgXCJBdXRvIHN5bmNpbmdcIixcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UuYXV0b1N5bmMgPT09IFwibXV0ZWRcIlxuICAgICAgICApO1xuICAgICAgICBjb25zdCBlcnJvckNhdWdodCA9IGF3YWl0IHRoaXMuY2F0Y2hFcnJvckFuZE5vdGlmeSh0aGlzLnN5bmMsIHN5bmNOb3RpY2UpO1xuICAgICAgICBpZiAoZXJyb3JDYXVnaHQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHN5bmNOb3RpY2UucmVtb3ZlKFwiZXJyb3JcIilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN5bmNOb3RpY2UucmVtb3ZlKClcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF1dG9TeW5jaW5nID0gZmFsc2VcbiAgICB9XG5cbiAgICBhc3luYyBhdXRvVXBkYXRlKCkge1xuICAgICAgICBpZiAoISh0aGlzLnN0b3JhZ2UuYXV0b1N5bmMgPT09IFwib2ZmXCIpICYmICF0aGlzLnN5bmNpbmcgJiYgIXRoaXMuYXV0b1N5bmNpbmcgJiYgYXdhaXQgdGhpcy5jaGVja1NldHRpbmdzQ29uZmlndXJlZCgpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdG9yYWdlLmF1dG9TeW5jID09PSBcIm9uXCIgfHwgdGhpcy5zdG9yYWdlLmF1dG9TeW5jID09PSBcIm11dGVkXCIpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmF1dG9TeW5jKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RvcmFnZS5hdXRvU3luYyA9PT0gXCJyZW1pbmRcIikge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGZpdCBvZiB0aGlzLmZpdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB1cGRhdGVkIH0gPSBhd2FpdCBmaXQucmVtb3RlVXBkYXRlZCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh1cGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbml0aWFsTWVzc2FnZSA9IFwiUmVtb3RlIHVwZGF0ZSBkZXRlY3RlZCwgcGxlYXNlIHB1bGwgdGhlIGxhdGVzdCBjaGFuZ2VzLlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW50ZXJ2YWxOb3RpY2UgPSBuZXcgRml0Tm90aWNlKFtcInN0YXRpY1wiXSwgaW5pdGlhbE1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWxOb3RpY2UucmVtb3ZlKFwic3RhdGljXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBhc3luYyBzdGFydE9yVXBkYXRlQXV0b1N5bmNJbnRlcnZhbCgpIHtcbiAgICAgICAgLy8gQ2xlYXIgZXhpc3RpbmcgaW50ZXJ2YWwgaWYgaXQgZXhpc3RzXG4gICAgICAgIGlmICh0aGlzLmF1dG9TeW5jSW50ZXJ2YWxJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy5hdXRvU3luY0ludGVydmFsSWQpO1xuICAgICAgICAgICAgdGhpcy5hdXRvU3luY0ludGVydmFsSWQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgcmVtb3RlIGV2ZXJ5IFggbWludXRlcyAoc2V0IGluIHNldHRpbmdzKVxuICAgICAgICB0aGlzLmF1dG9TeW5jSW50ZXJ2YWxJZCA9IHdpbmRvdy5zZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmF1dG9VcGRhdGUoKTtcbiAgICAgICAgfSwgdGhpcy5zdG9yYWdlLmNoZWNrRXZlcnlYTWludXRlcyAqIDYwICogMTAwMCk7XG4gICAgfVxuXG4gICAgYXN5bmMgb25sb2FkKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xuXG4gICAgICAgIHRoaXMudmF1bHRPcHMgPSBuZXcgVmF1bHRPcGVyYXRpb25zKHRoaXMuYXBwLnZhdWx0KVxuXG4gICAgICAgIGNvbnN0IGV4Y2x1ZGVzID0gdGhpcy5nZXRFeGNsdWRlcygpXG4gICAgICAgIGZvciAobGV0IHJlcG9fIG9mIHRoaXMuc3RvcmFnZS5yZXBvKSB7XG4gICAgICAgICAgICBsZXQgcmVwbyA9IHN0cnVjdHVyZWRDbG9uZShyZXBvXylcblxuICAgICAgICAgICAgZm9yIChsZXQgZXhjbHVkZSBvZiBleGNsdWRlcykge1xuICAgICAgICAgICAgICAgIGlmIChleGNsdWRlID09PSByZXBvLnNldHRpbmdzLnN5bmNQYXRoKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgICAgICAgICAgcmVwby5zZXR0aW5ncy5leGNsdWRlcy5wdXNoKGV4Y2x1ZGUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGZpdCA9IG5ldyBGaXQocmVwbywgdGhpcy52YXVsdE9wcylcblxuICAgICAgICAgICAgdGhpcy5maXRzLnB1c2goZml0KVxuICAgICAgICAgICAgdGhpcy5maXRTeW5jLnB1c2goXG4gICAgICAgICAgICAgICAgbmV3IEZpdFN5bmMoZml0LCB0aGlzLnZhdWx0T3BzLCB0aGlzLnNhdmVMb2NhbFN0b3JlQ2FsbGJhY2spXG4gICAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN5bmNpbmcgPSBmYWxzZVxuICAgICAgICB0aGlzLmF1dG9TeW5jaW5nID0gZmFsc2VcbiAgICAgICAgdGhpcy5zZXR0aW5nVGFiID0gbmV3IEZpdFNldHRpbmdUYWIodGhpcy5hcHAsIHRoaXMpXG4gICAgICAgIHRoaXMubG9hZFJpYmJvbkljb25zKCk7XG5cbiAgICAgICAgLy8gVGhpcyBhZGRzIGEgc2V0dGluZ3MgdGFiIHNvIHRoZSB1c2VyIGNhbiBjb25maWd1cmUgdmFyaW91cyBhc3BlY3RzIG9mIHRoZSBwbHVnaW5cbiAgICAgICAgdGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBGaXRTZXR0aW5nVGFiKHRoaXMuYXBwLCB0aGlzKSk7XG5cbiAgICAgICAgLy8gcmVnaXN0ZXIgaW50ZXJ2YWwgdG8gcmVwZWF0IGF1dG8gY2hlY2tcbiAgICAgICAgYXdhaXQgdGhpcy5zdGFydE9yVXBkYXRlQXV0b1N5bmNJbnRlcnZhbCgpO1xuICAgIH1cblxuICAgIG9udW5sb2FkKCkge1xuICAgICAgICBpZiAodGhpcy5hdXRvU3luY0ludGVydmFsSWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuYXV0b1N5bmNJbnRlcnZhbElkKTtcbiAgICAgICAgICAgIHRoaXMuYXV0b1N5bmNJbnRlcnZhbElkID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcbiAgICAgICAgY29uc3QgdXNlclNldHRpbmcgPSBhd2FpdCB0aGlzLmxvYWREYXRhKClcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCB1c2VyU2V0dGluZyk7XG4gICAgICAgIGNvbnN0IHNldHRpbmdzT2JqOiBGaXRTdG9yYWdlID0gT2JqZWN0LmtleXMoREVGQVVMVF9TRVRUSU5HUykucmVkdWNlKFxuICAgICAgICAgICAgKG9iaiwga2V5OiBrZXlvZiBGaXRTdG9yYWdlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PSBcImNoZWNrRXZlcnlYTWludXRlc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IE51bWJlcihzZXR0aW5nc1trZXldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwibm90aWZ5Q2hhbmdlc1wiIHx8IGtleSA9PT0gXCJub3RpZnlDb25mbGljdHNcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0gPSBCb29sZWFuKHNldHRpbmdzW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0gPSBzZXR0aW5nc1trZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9LCB7fSBhcyBGaXRTdG9yYWdlKTtcbiAgICAgICAgdGhpcy5zdG9yYWdlID0gc2V0dGluZ3NPYmpcbiAgICB9XG5cbiAgICAvLyBhbGxvdyBzYXZpbmcgb2YgbG9jYWwgc3RvcmVzIHByb3BlcnR5LCBwYXNzZWQgaW4gcHJvcGVydGllcyB3aWxsIG92ZXJyaWRlIGV4aXN0aW5nIHN0b3JlZCB2YWx1ZVxuICAgIGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfU0VUVElOR1MsIGF3YWl0IHRoaXMubG9hZERhdGEoKSk7XG4gICAgICAgIC8vIGNvbnN0IGRhdGEgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCB0aGlzLnN0b3JhZ2UpO1xuICAgICAgICBjb25zdCByZXN1bHQ6IEZpdFN0b3JhZ2UgPSB7IC4uLmRhdGEsIC4uLnRoaXMuc3RvcmFnZSB9XG5cbiAgICAgICAgYXdhaXQgdGhpcy5zYXZlRGF0YShyZXN1bHQpO1xuXG4gICAgICAgIGNvbnN0IGV4Y2x1ZGVzID0gdGhpcy5nZXRFeGNsdWRlcygpXG5cbiAgICAgICAgLy8gc3luYyBzZXR0aW5ncyB0byBGaXQgY2xhc3MgYXMgd2VsbCB1cG9uIHNhdmluZ1xuICAgICAgICBmb3IgKGxldCBpIGluIHRoaXMuZml0cykge1xuICAgICAgICAgICAgbGV0IHJlcG8gPSBzdHJ1Y3R1cmVkQ2xvbmUodGhpcy5zdG9yYWdlLnJlcG9baV0pXG5cbiAgICAgICAgICAgIGZvciAobGV0IGV4Y2x1ZGUgb2YgZXhjbHVkZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhjbHVkZSA9PT0gcmVwby5zZXR0aW5ncy5zeW5jUGF0aClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWVcblxuICAgICAgICAgICAgICAgIHJlcG8uc2V0dGluZ3MuZXhjbHVkZXMucHVzaChleGNsdWRlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmZpdHNbaV0ubG9hZFNldHRpbmdzKHJlcG8pXG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgYXV0byBzeW5jIGludGVydmFsIHdpdGggbmV3IHNldHRpbmdcbiAgICAgICAgdGhpcy5zdGFydE9yVXBkYXRlQXV0b1N5bmNJbnRlcnZhbCgpO1xuICAgIH1cblxuICAgIGdldEV4Y2x1ZGVzKCk6IHN0cmluZ1tdIHtcbiAgICAgICAgY29uc3QgZXhjbHVkZXMgPSBbXVxuICAgICAgICBmb3IgKGxldCByZXBvIG9mIHRoaXMuc3RvcmFnZS5yZXBvKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gcmVwby5zZXR0aW5ncy5zeW5jUGF0aFxuICAgICAgICAgICAgaWYgKHBhdGgpXG4gICAgICAgICAgICAgICAgZXhjbHVkZXMucHVzaChwYXRoKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4Y2x1ZGVzXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBnZXRDb25mbGljdFN0YXR1cyhjb25mbGljdEZpbGVzOiBzdHJpbmdbXSk6IFByb21pc2U8Q29uZmxpY3RTdGF0dXNbXT4ge1xuICAgICAgICBjb25zdCByZXM6IENvbmZsaWN0U3RhdHVzW10gPSBbXVxuICAgICAgICBmb3IgKGxldCBmaWxlIG9mIGNvbmZsaWN0RmlsZXMpIHtcbiAgICAgICAgICAgIGxldCBuZXdGaWxlID0gZmlsZS5zbGljZShjb25mbGljdFJlc29sdXRpb25Gb2xkZXIubGVuZ3RoKVxuXG4gICAgICAgICAgICBjb25zdCBpc0RlbGV0ZWQgPSAhYXdhaXQgdGhpcy52YXVsdE9wcy52YXVsdC5hZGFwdGVyLmV4aXN0cyhuZXdGaWxlKVxuXG4gICAgICAgICAgICBjb25zdCBpc0JpbmFyeSA9IGlzQmluYXJ5RmlsZShmaWxlKVxuXG4gICAgICAgICAgICByZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgb2xkRmlsZVBhdGg6IGZpbGUsXG4gICAgICAgICAgICAgICAgbmV3RmlsZVBhdGg6IG5ld0ZpbGUsXG4gICAgICAgICAgICAgICAgaXNEZWxldGVkLCBpc0JpbmFyeVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBnZXRUZXh0QnlDb25mbGljdFN0YXR1c2VzKHN0YXR1c2VzOiBDb25mbGljdFN0YXR1c1tdKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgbGV0IHJlc3VsdCA9ICcnXG4gICAgICAgIC8qIE5PVEVcbiAgICAgICAgPj4+Pj4+Pj4+Pi0tLS0tLS0tLS1zdGFydCBvZiB0aGUgPGZpbGUgcGF0aD5cbiAgICAgICAgLS0tbG9jYWwgbGluZVxuICAgICAgICA8Y29udGVudD5cbiAgICAgICAgLS0tcmVtb3RlIGxpbmVcbiAgICAgICAgPGNvbnRlbnQ+XG5cbiAgICAgICAgPj4+Pj4+Pj4+Pi0tLS0tLS0tLS1zdGFydCBvZiB0aGUgPGZpbGUgcGF0aD5cbiAgICAgICAgbG9jYWw6ICBjaGFuZ2VkXG4gICAgICAgIHJlbW90ZTogZGVsZXRlZFxuICAgICAgICAqL1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZVN0YXJ0ID0gXCJzdGFydCBvZiB0aGU6IFwiXG4gICAgICAgIGNvbnN0IHRlbXBsYXRlRW5kID0gXCJlbmQgb2YgdGhlOiBcIlxuXG4gICAgICAgIGZvciAobGV0IHN0YXR1cyBvZiBzdGF0dXNlcykge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGJhc2ljVGVtcGxhdGVDb25mbGljdCArIHRlbXBsYXRlU3RhcnQgKyBzdGF0dXMubmV3RmlsZVBhdGggKyBcIlxcblwiXG5cbiAgICAgICAgICAgIGlmIChzdGF0dXMuaXNEZWxldGVkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwibG9jYWw6ICBjaGFuZ2VkXFxuXCJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCJyZW1vdGU6IGRlbGV0ZWRcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhdHVzLmlzQmluYXJ5KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdib3RoIGZpbGUgd2FzIG1vZGlmaWVkOidcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gYFxcdG9sZDogJHtzdGF0dXMub2xkRmlsZVBhdGh9YFxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBgXFx0bmV3OiAke3N0YXR1cy5uZXdGaWxlUGF0aH1gXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gZ2V0RGlmZlRleHQoXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudmF1bHRPcHMudmF1bHQuYWRhcHRlci5yZWFkKHN0YXR1cy5vbGRGaWxlUGF0aCksXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudmF1bHRPcHMudmF1bHQuYWRhcHRlci5yZWFkKHN0YXR1cy5uZXdGaWxlUGF0aClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0gXCJcXG5cIlxuXG4gICAgICAgICAgICByZXN1bHQgKz0gYmFzaWNUZW1wbGF0ZUNvbmZsaWN0ICsgdGVtcGxhdGVFbmQgKyBzdGF0dXMubmV3RmlsZVBhdGggKyBcIlxcblwiXG4gICAgICAgICAgICByZXN1bHQgKz0gXCJcXG5cXG5cXG5cIlxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuXG4gICAgfVxuXG59XG4iLCAiZXhwb3J0IGNvbnN0IHJvb3RGaXRGb2xkZXIgPSBcIl9maXRcIlxuXG5leHBvcnQgY29uc3QgY29uZmxpY3RSZXBvcnRQYXRoID0gcm9vdEZpdEZvbGRlciArIFwiL3JlcG9ydC1jb25mbGljdC5tZFwiXG5leHBvcnQgY29uc3QgY29uZmxpY3RSZXNvbHV0aW9uRm9sZGVyID0gcm9vdEZpdEZvbGRlciArIFwiL2NvbmZsaWN0L1wiXG5cbmV4cG9ydCBjb25zdCBiYXNpY1RlbXBsYXRlQ29uZmxpY3QgPSBcIjw8PC0tLVwiXG5cbi8vIGV4cG9ydCBjb25zdCBjaGFuZ2VzID0gcm9vdEZpdEZvbGRlciArIFwiL2NoYW5nZXNcIlxuIiwgImV4cG9ydCBmdW5jdGlvbiBnZXRVc2VyQWdlbnQoKSB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSBcIm9iamVjdFwiICYmIFwidXNlckFnZW50XCIgaW4gbmF2aWdhdG9yKSB7XG4gICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gIH1cblxuICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2Vzcy52ZXJzaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gYE5vZGUuanMvJHtwcm9jZXNzLnZlcnNpb24uc3Vic3RyKDEpfSAoJHtwcm9jZXNzLnBsYXRmb3JtfTsgJHtcbiAgICAgIHByb2Nlc3MuYXJjaFxuICAgIH0pYDtcbiAgfVxuXG4gIHJldHVybiBcIjxlbnZpcm9ubWVudCB1bmRldGVjdGFibGU+XCI7XG59XG4iLCAiLy8gQHRzLWNoZWNrXG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlcihzdGF0ZSwgbmFtZSwgbWV0aG9kLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgbWV0aG9kICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJtZXRob2QgZm9yIGJlZm9yZSBob29rIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG5hbWUpKSB7XG4gICAgcmV0dXJuIG5hbWUucmV2ZXJzZSgpLnJlZHVjZSgoY2FsbGJhY2ssIG5hbWUpID0+IHtcbiAgICAgIHJldHVybiByZWdpc3Rlci5iaW5kKG51bGwsIHN0YXRlLCBuYW1lLCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gICAgfSwgbWV0aG9kKSgpO1xuICB9XG5cbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgIGlmICghc3RhdGUucmVnaXN0cnlbbmFtZV0pIHtcbiAgICAgIHJldHVybiBtZXRob2Qob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXRlLnJlZ2lzdHJ5W25hbWVdLnJlZHVjZSgobWV0aG9kLCByZWdpc3RlcmVkKSA9PiB7XG4gICAgICByZXR1cm4gcmVnaXN0ZXJlZC5ob29rLmJpbmQobnVsbCwgbWV0aG9kLCBvcHRpb25zKTtcbiAgICB9LCBtZXRob2QpKCk7XG4gIH0pO1xufVxuIiwgIi8vIEB0cy1jaGVja1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkSG9vayhzdGF0ZSwga2luZCwgbmFtZSwgaG9vaykge1xuICBjb25zdCBvcmlnID0gaG9vaztcbiAgaWYgKCFzdGF0ZS5yZWdpc3RyeVtuYW1lXSkge1xuICAgIHN0YXRlLnJlZ2lzdHJ5W25hbWVdID0gW107XG4gIH1cblxuICBpZiAoa2luZCA9PT0gXCJiZWZvcmVcIikge1xuICAgIGhvb2sgPSAobWV0aG9kLCBvcHRpb25zKSA9PiB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgLnRoZW4ob3JpZy5iaW5kKG51bGwsIG9wdGlvbnMpKVxuICAgICAgICAudGhlbihtZXRob2QuYmluZChudWxsLCBvcHRpb25zKSk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChraW5kID09PSBcImFmdGVyXCIpIHtcbiAgICBob29rID0gKG1ldGhvZCwgb3B0aW9ucykgPT4ge1xuICAgICAgbGV0IHJlc3VsdDtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAudGhlbihtZXRob2QuYmluZChudWxsLCBvcHRpb25zKSlcbiAgICAgICAgLnRoZW4oKHJlc3VsdF8pID0+IHtcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHRfO1xuICAgICAgICAgIHJldHVybiBvcmlnKHJlc3VsdCwgb3B0aW9ucyk7XG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKGtpbmQgPT09IFwiZXJyb3JcIikge1xuICAgIGhvb2sgPSAobWV0aG9kLCBvcHRpb25zKSA9PiB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgLnRoZW4obWV0aG9kLmJpbmQobnVsbCwgb3B0aW9ucykpXG4gICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICByZXR1cm4gb3JpZyhlcnJvciwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gIH1cblxuICBzdGF0ZS5yZWdpc3RyeVtuYW1lXS5wdXNoKHtcbiAgICBob29rOiBob29rLFxuICAgIG9yaWc6IG9yaWcsXG4gIH0pO1xufVxuIiwgIi8vIEB0cy1jaGVja1xuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlSG9vayhzdGF0ZSwgbmFtZSwgbWV0aG9kKSB7XG4gIGlmICghc3RhdGUucmVnaXN0cnlbbmFtZV0pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBpbmRleCA9IHN0YXRlLnJlZ2lzdHJ5W25hbWVdXG4gICAgLm1hcCgocmVnaXN0ZXJlZCkgPT4ge1xuICAgICAgcmV0dXJuIHJlZ2lzdGVyZWQub3JpZztcbiAgICB9KVxuICAgIC5pbmRleE9mKG1ldGhvZCk7XG5cbiAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN0YXRlLnJlZ2lzdHJ5W25hbWVdLnNwbGljZShpbmRleCwgMSk7XG59XG4iLCAiLy8gQHRzLWNoZWNrXG5cbmltcG9ydCB7IHJlZ2lzdGVyIH0gZnJvbSBcIi4vbGliL3JlZ2lzdGVyLmpzXCI7XG5pbXBvcnQgeyBhZGRIb29rIH0gZnJvbSBcIi4vbGliL2FkZC5qc1wiO1xuaW1wb3J0IHsgcmVtb3ZlSG9vayB9IGZyb20gXCIuL2xpYi9yZW1vdmUuanNcIjtcblxuLy8gYmluZCB3aXRoIGFycmF5IG9mIGFyZ3VtZW50czogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIxNzkyOTEzXG5jb25zdCBiaW5kID0gRnVuY3Rpb24uYmluZDtcbmNvbnN0IGJpbmRhYmxlID0gYmluZC5iaW5kKGJpbmQpO1xuXG5mdW5jdGlvbiBiaW5kQXBpKGhvb2ssIHN0YXRlLCBuYW1lKSB7XG4gIGNvbnN0IHJlbW92ZUhvb2tSZWYgPSBiaW5kYWJsZShyZW1vdmVIb29rLCBudWxsKS5hcHBseShcbiAgICBudWxsLFxuICAgIG5hbWUgPyBbc3RhdGUsIG5hbWVdIDogW3N0YXRlXVxuICApO1xuICBob29rLmFwaSA9IHsgcmVtb3ZlOiByZW1vdmVIb29rUmVmIH07XG4gIGhvb2sucmVtb3ZlID0gcmVtb3ZlSG9va1JlZjtcbiAgW1wiYmVmb3JlXCIsIFwiZXJyb3JcIiwgXCJhZnRlclwiLCBcIndyYXBcIl0uZm9yRWFjaCgoa2luZCkgPT4ge1xuICAgIGNvbnN0IGFyZ3MgPSBuYW1lID8gW3N0YXRlLCBraW5kLCBuYW1lXSA6IFtzdGF0ZSwga2luZF07XG4gICAgaG9va1traW5kXSA9IGhvb2suYXBpW2tpbmRdID0gYmluZGFibGUoYWRkSG9vaywgbnVsbCkuYXBwbHkobnVsbCwgYXJncyk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBTaW5ndWxhcigpIHtcbiAgY29uc3Qgc2luZ3VsYXJIb29rTmFtZSA9IFN5bWJvbChcIlNpbmd1bGFyXCIpO1xuICBjb25zdCBzaW5ndWxhckhvb2tTdGF0ZSA9IHtcbiAgICByZWdpc3RyeToge30sXG4gIH07XG4gIGNvbnN0IHNpbmd1bGFySG9vayA9IHJlZ2lzdGVyLmJpbmQobnVsbCwgc2luZ3VsYXJIb29rU3RhdGUsIHNpbmd1bGFySG9va05hbWUpO1xuICBiaW5kQXBpKHNpbmd1bGFySG9vaywgc2luZ3VsYXJIb29rU3RhdGUsIHNpbmd1bGFySG9va05hbWUpO1xuICByZXR1cm4gc2luZ3VsYXJIb29rO1xufVxuXG5mdW5jdGlvbiBDb2xsZWN0aW9uKCkge1xuICBjb25zdCBzdGF0ZSA9IHtcbiAgICByZWdpc3RyeToge30sXG4gIH07XG5cbiAgY29uc3QgaG9vayA9IHJlZ2lzdGVyLmJpbmQobnVsbCwgc3RhdGUpO1xuICBiaW5kQXBpKGhvb2ssIHN0YXRlKTtcblxuICByZXR1cm4gaG9vaztcbn1cblxuZXhwb3J0IGRlZmF1bHQgeyBTaW5ndWxhciwgQ29sbGVjdGlvbiB9O1xuIiwgImV4cG9ydCBmdW5jdGlvbiBnZXRVc2VyQWdlbnQoKSB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSBcIm9iamVjdFwiICYmIFwidXNlckFnZW50XCIgaW4gbmF2aWdhdG9yKSB7XG4gICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gIH1cblxuICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2Vzcy52ZXJzaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gYE5vZGUuanMvJHtwcm9jZXNzLnZlcnNpb24uc3Vic3RyKDEpfSAoJHtwcm9jZXNzLnBsYXRmb3JtfTsgJHtcbiAgICAgIHByb2Nlc3MuYXJjaFxuICAgIH0pYDtcbiAgfVxuXG4gIHJldHVybiBcIjxlbnZpcm9ubWVudCB1bmRldGVjdGFibGU+XCI7XG59XG4iLCAiLy8gcGtnL2Rpc3Qtc3JjL2RlZmF1bHRzLmpzXG5pbXBvcnQgeyBnZXRVc2VyQWdlbnQgfSBmcm9tIFwidW5pdmVyc2FsLXVzZXItYWdlbnRcIjtcblxuLy8gcGtnL2Rpc3Qtc3JjL3ZlcnNpb24uanNcbnZhciBWRVJTSU9OID0gXCIwLjAuMC1kZXZlbG9wbWVudFwiO1xuXG4vLyBwa2cvZGlzdC1zcmMvZGVmYXVsdHMuanNcbnZhciB1c2VyQWdlbnQgPSBgb2N0b2tpdC1lbmRwb2ludC5qcy8ke1ZFUlNJT059ICR7Z2V0VXNlckFnZW50KCl9YDtcbnZhciBERUZBVUxUUyA9IHtcbiAgbWV0aG9kOiBcIkdFVFwiLFxuICBiYXNlVXJsOiBcImh0dHBzOi8vYXBpLmdpdGh1Yi5jb21cIixcbiAgaGVhZGVyczoge1xuICAgIGFjY2VwdDogXCJhcHBsaWNhdGlvbi92bmQuZ2l0aHViLnYzK2pzb25cIixcbiAgICBcInVzZXItYWdlbnRcIjogdXNlckFnZW50XG4gIH0sXG4gIG1lZGlhVHlwZToge1xuICAgIGZvcm1hdDogXCJcIlxuICB9XG59O1xuXG4vLyBwa2cvZGlzdC1zcmMvdXRpbC9sb3dlcmNhc2Uta2V5cy5qc1xuZnVuY3Rpb24gbG93ZXJjYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFvYmplY3QpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iamVjdCkucmVkdWNlKChuZXdPYmosIGtleSkgPT4ge1xuICAgIG5ld09ialtrZXkudG9Mb3dlckNhc2UoKV0gPSBvYmplY3Rba2V5XTtcbiAgICByZXR1cm4gbmV3T2JqO1xuICB9LCB7fSk7XG59XG5cbi8vIHBrZy9kaXN0LXNyYy91dGlsL2lzLXBsYWluLW9iamVjdC5qc1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09PSBudWxsKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgIT09IFwiW29iamVjdCBPYmplY3RdXCIpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbClcbiAgICByZXR1cm4gdHJ1ZTtcbiAgY29uc3QgQ3RvciA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgXCJjb25zdHJ1Y3RvclwiKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwoQ3RvcikgPT09IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsKHZhbHVlKTtcbn1cblxuLy8gcGtnL2Rpc3Qtc3JjL3V0aWwvbWVyZ2UtZGVlcC5qc1xuZnVuY3Rpb24gbWVyZ2VEZWVwKGRlZmF1bHRzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzKTtcbiAgT2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgaWYgKGlzUGxhaW5PYmplY3Qob3B0aW9uc1trZXldKSkge1xuICAgICAgaWYgKCEoa2V5IGluIGRlZmF1bHRzKSlcbiAgICAgICAgT2JqZWN0LmFzc2lnbihyZXN1bHQsIHsgW2tleV06IG9wdGlvbnNba2V5XSB9KTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZURlZXAoZGVmYXVsdHNba2V5XSwgb3B0aW9uc1trZXldKTtcbiAgICB9IGVsc2Uge1xuICAgICAgT2JqZWN0LmFzc2lnbihyZXN1bHQsIHsgW2tleV06IG9wdGlvbnNba2V5XSB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvdXRpbC9yZW1vdmUtdW5kZWZpbmVkLXByb3BlcnRpZXMuanNcbmZ1bmN0aW9uIHJlbW92ZVVuZGVmaW5lZFByb3BlcnRpZXMob2JqKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIGlmIChvYmpba2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8vIHBrZy9kaXN0LXNyYy9tZXJnZS5qc1xuZnVuY3Rpb24gbWVyZ2UoZGVmYXVsdHMsIHJvdXRlLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygcm91dGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICBsZXQgW21ldGhvZCwgdXJsXSA9IHJvdXRlLnNwbGl0KFwiIFwiKTtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih1cmwgPyB7IG1ldGhvZCwgdXJsIH0gOiB7IHVybDogbWV0aG9kIH0sIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCByb3V0ZSk7XG4gIH1cbiAgb3B0aW9ucy5oZWFkZXJzID0gbG93ZXJjYXNlS2V5cyhvcHRpb25zLmhlYWRlcnMpO1xuICByZW1vdmVVbmRlZmluZWRQcm9wZXJ0aWVzKG9wdGlvbnMpO1xuICByZW1vdmVVbmRlZmluZWRQcm9wZXJ0aWVzKG9wdGlvbnMuaGVhZGVycyk7XG4gIGNvbnN0IG1lcmdlZE9wdGlvbnMgPSBtZXJnZURlZXAoZGVmYXVsdHMgfHwge30sIG9wdGlvbnMpO1xuICBpZiAob3B0aW9ucy51cmwgPT09IFwiL2dyYXBocWxcIikge1xuICAgIGlmIChkZWZhdWx0cyAmJiBkZWZhdWx0cy5tZWRpYVR5cGUucHJldmlld3M/Lmxlbmd0aCkge1xuICAgICAgbWVyZ2VkT3B0aW9ucy5tZWRpYVR5cGUucHJldmlld3MgPSBkZWZhdWx0cy5tZWRpYVR5cGUucHJldmlld3MuZmlsdGVyKFxuICAgICAgICAocHJldmlldykgPT4gIW1lcmdlZE9wdGlvbnMubWVkaWFUeXBlLnByZXZpZXdzLmluY2x1ZGVzKHByZXZpZXcpXG4gICAgICApLmNvbmNhdChtZXJnZWRPcHRpb25zLm1lZGlhVHlwZS5wcmV2aWV3cyk7XG4gICAgfVxuICAgIG1lcmdlZE9wdGlvbnMubWVkaWFUeXBlLnByZXZpZXdzID0gKG1lcmdlZE9wdGlvbnMubWVkaWFUeXBlLnByZXZpZXdzIHx8IFtdKS5tYXAoKHByZXZpZXcpID0+IHByZXZpZXcucmVwbGFjZSgvLXByZXZpZXcvLCBcIlwiKSk7XG4gIH1cbiAgcmV0dXJuIG1lcmdlZE9wdGlvbnM7XG59XG5cbi8vIHBrZy9kaXN0LXNyYy91dGlsL2FkZC1xdWVyeS1wYXJhbWV0ZXJzLmpzXG5mdW5jdGlvbiBhZGRRdWVyeVBhcmFtZXRlcnModXJsLCBwYXJhbWV0ZXJzKSB7XG4gIGNvbnN0IHNlcGFyYXRvciA9IC9cXD8vLnRlc3QodXJsKSA/IFwiJlwiIDogXCI/XCI7XG4gIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMocGFyYW1ldGVycyk7XG4gIGlmIChuYW1lcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIHJldHVybiB1cmwgKyBzZXBhcmF0b3IgKyBuYW1lcy5tYXAoKG5hbWUpID0+IHtcbiAgICBpZiAobmFtZSA9PT0gXCJxXCIpIHtcbiAgICAgIHJldHVybiBcInE9XCIgKyBwYXJhbWV0ZXJzLnEuc3BsaXQoXCIrXCIpLm1hcChlbmNvZGVVUklDb21wb25lbnQpLmpvaW4oXCIrXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYCR7bmFtZX09JHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1ldGVyc1tuYW1lXSl9YDtcbiAgfSkuam9pbihcIiZcIik7XG59XG5cbi8vIHBrZy9kaXN0LXNyYy91dGlsL2V4dHJhY3QtdXJsLXZhcmlhYmxlLW5hbWVzLmpzXG52YXIgdXJsVmFyaWFibGVSZWdleCA9IC9cXHtbXn1dK1xcfS9nO1xuZnVuY3Rpb24gcmVtb3ZlTm9uQ2hhcnModmFyaWFibGVOYW1lKSB7XG4gIHJldHVybiB2YXJpYWJsZU5hbWUucmVwbGFjZSgvXlxcVyt8XFxXKyQvZywgXCJcIikuc3BsaXQoLywvKTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RVcmxWYXJpYWJsZU5hbWVzKHVybCkge1xuICBjb25zdCBtYXRjaGVzID0gdXJsLm1hdGNoKHVybFZhcmlhYmxlUmVnZXgpO1xuICBpZiAoIW1hdGNoZXMpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIG1hdGNoZXMubWFwKHJlbW92ZU5vbkNoYXJzKS5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpLCBbXSk7XG59XG5cbi8vIHBrZy9kaXN0LXNyYy91dGlsL29taXQuanNcbmZ1bmN0aW9uIG9taXQob2JqZWN0LCBrZXlzVG9PbWl0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHsgX19wcm90b19fOiBudWxsIH07XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9iamVjdCkpIHtcbiAgICBpZiAoa2V5c1RvT21pdC5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG9iamVjdFtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvdXRpbC91cmwtdGVtcGxhdGUuanNcbmZ1bmN0aW9uIGVuY29kZVJlc2VydmVkKHN0cikge1xuICByZXR1cm4gc3RyLnNwbGl0KC8oJVswLTlBLUZhLWZdezJ9KS9nKS5tYXAoZnVuY3Rpb24ocGFydCkge1xuICAgIGlmICghLyVbMC05QS1GYS1mXS8udGVzdChwYXJ0KSkge1xuICAgICAgcGFydCA9IGVuY29kZVVSSShwYXJ0KS5yZXBsYWNlKC8lNUIvZywgXCJbXCIpLnJlcGxhY2UoLyU1RC9nLCBcIl1cIik7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0O1xuICB9KS5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gZW5jb2RlVW5yZXNlcnZlZChzdHIpIHtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpLnJlcGxhY2UoL1shJygpKl0vZywgZnVuY3Rpb24oYykge1xuICAgIHJldHVybiBcIiVcIiArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBlbmNvZGVWYWx1ZShvcGVyYXRvciwgdmFsdWUsIGtleSkge1xuICB2YWx1ZSA9IG9wZXJhdG9yID09PSBcIitcIiB8fCBvcGVyYXRvciA9PT0gXCIjXCIgPyBlbmNvZGVSZXNlcnZlZCh2YWx1ZSkgOiBlbmNvZGVVbnJlc2VydmVkKHZhbHVlKTtcbiAgaWYgKGtleSkge1xuICAgIHJldHVybiBlbmNvZGVVbnJlc2VydmVkKGtleSkgKyBcIj1cIiArIHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdm9pZCAwICYmIHZhbHVlICE9PSBudWxsO1xufVxuZnVuY3Rpb24gaXNLZXlPcGVyYXRvcihvcGVyYXRvcikge1xuICByZXR1cm4gb3BlcmF0b3IgPT09IFwiO1wiIHx8IG9wZXJhdG9yID09PSBcIiZcIiB8fCBvcGVyYXRvciA9PT0gXCI/XCI7XG59XG5mdW5jdGlvbiBnZXRWYWx1ZXMoY29udGV4dCwgb3BlcmF0b3IsIGtleSwgbW9kaWZpZXIpIHtcbiAgdmFyIHZhbHVlID0gY29udGV4dFtrZXldLCByZXN1bHQgPSBbXTtcbiAgaWYgKGlzRGVmaW5lZCh2YWx1ZSkgJiYgdmFsdWUgIT09IFwiXCIpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICBpZiAobW9kaWZpZXIgJiYgbW9kaWZpZXIgIT09IFwiKlwiKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDAsIHBhcnNlSW50KG1vZGlmaWVyLCAxMCkpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgIGVuY29kZVZhbHVlKG9wZXJhdG9yLCB2YWx1ZSwgaXNLZXlPcGVyYXRvcihvcGVyYXRvcikgPyBrZXkgOiBcIlwiKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG1vZGlmaWVyID09PSBcIipcIikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZS5maWx0ZXIoaXNEZWZpbmVkKS5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlMikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgICAgIGVuY29kZVZhbHVlKG9wZXJhdG9yLCB2YWx1ZTIsIGlzS2V5T3BlcmF0b3Iob3BlcmF0b3IpID8ga2V5IDogXCJcIilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgT2JqZWN0LmtleXModmFsdWUpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgICAgICAgaWYgKGlzRGVmaW5lZCh2YWx1ZVtrXSkpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlVmFsdWUob3BlcmF0b3IsIHZhbHVlW2tdLCBrKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHRtcCA9IFtdO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZS5maWx0ZXIoaXNEZWZpbmVkKS5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlMikge1xuICAgICAgICAgICAgdG1wLnB1c2goZW5jb2RlVmFsdWUob3BlcmF0b3IsIHZhbHVlMikpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIE9iamVjdC5rZXlzKHZhbHVlKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICAgIGlmIChpc0RlZmluZWQodmFsdWVba10pKSB7XG4gICAgICAgICAgICAgIHRtcC5wdXNoKGVuY29kZVVucmVzZXJ2ZWQoaykpO1xuICAgICAgICAgICAgICB0bXAucHVzaChlbmNvZGVWYWx1ZShvcGVyYXRvciwgdmFsdWVba10udG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0tleU9wZXJhdG9yKG9wZXJhdG9yKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGVuY29kZVVucmVzZXJ2ZWQoa2V5KSArIFwiPVwiICsgdG1wLmpvaW4oXCIsXCIpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0bXAubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godG1wLmpvaW4oXCIsXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAob3BlcmF0b3IgPT09IFwiO1wiKSB7XG4gICAgICBpZiAoaXNEZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICByZXN1bHQucHVzaChlbmNvZGVVbnJlc2VydmVkKGtleSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IFwiXCIgJiYgKG9wZXJhdG9yID09PSBcIiZcIiB8fCBvcGVyYXRvciA9PT0gXCI/XCIpKSB7XG4gICAgICByZXN1bHQucHVzaChlbmNvZGVVbnJlc2VydmVkKGtleSkgKyBcIj1cIik7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gXCJcIikge1xuICAgICAgcmVzdWx0LnB1c2goXCJcIik7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXJzZVVybCh0ZW1wbGF0ZSkge1xuICByZXR1cm4ge1xuICAgIGV4cGFuZDogZXhwYW5kLmJpbmQobnVsbCwgdGVtcGxhdGUpXG4gIH07XG59XG5mdW5jdGlvbiBleHBhbmQodGVtcGxhdGUsIGNvbnRleHQpIHtcbiAgdmFyIG9wZXJhdG9ycyA9IFtcIitcIiwgXCIjXCIsIFwiLlwiLCBcIi9cIiwgXCI7XCIsIFwiP1wiLCBcIiZcIl07XG4gIHRlbXBsYXRlID0gdGVtcGxhdGUucmVwbGFjZShcbiAgICAvXFx7KFteXFx7XFx9XSspXFx9fChbXlxce1xcfV0rKS9nLFxuICAgIGZ1bmN0aW9uKF8sIGV4cHJlc3Npb24sIGxpdGVyYWwpIHtcbiAgICAgIGlmIChleHByZXNzaW9uKSB7XG4gICAgICAgIGxldCBvcGVyYXRvciA9IFwiXCI7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgICAgICBpZiAob3BlcmF0b3JzLmluZGV4T2YoZXhwcmVzc2lvbi5jaGFyQXQoMCkpICE9PSAtMSkge1xuICAgICAgICAgIG9wZXJhdG9yID0gZXhwcmVzc2lvbi5jaGFyQXQoMCk7XG4gICAgICAgICAgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb24uc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgICAgIGV4cHJlc3Npb24uc3BsaXQoLywvZykuZm9yRWFjaChmdW5jdGlvbih2YXJpYWJsZSkge1xuICAgICAgICAgIHZhciB0bXAgPSAvKFteOlxcKl0qKSg/OjooXFxkKyl8KFxcKikpPy8uZXhlYyh2YXJpYWJsZSk7XG4gICAgICAgICAgdmFsdWVzLnB1c2goZ2V0VmFsdWVzKGNvbnRleHQsIG9wZXJhdG9yLCB0bXBbMV0sIHRtcFsyXSB8fCB0bXBbM10pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvcGVyYXRvciAmJiBvcGVyYXRvciAhPT0gXCIrXCIpIHtcbiAgICAgICAgICB2YXIgc2VwYXJhdG9yID0gXCIsXCI7XG4gICAgICAgICAgaWYgKG9wZXJhdG9yID09PSBcIj9cIikge1xuICAgICAgICAgICAgc2VwYXJhdG9yID0gXCImXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChvcGVyYXRvciAhPT0gXCIjXCIpIHtcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gKHZhbHVlcy5sZW5ndGggIT09IDAgPyBvcGVyYXRvciA6IFwiXCIpICsgdmFsdWVzLmpvaW4oc2VwYXJhdG9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWVzLmpvaW4oXCIsXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZW5jb2RlUmVzZXJ2ZWQobGl0ZXJhbCk7XG4gICAgICB9XG4gICAgfVxuICApO1xuICBpZiAodGVtcGxhdGUgPT09IFwiL1wiKSB7XG4gICAgcmV0dXJuIHRlbXBsYXRlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0ZW1wbGF0ZS5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG4gIH1cbn1cblxuLy8gcGtnL2Rpc3Qtc3JjL3BhcnNlLmpzXG5mdW5jdGlvbiBwYXJzZShvcHRpb25zKSB7XG4gIGxldCBtZXRob2QgPSBvcHRpb25zLm1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICBsZXQgdXJsID0gKG9wdGlvbnMudXJsIHx8IFwiL1wiKS5yZXBsYWNlKC86KFthLXpdXFx3KykvZywgXCJ7JDF9XCIpO1xuICBsZXQgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMuaGVhZGVycyk7XG4gIGxldCBib2R5O1xuICBsZXQgcGFyYW1ldGVycyA9IG9taXQob3B0aW9ucywgW1xuICAgIFwibWV0aG9kXCIsXG4gICAgXCJiYXNlVXJsXCIsXG4gICAgXCJ1cmxcIixcbiAgICBcImhlYWRlcnNcIixcbiAgICBcInJlcXVlc3RcIixcbiAgICBcIm1lZGlhVHlwZVwiXG4gIF0pO1xuICBjb25zdCB1cmxWYXJpYWJsZU5hbWVzID0gZXh0cmFjdFVybFZhcmlhYmxlTmFtZXModXJsKTtcbiAgdXJsID0gcGFyc2VVcmwodXJsKS5leHBhbmQocGFyYW1ldGVycyk7XG4gIGlmICghL15odHRwLy50ZXN0KHVybCkpIHtcbiAgICB1cmwgPSBvcHRpb25zLmJhc2VVcmwgKyB1cmw7XG4gIH1cbiAgY29uc3Qgb21pdHRlZFBhcmFtZXRlcnMgPSBPYmplY3Qua2V5cyhvcHRpb25zKS5maWx0ZXIoKG9wdGlvbikgPT4gdXJsVmFyaWFibGVOYW1lcy5pbmNsdWRlcyhvcHRpb24pKS5jb25jYXQoXCJiYXNlVXJsXCIpO1xuICBjb25zdCByZW1haW5pbmdQYXJhbWV0ZXJzID0gb21pdChwYXJhbWV0ZXJzLCBvbWl0dGVkUGFyYW1ldGVycyk7XG4gIGNvbnN0IGlzQmluYXJ5UmVxdWVzdCA9IC9hcHBsaWNhdGlvblxcL29jdGV0LXN0cmVhbS9pLnRlc3QoaGVhZGVycy5hY2NlcHQpO1xuICBpZiAoIWlzQmluYXJ5UmVxdWVzdCkge1xuICAgIGlmIChvcHRpb25zLm1lZGlhVHlwZS5mb3JtYXQpIHtcbiAgICAgIGhlYWRlcnMuYWNjZXB0ID0gaGVhZGVycy5hY2NlcHQuc3BsaXQoLywvKS5tYXAoXG4gICAgICAgIChmb3JtYXQpID0+IGZvcm1hdC5yZXBsYWNlKFxuICAgICAgICAgIC9hcHBsaWNhdGlvblxcL3ZuZChcXC5cXHcrKShcXC52Myk/KFxcLlxcdyspPyhcXCtqc29uKT8kLyxcbiAgICAgICAgICBgYXBwbGljYXRpb24vdm5kJDEkMi4ke29wdGlvbnMubWVkaWFUeXBlLmZvcm1hdH1gXG4gICAgICAgIClcbiAgICAgICkuam9pbihcIixcIik7XG4gICAgfVxuICAgIGlmICh1cmwuZW5kc1dpdGgoXCIvZ3JhcGhxbFwiKSkge1xuICAgICAgaWYgKG9wdGlvbnMubWVkaWFUeXBlLnByZXZpZXdzPy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcHJldmlld3NGcm9tQWNjZXB0SGVhZGVyID0gaGVhZGVycy5hY2NlcHQubWF0Y2goL1tcXHctXSsoPz0tcHJldmlldykvZykgfHwgW107XG4gICAgICAgIGhlYWRlcnMuYWNjZXB0ID0gcHJldmlld3NGcm9tQWNjZXB0SGVhZGVyLmNvbmNhdChvcHRpb25zLm1lZGlhVHlwZS5wcmV2aWV3cykubWFwKChwcmV2aWV3KSA9PiB7XG4gICAgICAgICAgY29uc3QgZm9ybWF0ID0gb3B0aW9ucy5tZWRpYVR5cGUuZm9ybWF0ID8gYC4ke29wdGlvbnMubWVkaWFUeXBlLmZvcm1hdH1gIDogXCIranNvblwiO1xuICAgICAgICAgIHJldHVybiBgYXBwbGljYXRpb24vdm5kLmdpdGh1Yi4ke3ByZXZpZXd9LXByZXZpZXcke2Zvcm1hdH1gO1xuICAgICAgICB9KS5qb2luKFwiLFwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKFtcIkdFVFwiLCBcIkhFQURcIl0uaW5jbHVkZXMobWV0aG9kKSkge1xuICAgIHVybCA9IGFkZFF1ZXJ5UGFyYW1ldGVycyh1cmwsIHJlbWFpbmluZ1BhcmFtZXRlcnMpO1xuICB9IGVsc2Uge1xuICAgIGlmIChcImRhdGFcIiBpbiByZW1haW5pbmdQYXJhbWV0ZXJzKSB7XG4gICAgICBib2R5ID0gcmVtYWluaW5nUGFyYW1ldGVycy5kYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoT2JqZWN0LmtleXMocmVtYWluaW5nUGFyYW1ldGVycykubGVuZ3RoKSB7XG4gICAgICAgIGJvZHkgPSByZW1haW5pbmdQYXJhbWV0ZXJzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gJiYgdHlwZW9mIGJvZHkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBoZWFkZXJzW1wiY29udGVudC10eXBlXCJdID0gXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCI7XG4gIH1cbiAgaWYgKFtcIlBBVENIXCIsIFwiUFVUXCJdLmluY2x1ZGVzKG1ldGhvZCkgJiYgdHlwZW9mIGJvZHkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBib2R5ID0gXCJcIjtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICB7IG1ldGhvZCwgdXJsLCBoZWFkZXJzIH0sXG4gICAgdHlwZW9mIGJvZHkgIT09IFwidW5kZWZpbmVkXCIgPyB7IGJvZHkgfSA6IG51bGwsXG4gICAgb3B0aW9ucy5yZXF1ZXN0ID8geyByZXF1ZXN0OiBvcHRpb25zLnJlcXVlc3QgfSA6IG51bGxcbiAgKTtcbn1cblxuLy8gcGtnL2Rpc3Qtc3JjL2VuZHBvaW50LXdpdGgtZGVmYXVsdHMuanNcbmZ1bmN0aW9uIGVuZHBvaW50V2l0aERlZmF1bHRzKGRlZmF1bHRzLCByb3V0ZSwgb3B0aW9ucykge1xuICByZXR1cm4gcGFyc2UobWVyZ2UoZGVmYXVsdHMsIHJvdXRlLCBvcHRpb25zKSk7XG59XG5cbi8vIHBrZy9kaXN0LXNyYy93aXRoLWRlZmF1bHRzLmpzXG5mdW5jdGlvbiB3aXRoRGVmYXVsdHMob2xkRGVmYXVsdHMsIG5ld0RlZmF1bHRzKSB7XG4gIGNvbnN0IERFRkFVTFRTMiA9IG1lcmdlKG9sZERlZmF1bHRzLCBuZXdEZWZhdWx0cyk7XG4gIGNvbnN0IGVuZHBvaW50MiA9IGVuZHBvaW50V2l0aERlZmF1bHRzLmJpbmQobnVsbCwgREVGQVVMVFMyKTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZW5kcG9pbnQyLCB7XG4gICAgREVGQVVMVFM6IERFRkFVTFRTMixcbiAgICBkZWZhdWx0czogd2l0aERlZmF1bHRzLmJpbmQobnVsbCwgREVGQVVMVFMyKSxcbiAgICBtZXJnZTogbWVyZ2UuYmluZChudWxsLCBERUZBVUxUUzIpLFxuICAgIHBhcnNlXG4gIH0pO1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvaW5kZXguanNcbnZhciBlbmRwb2ludCA9IHdpdGhEZWZhdWx0cyhudWxsLCBERUZBVUxUUyk7XG5leHBvcnQge1xuICBlbmRwb2ludFxufTtcbiIsICJleHBvcnQgZnVuY3Rpb24gZ2V0VXNlckFnZW50KCkge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gXCJvYmplY3RcIiAmJiBcInVzZXJBZ2VudFwiIGluIG5hdmlnYXRvcikge1xuICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MudmVyc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGBOb2RlLmpzLyR7cHJvY2Vzcy52ZXJzaW9uLnN1YnN0cigxKX0gKCR7cHJvY2Vzcy5wbGF0Zm9ybX07ICR7XG4gICAgICBwcm9jZXNzLmFyY2hcbiAgICB9KWA7XG4gIH1cblxuICByZXR1cm4gXCI8ZW52aXJvbm1lbnQgdW5kZXRlY3RhYmxlPlwiO1xufVxuIiwgImNsYXNzIFJlcXVlc3RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgbmFtZTtcbiAgLyoqXG4gICAqIGh0dHAgc3RhdHVzIGNvZGVcbiAgICovXG4gIHN0YXR1cztcbiAgLyoqXG4gICAqIFJlcXVlc3Qgb3B0aW9ucyB0aGF0IGxlYWQgdG8gdGhlIGVycm9yLlxuICAgKi9cbiAgcmVxdWVzdDtcbiAgLyoqXG4gICAqIFJlc3BvbnNlIG9iamVjdCBpZiBhIHJlc3BvbnNlIHdhcyByZWNlaXZlZFxuICAgKi9cbiAgcmVzcG9uc2U7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1c0NvZGUsIG9wdGlvbnMpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgIH1cbiAgICB0aGlzLm5hbWUgPSBcIkh0dHBFcnJvclwiO1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzQ29kZTtcbiAgICBpZiAoXCJyZXNwb25zZVwiIGluIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMucmVzcG9uc2UgPSBvcHRpb25zLnJlc3BvbnNlO1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0Q29weSA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMucmVxdWVzdCk7XG4gICAgaWYgKG9wdGlvbnMucmVxdWVzdC5oZWFkZXJzLmF1dGhvcml6YXRpb24pIHtcbiAgICAgIHJlcXVlc3RDb3B5LmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLnJlcXVlc3QuaGVhZGVycywge1xuICAgICAgICBhdXRob3JpemF0aW9uOiBvcHRpb25zLnJlcXVlc3QuaGVhZGVycy5hdXRob3JpemF0aW9uLnJlcGxhY2UoXG4gICAgICAgICAgLyAuKiQvLFxuICAgICAgICAgIFwiIFtSRURBQ1RFRF1cIlxuICAgICAgICApXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmVxdWVzdENvcHkudXJsID0gcmVxdWVzdENvcHkudXJsLnJlcGxhY2UoL1xcYmNsaWVudF9zZWNyZXQ9XFx3Ky9nLCBcImNsaWVudF9zZWNyZXQ9W1JFREFDVEVEXVwiKS5yZXBsYWNlKC9cXGJhY2Nlc3NfdG9rZW49XFx3Ky9nLCBcImFjY2Vzc190b2tlbj1bUkVEQUNURURdXCIpO1xuICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3RDb3B5O1xuICB9XG59XG5leHBvcnQge1xuICBSZXF1ZXN0RXJyb3Jcbn07XG4iLCAiLy8gcGtnL2Rpc3Qtc3JjL2luZGV4LmpzXG5pbXBvcnQgeyBlbmRwb2ludCB9IGZyb20gXCJAb2N0b2tpdC9lbmRwb2ludFwiO1xuaW1wb3J0IHsgZ2V0VXNlckFnZW50IH0gZnJvbSBcInVuaXZlcnNhbC11c2VyLWFnZW50XCI7XG5cbi8vIHBrZy9kaXN0LXNyYy92ZXJzaW9uLmpzXG52YXIgVkVSU0lPTiA9IFwiMC4wLjAtZGV2ZWxvcG1lbnRcIjtcblxuLy8gcGtnL2Rpc3Qtc3JjL2lzLXBsYWluLW9iamVjdC5qc1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09PSBudWxsKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgIT09IFwiW29iamVjdCBPYmplY3RdXCIpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbClcbiAgICByZXR1cm4gdHJ1ZTtcbiAgY29uc3QgQ3RvciA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgXCJjb25zdHJ1Y3RvclwiKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwoQ3RvcikgPT09IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsKHZhbHVlKTtcbn1cblxuLy8gcGtnL2Rpc3Qtc3JjL2ZldGNoLXdyYXBwZXIuanNcbmltcG9ydCB7IFJlcXVlc3RFcnJvciB9IGZyb20gXCJAb2N0b2tpdC9yZXF1ZXN0LWVycm9yXCI7XG5cbi8vIHBrZy9kaXN0LXNyYy9nZXQtYnVmZmVyLXJlc3BvbnNlLmpzXG5mdW5jdGlvbiBnZXRCdWZmZXJSZXNwb25zZShyZXNwb25zZSkge1xuICByZXR1cm4gcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbn1cblxuLy8gcGtnL2Rpc3Qtc3JjL2ZldGNoLXdyYXBwZXIuanNcbmZ1bmN0aW9uIGZldGNoV3JhcHBlcihyZXF1ZXN0T3B0aW9ucykge1xuICBjb25zdCBsb2cgPSByZXF1ZXN0T3B0aW9ucy5yZXF1ZXN0ICYmIHJlcXVlc3RPcHRpb25zLnJlcXVlc3QubG9nID8gcmVxdWVzdE9wdGlvbnMucmVxdWVzdC5sb2cgOiBjb25zb2xlO1xuICBjb25zdCBwYXJzZVN1Y2Nlc3NSZXNwb25zZUJvZHkgPSByZXF1ZXN0T3B0aW9ucy5yZXF1ZXN0Py5wYXJzZVN1Y2Nlc3NSZXNwb25zZUJvZHkgIT09IGZhbHNlO1xuICBpZiAoaXNQbGFpbk9iamVjdChyZXF1ZXN0T3B0aW9ucy5ib2R5KSB8fCBBcnJheS5pc0FycmF5KHJlcXVlc3RPcHRpb25zLmJvZHkpKSB7XG4gICAgcmVxdWVzdE9wdGlvbnMuYm9keSA9IEpTT04uc3RyaW5naWZ5KHJlcXVlc3RPcHRpb25zLmJvZHkpO1xuICB9XG4gIGxldCBoZWFkZXJzID0ge307XG4gIGxldCBzdGF0dXM7XG4gIGxldCB1cmw7XG4gIGxldCB7IGZldGNoIH0gPSBnbG9iYWxUaGlzO1xuICBpZiAocmVxdWVzdE9wdGlvbnMucmVxdWVzdD8uZmV0Y2gpIHtcbiAgICBmZXRjaCA9IHJlcXVlc3RPcHRpb25zLnJlcXVlc3QuZmV0Y2g7XG4gIH1cbiAgaWYgKCFmZXRjaCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiZmV0Y2ggaXMgbm90IHNldC4gUGxlYXNlIHBhc3MgYSBmZXRjaCBpbXBsZW1lbnRhdGlvbiBhcyBuZXcgT2N0b2tpdCh7IHJlcXVlc3Q6IHsgZmV0Y2ggfX0pLiBMZWFybiBtb3JlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9vY3Rva2l0L29jdG9raXQuanMvI2ZldGNoLW1pc3NpbmdcIlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGZldGNoKHJlcXVlc3RPcHRpb25zLnVybCwge1xuICAgIG1ldGhvZDogcmVxdWVzdE9wdGlvbnMubWV0aG9kLFxuICAgIGJvZHk6IHJlcXVlc3RPcHRpb25zLmJvZHksXG4gICAgLy8gSGVhZGVyIHZhbHVlcyBtdXN0IGJlIGBzdHJpbmdgXG4gICAgaGVhZGVyczogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgT2JqZWN0LmVudHJpZXMocmVxdWVzdE9wdGlvbnMuaGVhZGVycykubWFwKChbbmFtZSwgdmFsdWVdKSA9PiBbXG4gICAgICAgIG5hbWUsXG4gICAgICAgIFN0cmluZyh2YWx1ZSlcbiAgICAgIF0pXG4gICAgKSxcbiAgICBzaWduYWw6IHJlcXVlc3RPcHRpb25zLnJlcXVlc3Q/LnNpZ25hbCxcbiAgICAvLyBkdXBsZXggbXVzdCBiZSBzZXQgaWYgcmVxdWVzdC5ib2R5IGlzIFJlYWRhYmxlU3RyZWFtIG9yIEFzeW5jIEl0ZXJhYmxlcy5cbiAgICAvLyBTZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1yZXF1ZXN0aW5pdC1kdXBsZXguXG4gICAgLi4ucmVxdWVzdE9wdGlvbnMuYm9keSAmJiB7IGR1cGxleDogXCJoYWxmXCIgfVxuICB9KS50aGVuKGFzeW5jIChyZXNwb25zZSkgPT4ge1xuICAgIHVybCA9IHJlc3BvbnNlLnVybDtcbiAgICBzdGF0dXMgPSByZXNwb25zZS5zdGF0dXM7XG4gICAgZm9yIChjb25zdCBrZXlBbmRWYWx1ZSBvZiByZXNwb25zZS5oZWFkZXJzKSB7XG4gICAgICBoZWFkZXJzW2tleUFuZFZhbHVlWzBdXSA9IGtleUFuZFZhbHVlWzFdO1xuICAgIH1cbiAgICBpZiAoXCJkZXByZWNhdGlvblwiIGluIGhlYWRlcnMpIHtcbiAgICAgIGNvbnN0IG1hdGNoZXMgPSBoZWFkZXJzLmxpbmsgJiYgaGVhZGVycy5saW5rLm1hdGNoKC88KFtePl0rKT47IHJlbD1cImRlcHJlY2F0aW9uXCIvKTtcbiAgICAgIGNvbnN0IGRlcHJlY2F0aW9uTGluayA9IG1hdGNoZXMgJiYgbWF0Y2hlcy5wb3AoKTtcbiAgICAgIGxvZy53YXJuKFxuICAgICAgICBgW0BvY3Rva2l0L3JlcXVlc3RdIFwiJHtyZXF1ZXN0T3B0aW9ucy5tZXRob2R9ICR7cmVxdWVzdE9wdGlvbnMudXJsfVwiIGlzIGRlcHJlY2F0ZWQuIEl0IGlzIHNjaGVkdWxlZCB0byBiZSByZW1vdmVkIG9uICR7aGVhZGVycy5zdW5zZXR9JHtkZXByZWNhdGlvbkxpbmsgPyBgLiBTZWUgJHtkZXByZWNhdGlvbkxpbmt9YCA6IFwiXCJ9YFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHN0YXR1cyA9PT0gMjA0IHx8IHN0YXR1cyA9PT0gMjA1KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChyZXF1ZXN0T3B0aW9ucy5tZXRob2QgPT09IFwiSEVBRFwiKSB7XG4gICAgICBpZiAoc3RhdHVzIDwgNDAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBSZXF1ZXN0RXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCwgc3RhdHVzLCB7XG4gICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIGRhdGE6IHZvaWQgMFxuICAgICAgICB9LFxuICAgICAgICByZXF1ZXN0OiByZXF1ZXN0T3B0aW9uc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09IDMwNCkge1xuICAgICAgdGhyb3cgbmV3IFJlcXVlc3RFcnJvcihcIk5vdCBtb2RpZmllZFwiLCBzdGF0dXMsIHtcbiAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgZGF0YTogYXdhaXQgZ2V0UmVzcG9uc2VEYXRhKHJlc3BvbnNlKVxuICAgICAgICB9LFxuICAgICAgICByZXF1ZXN0OiByZXF1ZXN0T3B0aW9uc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPj0gNDAwKSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgZ2V0UmVzcG9uc2VEYXRhKHJlc3BvbnNlKTtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IFJlcXVlc3RFcnJvcih0b0Vycm9yTWVzc2FnZShkYXRhKSwgc3RhdHVzLCB7XG4gICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIGRhdGFcbiAgICAgICAgfSxcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdE9wdGlvbnNcbiAgICAgIH0pO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZVN1Y2Nlc3NSZXNwb25zZUJvZHkgPyBhd2FpdCBnZXRSZXNwb25zZURhdGEocmVzcG9uc2UpIDogcmVzcG9uc2UuYm9keTtcbiAgfSkudGhlbigoZGF0YSkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXMsXG4gICAgICB1cmwsXG4gICAgICBoZWFkZXJzLFxuICAgICAgZGF0YVxuICAgIH07XG4gIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFJlcXVlc3RFcnJvcilcbiAgICAgIHRocm93IGVycm9yO1xuICAgIGVsc2UgaWYgKGVycm9yLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiKVxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgbGV0IG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICAgIGlmIChlcnJvci5uYW1lID09PSBcIlR5cGVFcnJvclwiICYmIFwiY2F1c2VcIiBpbiBlcnJvcikge1xuICAgICAgaWYgKGVycm9yLmNhdXNlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgbWVzc2FnZSA9IGVycm9yLmNhdXNlLm1lc3NhZ2U7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlcnJvci5jYXVzZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBtZXNzYWdlID0gZXJyb3IuY2F1c2U7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBSZXF1ZXN0RXJyb3IobWVzc2FnZSwgNTAwLCB7XG4gICAgICByZXF1ZXN0OiByZXF1ZXN0T3B0aW9uc1xuICAgIH0pO1xuICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFJlc3BvbnNlRGF0YShyZXNwb25zZSkge1xuICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpO1xuICBpZiAoL2FwcGxpY2F0aW9uXFwvanNvbi8udGVzdChjb250ZW50VHlwZSkpIHtcbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+IHJlc3BvbnNlLnRleHQoKSkuY2F0Y2goKCkgPT4gXCJcIik7XG4gIH1cbiAgaWYgKCFjb250ZW50VHlwZSB8fCAvXnRleHRcXC98Y2hhcnNldD11dGYtOCQvLnRlc3QoY29udGVudFR5cGUpKSB7XG4gICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgfVxuICByZXR1cm4gZ2V0QnVmZmVyUmVzcG9uc2UocmVzcG9uc2UpO1xufVxuZnVuY3Rpb24gdG9FcnJvck1lc3NhZ2UoZGF0YSkge1xuICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIGRhdGE7XG4gIGxldCBzdWZmaXg7XG4gIGlmIChcImRvY3VtZW50YXRpb25fdXJsXCIgaW4gZGF0YSkge1xuICAgIHN1ZmZpeCA9IGAgLSAke2RhdGEuZG9jdW1lbnRhdGlvbl91cmx9YDtcbiAgfSBlbHNlIHtcbiAgICBzdWZmaXggPSBcIlwiO1xuICB9XG4gIGlmIChcIm1lc3NhZ2VcIiBpbiBkYXRhKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YS5lcnJvcnMpKSB7XG4gICAgICByZXR1cm4gYCR7ZGF0YS5tZXNzYWdlfTogJHtkYXRhLmVycm9ycy5tYXAoSlNPTi5zdHJpbmdpZnkpLmpvaW4oXCIsIFwiKX0ke3N1ZmZpeH1gO1xuICAgIH1cbiAgICByZXR1cm4gYCR7ZGF0YS5tZXNzYWdlfSR7c3VmZml4fWA7XG4gIH1cbiAgcmV0dXJuIGBVbmtub3duIGVycm9yOiAke0pTT04uc3RyaW5naWZ5KGRhdGEpfWA7XG59XG5cbi8vIHBrZy9kaXN0LXNyYy93aXRoLWRlZmF1bHRzLmpzXG5mdW5jdGlvbiB3aXRoRGVmYXVsdHMob2xkRW5kcG9pbnQsIG5ld0RlZmF1bHRzKSB7XG4gIGNvbnN0IGVuZHBvaW50MiA9IG9sZEVuZHBvaW50LmRlZmF1bHRzKG5ld0RlZmF1bHRzKTtcbiAgY29uc3QgbmV3QXBpID0gZnVuY3Rpb24ocm91dGUsIHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBlbmRwb2ludE9wdGlvbnMgPSBlbmRwb2ludDIubWVyZ2Uocm91dGUsIHBhcmFtZXRlcnMpO1xuICAgIGlmICghZW5kcG9pbnRPcHRpb25zLnJlcXVlc3QgfHwgIWVuZHBvaW50T3B0aW9ucy5yZXF1ZXN0Lmhvb2spIHtcbiAgICAgIHJldHVybiBmZXRjaFdyYXBwZXIoZW5kcG9pbnQyLnBhcnNlKGVuZHBvaW50T3B0aW9ucykpO1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0MiA9IChyb3V0ZTIsIHBhcmFtZXRlcnMyKSA9PiB7XG4gICAgICByZXR1cm4gZmV0Y2hXcmFwcGVyKFxuICAgICAgICBlbmRwb2ludDIucGFyc2UoZW5kcG9pbnQyLm1lcmdlKHJvdXRlMiwgcGFyYW1ldGVyczIpKVxuICAgICAgKTtcbiAgICB9O1xuICAgIE9iamVjdC5hc3NpZ24ocmVxdWVzdDIsIHtcbiAgICAgIGVuZHBvaW50OiBlbmRwb2ludDIsXG4gICAgICBkZWZhdWx0czogd2l0aERlZmF1bHRzLmJpbmQobnVsbCwgZW5kcG9pbnQyKVxuICAgIH0pO1xuICAgIHJldHVybiBlbmRwb2ludE9wdGlvbnMucmVxdWVzdC5ob29rKHJlcXVlc3QyLCBlbmRwb2ludE9wdGlvbnMpO1xuICB9O1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXdBcGksIHtcbiAgICBlbmRwb2ludDogZW5kcG9pbnQyLFxuICAgIGRlZmF1bHRzOiB3aXRoRGVmYXVsdHMuYmluZChudWxsLCBlbmRwb2ludDIpXG4gIH0pO1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvaW5kZXguanNcbnZhciByZXF1ZXN0ID0gd2l0aERlZmF1bHRzKGVuZHBvaW50LCB7XG4gIGhlYWRlcnM6IHtcbiAgICBcInVzZXItYWdlbnRcIjogYG9jdG9raXQtcmVxdWVzdC5qcy8ke1ZFUlNJT059ICR7Z2V0VXNlckFnZW50KCl9YFxuICB9XG59KTtcbmV4cG9ydCB7XG4gIHJlcXVlc3Rcbn07XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGdldFVzZXJBZ2VudCgpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09IFwib2JqZWN0XCIgJiYgXCJ1c2VyQWdlbnRcIiBpbiBuYXZpZ2F0b3IpIHtcbiAgICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzLnZlcnNpb24gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBgTm9kZS5qcy8ke3Byb2Nlc3MudmVyc2lvbi5zdWJzdHIoMSl9ICgke3Byb2Nlc3MucGxhdGZvcm19OyAke1xuICAgICAgcHJvY2Vzcy5hcmNoXG4gICAgfSlgO1xuICB9XG5cbiAgcmV0dXJuIFwiPGVudmlyb25tZW50IHVuZGV0ZWN0YWJsZT5cIjtcbn1cbiIsICIvLyBwa2cvZGlzdC1zcmMvaW5kZXguanNcbmltcG9ydCB7IHJlcXVlc3QgfSBmcm9tIFwiQG9jdG9raXQvcmVxdWVzdFwiO1xuaW1wb3J0IHsgZ2V0VXNlckFnZW50IH0gZnJvbSBcInVuaXZlcnNhbC11c2VyLWFnZW50XCI7XG5cbi8vIHBrZy9kaXN0LXNyYy92ZXJzaW9uLmpzXG52YXIgVkVSU0lPTiA9IFwiMC4wLjAtZGV2ZWxvcG1lbnRcIjtcblxuLy8gcGtnL2Rpc3Qtc3JjL3dpdGgtZGVmYXVsdHMuanNcbmltcG9ydCB7IHJlcXVlc3QgYXMgUmVxdWVzdDIgfSBmcm9tIFwiQG9jdG9raXQvcmVxdWVzdFwiO1xuXG4vLyBwa2cvZGlzdC1zcmMvZ3JhcGhxbC5qc1xuaW1wb3J0IHsgcmVxdWVzdCBhcyBSZXF1ZXN0IH0gZnJvbSBcIkBvY3Rva2l0L3JlcXVlc3RcIjtcblxuLy8gcGtnL2Rpc3Qtc3JjL2Vycm9yLmpzXG5mdW5jdGlvbiBfYnVpbGRNZXNzYWdlRm9yUmVzcG9uc2VFcnJvcnMoZGF0YSkge1xuICByZXR1cm4gYFJlcXVlc3QgZmFpbGVkIGR1ZSB0byBmb2xsb3dpbmcgcmVzcG9uc2UgZXJyb3JzOlxuYCArIGRhdGEuZXJyb3JzLm1hcCgoZSkgPT4gYCAtICR7ZS5tZXNzYWdlfWApLmpvaW4oXCJcXG5cIik7XG59XG52YXIgR3JhcGhxbFJlc3BvbnNlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IocmVxdWVzdDIsIGhlYWRlcnMsIHJlc3BvbnNlKSB7XG4gICAgc3VwZXIoX2J1aWxkTWVzc2FnZUZvclJlc3BvbnNlRXJyb3JzKHJlc3BvbnNlKSk7XG4gICAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDI7XG4gICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgdGhpcy5lcnJvcnMgPSByZXNwb25zZS5lcnJvcnM7XG4gICAgdGhpcy5kYXRhID0gcmVzcG9uc2UuZGF0YTtcbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgIH1cbiAgfVxuICBuYW1lID0gXCJHcmFwaHFsUmVzcG9uc2VFcnJvclwiO1xuICBlcnJvcnM7XG4gIGRhdGE7XG59O1xuXG4vLyBwa2cvZGlzdC1zcmMvZ3JhcGhxbC5qc1xudmFyIE5PTl9WQVJJQUJMRV9PUFRJT05TID0gW1xuICBcIm1ldGhvZFwiLFxuICBcImJhc2VVcmxcIixcbiAgXCJ1cmxcIixcbiAgXCJoZWFkZXJzXCIsXG4gIFwicmVxdWVzdFwiLFxuICBcInF1ZXJ5XCIsXG4gIFwibWVkaWFUeXBlXCJcbl07XG52YXIgRk9SQklEREVOX1ZBUklBQkxFX09QVElPTlMgPSBbXCJxdWVyeVwiLCBcIm1ldGhvZFwiLCBcInVybFwiXTtcbnZhciBHSEVTX1YzX1NVRkZJWF9SRUdFWCA9IC9cXC9hcGlcXC92M1xcLz8kLztcbmZ1bmN0aW9uIGdyYXBocWwocmVxdWVzdDIsIHF1ZXJ5LCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBxdWVyeSA9PT0gXCJzdHJpbmdcIiAmJiBcInF1ZXJ5XCIgaW4gb3B0aW9ucykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgICBuZXcgRXJyb3IoYFtAb2N0b2tpdC9ncmFwaHFsXSBcInF1ZXJ5XCIgY2Fubm90IGJlIHVzZWQgYXMgdmFyaWFibGUgbmFtZWApXG4gICAgICApO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAoIUZPUkJJRERFTl9WQVJJQUJMRV9PUFRJT05TLmluY2x1ZGVzKGtleSkpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgYFtAb2N0b2tpdC9ncmFwaHFsXSBcIiR7a2V5fVwiIGNhbm5vdCBiZSB1c2VkIGFzIHZhcmlhYmxlIG5hbWVgXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHBhcnNlZE9wdGlvbnMgPSB0eXBlb2YgcXVlcnkgPT09IFwic3RyaW5nXCIgPyBPYmplY3QuYXNzaWduKHsgcXVlcnkgfSwgb3B0aW9ucykgOiBxdWVyeTtcbiAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSBPYmplY3Qua2V5cyhcbiAgICBwYXJzZWRPcHRpb25zXG4gICkucmVkdWNlKChyZXN1bHQsIGtleSkgPT4ge1xuICAgIGlmIChOT05fVkFSSUFCTEVfT1BUSU9OUy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IHBhcnNlZE9wdGlvbnNba2V5XTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICghcmVzdWx0LnZhcmlhYmxlcykge1xuICAgICAgcmVzdWx0LnZhcmlhYmxlcyA9IHt9O1xuICAgIH1cbiAgICByZXN1bHQudmFyaWFibGVzW2tleV0gPSBwYXJzZWRPcHRpb25zW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwge30pO1xuICBjb25zdCBiYXNlVXJsID0gcGFyc2VkT3B0aW9ucy5iYXNlVXJsIHx8IHJlcXVlc3QyLmVuZHBvaW50LkRFRkFVTFRTLmJhc2VVcmw7XG4gIGlmIChHSEVTX1YzX1NVRkZJWF9SRUdFWC50ZXN0KGJhc2VVcmwpKSB7XG4gICAgcmVxdWVzdE9wdGlvbnMudXJsID0gYmFzZVVybC5yZXBsYWNlKEdIRVNfVjNfU1VGRklYX1JFR0VYLCBcIi9hcGkvZ3JhcGhxbFwiKTtcbiAgfVxuICByZXR1cm4gcmVxdWVzdDIocmVxdWVzdE9wdGlvbnMpLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgaWYgKHJlc3BvbnNlLmRhdGEuZXJyb3JzKSB7XG4gICAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhyZXNwb25zZS5oZWFkZXJzKSkge1xuICAgICAgICBoZWFkZXJzW2tleV0gPSByZXNwb25zZS5oZWFkZXJzW2tleV07XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgR3JhcGhxbFJlc3BvbnNlRXJyb3IoXG4gICAgICAgIHJlcXVlc3RPcHRpb25zLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICByZXNwb25zZS5kYXRhXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5kYXRhO1xuICB9KTtcbn1cblxuLy8gcGtnL2Rpc3Qtc3JjL3dpdGgtZGVmYXVsdHMuanNcbmZ1bmN0aW9uIHdpdGhEZWZhdWx0cyhyZXF1ZXN0MiwgbmV3RGVmYXVsdHMpIHtcbiAgY29uc3QgbmV3UmVxdWVzdCA9IHJlcXVlc3QyLmRlZmF1bHRzKG5ld0RlZmF1bHRzKTtcbiAgY29uc3QgbmV3QXBpID0gKHF1ZXJ5LCBvcHRpb25zKSA9PiB7XG4gICAgcmV0dXJuIGdyYXBocWwobmV3UmVxdWVzdCwgcXVlcnksIG9wdGlvbnMpO1xuICB9O1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXdBcGksIHtcbiAgICBkZWZhdWx0czogd2l0aERlZmF1bHRzLmJpbmQobnVsbCwgbmV3UmVxdWVzdCksXG4gICAgZW5kcG9pbnQ6IG5ld1JlcXVlc3QuZW5kcG9pbnRcbiAgfSk7XG59XG5cbi8vIHBrZy9kaXN0LXNyYy9pbmRleC5qc1xudmFyIGdyYXBocWwyID0gd2l0aERlZmF1bHRzKHJlcXVlc3QsIHtcbiAgaGVhZGVyczoge1xuICAgIFwidXNlci1hZ2VudFwiOiBgb2N0b2tpdC1ncmFwaHFsLmpzLyR7VkVSU0lPTn0gJHtnZXRVc2VyQWdlbnQoKX1gXG4gIH0sXG4gIG1ldGhvZDogXCJQT1NUXCIsXG4gIHVybDogXCIvZ3JhcGhxbFwiXG59KTtcbmZ1bmN0aW9uIHdpdGhDdXN0b21SZXF1ZXN0KGN1c3RvbVJlcXVlc3QpIHtcbiAgcmV0dXJuIHdpdGhEZWZhdWx0cyhjdXN0b21SZXF1ZXN0LCB7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICB1cmw6IFwiL2dyYXBocWxcIlxuICB9KTtcbn1cbmV4cG9ydCB7XG4gIEdyYXBocWxSZXNwb25zZUVycm9yLFxuICBncmFwaHFsMiBhcyBncmFwaHFsLFxuICB3aXRoQ3VzdG9tUmVxdWVzdFxufTtcbiIsICIvLyBwa2cvZGlzdC1zcmMvYXV0aC5qc1xudmFyIFJFR0VYX0lTX0lOU1RBTExBVElPTl9MRUdBQ1kgPSAvXnYxXFwuLztcbnZhciBSRUdFWF9JU19JTlNUQUxMQVRJT04gPSAvXmdoc18vO1xudmFyIFJFR0VYX0lTX1VTRVJfVE9fU0VSVkVSID0gL15naHVfLztcbmFzeW5jIGZ1bmN0aW9uIGF1dGgodG9rZW4pIHtcbiAgY29uc3QgaXNBcHAgPSB0b2tlbi5zcGxpdCgvXFwuLykubGVuZ3RoID09PSAzO1xuICBjb25zdCBpc0luc3RhbGxhdGlvbiA9IFJFR0VYX0lTX0lOU1RBTExBVElPTl9MRUdBQ1kudGVzdCh0b2tlbikgfHwgUkVHRVhfSVNfSU5TVEFMTEFUSU9OLnRlc3QodG9rZW4pO1xuICBjb25zdCBpc1VzZXJUb1NlcnZlciA9IFJFR0VYX0lTX1VTRVJfVE9fU0VSVkVSLnRlc3QodG9rZW4pO1xuICBjb25zdCB0b2tlblR5cGUgPSBpc0FwcCA/IFwiYXBwXCIgOiBpc0luc3RhbGxhdGlvbiA/IFwiaW5zdGFsbGF0aW9uXCIgOiBpc1VzZXJUb1NlcnZlciA/IFwidXNlci10by1zZXJ2ZXJcIiA6IFwib2F1dGhcIjtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInRva2VuXCIsXG4gICAgdG9rZW4sXG4gICAgdG9rZW5UeXBlXG4gIH07XG59XG5cbi8vIHBrZy9kaXN0LXNyYy93aXRoLWF1dGhvcml6YXRpb24tcHJlZml4LmpzXG5mdW5jdGlvbiB3aXRoQXV0aG9yaXphdGlvblByZWZpeCh0b2tlbikge1xuICBpZiAodG9rZW4uc3BsaXQoL1xcLi8pLmxlbmd0aCA9PT0gMykge1xuICAgIHJldHVybiBgYmVhcmVyICR7dG9rZW59YDtcbiAgfVxuICByZXR1cm4gYHRva2VuICR7dG9rZW59YDtcbn1cblxuLy8gcGtnL2Rpc3Qtc3JjL2hvb2suanNcbmFzeW5jIGZ1bmN0aW9uIGhvb2sodG9rZW4sIHJlcXVlc3QsIHJvdXRlLCBwYXJhbWV0ZXJzKSB7XG4gIGNvbnN0IGVuZHBvaW50ID0gcmVxdWVzdC5lbmRwb2ludC5tZXJnZShcbiAgICByb3V0ZSxcbiAgICBwYXJhbWV0ZXJzXG4gICk7XG4gIGVuZHBvaW50LmhlYWRlcnMuYXV0aG9yaXphdGlvbiA9IHdpdGhBdXRob3JpemF0aW9uUHJlZml4KHRva2VuKTtcbiAgcmV0dXJuIHJlcXVlc3QoZW5kcG9pbnQpO1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvaW5kZXguanNcbnZhciBjcmVhdGVUb2tlbkF1dGggPSBmdW5jdGlvbiBjcmVhdGVUb2tlbkF1dGgyKHRva2VuKSB7XG4gIGlmICghdG9rZW4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJbQG9jdG9raXQvYXV0aC10b2tlbl0gTm8gdG9rZW4gcGFzc2VkIHRvIGNyZWF0ZVRva2VuQXV0aFwiKTtcbiAgfVxuICBpZiAodHlwZW9mIHRva2VuICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJbQG9jdG9raXQvYXV0aC10b2tlbl0gVG9rZW4gcGFzc2VkIHRvIGNyZWF0ZVRva2VuQXV0aCBpcyBub3QgYSBzdHJpbmdcIlxuICAgICk7XG4gIH1cbiAgdG9rZW4gPSB0b2tlbi5yZXBsYWNlKC9eKHRva2VufGJlYXJlcikgKy9pLCBcIlwiKTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYXV0aC5iaW5kKG51bGwsIHRva2VuKSwge1xuICAgIGhvb2s6IGhvb2suYmluZChudWxsLCB0b2tlbilcbiAgfSk7XG59O1xuZXhwb3J0IHtcbiAgY3JlYXRlVG9rZW5BdXRoXG59O1xuIiwgImNvbnN0IFZFUlNJT04gPSBcIjYuMC4xXCI7XG5leHBvcnQge1xuICBWRVJTSU9OXG59O1xuIiwgImltcG9ydCB7IGdldFVzZXJBZ2VudCB9IGZyb20gXCJ1bml2ZXJzYWwtdXNlci1hZ2VudFwiO1xuaW1wb3J0IEhvb2sgZnJvbSBcImJlZm9yZS1hZnRlci1ob29rXCI7XG5pbXBvcnQgeyByZXF1ZXN0IH0gZnJvbSBcIkBvY3Rva2l0L3JlcXVlc3RcIjtcbmltcG9ydCB7IGdyYXBocWwsIHdpdGhDdXN0b21SZXF1ZXN0IH0gZnJvbSBcIkBvY3Rva2l0L2dyYXBocWxcIjtcbmltcG9ydCB7IGNyZWF0ZVRva2VuQXV0aCB9IGZyb20gXCJAb2N0b2tpdC9hdXRoLXRva2VuXCI7XG5pbXBvcnQgeyBWRVJTSU9OIH0gZnJvbSBcIi4vdmVyc2lvbi5qc1wiO1xuY29uc3Qgbm9vcCA9ICgpID0+IHtcbn07XG5jb25zdCBjb25zb2xlV2FybiA9IGNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO1xuY29uc3QgY29uc29sZUVycm9yID0gY29uc29sZS5lcnJvci5iaW5kKGNvbnNvbGUpO1xuY29uc3QgdXNlckFnZW50VHJhaWwgPSBgb2N0b2tpdC1jb3JlLmpzLyR7VkVSU0lPTn0gJHtnZXRVc2VyQWdlbnQoKX1gO1xuY2xhc3MgT2N0b2tpdCB7XG4gIHN0YXRpYyBWRVJTSU9OID0gVkVSU0lPTjtcbiAgc3RhdGljIGRlZmF1bHRzKGRlZmF1bHRzKSB7XG4gICAgY29uc3QgT2N0b2tpdFdpdGhEZWZhdWx0cyA9IGNsYXNzIGV4dGVuZHMgdGhpcyB7XG4gICAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBhcmdzWzBdIHx8IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRlZmF1bHRzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBzdXBlcihkZWZhdWx0cyhvcHRpb25zKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKFxuICAgICAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIGRlZmF1bHRzLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIG9wdGlvbnMudXNlckFnZW50ICYmIGRlZmF1bHRzLnVzZXJBZ2VudCA/IHtcbiAgICAgICAgICAgICAgdXNlckFnZW50OiBgJHtvcHRpb25zLnVzZXJBZ2VudH0gJHtkZWZhdWx0cy51c2VyQWdlbnR9YFxuICAgICAgICAgICAgfSA6IG51bGxcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gT2N0b2tpdFdpdGhEZWZhdWx0cztcbiAgfVxuICBzdGF0aWMgcGx1Z2lucyA9IFtdO1xuICAvKipcbiAgICogQXR0YWNoIGEgcGx1Z2luIChvciBtYW55KSB0byB5b3VyIE9jdG9raXQgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IEFQSSA9IE9jdG9raXQucGx1Z2luKHBsdWdpbjEsIHBsdWdpbjIsIHBsdWdpbjMsIC4uLilcbiAgICovXG4gIHN0YXRpYyBwbHVnaW4oLi4ubmV3UGx1Z2lucykge1xuICAgIGNvbnN0IGN1cnJlbnRQbHVnaW5zID0gdGhpcy5wbHVnaW5zO1xuICAgIGNvbnN0IE5ld09jdG9raXQgPSBjbGFzcyBleHRlbmRzIHRoaXMge1xuICAgICAgc3RhdGljIHBsdWdpbnMgPSBjdXJyZW50UGx1Z2lucy5jb25jYXQoXG4gICAgICAgIG5ld1BsdWdpbnMuZmlsdGVyKChwbHVnaW4pID0+ICFjdXJyZW50UGx1Z2lucy5pbmNsdWRlcyhwbHVnaW4pKVxuICAgICAgKTtcbiAgICB9O1xuICAgIHJldHVybiBOZXdPY3Rva2l0O1xuICB9XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGhvb2sgPSBuZXcgSG9vay5Db2xsZWN0aW9uKCk7XG4gICAgY29uc3QgcmVxdWVzdERlZmF1bHRzID0ge1xuICAgICAgYmFzZVVybDogcmVxdWVzdC5lbmRwb2ludC5ERUZBVUxUUy5iYXNlVXJsLFxuICAgICAgaGVhZGVyczoge30sXG4gICAgICByZXF1ZXN0OiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLnJlcXVlc3QsIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBpbnRlcm5hbCB1c2FnZSBvbmx5LCBubyBuZWVkIHRvIHR5cGVcbiAgICAgICAgaG9vazogaG9vay5iaW5kKG51bGwsIFwicmVxdWVzdFwiKVxuICAgICAgfSksXG4gICAgICBtZWRpYVR5cGU6IHtcbiAgICAgICAgcHJldmlld3M6IFtdLFxuICAgICAgICBmb3JtYXQ6IFwiXCJcbiAgICAgIH1cbiAgICB9O1xuICAgIHJlcXVlc3REZWZhdWx0cy5oZWFkZXJzW1widXNlci1hZ2VudFwiXSA9IG9wdGlvbnMudXNlckFnZW50ID8gYCR7b3B0aW9ucy51c2VyQWdlbnR9ICR7dXNlckFnZW50VHJhaWx9YCA6IHVzZXJBZ2VudFRyYWlsO1xuICAgIGlmIChvcHRpb25zLmJhc2VVcmwpIHtcbiAgICAgIHJlcXVlc3REZWZhdWx0cy5iYXNlVXJsID0gb3B0aW9ucy5iYXNlVXJsO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5wcmV2aWV3cykge1xuICAgICAgcmVxdWVzdERlZmF1bHRzLm1lZGlhVHlwZS5wcmV2aWV3cyA9IG9wdGlvbnMucHJldmlld3M7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnRpbWVab25lKSB7XG4gICAgICByZXF1ZXN0RGVmYXVsdHMuaGVhZGVyc1tcInRpbWUtem9uZVwiXSA9IG9wdGlvbnMudGltZVpvbmU7XG4gICAgfVxuICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3QuZGVmYXVsdHMocmVxdWVzdERlZmF1bHRzKTtcbiAgICB0aGlzLmdyYXBocWwgPSB3aXRoQ3VzdG9tUmVxdWVzdCh0aGlzLnJlcXVlc3QpLmRlZmF1bHRzKHJlcXVlc3REZWZhdWx0cyk7XG4gICAgdGhpcy5sb2cgPSBPYmplY3QuYXNzaWduKFxuICAgICAge1xuICAgICAgICBkZWJ1Zzogbm9vcCxcbiAgICAgICAgaW5mbzogbm9vcCxcbiAgICAgICAgd2FybjogY29uc29sZVdhcm4sXG4gICAgICAgIGVycm9yOiBjb25zb2xlRXJyb3JcbiAgICAgIH0sXG4gICAgICBvcHRpb25zLmxvZ1xuICAgICk7XG4gICAgdGhpcy5ob29rID0gaG9vaztcbiAgICBpZiAoIW9wdGlvbnMuYXV0aFN0cmF0ZWd5KSB7XG4gICAgICBpZiAoIW9wdGlvbnMuYXV0aCkge1xuICAgICAgICB0aGlzLmF1dGggPSBhc3luYyAoKSA9PiAoe1xuICAgICAgICAgIHR5cGU6IFwidW5hdXRoZW50aWNhdGVkXCJcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBhdXRoID0gY3JlYXRlVG9rZW5BdXRoKG9wdGlvbnMuYXV0aCk7XG4gICAgICAgIGhvb2sud3JhcChcInJlcXVlc3RcIiwgYXV0aC5ob29rKTtcbiAgICAgICAgdGhpcy5hdXRoID0gYXV0aDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgeyBhdXRoU3RyYXRlZ3ksIC4uLm90aGVyT3B0aW9ucyB9ID0gb3B0aW9ucztcbiAgICAgIGNvbnN0IGF1dGggPSBhdXRoU3RyYXRlZ3koXG4gICAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge1xuICAgICAgICAgICAgcmVxdWVzdDogdGhpcy5yZXF1ZXN0LFxuICAgICAgICAgICAgbG9nOiB0aGlzLmxvZyxcbiAgICAgICAgICAgIC8vIHdlIHBhc3MgdGhlIGN1cnJlbnQgb2N0b2tpdCBpbnN0YW5jZSBhcyB3ZWxsIGFzIGl0cyBjb25zdHJ1Y3RvciBvcHRpb25zXG4gICAgICAgICAgICAvLyB0byBhbGxvdyBmb3IgYXV0aGVudGljYXRpb24gc3RyYXRlZ2llcyB0aGF0IHJldHVybiBhIG5ldyBvY3Rva2l0IGluc3RhbmNlXG4gICAgICAgICAgICAvLyB0aGF0IHNoYXJlcyB0aGUgc2FtZSBpbnRlcm5hbCBzdGF0ZSBhcyB0aGUgY3VycmVudCBvbmUuIFRoZSBvcmlnaW5hbFxuICAgICAgICAgICAgLy8gcmVxdWlyZW1lbnQgZm9yIHRoaXMgd2FzIHRoZSBcImV2ZW50LW9jdG9raXRcIiBhdXRoZW50aWNhdGlvbiBzdHJhdGVneVxuICAgICAgICAgICAgLy8gb2YgaHR0cHM6Ly9naXRodWIuY29tL3Byb2JvdC9vY3Rva2l0LWF1dGgtcHJvYm90LlxuICAgICAgICAgICAgb2N0b2tpdDogdGhpcyxcbiAgICAgICAgICAgIG9jdG9raXRPcHRpb25zOiBvdGhlck9wdGlvbnNcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9wdGlvbnMuYXV0aFxuICAgICAgICApXG4gICAgICApO1xuICAgICAgaG9vay53cmFwKFwicmVxdWVzdFwiLCBhdXRoLmhvb2spO1xuICAgICAgdGhpcy5hdXRoID0gYXV0aDtcbiAgICB9XG4gICAgY29uc3QgY2xhc3NDb25zdHJ1Y3RvciA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbGFzc0NvbnN0cnVjdG9yLnBsdWdpbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2xhc3NDb25zdHJ1Y3Rvci5wbHVnaW5zW2ldKHRoaXMsIG9wdGlvbnMpKTtcbiAgICB9XG4gIH1cbiAgLy8gYXNzaWduZWQgZHVyaW5nIGNvbnN0cnVjdG9yXG4gIHJlcXVlc3Q7XG4gIGdyYXBocWw7XG4gIGxvZztcbiAgaG9vaztcbiAgLy8gVE9ETzogdHlwZSBgb2N0b2tpdC5hdXRoYCBiYXNlZCBvbiBwYXNzZWQgb3B0aW9ucy5hdXRoU3RyYXRlZ3lcbiAgYXV0aDtcbn1cbmV4cG9ydCB7XG4gIE9jdG9raXRcbn07XG4iLCAiaW1wb3J0IHsgTm90aWNlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBDbGFzaFN0YXR1cywgRmlsZU9wUmVjb3JkLCBMb2NhbEZpbGVTdGF0dXMsIFJlbW90ZUNoYW5nZVR5cGUgfSBmcm9tIFwiLi9maXRUeXBlc1wiO1xuaW1wb3J0IHsgYmFzaWNUZW1wbGF0ZUNvbmZsaWN0LCBjb25mbGljdFJlc29sdXRpb25Gb2xkZXIgfSBmcm9tIFwiLi9jb25zdFwiO1xuaW1wb3J0IHsgZGlmZldvcmRzIH0gZnJvbSBcImRpZmZcIjtcblxudHlwZSBTdGF0dXMgPSBSZW1vdGVDaGFuZ2VUeXBlIHwgTG9jYWxGaWxlU3RhdHVzXG5cbnR5cGUgRmlsZUxvY2F0aW9uID0gXCJyZW1vdGVcIiB8IFwibG9jYWxcIlxuXG50eXBlIENvbXBhcmlzb25SZXN1bHQ8RW52IGV4dGVuZHMgRmlsZUxvY2F0aW9uPiA9IHtcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgc3RhdHVzOiBFbnYgZXh0ZW5kcyBcImxvY2FsXCIgPyBMb2NhbEZpbGVTdGF0dXM6IFJlbW90ZUNoYW5nZVR5cGVcbiAgICBjdXJyZW50U2hhPzogc3RyaW5nXG4gICAgZXh0ZW5zaW9uPzogc3RyaW5nXG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlT3JOdWxsKG9iajogUmVjb3JkPHN0cmluZywgc3RyaW5nPiwga2V5OiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsIHtcbiAgICByZXR1cm4gb2JqLmhhc093blByb3BlcnR5KGtleSkgPyBvYmpba2V5XSA6IG51bGw7XG59XG5cblxuLy8gY29tcGFyZSBjdXJyZW50U2hhIHdpdGggc3RvcmVkU2hhIGFuZCBjaGVjayBmb3IgZGlmZmVyZW5jZXMsIGZpbGVzIG9ubHkgaW4gY3VycmVudFNoYVxuLy8gIGFyZSBjb25zaWRlcmQgYWRkZWQsIHdoaWxlIGZpbGVzIG9ubHkgaW4gc3RvcmVkU2hhIGFyZSBjb25zaWRlcmVkIHJlbW92ZWRcbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlU2hhPEVudiBleHRlbmRzIEZpbGVMb2NhdGlvbj4oXG4gICAgY3VycmVudFNoYU1hcDogUmVjb3JkPHN0cmluZywgc3RyaW5nPixcbiAgICBzdG9yZWRTaGFNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4sXG4gICAgZW52OiBFbnYpOiBDb21wYXJpc29uUmVzdWx0PEVudj5bXSB7XG4gICAgICAgIGNvbnN0IGRldGVybWluZVN0YXR1cyA9IChjdXJyZW50U2hhOiBzdHJpbmcgfCBudWxsLCBzdG9yZWRTaGE6IHN0cmluZyB8IG51bGwpOiBTdGF0dXMgfCBudWxsICA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFNoYSAmJiBzdG9yZWRTaGEgJiYgY3VycmVudFNoYSAhPT0gc3RvcmVkU2hhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudiA9PT0gXCJsb2NhbFwiID8gXCJjaGFuZ2VkXCIgOiBcIk1PRElGSUVEXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRTaGEgJiYgIXN0b3JlZFNoYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbnYgPT09IFwibG9jYWxcIiA/IFwiY3JlYXRlZFwiIDogXCJBRERFRFwiO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghY3VycmVudFNoYSAmJiBzdG9yZWRTaGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW52ID09PSBcImxvY2FsXCIgPyBcImRlbGV0ZWRcIiA6IFwiUkVNT1ZFRFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh7IC4uLmN1cnJlbnRTaGFNYXAsIC4uLnN0b3JlZFNoYU1hcCB9KS5mbGF0TWFwKChwYXRoKTogQ29tcGFyaXNvblJlc3VsdDxFbnY+W10gPT4ge1xuICAgICAgICAgICAgY29uc3QgW2N1cnJlbnRTaGEsIHN0b3JlZFNoYV0gPSBbZ2V0VmFsdWVPck51bGwoY3VycmVudFNoYU1hcCwgcGF0aCksIGdldFZhbHVlT3JOdWxsKHN0b3JlZFNoYU1hcCwgcGF0aCldO1xuICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gZGV0ZXJtaW5lU3RhdHVzKGN1cnJlbnRTaGEsIHN0b3JlZFNoYSk7XG4gICAgICAgICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogc3RhdHVzIGFzIEVudiBleHRlbmRzIFwibG9jYWxcIiA/IExvY2FsRmlsZVN0YXR1cyA6IFJlbW90ZUNoYW5nZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTaGE6IGN1cnJlbnRTaGEgPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBleHRlbnNpb246IGV4dHJhY3RFeHRlbnNpb24ocGF0aClcbiAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSk7XG59XG5cbmV4cG9ydCBjb25zdCBSRUNPR05JWkVEX1RYVF9FWFQgPSBbXCJ0eHRcIiwgXCJtZFwiXVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdEV4dGVuc2lvbihwYXRoOiBzdHJpbmcpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiBwYXRoLm1hdGNoKC9bXi5dKyQvKT8uWzBdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNCaW5hcnlGaWxlKHBhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IGV4dHJhY3RFeHRlbnNpb24ocGF0aClcbiAgICBjb25zdCBpc1R4dCA9IGV4dGVuc2lvbiAmJiBSRUNPR05JWkVEX1RYVF9FWFQuaW5jbHVkZXMoZXh0ZW5zaW9uKTtcblxuICAgIHJldHVybiAhaXNUeHRcbn1cblxuLy8gVXNpbmcgZmlsZSBleHRlbnNpb24gdG8gZGV0ZXJtaW5lIGVuY29kaW5nIG9mIGZpbGVzICh3b3JrcyBpbiBtb3N0IGNhc2VzKVxuZXhwb3J0IGZ1bmN0aW9uIGdldEZpbGVFbmNvZGluZyhwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmIChpc0JpbmFyeUZpbGUocGF0aCkpXG4gICAgICAgIHJldHVybiBcImJhc2U2NFwiXG4gICAgcmV0dXJuIFwidXRmLThcIlxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0RXF1YWw8VD4oYXJyMTogQXJyYXk8VD4sIGFycjI6IEFycmF5PFQ+KSB7XG4gICAgY29uc3Qgc2V0MSA9IG5ldyBTZXQoYXJyMSk7XG4gICAgY29uc3Qgc2V0MiA9IG5ldyBTZXQoYXJyMik7XG4gICAgY29uc3QgaXNFcXVhbCA9IHNldDEuc2l6ZSA9PT0gc2V0Mi5zaXplICYmIFsuLi5zZXQxXS5ldmVyeSh2YWx1ZSA9PiBzZXQyLmhhcyh2YWx1ZSkpO1xuICAgIHJldHVybiBpc0VxdWFsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVMaW5lRW5kaW5nc0Zyb21CYXNlNjRTdHJpbmcoY29udGVudDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gY29udGVudC5yZXBsYWNlKC9cXHI/XFxufFxccnxcXG4vZywgJycpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hvd0ZpbGVPcHNSZWNvcmQocmVjb3JkczogQXJyYXk8e2hlYWRpbmc6IHN0cmluZywgb3BzOiBGaWxlT3BSZWNvcmRbXX0+KTogdm9pZCB7XG4gICAgaWYgKHJlY29yZHMubGVuZ3RoID09PSAwIHx8IHJlY29yZHMuZXZlcnkocj0+ci5vcHMubGVuZ3RoPT09MCkpIHtyZXR1cm59XG4gICAgY29uc3QgZmlsZU9wc05vdGljZSA9IG5ldyBOb3RpY2UoXCJcIiwgMClcbiAgICByZWNvcmRzLm1hcChyZWNvcmRTZXQgPT4ge1xuICAgICAgICBpZiAocmVjb3JkU2V0Lm9wcy5sZW5ndGggPT09IDApIHtyZXR1cm59XG4gICAgICAgIGNvbnN0IGhlYWRpbmcgPSBmaWxlT3BzTm90aWNlLm5vdGljZUVsLmNyZWF0ZUVsKFwic3BhblwiLCB7XG4gICAgICAgICAgICBjbHM6IFwiZmlsZS1jaGFuZ2VzLWhlYWRpbmdcIlxuICAgICAgICB9KVxuICAgICAgICBoZWFkaW5nLnNldFRleHQoYCR7cmVjb3JkU2V0LmhlYWRpbmd9XFxuYClcbiAgICAgICAgY29uc3QgZmlsZUNoYW5nZXMgPSB7XG4gICAgICAgICAgICBjcmVhdGVkOiBbXSBhcyBBcnJheTxzdHJpbmc+LFxuICAgICAgICAgICAgY2hhbmdlZDogW10gYXMgQXJyYXk8c3RyaW5nPixcbiAgICAgICAgICAgIGRlbGV0ZWQ6IFtdIGFzIEFycmF5PHN0cmluZz5cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IG9wIG9mIHJlY29yZFNldC5vcHMpIHtcbiAgICAgICAgICAgIGZpbGVDaGFuZ2VzW29wLnN0YXR1c10ucHVzaChvcC5wYXRoKVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW2NoYW5nZVR5cGUsIHBhdGhzXSBvZiBPYmplY3QuZW50cmllcyhmaWxlQ2hhbmdlcykpIHtcbiAgICAgICAgICAgIGlmIChwYXRocy5sZW5ndGggPT09IDApIHtjb250aW51ZX1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRpbmcgPSBmaWxlT3BzTm90aWNlLm5vdGljZUVsLmNyZWF0ZUVsKFwic3BhblwiKVxuICAgICAgICAgICAgaGVhZGluZy5zZXRUZXh0KGAke2NoYW5nZVR5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBjaGFuZ2VUeXBlLnNsaWNlKDEpfVxcbmApXG4gICAgICAgICAgICBoZWFkaW5nLmFkZENsYXNzKGBmaWxlLWNoYW5nZXMtc3ViaGVhZGluZ2ApXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsaXN0SXRlbSA9IGZpbGVPcHNOb3RpY2Uubm90aWNlRWwuY3JlYXRlRWwoXCJsaVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGNsczogXCJmaWxlLXVwZGF0ZS1yb3dcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGxpc3RJdGVtLnNldFRleHQoYCR7cGF0aH1gKTtcbiAgICAgICAgICAgICAgICBsaXN0SXRlbS5hZGRDbGFzcyhgZmlsZS0ke2NoYW5nZVR5cGV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hvd1VuYXBwbGllZENvbmZsaWN0cyhjbGFzaGVkRmlsZXM6IEFycmF5PENsYXNoU3RhdHVzPik6IHZvaWQge1xuICAgIGlmIChjbGFzaGVkRmlsZXMubGVuZ3RoID09PSAwKSB7cmV0dXJufVxuICAgIGNvbnN0IGxvY2FsU3RhdHVzTWFwID0ge1xuICAgICAgICBjcmVhdGVkOiBcImNyZWF0ZVwiLFxuICAgICAgICBjaGFuZ2VkOiBcImNoYW5nZVwiLFxuICAgICAgICBkZWxldGVkOiBcImRlbGV0ZVwiXG4gICAgfVxuICAgIGNvbnN0IHJlbW90ZVN0YXR1c01hcCA9IHtcbiAgICAgICAgQURERUQ6ICBcImNyZWF0ZVwiLFxuICAgICAgICBNT0RJRklFRDogXCJjaGFuZ2VcIixcbiAgICAgICAgUkVNT1ZFRDogXCJkZWxldGVcIlxuICAgIH1cbiAgICBjb25zdCBjb25mbGljdE5vdGljZSA9IG5ldyBOb3RpY2UoXCJcIiwgMClcbiAgICBjb25zdCBoZWFkaW5nID0gY29uZmxpY3ROb3RpY2Uubm90aWNlRWwuY3JlYXRlRWwoXCJzcGFuXCIpXG4gICAgaGVhZGluZy5zZXRUZXh0KGBDaGFuZ2UgY29uZmxpY3RzOlxcbmApXG4gICAgaGVhZGluZy5hZGRDbGFzcyhgZmlsZS1jaGFuZ2VzLXN1YmhlYWRpbmdgKVxuICAgIGNvbnN0IGNvbmZsaWN0U3RhdHVzID0gY29uZmxpY3ROb3RpY2Uubm90aWNlRWwuY3JlYXRlRGl2KHtcbiAgICAgICAgY2xzOiBcImZpbGUtY29uZmxpY3Qtcm93XCJcbiAgICB9KTtcbiAgICBjb25mbGljdFN0YXR1cy5jcmVhdGVEaXYoKS5zZXRUZXh0KFwiTG9jYWxcIilcbiAgICBjb25mbGljdFN0YXR1cy5jcmVhdGVEaXYoKS5zZXRUZXh0KFwiUmVtb3RlXCIpXG4gICAgZm9yIChjb25zdCBjbGFzaCBvZiBjbGFzaGVkRmlsZXMpIHtcbiAgICAgICAgY29uc3QgY29uZmxpY3RJdGVtID0gY29uZmxpY3ROb3RpY2Uubm90aWNlRWwuY3JlYXRlRGl2KHtcbiAgICAgICAgICAgIGNsczogXCJmaWxlLWNvbmZsaWN0LXJvd1wiXG4gICAgICAgIH0pO1xuICAgICAgICBjb25mbGljdEl0ZW0uY3JlYXRlRGl2KHtcbiAgICAgICAgICAgIGNsczogYGZpbGUtY29uZmxpY3QtJHtsb2NhbFN0YXR1c01hcFtjbGFzaC5sb2NhbFN0YXR1c119YFxuICAgICAgICB9KTtcbiAgICAgICAgY29uZmxpY3RJdGVtLmNyZWF0ZURpdihcImRpdlwiKVxuICAgICAgICAgICAgLnNldFRleHQoY2xhc2gucGF0aCk7XG4gICAgICAgIGNvbmZsaWN0SXRlbS5jcmVhdGVEaXYoe1xuICAgICAgICAgICAgY2xzOiBgZmlsZS1jb25mbGljdC0ke3JlbW90ZVN0YXR1c01hcFtjbGFzaC5yZW1vdGVTdGF0dXNdfWBcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGZvb3RlciA9IGNvbmZsaWN0Tm90aWNlLm5vdGljZUVsLmNyZWF0ZURpdih7XG4gICAgICAgIGNsczogXCJmaWxlLWNvbmZsaWN0LXJvd1wiXG4gICAgfSlcbiAgICBmb290ZXIuc2V0VGV4dChcIk5vdGU6XCIpXG4gICAgZm9vdGVyLnN0eWxlLmZvbnRXZWlnaHQgPSBcImJvbGRcIjtcbiAgICBjb25mbGljdE5vdGljZS5ub3RpY2VFbC5jcmVhdGVFbChcImxpXCIsIHtjbHM6IFwiZmlsZS1jb25mbGljdC1ub3RlXCJ9KVxuICAgICAgICAuc2V0VGV4dChgUmVtb3RlIGNoYW5nZXMgaW4gJHtjb25mbGljdFJlc29sdXRpb25Gb2xkZXJ9YClcbiAgICBjb25mbGljdE5vdGljZS5ub3RpY2VFbC5jcmVhdGVFbChcImxpXCIsIHtjbHM6IFwiZmlsZS1jb25mbGljdC1ub3RlXCJ9KVxuICAgICAgICAuc2V0VGV4dChgJHtjb25mbGljdFJlc29sdXRpb25Gb2xkZXJ9IGZvbGRlciBpcyBvdmVyd3JpdHRlbiBvbiBjb25mbGljdCwgY29weSBuZWVkZWQgY2hhbmdlcyBvdXRzaWRlICR7Y29uZmxpY3RSZXNvbHV0aW9uRm9sZGVyfS5gKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJzZWN0aW9uKHNldEE6IFNldDxhbnk+LCBzZXRCOiBTZXQ8YW55Pikge1xuICAgIHJldHVybiBuZXcgU2V0KFsuLi5zZXRBXS5maWx0ZXIoeCA9PiBzZXRCLmhhcyh4KSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlmZmVyZW5jZShzZXRBOiBTZXQ8YW55Piwgc2V0QjogU2V0PGFueT4pIHtcbiAgICByZXR1cm4gbmV3IFNldChbLi4uc2V0QV0uZmlsdGVyKHggPT4gIXNldEIuaGFzKHgpKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREaWZmVGV4dChvbGRDb250ZW50OiBzdHJpbmcsIG5ld0NvbnRlbnQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuXG4gICAgY29uc3QgZGlmZiA9IGRpZmZXb3JkcyhvbGRDb250ZW50LCBuZXdDb250ZW50KTtcblxuICAgIGNvbnN0IGhhc0NoYW5nZXMgPSBkaWZmLnNvbWUocGFydCA9PiBwYXJ0LmFkZGVkIHx8IHBhcnQucmVtb3ZlZCk7XG4gICAgaWYgKCFoYXNDaGFuZ2VzKSB7XG4gICAgICAgIHJldHVybiBiYXNpY1RlbXBsYXRlQ29uZmxpY3QgKyAnTm8gZGlmZmVyZW5jZXMgZm91bmQnO1xuICAgIH1cblxuICAgIGxldCBjdXJyZW50TGluZSA9ICcnO1xuICAgIGxldCBoYXNMaW5lQ2hhbmdlcyA9IGZhbHNlO1xuXG4gICAgZm9yIChsZXQgcGFydCBvZiBkaWZmKSB7XG4gICAgICAgIGxldCB0ZXh0OiBzdHJpbmdcbiAgICAgICAgaWYgKHBhcnQucmVtb3ZlZCkge1xuICAgICAgICAgICAgdGV4dCA9IGA8c3BhbiBzdHlsZT1cImNvbG9yOnJnYigyMjMsIDczLCA3MylcIj4ke3BhcnQudmFsdWV9PC9zcGFuPmBcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJ0LmFkZGVkKSB7XG4gICAgICAgICAgICB0ZXh0ID0gYDxzcGFuIHN0eWxlPVwiY29sb3I6cmdiKDAsIDE3NiwgODApXCI+JHtwYXJ0LnZhbHVlfTwvc3Bhbj5gXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0ZXh0ID0gcGFydC52YWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKTtcblxuICAgICAgICBjdXJyZW50TGluZSArPSBsaW5lc1swXTtcbiAgICAgICAgaWYgKHBhcnQuYWRkZWQgfHwgcGFydC5yZW1vdmVkKSB7XG4gICAgICAgICAgICBoYXNMaW5lQ2hhbmdlcyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaGFzTGluZUNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gY3VycmVudExpbmUgKyAnXFxuJ1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyZW50TGluZSA9IGxpbmVzW2ldXG4gICAgICAgICAgICBoYXNMaW5lQ2hhbmdlcyA9IHBhcnQuYWRkZWQgfHwgcGFydC5yZW1vdmVkXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzTGluZUNoYW5nZXMgJiYgY3VycmVudExpbmUpIHtcbiAgICAgICAgcmVzdWx0ICs9IGN1cnJlbnRMaW5lICsgJ1xcbic7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsICJleHBvcnQgZGVmYXVsdCBjbGFzcyBEaWZmIHtcbiAgICBkaWZmKG9sZFN0ciwgbmV3U3RyLCBcbiAgICAvLyBUeXBlIGJlbG93IGlzIG5vdCBhY2N1cmF0ZS9jb21wbGV0ZSAtIHNlZSBhYm92ZSBmb3IgZnVsbCBwb3NzaWJpbGl0aWVzIC0gYnV0IGl0IGNvbXBpbGVzXG4gICAgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCBjYWxsYmFjaztcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJ2NhbGxiYWNrJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWxsb3cgc3ViY2xhc3NlcyB0byBtYXNzYWdlIHRoZSBpbnB1dCBwcmlvciB0byBydW5uaW5nXG4gICAgICAgIGNvbnN0IG9sZFN0cmluZyA9IHRoaXMuY2FzdElucHV0KG9sZFN0ciwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IG5ld1N0cmluZyA9IHRoaXMuY2FzdElucHV0KG5ld1N0ciwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IG9sZFRva2VucyA9IHRoaXMucmVtb3ZlRW1wdHkodGhpcy50b2tlbml6ZShvbGRTdHJpbmcsIG9wdGlvbnMpKTtcbiAgICAgICAgY29uc3QgbmV3VG9rZW5zID0gdGhpcy5yZW1vdmVFbXB0eSh0aGlzLnRva2VuaXplKG5ld1N0cmluZywgb3B0aW9ucykpO1xuICAgICAgICByZXR1cm4gdGhpcy5kaWZmV2l0aE9wdGlvbnNPYmoob2xkVG9rZW5zLCBuZXdUb2tlbnMsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgZGlmZldpdGhPcHRpb25zT2JqKG9sZFRva2VucywgbmV3VG9rZW5zLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGRvbmUgPSAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wb3N0UHJvY2Vzcyh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgY2FsbGJhY2sodmFsdWUpOyB9LCAwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBuZXdMZW4gPSBuZXdUb2tlbnMubGVuZ3RoLCBvbGRMZW4gPSBvbGRUb2tlbnMubGVuZ3RoO1xuICAgICAgICBsZXQgZWRpdExlbmd0aCA9IDE7XG4gICAgICAgIGxldCBtYXhFZGl0TGVuZ3RoID0gbmV3TGVuICsgb2xkTGVuO1xuICAgICAgICBpZiAob3B0aW9ucy5tYXhFZGl0TGVuZ3RoICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1heEVkaXRMZW5ndGggPSBNYXRoLm1pbihtYXhFZGl0TGVuZ3RoLCBvcHRpb25zLm1heEVkaXRMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1heEV4ZWN1dGlvblRpbWUgPSAoX2EgPSBvcHRpb25zLnRpbWVvdXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IEluZmluaXR5O1xuICAgICAgICBjb25zdCBhYm9ydEFmdGVyVGltZXN0YW1wID0gRGF0ZS5ub3coKSArIG1heEV4ZWN1dGlvblRpbWU7XG4gICAgICAgIGNvbnN0IGJlc3RQYXRoID0gW3sgb2xkUG9zOiAtMSwgbGFzdENvbXBvbmVudDogdW5kZWZpbmVkIH1dO1xuICAgICAgICAvLyBTZWVkIGVkaXRMZW5ndGggPSAwLCBpLmUuIHRoZSBjb250ZW50IHN0YXJ0cyB3aXRoIHRoZSBzYW1lIHZhbHVlc1xuICAgICAgICBsZXQgbmV3UG9zID0gdGhpcy5leHRyYWN0Q29tbW9uKGJlc3RQYXRoWzBdLCBuZXdUb2tlbnMsIG9sZFRva2VucywgMCwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChiZXN0UGF0aFswXS5vbGRQb3MgKyAxID49IG9sZExlbiAmJiBuZXdQb3MgKyAxID49IG5ld0xlbikge1xuICAgICAgICAgICAgLy8gSWRlbnRpdHkgcGVyIHRoZSBlcXVhbGl0eSBhbmQgdG9rZW5pemVyXG4gICAgICAgICAgICByZXR1cm4gZG9uZSh0aGlzLmJ1aWxkVmFsdWVzKGJlc3RQYXRoWzBdLmxhc3RDb21wb25lbnQsIG5ld1Rva2Vucywgb2xkVG9rZW5zKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25jZSB3ZSBoaXQgdGhlIHJpZ2h0IGVkZ2Ugb2YgdGhlIGVkaXQgZ3JhcGggb24gc29tZSBkaWFnb25hbCBrLCB3ZSBjYW5cbiAgICAgICAgLy8gZGVmaW5pdGVseSByZWFjaCB0aGUgZW5kIG9mIHRoZSBlZGl0IGdyYXBoIGluIG5vIG1vcmUgdGhhbiBrIGVkaXRzLCBzb1xuICAgICAgICAvLyB0aGVyZSdzIG5vIHBvaW50IGluIGNvbnNpZGVyaW5nIGFueSBtb3ZlcyB0byBkaWFnb25hbCBrKzEgYW55IG1vcmUgKGZyb21cbiAgICAgICAgLy8gd2hpY2ggd2UncmUgZ3VhcmFudGVlZCB0byBuZWVkIGF0IGxlYXN0IGsrMSBtb3JlIGVkaXRzKS5cbiAgICAgICAgLy8gU2ltaWxhcmx5LCBvbmNlIHdlJ3ZlIHJlYWNoZWQgdGhlIGJvdHRvbSBvZiB0aGUgZWRpdCBncmFwaCwgdGhlcmUncyBub1xuICAgICAgICAvLyBwb2ludCBjb25zaWRlcmluZyBtb3ZlcyB0byBsb3dlciBkaWFnb25hbHMuXG4gICAgICAgIC8vIFdlIHJlY29yZCB0aGlzIGZhY3QgYnkgc2V0dGluZyBtaW5EaWFnb25hbFRvQ29uc2lkZXIgYW5kXG4gICAgICAgIC8vIG1heERpYWdvbmFsVG9Db25zaWRlciB0byBzb21lIGZpbml0ZSB2YWx1ZSBvbmNlIHdlJ3ZlIGhpdCB0aGUgZWRnZSBvZlxuICAgICAgICAvLyB0aGUgZWRpdCBncmFwaC5cbiAgICAgICAgLy8gVGhpcyBvcHRpbWl6YXRpb24gaXMgbm90IGZhaXRoZnVsIHRvIHRoZSBvcmlnaW5hbCBhbGdvcml0aG0gcHJlc2VudGVkIGluXG4gICAgICAgIC8vIE15ZXJzJ3MgcGFwZXIsIHdoaWNoIGluc3RlYWQgcG9pbnRsZXNzbHkgZXh0ZW5kcyBELXBhdGhzIG9mZiB0aGUgZW5kIG9mXG4gICAgICAgIC8vIHRoZSBlZGl0IGdyYXBoIC0gc2VlIHBhZ2UgNyBvZiBNeWVycydzIHBhcGVyIHdoaWNoIG5vdGVzIHRoaXMgcG9pbnRcbiAgICAgICAgLy8gZXhwbGljaXRseSBhbmQgaWxsdXN0cmF0ZXMgaXQgd2l0aCBhIGRpYWdyYW0uIFRoaXMgaGFzIG1ham9yIHBlcmZvcm1hbmNlXG4gICAgICAgIC8vIGltcGxpY2F0aW9ucyBmb3Igc29tZSBjb21tb24gc2NlbmFyaW9zLiBGb3IgaW5zdGFuY2UsIHRvIGNvbXB1dGUgYSBkaWZmXG4gICAgICAgIC8vIHdoZXJlIHRoZSBuZXcgdGV4dCBzaW1wbHkgYXBwZW5kcyBkIGNoYXJhY3RlcnMgb24gdGhlIGVuZCBvZiB0aGVcbiAgICAgICAgLy8gb3JpZ2luYWwgdGV4dCBvZiBsZW5ndGggbiwgdGhlIHRydWUgTXllcnMgYWxnb3JpdGhtIHdpbGwgdGFrZSBPKG4rZF4yKVxuICAgICAgICAvLyB0aW1lIHdoaWxlIHRoaXMgb3B0aW1pemF0aW9uIG5lZWRzIG9ubHkgTyhuK2QpIHRpbWUuXG4gICAgICAgIGxldCBtaW5EaWFnb25hbFRvQ29uc2lkZXIgPSAtSW5maW5pdHksIG1heERpYWdvbmFsVG9Db25zaWRlciA9IEluZmluaXR5O1xuICAgICAgICAvLyBNYWluIHdvcmtlciBtZXRob2QuIGNoZWNrcyBhbGwgcGVybXV0YXRpb25zIG9mIGEgZ2l2ZW4gZWRpdCBsZW5ndGggZm9yIGFjY2VwdGFuY2UuXG4gICAgICAgIGNvbnN0IGV4ZWNFZGl0TGVuZ3RoID0gKCkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgZGlhZ29uYWxQYXRoID0gTWF0aC5tYXgobWluRGlhZ29uYWxUb0NvbnNpZGVyLCAtZWRpdExlbmd0aCk7IGRpYWdvbmFsUGF0aCA8PSBNYXRoLm1pbihtYXhEaWFnb25hbFRvQ29uc2lkZXIsIGVkaXRMZW5ndGgpOyBkaWFnb25hbFBhdGggKz0gMikge1xuICAgICAgICAgICAgICAgIGxldCBiYXNlUGF0aDtcbiAgICAgICAgICAgICAgICBjb25zdCByZW1vdmVQYXRoID0gYmVzdFBhdGhbZGlhZ29uYWxQYXRoIC0gMV0sIGFkZFBhdGggPSBiZXN0UGF0aFtkaWFnb25hbFBhdGggKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZlUGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBObyBvbmUgZWxzZSBpcyBnb2luZyB0byBhdHRlbXB0IHRvIHVzZSB0aGlzIHZhbHVlLCBjbGVhciBpdFxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gcGVyZiBvcHRpbWlzYXRpb24uIFRoaXMgdHlwZS12aW9sYXRpbmcgdmFsdWUgd2lsbCBuZXZlciBiZSByZWFkLlxuICAgICAgICAgICAgICAgICAgICBiZXN0UGF0aFtkaWFnb25hbFBhdGggLSAxXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGNhbkFkZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChhZGRQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdoYXQgbmV3UG9zIHdpbGwgYmUgYWZ0ZXIgd2UgZG8gYW4gaW5zZXJ0aW9uOlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhZGRQYXRoTmV3UG9zID0gYWRkUGF0aC5vbGRQb3MgLSBkaWFnb25hbFBhdGg7XG4gICAgICAgICAgICAgICAgICAgIGNhbkFkZCA9IGFkZFBhdGggJiYgMCA8PSBhZGRQYXRoTmV3UG9zICYmIGFkZFBhdGhOZXdQb3MgPCBuZXdMZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNhblJlbW92ZSA9IHJlbW92ZVBhdGggJiYgcmVtb3ZlUGF0aC5vbGRQb3MgKyAxIDwgb2xkTGVuO1xuICAgICAgICAgICAgICAgIGlmICghY2FuQWRkICYmICFjYW5SZW1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBwYXRoIGlzIGEgdGVybWluYWwgdGhlbiBwcnVuZVxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gcGVyZiBvcHRpbWlzYXRpb24uIFRoaXMgdHlwZS12aW9sYXRpbmcgdmFsdWUgd2lsbCBuZXZlciBiZSByZWFkLlxuICAgICAgICAgICAgICAgICAgICBiZXN0UGF0aFtkaWFnb25hbFBhdGhdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2VsZWN0IHRoZSBkaWFnb25hbCB0aGF0IHdlIHdhbnQgdG8gYnJhbmNoIGZyb20uIFdlIHNlbGVjdCB0aGUgcHJpb3JcbiAgICAgICAgICAgICAgICAvLyBwYXRoIHdob3NlIHBvc2l0aW9uIGluIHRoZSBvbGQgc3RyaW5nIGlzIHRoZSBmYXJ0aGVzdCBmcm9tIHRoZSBvcmlnaW5cbiAgICAgICAgICAgICAgICAvLyBhbmQgZG9lcyBub3QgcGFzcyB0aGUgYm91bmRzIG9mIHRoZSBkaWZmIGdyYXBoXG4gICAgICAgICAgICAgICAgaWYgKCFjYW5SZW1vdmUgfHwgKGNhbkFkZCAmJiByZW1vdmVQYXRoLm9sZFBvcyA8IGFkZFBhdGgub2xkUG9zKSkge1xuICAgICAgICAgICAgICAgICAgICBiYXNlUGF0aCA9IHRoaXMuYWRkVG9QYXRoKGFkZFBhdGgsIHRydWUsIGZhbHNlLCAwLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2VQYXRoID0gdGhpcy5hZGRUb1BhdGgocmVtb3ZlUGF0aCwgZmFsc2UsIHRydWUsIDEsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdQb3MgPSB0aGlzLmV4dHJhY3RDb21tb24oYmFzZVBhdGgsIG5ld1Rva2Vucywgb2xkVG9rZW5zLCBkaWFnb25hbFBhdGgsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChiYXNlUGF0aC5vbGRQb3MgKyAxID49IG9sZExlbiAmJiBuZXdQb3MgKyAxID49IG5ld0xlbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGhpdCB0aGUgZW5kIG9mIGJvdGggc3RyaW5ncywgdGhlbiB3ZSBhcmUgZG9uZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9uZSh0aGlzLmJ1aWxkVmFsdWVzKGJhc2VQYXRoLmxhc3RDb21wb25lbnQsIG5ld1Rva2Vucywgb2xkVG9rZW5zKSkgfHwgdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RQYXRoW2RpYWdvbmFsUGF0aF0gPSBiYXNlUGF0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJhc2VQYXRoLm9sZFBvcyArIDEgPj0gb2xkTGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhEaWFnb25hbFRvQ29uc2lkZXIgPSBNYXRoLm1pbihtYXhEaWFnb25hbFRvQ29uc2lkZXIsIGRpYWdvbmFsUGF0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdQb3MgKyAxID49IG5ld0xlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluRGlhZ29uYWxUb0NvbnNpZGVyID0gTWF0aC5tYXgobWluRGlhZ29uYWxUb0NvbnNpZGVyLCBkaWFnb25hbFBhdGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVkaXRMZW5ndGgrKztcbiAgICAgICAgfTtcbiAgICAgICAgLy8gUGVyZm9ybXMgdGhlIGxlbmd0aCBvZiBlZGl0IGl0ZXJhdGlvbi4gSXMgYSBiaXQgZnVnbHkgYXMgdGhpcyBoYXMgdG8gc3VwcG9ydCB0aGVcbiAgICAgICAgLy8gc3luYyBhbmQgYXN5bmMgbW9kZSB3aGljaCBpcyBuZXZlciBmdW4uIExvb3BzIG92ZXIgZXhlY0VkaXRMZW5ndGggdW50aWwgYSB2YWx1ZVxuICAgICAgICAvLyBpcyBwcm9kdWNlZCwgb3IgdW50aWwgdGhlIGVkaXQgbGVuZ3RoIGV4Y2VlZHMgb3B0aW9ucy5tYXhFZGl0TGVuZ3RoIChpZiBnaXZlbiksXG4gICAgICAgIC8vIGluIHdoaWNoIGNhc2UgaXQgd2lsbCByZXR1cm4gdW5kZWZpbmVkLlxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIChmdW5jdGlvbiBleGVjKCkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWRpdExlbmd0aCA+IG1heEVkaXRMZW5ndGggfHwgRGF0ZS5ub3coKSA+IGFib3J0QWZ0ZXJUaW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXhlY0VkaXRMZW5ndGgoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhlYygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9KCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKGVkaXRMZW5ndGggPD0gbWF4RWRpdExlbmd0aCAmJiBEYXRlLm5vdygpIDw9IGFib3J0QWZ0ZXJUaW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXQgPSBleGVjRWRpdExlbmd0aCgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkVG9QYXRoKHBhdGgsIGFkZGVkLCByZW1vdmVkLCBvbGRQb3NJbmMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbGFzdCA9IHBhdGgubGFzdENvbXBvbmVudDtcbiAgICAgICAgaWYgKGxhc3QgJiYgIW9wdGlvbnMub25lQ2hhbmdlUGVyVG9rZW4gJiYgbGFzdC5hZGRlZCA9PT0gYWRkZWQgJiYgbGFzdC5yZW1vdmVkID09PSByZW1vdmVkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9sZFBvczogcGF0aC5vbGRQb3MgKyBvbGRQb3NJbmMsXG4gICAgICAgICAgICAgICAgbGFzdENvbXBvbmVudDogeyBjb3VudDogbGFzdC5jb3VudCArIDEsIGFkZGVkOiBhZGRlZCwgcmVtb3ZlZDogcmVtb3ZlZCwgcHJldmlvdXNDb21wb25lbnQ6IGxhc3QucHJldmlvdXNDb21wb25lbnQgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb2xkUG9zOiBwYXRoLm9sZFBvcyArIG9sZFBvc0luYyxcbiAgICAgICAgICAgICAgICBsYXN0Q29tcG9uZW50OiB7IGNvdW50OiAxLCBhZGRlZDogYWRkZWQsIHJlbW92ZWQ6IHJlbW92ZWQsIHByZXZpb3VzQ29tcG9uZW50OiBsYXN0IH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXh0cmFjdENvbW1vbihiYXNlUGF0aCwgbmV3VG9rZW5zLCBvbGRUb2tlbnMsIGRpYWdvbmFsUGF0aCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBuZXdMZW4gPSBuZXdUb2tlbnMubGVuZ3RoLCBvbGRMZW4gPSBvbGRUb2tlbnMubGVuZ3RoO1xuICAgICAgICBsZXQgb2xkUG9zID0gYmFzZVBhdGgub2xkUG9zLCBuZXdQb3MgPSBvbGRQb3MgLSBkaWFnb25hbFBhdGgsIGNvbW1vbkNvdW50ID0gMDtcbiAgICAgICAgd2hpbGUgKG5ld1BvcyArIDEgPCBuZXdMZW4gJiYgb2xkUG9zICsgMSA8IG9sZExlbiAmJiB0aGlzLmVxdWFscyhvbGRUb2tlbnNbb2xkUG9zICsgMV0sIG5ld1Rva2Vuc1tuZXdQb3MgKyAxXSwgb3B0aW9ucykpIHtcbiAgICAgICAgICAgIG5ld1BvcysrO1xuICAgICAgICAgICAgb2xkUG9zKys7XG4gICAgICAgICAgICBjb21tb25Db3VudCsrO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lQ2hhbmdlUGVyVG9rZW4pIHtcbiAgICAgICAgICAgICAgICBiYXNlUGF0aC5sYXN0Q29tcG9uZW50ID0geyBjb3VudDogMSwgcHJldmlvdXNDb21wb25lbnQ6IGJhc2VQYXRoLmxhc3RDb21wb25lbnQsIGFkZGVkOiBmYWxzZSwgcmVtb3ZlZDogZmFsc2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tbW9uQ291bnQgJiYgIW9wdGlvbnMub25lQ2hhbmdlUGVyVG9rZW4pIHtcbiAgICAgICAgICAgIGJhc2VQYXRoLmxhc3RDb21wb25lbnQgPSB7IGNvdW50OiBjb21tb25Db3VudCwgcHJldmlvdXNDb21wb25lbnQ6IGJhc2VQYXRoLmxhc3RDb21wb25lbnQsIGFkZGVkOiBmYWxzZSwgcmVtb3ZlZDogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICBiYXNlUGF0aC5vbGRQb3MgPSBvbGRQb3M7XG4gICAgICAgIHJldHVybiBuZXdQb3M7XG4gICAgfVxuICAgIGVxdWFscyhsZWZ0LCByaWdodCwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5jb21wYXJhdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jb21wYXJhdG9yKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsZWZ0ID09PSByaWdodFxuICAgICAgICAgICAgICAgIHx8ICghIW9wdGlvbnMuaWdub3JlQ2FzZSAmJiBsZWZ0LnRvTG93ZXJDYXNlKCkgPT09IHJpZ2h0LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZUVtcHR5KGFycmF5KSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYXJyYXlbaV0pIHtcbiAgICAgICAgICAgICAgICByZXQucHVzaChhcnJheVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGNhc3RJbnB1dCh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICB0b2tlbml6ZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh2YWx1ZSk7XG4gICAgfVxuICAgIGpvaW4oY2hhcnMpIHtcbiAgICAgICAgLy8gQXNzdW1lcyBWYWx1ZVQgaXMgc3RyaW5nLCB3aGljaCBpcyB0aGUgY2FzZSBmb3IgbW9zdCBzdWJjbGFzc2VzLlxuICAgICAgICAvLyBXaGVuIGl0J3MgZmFsc2UsIGUuZy4gaW4gZGlmZkFycmF5cywgdGhpcyBtZXRob2QgbmVlZHMgdG8gYmUgb3ZlcnJpZGRlbiAoZS5nLiB3aXRoIGEgbm8tb3ApXG4gICAgICAgIC8vIFllcywgdGhlIGNhc3RzIGFyZSB2ZXJib3NlIGFuZCB1Z2x5LCBiZWNhdXNlIHRoaXMgcGF0dGVybiAtIG9mIGhhdmluZyB0aGUgYmFzZSBjbGFzcyBTT1JUIE9GXG4gICAgICAgIC8vIGFzc3VtZSB0b2tlbnMgYW5kIHZhbHVlcyBhcmUgc3RyaW5ncywgYnV0IG5vdCBjb21wbGV0ZWx5IC0gaXMgd2VpcmQgYW5kIGphbmt5LlxuICAgICAgICByZXR1cm4gY2hhcnMuam9pbignJyk7XG4gICAgfVxuICAgIHBvc3RQcm9jZXNzKGNoYW5nZU9iamVjdHMsIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBjaGFuZ2VPYmplY3RzO1xuICAgIH1cbiAgICBnZXQgdXNlTG9uZ2VzdFRva2VuKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGJ1aWxkVmFsdWVzKGxhc3RDb21wb25lbnQsIG5ld1Rva2Vucywgb2xkVG9rZW5zKSB7XG4gICAgICAgIC8vIEZpcnN0IHdlIGNvbnZlcnQgb3VyIGxpbmtlZCBsaXN0IG9mIGNvbXBvbmVudHMgaW4gcmV2ZXJzZSBvcmRlciB0byBhblxuICAgICAgICAvLyBhcnJheSBpbiB0aGUgcmlnaHQgb3JkZXI6XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgbGV0IG5leHRDb21wb25lbnQ7XG4gICAgICAgIHdoaWxlIChsYXN0Q29tcG9uZW50KSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnB1c2gobGFzdENvbXBvbmVudCk7XG4gICAgICAgICAgICBuZXh0Q29tcG9uZW50ID0gbGFzdENvbXBvbmVudC5wcmV2aW91c0NvbXBvbmVudDtcbiAgICAgICAgICAgIGRlbGV0ZSBsYXN0Q29tcG9uZW50LnByZXZpb3VzQ29tcG9uZW50O1xuICAgICAgICAgICAgbGFzdENvbXBvbmVudCA9IG5leHRDb21wb25lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY29tcG9uZW50cy5yZXZlcnNlKCk7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudExlbiA9IGNvbXBvbmVudHMubGVuZ3RoO1xuICAgICAgICBsZXQgY29tcG9uZW50UG9zID0gMCwgbmV3UG9zID0gMCwgb2xkUG9zID0gMDtcbiAgICAgICAgZm9yICg7IGNvbXBvbmVudFBvcyA8IGNvbXBvbmVudExlbjsgY29tcG9uZW50UG9zKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGNvbXBvbmVudHNbY29tcG9uZW50UG9zXTtcbiAgICAgICAgICAgIGlmICghY29tcG9uZW50LnJlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBvbmVudC5hZGRlZCAmJiB0aGlzLnVzZUxvbmdlc3RUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBuZXdUb2tlbnMuc2xpY2UobmV3UG9zLCBuZXdQb3MgKyBjb21wb25lbnQuY291bnQpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLm1hcChmdW5jdGlvbiAodmFsdWUsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZFZhbHVlID0gb2xkVG9rZW5zW29sZFBvcyArIGldO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9sZFZhbHVlLmxlbmd0aCA+IHZhbHVlLmxlbmd0aCA/IG9sZFZhbHVlIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQudmFsdWUgPSB0aGlzLmpvaW4odmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LnZhbHVlID0gdGhpcy5qb2luKG5ld1Rva2Vucy5zbGljZShuZXdQb3MsIG5ld1BvcyArIGNvbXBvbmVudC5jb3VudCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdQb3MgKz0gY29tcG9uZW50LmNvdW50O1xuICAgICAgICAgICAgICAgIC8vIENvbW1vbiBjYXNlXG4gICAgICAgICAgICAgICAgaWYgKCFjb21wb25lbnQuYWRkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkUG9zICs9IGNvbXBvbmVudC5jb3VudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQudmFsdWUgPSB0aGlzLmpvaW4ob2xkVG9rZW5zLnNsaWNlKG9sZFBvcywgb2xkUG9zICsgY29tcG9uZW50LmNvdW50KSk7XG4gICAgICAgICAgICAgICAgb2xkUG9zICs9IGNvbXBvbmVudC5jb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcG9uZW50cztcbiAgICB9XG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGxvbmdlc3RDb21tb25QcmVmaXgoc3RyMSwgc3RyMikge1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdHIxLmxlbmd0aCAmJiBpIDwgc3RyMi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc3RyMVtpXSAhPSBzdHIyW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyMS5zbGljZSgwLCBpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyMS5zbGljZSgwLCBpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBsb25nZXN0Q29tbW9uU3VmZml4KHN0cjEsIHN0cjIpIHtcbiAgICBsZXQgaTtcbiAgICAvLyBVbmxpa2UgbG9uZ2VzdENvbW1vblByZWZpeCwgd2UgbmVlZCBhIHNwZWNpYWwgY2FzZSB0byBoYW5kbGUgYWxsIHNjZW5hcmlvc1xuICAgIC8vIHdoZXJlIHdlIHJldHVybiB0aGUgZW1wdHkgc3RyaW5nIHNpbmNlIHN0cjEuc2xpY2UoLTApIHdpbGwgcmV0dXJuIHRoZVxuICAgIC8vIGVudGlyZSBzdHJpbmcuXG4gICAgaWYgKCFzdHIxIHx8ICFzdHIyIHx8IHN0cjFbc3RyMS5sZW5ndGggLSAxXSAhPSBzdHIyW3N0cjIubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RyMS5sZW5ndGggJiYgaSA8IHN0cjIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHN0cjFbc3RyMS5sZW5ndGggLSAoaSArIDEpXSAhPSBzdHIyW3N0cjIubGVuZ3RoIC0gKGkgKyAxKV0pIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIxLnNsaWNlKC1pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyMS5zbGljZSgtaSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZVByZWZpeChzdHJpbmcsIG9sZFByZWZpeCwgbmV3UHJlZml4KSB7XG4gICAgaWYgKHN0cmluZy5zbGljZSgwLCBvbGRQcmVmaXgubGVuZ3RoKSAhPSBvbGRQcmVmaXgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYHN0cmluZyAke0pTT04uc3RyaW5naWZ5KHN0cmluZyl9IGRvZXNuJ3Qgc3RhcnQgd2l0aCBwcmVmaXggJHtKU09OLnN0cmluZ2lmeShvbGRQcmVmaXgpfTsgdGhpcyBpcyBhIGJ1Z2ApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3UHJlZml4ICsgc3RyaW5nLnNsaWNlKG9sZFByZWZpeC5sZW5ndGgpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlcGxhY2VTdWZmaXgoc3RyaW5nLCBvbGRTdWZmaXgsIG5ld1N1ZmZpeCkge1xuICAgIGlmICghb2xkU3VmZml4KSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcgKyBuZXdTdWZmaXg7XG4gICAgfVxuICAgIGlmIChzdHJpbmcuc2xpY2UoLW9sZFN1ZmZpeC5sZW5ndGgpICE9IG9sZFN1ZmZpeCkge1xuICAgICAgICB0aHJvdyBFcnJvcihgc3RyaW5nICR7SlNPTi5zdHJpbmdpZnkoc3RyaW5nKX0gZG9lc24ndCBlbmQgd2l0aCBzdWZmaXggJHtKU09OLnN0cmluZ2lmeShvbGRTdWZmaXgpfTsgdGhpcyBpcyBhIGJ1Z2ApO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nLnNsaWNlKDAsIC1vbGRTdWZmaXgubGVuZ3RoKSArIG5ld1N1ZmZpeDtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVQcmVmaXgoc3RyaW5nLCBvbGRQcmVmaXgpIHtcbiAgICByZXR1cm4gcmVwbGFjZVByZWZpeChzdHJpbmcsIG9sZFByZWZpeCwgJycpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVN1ZmZpeChzdHJpbmcsIG9sZFN1ZmZpeCkge1xuICAgIHJldHVybiByZXBsYWNlU3VmZml4KHN0cmluZywgb2xkU3VmZml4LCAnJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gbWF4aW11bU92ZXJsYXAoc3RyaW5nMSwgc3RyaW5nMikge1xuICAgIHJldHVybiBzdHJpbmcyLnNsaWNlKDAsIG92ZXJsYXBDb3VudChzdHJpbmcxLCBzdHJpbmcyKSk7XG59XG4vLyBOaWNrZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNjA0MjI4NTMvMTcwOTU4N1xuZnVuY3Rpb24gb3ZlcmxhcENvdW50KGEsIGIpIHtcbiAgICAvLyBEZWFsIHdpdGggY2FzZXMgd2hlcmUgdGhlIHN0cmluZ3MgZGlmZmVyIGluIGxlbmd0aFxuICAgIGxldCBzdGFydEEgPSAwO1xuICAgIGlmIChhLmxlbmd0aCA+IGIubGVuZ3RoKSB7XG4gICAgICAgIHN0YXJ0QSA9IGEubGVuZ3RoIC0gYi5sZW5ndGg7XG4gICAgfVxuICAgIGxldCBlbmRCID0gYi5sZW5ndGg7XG4gICAgaWYgKGEubGVuZ3RoIDwgYi5sZW5ndGgpIHtcbiAgICAgICAgZW5kQiA9IGEubGVuZ3RoO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgYSBiYWNrLXJlZmVyZW5jZSBmb3IgZWFjaCBpbmRleFxuICAgIC8vICAgdGhhdCBzaG91bGQgYmUgZm9sbG93ZWQgaW4gY2FzZSBvZiBhIG1pc21hdGNoLlxuICAgIC8vICAgV2Ugb25seSBuZWVkIEIgdG8gbWFrZSB0aGVzZSByZWZlcmVuY2VzOlxuICAgIGNvbnN0IG1hcCA9IEFycmF5KGVuZEIpO1xuICAgIGxldCBrID0gMDsgLy8gSW5kZXggdGhhdCBsYWdzIGJlaGluZCBqXG4gICAgbWFwWzBdID0gMDtcbiAgICBmb3IgKGxldCBqID0gMTsgaiA8IGVuZEI7IGorKykge1xuICAgICAgICBpZiAoYltqXSA9PSBiW2tdKSB7XG4gICAgICAgICAgICBtYXBbal0gPSBtYXBba107IC8vIHNraXAgb3ZlciB0aGUgc2FtZSBjaGFyYWN0ZXIgKG9wdGlvbmFsIG9wdGltaXNhdGlvbilcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1hcFtqXSA9IGs7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGsgPiAwICYmIGJbal0gIT0gYltrXSkge1xuICAgICAgICAgICAgayA9IG1hcFtrXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYltqXSA9PSBiW2tdKSB7XG4gICAgICAgICAgICBrKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUGhhc2UgMjogdXNlIHRoZXNlIHJlZmVyZW5jZXMgd2hpbGUgaXRlcmF0aW5nIG92ZXIgQVxuICAgIGsgPSAwO1xuICAgIGZvciAobGV0IGkgPSBzdGFydEE7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHdoaWxlIChrID4gMCAmJiBhW2ldICE9IGJba10pIHtcbiAgICAgICAgICAgIGsgPSBtYXBba107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFbaV0gPT0gYltrXSkge1xuICAgICAgICAgICAgaysrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHN0cmluZyBjb25zaXN0ZW50bHkgdXNlcyBXaW5kb3dzIGxpbmUgZW5kaW5ncy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc09ubHlXaW5MaW5lRW5kaW5ncyhzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLmluY2x1ZGVzKCdcXHJcXG4nKSAmJiAhc3RyaW5nLnN0YXJ0c1dpdGgoJ1xcbicpICYmICFzdHJpbmcubWF0Y2goL1teXFxyXVxcbi8pO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHN0cmluZyBjb25zaXN0ZW50bHkgdXNlcyBVbml4IGxpbmUgZW5kaW5ncy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc09ubHlVbml4TGluZUVuZGluZ3Moc3RyaW5nKSB7XG4gICAgcmV0dXJuICFzdHJpbmcuaW5jbHVkZXMoJ1xcclxcbicpICYmIHN0cmluZy5pbmNsdWRlcygnXFxuJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gdHJhaWxpbmdXcyhzdHJpbmcpIHtcbiAgICAvLyBZZXMsIHRoaXMgbG9va3Mgb3ZlcmNvbXBsaWNhdGVkIGFuZCBkdW1iIC0gd2h5IG5vdCByZXBsYWNlIHRoZSB3aG9sZSBmdW5jdGlvbiB3aXRoXG4gICAgLy8gICAgIHJldHVybiBzdHJpbmcgbWF0Y2goL1xccyokLylbMF1cbiAgICAvLyB5b3UgYXNrPyBCZWNhdXNlOlxuICAgIC8vIDEuIHRoZSB0cmFwIGRlc2NyaWJlZCBhdCBodHRwczovL21hcmthbWVyeS5jb20vYmxvZy9xdWFkcmF0aWMtdGltZS1yZWdleGVzLyB3b3VsZCBtZWFuIGRvaW5nXG4gICAgLy8gICAgdGhpcyB3b3VsZCBjYXVzZSB0aGlzIGZ1bmN0aW9uIHRvIHRha2UgTyhuXHUwMEIyKSB0aW1lIGluIHRoZSB3b3JzdCBjYXNlIChzcGVjaWZpY2FsbHkgd2hlblxuICAgIC8vICAgIHRoZXJlIGlzIGEgbWFzc2l2ZSBydW4gb2YgTk9OLVRSQUlMSU5HIHdoaXRlc3BhY2UgaW4gYHN0cmluZ2ApLCBhbmRcbiAgICAvLyAyLiB0aGUgZml4IHByb3Bvc2VkIGluIHRoZSBzYW1lIGJsb2cgcG9zdCwgb2YgdXNpbmcgYSBuZWdhdGl2ZSBsb29rYmVoaW5kLCBpcyBpbmNvbXBhdGlibGVcbiAgICAvLyAgICB3aXRoIG9sZCBTYWZhcmkgdmVyc2lvbnMgdGhhdCB3ZSdkIGxpa2UgdG8gbm90IGJyZWFrIGlmIHBvc3NpYmxlIChzZWVcbiAgICAvLyAgICBodHRwczovL2dpdGh1Yi5jb20va3BkZWNrZXIvanNkaWZmL3B1bGwvNTUwKVxuICAgIC8vIEl0IGZlZWxzIGFic3VyZCB0byBkbyB0aGlzIHdpdGggYW4gZXhwbGljaXQgbG9vcCBpbnN0ZWFkIG9mIGEgcmVnZXgsIGJ1dCBJIHJlYWxseSBjYW4ndCBzZWUgYVxuICAgIC8vIGJldHRlciB3YXkgdGhhdCBkb2Vzbid0IHJlc3VsdCBpbiBicm9rZW4gYmVoYXZpb3VyLlxuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IHN0cmluZy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAoIXN0cmluZ1tpXS5tYXRjaCgvXFxzLykpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHJpbmcuc3Vic3RyaW5nKGkgKyAxKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBsZWFkaW5nV3Moc3RyaW5nKSB7XG4gICAgLy8gVGhhbmtmdWxseSB0aGUgYW5ub3lpbmcgY29uc2lkZXJhdGlvbnMgZGVzY3JpYmVkIGluIHRyYWlsaW5nV3MgZG9uJ3QgYXBwbHkgaGVyZTpcbiAgICBjb25zdCBtYXRjaCA9IHN0cmluZy5tYXRjaCgvXlxccyovKTtcbiAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFswXSA6ICcnO1xufVxuIiwgImltcG9ydCBEaWZmIGZyb20gJy4vYmFzZS5qcyc7XG5pbXBvcnQgeyBsb25nZXN0Q29tbW9uUHJlZml4LCBsb25nZXN0Q29tbW9uU3VmZml4LCByZXBsYWNlUHJlZml4LCByZXBsYWNlU3VmZml4LCByZW1vdmVQcmVmaXgsIHJlbW92ZVN1ZmZpeCwgbWF4aW11bU92ZXJsYXAsIGxlYWRpbmdXcywgdHJhaWxpbmdXcyB9IGZyb20gJy4uL3V0aWwvc3RyaW5nLmpzJztcbi8vIEJhc2VkIG9uIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluX3NjcmlwdF9pbl9Vbmljb2RlXG4vL1xuLy8gUmFuZ2VzIGFuZCBleGNlcHRpb25zOlxuLy8gTGF0aW4tMSBTdXBwbGVtZW50LCAwMDgwXHUyMDEzMDBGRlxuLy8gIC0gVSswMEQ3ICBcdTAwRDcgTXVsdGlwbGljYXRpb24gc2lnblxuLy8gIC0gVSswMEY3ICBcdTAwRjcgRGl2aXNpb24gc2lnblxuLy8gTGF0aW4gRXh0ZW5kZWQtQSwgMDEwMFx1MjAxMzAxN0Zcbi8vIExhdGluIEV4dGVuZGVkLUIsIDAxODBcdTIwMTMwMjRGXG4vLyBJUEEgRXh0ZW5zaW9ucywgMDI1MFx1MjAxMzAyQUZcbi8vIFNwYWNpbmcgTW9kaWZpZXIgTGV0dGVycywgMDJCMFx1MjAxMzAyRkZcbi8vICAtIFUrMDJDNyAgXHUwMkM3ICYjNzExOyAgQ2Fyb25cbi8vICAtIFUrMDJEOCAgXHUwMkQ4ICYjNzI4OyAgQnJldmVcbi8vICAtIFUrMDJEOSAgXHUwMkQ5ICYjNzI5OyAgRG90IEFib3ZlXG4vLyAgLSBVKzAyREEgIFx1MDJEQSAmIzczMDsgIFJpbmcgQWJvdmVcbi8vICAtIFUrMDJEQiAgXHUwMkRCICYjNzMxOyAgT2dvbmVrXG4vLyAgLSBVKzAyREMgIFx1MDJEQyAmIzczMjsgIFNtYWxsIFRpbGRlXG4vLyAgLSBVKzAyREQgIFx1MDJERCAmIzczMzsgIERvdWJsZSBBY3V0ZSBBY2NlbnRcbi8vIExhdGluIEV4dGVuZGVkIEFkZGl0aW9uYWwsIDFFMDBcdTIwMTMxRUZGXG5jb25zdCBleHRlbmRlZFdvcmRDaGFycyA9ICdhLXpBLVowLTlfXFxcXHV7QzB9LVxcXFx1e0ZGfVxcXFx1e0Q4fS1cXFxcdXtGNn1cXFxcdXtGOH0tXFxcXHV7MkM2fVxcXFx1ezJDOH0tXFxcXHV7MkQ3fVxcXFx1ezJERX0tXFxcXHV7MkZGfVxcXFx1ezFFMDB9LVxcXFx1ezFFRkZ9Jztcbi8vIEVhY2ggdG9rZW4gaXMgb25lIG9mIHRoZSBmb2xsb3dpbmc6XG4vLyAtIEEgcHVuY3R1YXRpb24gbWFyayBwbHVzIHRoZSBzdXJyb3VuZGluZyB3aGl0ZXNwYWNlXG4vLyAtIEEgd29yZCBwbHVzIHRoZSBzdXJyb3VuZGluZyB3aGl0ZXNwYWNlXG4vLyAtIFB1cmUgd2hpdGVzcGFjZSAoYnV0IG9ubHkgaW4gdGhlIHNwZWNpYWwgY2FzZSB3aGVyZSB0aGlzIHRoZSBlbnRpcmUgdGV4dFxuLy8gICBpcyBqdXN0IHdoaXRlc3BhY2UpXG4vL1xuLy8gV2UgaGF2ZSB0byBpbmNsdWRlIHN1cnJvdW5kaW5nIHdoaXRlc3BhY2UgaW4gdGhlIHRva2VucyBiZWNhdXNlIHRoZSB0d29cbi8vIGFsdGVybmF0aXZlIGFwcHJvYWNoZXMgcHJvZHVjZSBob3JyaWJseSBicm9rZW4gcmVzdWx0czpcbi8vICogSWYgd2UganVzdCBkaXNjYXJkIHRoZSB3aGl0ZXNwYWNlLCB3ZSBjYW4ndCBmdWxseSByZXByb2R1Y2UgdGhlIG9yaWdpbmFsXG4vLyAgIHRleHQgZnJvbSB0aGUgc2VxdWVuY2Ugb2YgdG9rZW5zIGFuZCBhbnkgYXR0ZW1wdCB0byByZW5kZXIgdGhlIGRpZmYgd2lsbFxuLy8gICBnZXQgdGhlIHdoaXRlc3BhY2Ugd3JvbmcuXG4vLyAqIElmIHdlIGhhdmUgc2VwYXJhdGUgdG9rZW5zIGZvciB3aGl0ZXNwYWNlLCB0aGVuIGluIGEgdHlwaWNhbCB0ZXh0IGV2ZXJ5XG4vLyAgIHNlY29uZCB0b2tlbiB3aWxsIGJlIGEgc2luZ2xlIHNwYWNlIGNoYXJhY3Rlci4gQnV0IHRoaXMgb2Z0ZW4gcmVzdWx0cyBpblxuLy8gICB0aGUgb3B0aW1hbCBkaWZmIGJldHdlZW4gdHdvIHRleHRzIGJlaW5nIGEgcGVydmVyc2Ugb25lIHRoYXQgcHJlc2VydmVzXG4vLyAgIHRoZSBzcGFjZXMgYmV0d2VlbiB3b3JkcyBidXQgZGVsZXRlcyBhbmQgcmVpbnNlcnRzIGFjdHVhbCBjb21tb24gd29yZHMuXG4vLyAgIFNlZSBodHRwczovL2dpdGh1Yi5jb20va3BkZWNrZXIvanNkaWZmL2lzc3Vlcy8xNjAjaXNzdWVjb21tZW50LTE4NjYwOTk2NDBcbi8vICAgZm9yIGFuIGV4YW1wbGUuXG4vL1xuLy8gS2VlcGluZyB0aGUgc3Vycm91bmRpbmcgd2hpdGVzcGFjZSBvZiBjb3Vyc2UgaGFzIGltcGxpY2F0aW9ucyBmb3IgLmVxdWFsc1xuLy8gYW5kIC5qb2luLCBub3QganVzdCAudG9rZW5pemUuXG4vLyBUaGlzIHJlZ2V4IGRvZXMgTk9UIGZ1bGx5IGltcGxlbWVudCB0aGUgdG9rZW5pemF0aW9uIHJ1bGVzIGRlc2NyaWJlZCBhYm92ZS5cbi8vIEluc3RlYWQsIGl0IGdpdmVzIHJ1bnMgb2Ygd2hpdGVzcGFjZSB0aGVpciBvd24gXCJ0b2tlblwiLiBUaGUgdG9rZW5pemUgbWV0aG9kXG4vLyB0aGVuIGhhbmRsZXMgc3RpdGNoaW5nIHdoaXRlc3BhY2UgdG9rZW5zIG9udG8gYWRqYWNlbnQgd29yZCBvciBwdW5jdHVhdGlvblxuLy8gdG9rZW5zLlxuY29uc3QgdG9rZW5pemVJbmNsdWRpbmdXaGl0ZXNwYWNlID0gbmV3IFJlZ0V4cChgWyR7ZXh0ZW5kZWRXb3JkQ2hhcnN9XSt8XFxcXHMrfFteJHtleHRlbmRlZFdvcmRDaGFyc31dYCwgJ3VnJyk7XG5jbGFzcyBXb3JkRGlmZiBleHRlbmRzIERpZmYge1xuICAgIGVxdWFscyhsZWZ0LCByaWdodCwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5pZ25vcmVDYXNlKSB7XG4gICAgICAgICAgICBsZWZ0ID0gbGVmdC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgcmlnaHQgPSByaWdodC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZWZ0LnRyaW0oKSA9PT0gcmlnaHQudHJpbSgpO1xuICAgIH1cbiAgICB0b2tlbml6ZSh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCBwYXJ0cztcbiAgICAgICAgaWYgKG9wdGlvbnMuaW50bFNlZ21lbnRlcikge1xuICAgICAgICAgICAgY29uc3Qgc2VnbWVudGVyID0gb3B0aW9ucy5pbnRsU2VnbWVudGVyO1xuICAgICAgICAgICAgaWYgKHNlZ21lbnRlci5yZXNvbHZlZE9wdGlvbnMoKS5ncmFudWxhcml0eSAhPSAnd29yZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzZWdtZW50ZXIgcGFzc2VkIG11c3QgaGF2ZSBhIGdyYW51bGFyaXR5IG9mIFwid29yZFwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJ0cyA9IEFycmF5LmZyb20oc2VnbWVudGVyLnNlZ21lbnQodmFsdWUpLCBzZWdtZW50ID0+IHNlZ21lbnQuc2VnbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJ0cyA9IHZhbHVlLm1hdGNoKHRva2VuaXplSW5jbHVkaW5nV2hpdGVzcGFjZSkgfHwgW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9rZW5zID0gW107XG4gICAgICAgIGxldCBwcmV2UGFydCA9IG51bGw7XG4gICAgICAgIHBhcnRzLmZvckVhY2gocGFydCA9PiB7XG4gICAgICAgICAgICBpZiAoKC9cXHMvKS50ZXN0KHBhcnQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZQYXJ0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2gocGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbnMucG9wKCkgKyBwYXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcmV2UGFydCAhPSBudWxsICYmICgvXFxzLykudGVzdChwcmV2UGFydCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXSA9PSBwcmV2UGFydCkge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbnMucG9wKCkgKyBwYXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHByZXZQYXJ0ICsgcGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2gocGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2UGFydCA9IHBhcnQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cbiAgICBqb2luKHRva2Vucykge1xuICAgICAgICAvLyBUb2tlbnMgYmVpbmcgam9pbmVkIGhlcmUgd2lsbCBhbHdheXMgaGF2ZSBhcHBlYXJlZCBjb25zZWN1dGl2ZWx5IGluIHRoZVxuICAgICAgICAvLyBzYW1lIHRleHQsIHNvIHdlIGNhbiBzaW1wbHkgc3RyaXAgb2ZmIHRoZSBsZWFkaW5nIHdoaXRlc3BhY2UgZnJvbSBhbGwgdGhlXG4gICAgICAgIC8vIHRva2VucyBleGNlcHQgdGhlIGZpcnN0IChhbmQgZXhjZXB0IGFueSB3aGl0ZXNwYWNlLW9ubHkgdG9rZW5zIC0gYnV0IHN1Y2hcbiAgICAgICAgLy8gYSB0b2tlbiB3aWxsIGFsd2F5cyBiZSB0aGUgZmlyc3QgYW5kIG9ubHkgdG9rZW4gYW55d2F5KSBhbmQgdGhlbiBqb2luIHRoZW1cbiAgICAgICAgLy8gYW5kIHRoZSB3aGl0ZXNwYWNlIGFyb3VuZCB3b3JkcyBhbmQgcHVuY3R1YXRpb24gd2lsbCBlbmQgdXAgY29ycmVjdC5cbiAgICAgICAgcmV0dXJuIHRva2Vucy5tYXAoKHRva2VuLCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAoaSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuLnJlcGxhY2UoKC9eXFxzKy8pLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmpvaW4oJycpO1xuICAgIH1cbiAgICBwb3N0UHJvY2VzcyhjaGFuZ2VzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghY2hhbmdlcyB8fCBvcHRpb25zLm9uZUNoYW5nZVBlclRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlcztcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGFzdEtlZXAgPSBudWxsO1xuICAgICAgICAvLyBDaGFuZ2Ugb2JqZWN0cyByZXByZXNlbnRpbmcgYW55IGluc2VydGlvbiBvciBkZWxldGlvbiBzaW5jZSB0aGUgbGFzdFxuICAgICAgICAvLyBcImtlZXBcIiBjaGFuZ2Ugb2JqZWN0LiBUaGVyZSBjYW4gYmUgYXQgbW9zdCBvbmUgb2YgZWFjaC5cbiAgICAgICAgbGV0IGluc2VydGlvbiA9IG51bGw7XG4gICAgICAgIGxldCBkZWxldGlvbiA9IG51bGw7XG4gICAgICAgIGNoYW5nZXMuZm9yRWFjaChjaGFuZ2UgPT4ge1xuICAgICAgICAgICAgaWYgKGNoYW5nZS5hZGRlZCkge1xuICAgICAgICAgICAgICAgIGluc2VydGlvbiA9IGNoYW5nZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYW5nZS5yZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRpb24gPSBjaGFuZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0aW9uIHx8IGRlbGV0aW9uKSB7IC8vIE1heSBiZSBmYWxzZSBhdCBzdGFydCBvZiB0ZXh0XG4gICAgICAgICAgICAgICAgICAgIGRlZHVwZVdoaXRlc3BhY2VJbkNoYW5nZU9iamVjdHMobGFzdEtlZXAsIGRlbGV0aW9uLCBpbnNlcnRpb24sIGNoYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RLZWVwID0gY2hhbmdlO1xuICAgICAgICAgICAgICAgIGluc2VydGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgZGVsZXRpb24gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGluc2VydGlvbiB8fCBkZWxldGlvbikge1xuICAgICAgICAgICAgZGVkdXBlV2hpdGVzcGFjZUluQ2hhbmdlT2JqZWN0cyhsYXN0S2VlcCwgZGVsZXRpb24sIGluc2VydGlvbiwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5nZXM7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IHdvcmREaWZmID0gbmV3IFdvcmREaWZmKCk7XG5leHBvcnQgZnVuY3Rpb24gZGlmZldvcmRzKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKSB7XG4gICAgLy8gVGhpcyBvcHRpb24gaGFzIG5ldmVyIGJlZW4gZG9jdW1lbnRlZCBhbmQgbmV2ZXIgd2lsbCBiZSAoaXQncyBjbGVhcmVyIHRvXG4gICAgLy8ganVzdCBjYWxsIGBkaWZmV29yZHNXaXRoU3BhY2VgIGRpcmVjdGx5IGlmIHlvdSBuZWVkIHRoYXQgYmVoYXZpb3IpLCBidXRcbiAgICAvLyBoYXMgZXhpc3RlZCBpbiBqc2RpZmYgZm9yIGEgbG9uZyB0aW1lLCBzbyB3ZSByZXRhaW4gc3VwcG9ydCBmb3IgaXQgaGVyZVxuICAgIC8vIGZvciB0aGUgc2FrZSBvZiBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5pZ25vcmVXaGl0ZXNwYWNlKSAhPSBudWxsICYmICFvcHRpb25zLmlnbm9yZVdoaXRlc3BhY2UpIHtcbiAgICAgICAgcmV0dXJuIGRpZmZXb3Jkc1dpdGhTcGFjZShvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB3b3JkRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGRlZHVwZVdoaXRlc3BhY2VJbkNoYW5nZU9iamVjdHMoc3RhcnRLZWVwLCBkZWxldGlvbiwgaW5zZXJ0aW9uLCBlbmRLZWVwKSB7XG4gICAgLy8gQmVmb3JlIHJldHVybmluZywgd2UgdGlkeSB1cCB0aGUgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZSBvZiB0aGVcbiAgICAvLyBjaGFuZ2Ugb2JqZWN0cyB0byBlbGltaW5hdGUgY2FzZXMgd2hlcmUgdHJhaWxpbmcgd2hpdGVzcGFjZSBpbiBvbmUgb2JqZWN0XG4gICAgLy8gaXMgcmVwZWF0ZWQgYXMgbGVhZGluZyB3aGl0ZXNwYWNlIGluIHRoZSBuZXh0LlxuICAgIC8vIEJlbG93IGFyZSBleGFtcGxlcyBvZiB0aGUgb3V0Y29tZXMgd2Ugd2FudCBoZXJlIHRvIGV4cGxhaW4gdGhlIGNvZGUuXG4gICAgLy8gST1pbnNlcnQsIEs9a2VlcCwgRD1kZWxldGVcbiAgICAvLyAxLiBkaWZmaW5nICdmb28gYmFyIGJheicgdnMgJ2ZvbyBiYXonXG4gICAgLy8gICAgUHJpb3IgdG8gY2xlYW51cCwgd2UgaGF2ZSBLOidmb28gJyBEOicgYmFyICcgSzonIGJheidcbiAgICAvLyAgICBBZnRlciBjbGVhbnVwLCB3ZSB3YW50OiAgIEs6J2ZvbyAnIEQ6J2JhciAnIEs6J2JheidcbiAgICAvL1xuICAgIC8vIDIuIERpZmZpbmcgJ2ZvbyBiYXIgYmF6JyB2cyAnZm9vIHF1eCBiYXonXG4gICAgLy8gICAgUHJpb3IgdG8gY2xlYW51cCwgd2UgaGF2ZSBLOidmb28gJyBEOicgYmFyICcgSTonIHF1eCAnIEs6JyBiYXonXG4gICAgLy8gICAgQWZ0ZXIgY2xlYW51cCwgd2Ugd2FudCBLOidmb28gJyBEOidiYXInIEk6J3F1eCcgSzonIGJheidcbiAgICAvL1xuICAgIC8vIDMuIERpZmZpbmcgJ2Zvb1xcbmJhciBiYXonIHZzICdmb28gYmF6J1xuICAgIC8vICAgIFByaW9yIHRvIGNsZWFudXAsIHdlIGhhdmUgSzonZm9vICcgRDonXFxuYmFyICcgSzonIGJheidcbiAgICAvLyAgICBBZnRlciBjbGVhbnVwLCB3ZSB3YW50IEsnZm9vJyBEOidcXG5iYXInIEs6JyBiYXonXG4gICAgLy9cbiAgICAvLyA0LiBEaWZmaW5nICdmb28gYmF6JyB2cyAnZm9vXFxuYmFyIGJheidcbiAgICAvLyAgICBQcmlvciB0byBjbGVhbnVwLCB3ZSBoYXZlIEs6J2Zvb1xcbicgSTonXFxuYmFyICcgSzonIGJheidcbiAgICAvLyAgICBBZnRlciBjbGVhbnVwLCB3ZSBpZGVhbGx5IHdhbnQgSydmb28nIEk6J1xcbmJhcicgSzonIGJheidcbiAgICAvLyAgICBidXQgZG9uJ3QgYWN0dWFsbHkgbWFuYWdlIHRoaXMgY3VycmVudGx5ICh0aGUgcHJlLWNsZWFudXAgY2hhbmdlXG4gICAgLy8gICAgb2JqZWN0cyBkb24ndCBjb250YWluIGVub3VnaCBpbmZvcm1hdGlvbiB0byBtYWtlIGl0IHBvc3NpYmxlKS5cbiAgICAvL1xuICAgIC8vIDUuIERpZmZpbmcgJ2ZvbyAgIGJhciBiYXonIHZzICdmb28gIGJheidcbiAgICAvLyAgICBQcmlvciB0byBjbGVhbnVwLCB3ZSBoYXZlIEs6J2ZvbyAgJyBEOicgICBiYXIgJyBLOicgIGJheidcbiAgICAvLyAgICBBZnRlciBjbGVhbnVwLCB3ZSB3YW50IEs6J2ZvbyAgJyBEOicgYmFyICcgSzonYmF6J1xuICAgIC8vXG4gICAgLy8gT3VyIGhhbmRsaW5nIGlzIHVuYXZvaWRhYmx5IGltcGVyZmVjdCBpbiB0aGUgY2FzZSB3aGVyZSB0aGVyZSdzIGEgc2luZ2xlXG4gICAgLy8gaW5kZWwgYmV0d2VlbiBrZWVwcyBhbmQgdGhlIHdoaXRlc3BhY2UgaGFzIGNoYW5nZWQuIEZvciBpbnN0YW5jZSwgY29uc2lkZXJcbiAgICAvLyBkaWZmaW5nICdmb29cXHRiYXJcXG5iYXonIHZzICdmb28gYmF6Jy4gVW5sZXNzIHdlIGNyZWF0ZSBhbiBleHRyYSBjaGFuZ2VcbiAgICAvLyBvYmplY3QgdG8gcmVwcmVzZW50IHRoZSBpbnNlcnRpb24gb2YgdGhlIHNwYWNlIGNoYXJhY3RlciAod2hpY2ggaXNuJ3QgZXZlblxuICAgIC8vIGEgdG9rZW4pLCB3ZSBoYXZlIG5vIHdheSB0byBhdm9pZCBsb3NpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHRleHRzJ1xuICAgIC8vIG9yaWdpbmFsIHdoaXRlc3BhY2UgaW4gdGhlIHJlc3VsdCB3ZSByZXR1cm4uIFN0aWxsLCB3ZSBkbyBvdXIgYmVzdCB0b1xuICAgIC8vIG91dHB1dCBzb21ldGhpbmcgdGhhdCB3aWxsIGxvb2sgc2Vuc2libGUgaWYgd2UgZS5nLiBwcmludCBpdCB3aXRoXG4gICAgLy8gaW5zZXJ0aW9ucyBpbiBncmVlbiBhbmQgZGVsZXRpb25zIGluIHJlZC5cbiAgICAvLyBCZXR3ZWVuIHR3byBcImtlZXBcIiBjaGFuZ2Ugb2JqZWN0cyAob3IgYmVmb3JlIHRoZSBmaXJzdCBvciBhZnRlciB0aGUgbGFzdFxuICAgIC8vIGNoYW5nZSBvYmplY3QpLCB3ZSBjYW4gaGF2ZSBlaXRoZXI6XG4gICAgLy8gKiBBIFwiZGVsZXRlXCIgZm9sbG93ZWQgYnkgYW4gXCJpbnNlcnRcIlxuICAgIC8vICogSnVzdCBhbiBcImluc2VydFwiXG4gICAgLy8gKiBKdXN0IGEgXCJkZWxldGVcIlxuICAgIC8vIFdlIGhhbmRsZSB0aGUgdGhyZWUgY2FzZXMgc2VwYXJhdGVseS5cbiAgICBpZiAoZGVsZXRpb24gJiYgaW5zZXJ0aW9uKSB7XG4gICAgICAgIGNvbnN0IG9sZFdzUHJlZml4ID0gbGVhZGluZ1dzKGRlbGV0aW9uLnZhbHVlKTtcbiAgICAgICAgY29uc3Qgb2xkV3NTdWZmaXggPSB0cmFpbGluZ1dzKGRlbGV0aW9uLnZhbHVlKTtcbiAgICAgICAgY29uc3QgbmV3V3NQcmVmaXggPSBsZWFkaW5nV3MoaW5zZXJ0aW9uLnZhbHVlKTtcbiAgICAgICAgY29uc3QgbmV3V3NTdWZmaXggPSB0cmFpbGluZ1dzKGluc2VydGlvbi52YWx1ZSk7XG4gICAgICAgIGlmIChzdGFydEtlZXApIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbW1vbldzUHJlZml4ID0gbG9uZ2VzdENvbW1vblByZWZpeChvbGRXc1ByZWZpeCwgbmV3V3NQcmVmaXgpO1xuICAgICAgICAgICAgc3RhcnRLZWVwLnZhbHVlID0gcmVwbGFjZVN1ZmZpeChzdGFydEtlZXAudmFsdWUsIG5ld1dzUHJlZml4LCBjb21tb25Xc1ByZWZpeCk7XG4gICAgICAgICAgICBkZWxldGlvbi52YWx1ZSA9IHJlbW92ZVByZWZpeChkZWxldGlvbi52YWx1ZSwgY29tbW9uV3NQcmVmaXgpO1xuICAgICAgICAgICAgaW5zZXJ0aW9uLnZhbHVlID0gcmVtb3ZlUHJlZml4KGluc2VydGlvbi52YWx1ZSwgY29tbW9uV3NQcmVmaXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmRLZWVwKSB7XG4gICAgICAgICAgICBjb25zdCBjb21tb25Xc1N1ZmZpeCA9IGxvbmdlc3RDb21tb25TdWZmaXgob2xkV3NTdWZmaXgsIG5ld1dzU3VmZml4KTtcbiAgICAgICAgICAgIGVuZEtlZXAudmFsdWUgPSByZXBsYWNlUHJlZml4KGVuZEtlZXAudmFsdWUsIG5ld1dzU3VmZml4LCBjb21tb25Xc1N1ZmZpeCk7XG4gICAgICAgICAgICBkZWxldGlvbi52YWx1ZSA9IHJlbW92ZVN1ZmZpeChkZWxldGlvbi52YWx1ZSwgY29tbW9uV3NTdWZmaXgpO1xuICAgICAgICAgICAgaW5zZXJ0aW9uLnZhbHVlID0gcmVtb3ZlU3VmZml4KGluc2VydGlvbi52YWx1ZSwgY29tbW9uV3NTdWZmaXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGluc2VydGlvbikge1xuICAgICAgICAvLyBUaGUgd2hpdGVzcGFjZXMgYWxsIHJlZmxlY3Qgd2hhdCB3YXMgaW4gdGhlIG5ldyB0ZXh0IHJhdGhlciB0aGFuXG4gICAgICAgIC8vIHRoZSBvbGQsIHNvIHdlIGVzc2VudGlhbGx5IGhhdmUgbm8gaW5mb3JtYXRpb24gYWJvdXQgd2hpdGVzcGFjZVxuICAgICAgICAvLyBpbnNlcnRpb24gb3IgZGVsZXRpb24uIFdlIGp1c3Qgd2FudCB0byBkZWR1cGUgdGhlIHdoaXRlc3BhY2UuXG4gICAgICAgIC8vIFdlIGRvIHRoYXQgYnkgaGF2aW5nIGVhY2ggY2hhbmdlIG9iamVjdCBrZWVwIGl0cyB0cmFpbGluZ1xuICAgICAgICAvLyB3aGl0ZXNwYWNlIGFuZCBkZWxldGluZyBkdXBsaWNhdGUgbGVhZGluZyB3aGl0ZXNwYWNlIHdoZXJlXG4gICAgICAgIC8vIHByZXNlbnQuXG4gICAgICAgIGlmIChzdGFydEtlZXApIHtcbiAgICAgICAgICAgIGNvbnN0IHdzID0gbGVhZGluZ1dzKGluc2VydGlvbi52YWx1ZSk7XG4gICAgICAgICAgICBpbnNlcnRpb24udmFsdWUgPSBpbnNlcnRpb24udmFsdWUuc3Vic3RyaW5nKHdzLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZEtlZXApIHtcbiAgICAgICAgICAgIGNvbnN0IHdzID0gbGVhZGluZ1dzKGVuZEtlZXAudmFsdWUpO1xuICAgICAgICAgICAgZW5kS2VlcC52YWx1ZSA9IGVuZEtlZXAudmFsdWUuc3Vic3RyaW5nKHdzLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3RoZXJ3aXNlIHdlJ3ZlIGdvdCBhIGRlbGV0aW9uIGFuZCBubyBpbnNlcnRpb25cbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhcnRLZWVwICYmIGVuZEtlZXApIHtcbiAgICAgICAgY29uc3QgbmV3V3NGdWxsID0gbGVhZGluZ1dzKGVuZEtlZXAudmFsdWUpLCBkZWxXc1N0YXJ0ID0gbGVhZGluZ1dzKGRlbGV0aW9uLnZhbHVlKSwgZGVsV3NFbmQgPSB0cmFpbGluZ1dzKGRlbGV0aW9uLnZhbHVlKTtcbiAgICAgICAgLy8gQW55IHdoaXRlc3BhY2UgdGhhdCBjb21lcyBzdHJhaWdodCBhZnRlciBzdGFydEtlZXAgaW4gYm90aCB0aGUgb2xkIGFuZFxuICAgICAgICAvLyBuZXcgdGV4dHMsIGFzc2lnbiB0byBzdGFydEtlZXAgYW5kIHJlbW92ZSBmcm9tIHRoZSBkZWxldGlvbi5cbiAgICAgICAgY29uc3QgbmV3V3NTdGFydCA9IGxvbmdlc3RDb21tb25QcmVmaXgobmV3V3NGdWxsLCBkZWxXc1N0YXJ0KTtcbiAgICAgICAgZGVsZXRpb24udmFsdWUgPSByZW1vdmVQcmVmaXgoZGVsZXRpb24udmFsdWUsIG5ld1dzU3RhcnQpO1xuICAgICAgICAvLyBBbnkgd2hpdGVzcGFjZSB0aGF0IGNvbWVzIHN0cmFpZ2h0IGJlZm9yZSBlbmRLZWVwIGluIGJvdGggdGhlIG9sZCBhbmRcbiAgICAgICAgLy8gbmV3IHRleHRzLCBhbmQgaGFzbid0IGFscmVhZHkgYmVlbiBhc3NpZ25lZCB0byBzdGFydEtlZXAsIGFzc2lnbiB0b1xuICAgICAgICAvLyBlbmRLZWVwIGFuZCByZW1vdmUgZnJvbSB0aGUgZGVsZXRpb24uXG4gICAgICAgIGNvbnN0IG5ld1dzRW5kID0gbG9uZ2VzdENvbW1vblN1ZmZpeChyZW1vdmVQcmVmaXgobmV3V3NGdWxsLCBuZXdXc1N0YXJ0KSwgZGVsV3NFbmQpO1xuICAgICAgICBkZWxldGlvbi52YWx1ZSA9IHJlbW92ZVN1ZmZpeChkZWxldGlvbi52YWx1ZSwgbmV3V3NFbmQpO1xuICAgICAgICBlbmRLZWVwLnZhbHVlID0gcmVwbGFjZVByZWZpeChlbmRLZWVwLnZhbHVlLCBuZXdXc0Z1bGwsIG5ld1dzRW5kKTtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBhbnkgd2hpdGVzcGFjZSBmcm9tIHRoZSBuZXcgdGV4dCB0aGF0IEhBU04nVCBhbHJlYWR5IGJlZW5cbiAgICAgICAgLy8gYXNzaWduZWQsIGFzc2lnbiBpdCB0byB0aGUgc3RhcnQ6XG4gICAgICAgIHN0YXJ0S2VlcC52YWx1ZSA9IHJlcGxhY2VTdWZmaXgoc3RhcnRLZWVwLnZhbHVlLCBuZXdXc0Z1bGwsIG5ld1dzRnVsbC5zbGljZSgwLCBuZXdXc0Z1bGwubGVuZ3RoIC0gbmV3V3NFbmQubGVuZ3RoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVuZEtlZXApIHtcbiAgICAgICAgLy8gV2UgYXJlIGF0IHRoZSBzdGFydCBvZiB0aGUgdGV4dC4gUHJlc2VydmUgYWxsIHRoZSB3aGl0ZXNwYWNlIG9uXG4gICAgICAgIC8vIGVuZEtlZXAsIGFuZCBqdXN0IHJlbW92ZSB3aGl0ZXNwYWNlIGZyb20gdGhlIGVuZCBvZiBkZWxldGlvbiB0byB0aGVcbiAgICAgICAgLy8gZXh0ZW50IHRoYXQgaXQgb3ZlcmxhcHMgd2l0aCB0aGUgc3RhcnQgb2YgZW5kS2VlcC5cbiAgICAgICAgY29uc3QgZW5kS2VlcFdzUHJlZml4ID0gbGVhZGluZ1dzKGVuZEtlZXAudmFsdWUpO1xuICAgICAgICBjb25zdCBkZWxldGlvbldzU3VmZml4ID0gdHJhaWxpbmdXcyhkZWxldGlvbi52YWx1ZSk7XG4gICAgICAgIGNvbnN0IG92ZXJsYXAgPSBtYXhpbXVtT3ZlcmxhcChkZWxldGlvbldzU3VmZml4LCBlbmRLZWVwV3NQcmVmaXgpO1xuICAgICAgICBkZWxldGlvbi52YWx1ZSA9IHJlbW92ZVN1ZmZpeChkZWxldGlvbi52YWx1ZSwgb3ZlcmxhcCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YXJ0S2VlcCkge1xuICAgICAgICAvLyBXZSBhcmUgYXQgdGhlIEVORCBvZiB0aGUgdGV4dC4gUHJlc2VydmUgYWxsIHRoZSB3aGl0ZXNwYWNlIG9uXG4gICAgICAgIC8vIHN0YXJ0S2VlcCwgYW5kIGp1c3QgcmVtb3ZlIHdoaXRlc3BhY2UgZnJvbSB0aGUgc3RhcnQgb2YgZGVsZXRpb24gdG9cbiAgICAgICAgLy8gdGhlIGV4dGVudCB0aGF0IGl0IG92ZXJsYXBzIHdpdGggdGhlIGVuZCBvZiBzdGFydEtlZXAuXG4gICAgICAgIGNvbnN0IHN0YXJ0S2VlcFdzU3VmZml4ID0gdHJhaWxpbmdXcyhzdGFydEtlZXAudmFsdWUpO1xuICAgICAgICBjb25zdCBkZWxldGlvbldzUHJlZml4ID0gbGVhZGluZ1dzKGRlbGV0aW9uLnZhbHVlKTtcbiAgICAgICAgY29uc3Qgb3ZlcmxhcCA9IG1heGltdW1PdmVybGFwKHN0YXJ0S2VlcFdzU3VmZml4LCBkZWxldGlvbldzUHJlZml4KTtcbiAgICAgICAgZGVsZXRpb24udmFsdWUgPSByZW1vdmVQcmVmaXgoZGVsZXRpb24udmFsdWUsIG92ZXJsYXApO1xuICAgIH1cbn1cbmNsYXNzIFdvcmRzV2l0aFNwYWNlRGlmZiBleHRlbmRzIERpZmYge1xuICAgIHRva2VuaXplKHZhbHVlKSB7XG4gICAgICAgIC8vIFNsaWdodGx5IGRpZmZlcmVudCB0byB0aGUgdG9rZW5pemVJbmNsdWRpbmdXaGl0ZXNwYWNlIHJlZ2V4IHVzZWQgYWJvdmUgaW5cbiAgICAgICAgLy8gdGhhdCB0aGlzIG9uZSB0cmVhdHMgZWFjaCBpbmRpdmlkdWFsIG5ld2xpbmUgYXMgYSBkaXN0aW5jdCB0b2tlbnMsIHJhdGhlclxuICAgICAgICAvLyB0aGFuIG1lcmdpbmcgdGhlbSBpbnRvIG90aGVyIHN1cnJvdW5kaW5nIHdoaXRlc3BhY2UuIFRoaXMgd2FzIHJlcXVlc3RlZFxuICAgICAgICAvLyBpbiBodHRwczovL2dpdGh1Yi5jb20va3BkZWNrZXIvanNkaWZmL2lzc3Vlcy8xODAgJlxuICAgICAgICAvLyAgICBodHRwczovL2dpdGh1Yi5jb20va3BkZWNrZXIvanNkaWZmL2lzc3Vlcy8yMTFcbiAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKGAoXFxcXHI/XFxcXG4pfFske2V4dGVuZGVkV29yZENoYXJzfV0rfFteXFxcXFNcXFxcblxcXFxyXSt8W14ke2V4dGVuZGVkV29yZENoYXJzfV1gLCAndWcnKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlLm1hdGNoKHJlZ2V4KSB8fCBbXTtcbiAgICB9XG59XG5leHBvcnQgY29uc3Qgd29yZHNXaXRoU3BhY2VEaWZmID0gbmV3IFdvcmRzV2l0aFNwYWNlRGlmZigpO1xuZXhwb3J0IGZ1bmN0aW9uIGRpZmZXb3Jkc1dpdGhTcGFjZShvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucykge1xuICAgIHJldHVybiB3b3Jkc1dpdGhTcGFjZURpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucyk7XG59XG4iLCAiaW1wb3J0IHsgTG9jYWxTdG9yZXMsIFJlcG9zaXRvcnksIFN5bmNTZXR0aW5nIH0gZnJvbSBcIm1haW5cIlxuaW1wb3J0IHsgT2N0b2tpdCB9IGZyb20gXCJAb2N0b2tpdC9jb3JlXCJcbmltcG9ydCB7IFJFQ09HTklaRURfVFhUX0VYVCwgY29tcGFyZVNoYSwgZXh0cmFjdEV4dGVuc2lvbiB9IGZyb20gXCIuL3V0aWxzXCJcbmltcG9ydCB7IFZhdWx0T3BlcmF0aW9ucyB9IGZyb20gXCIuL3ZhdWx0T3BzXCJcbmltcG9ydCB7IExvY2FsQ2hhbmdlLCBMb2NhbEZpbGVTdGF0dXMsIFJlbW90ZUNoYW5nZSwgUmVtb3RlQ2hhbmdlVHlwZSB9IGZyb20gXCIuL2ZpdFR5cGVzXCJcbmltcG9ydCB7IGFycmF5QnVmZmVyVG9CYXNlNjQgfSBmcm9tIFwib2JzaWRpYW5cIlxuaW1wb3J0IHsgY29uZmxpY3RSZXNvbHV0aW9uRm9sZGVyLCByb290Rml0Rm9sZGVyIH0gZnJvbSBcIi4vY29uc3RcIlxuXG50eXBlIEFkZFRvTG9jYWwgPSB7XG4gICAgcGF0aDogc3RyaW5nO1xuICAgIGNvbnRlbnQ6IHN0cmluZztcbn1cblxuXG5leHBvcnQgdHlwZSBUcmVlTm9kZSA9IHtcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgbW9kZTogXCIxMDA2NDRcIiB8IFwiMTAwNzU1XCIgfCBcIjA0MDAwMFwiIHwgXCIxNjAwMDBcIiB8IFwiMTIwMDAwXCIgfCB1bmRlZmluZWQsXG4gICAgdHlwZTogXCJjb21taXRcIiB8IFwiYmxvYlwiIHwgXCJ0cmVlXCIgfCB1bmRlZmluZWQsXG4gICAgc2hhOiBzdHJpbmcgfCBudWxsfVxuXG50eXBlIE9jdG9raXRDYWxsTWV0aG9kcyA9IHtcbiAgICAvLyBnZXRVc2VyOiAoKSA9PiBQcm9taXNlPHtvd25lcjogc3RyaW5nLCBhdmF0YXJVcmw6IHN0cmluZ30+XG4gICAgZ2V0UmVwb3M6ICgpID0+IFByb21pc2U8c3RyaW5nW10+XG4gICAgZ2V0UmVmOiAocmVmOiBzdHJpbmcpID0+IFByb21pc2U8c3RyaW5nPlxuICAgIGdldFRyZWU6ICh0cmVlX3NoYTogc3RyaW5nKSA9PiBQcm9taXNlPFRyZWVOb2RlW10+XG4gICAgZ2V0Q29tbWl0VHJlZVNoYTogKHJlZjogc3RyaW5nKSA9PiBQcm9taXNlPHN0cmluZz5cbiAgICBnZXRSZW1vdGVUcmVlU2hhOiAodHJlZV9zaGE6IHN0cmluZykgPT4gUHJvbWlzZTx7W2s6c3RyaW5nXTogc3RyaW5nfT5cbiAgICBjcmVhdGVCbG9iOiAoY29udGVudDogc3RyaW5nLCBlbmNvZGluZzogc3RyaW5nKSA9PlByb21pc2U8c3RyaW5nPlxuICAgIGNyZWF0ZVRyZWVOb2RlRnJvbUZpbGU6ICh7cGF0aCwgc3RhdHVzLCBleHRlbnNpb259OiBMb2NhbENoYW5nZSwgcmVtb3RlVHJlZTogVHJlZU5vZGVbXSkgPT4gUHJvbWlzZTxUcmVlTm9kZXxudWxsPlxuICAgIGNyZWF0ZUNvbW1pdDogKHRyZWVTaGE6IHN0cmluZywgcGFyZW50U2hhOiBzdHJpbmcpID0+UHJvbWlzZTxzdHJpbmc+XG4gICAgdXBkYXRlUmVmOiAoc2hhOiBzdHJpbmcsIHJlZjogc3RyaW5nKSA9PiBQcm9taXNlPHN0cmluZz5cbiAgICBnZXRCbG9iOiAoZmlsZV9zaGE6c3RyaW5nKSA9PlByb21pc2U8c3RyaW5nPlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElGaXQgZXh0ZW5kcyBPY3Rva2l0Q2FsbE1ldGhvZHN7XG4gICAgb3duZXI6IHN0cmluZ1xuICAgIHJlcG86IHN0cmluZ1xuICAgIGJyYW5jaDogc3RyaW5nXG4gICAgaGVhZGVyczoge1trOiBzdHJpbmddOiBzdHJpbmd9XG4gICAgZGV2aWNlTmFtZTogc3RyaW5nXG4gICAgbG9jYWxTaGE6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgICBsYXN0RmV0Y2hlZENvbW1pdFNoYTogc3RyaW5nIHwgbnVsbFxuICAgIGxhc3RGZXRjaGVkUmVtb3RlU2hhOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gICAgb2N0b2tpdDogT2N0b2tpdFxuICAgIHZhdWx0T3BzOiBWYXVsdE9wZXJhdGlvbnNcbiAgICBmaWxlU2hhMTogKHBhdGg6IHN0cmluZykgPT4gUHJvbWlzZTxzdHJpbmc+XG59XG5cbi8vIERlZmluZSBhIGN1c3RvbSBIdHRwRXJyb3IgY2xhc3MgdGhhdCBleHRlbmRzIEVycm9yXG5leHBvcnQgY2xhc3MgT2N0b2tpdEh0dHBFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBzdGF0dXM6IG51bWJlcjtcbiAgICBzb3VyY2U6IGtleW9mIE9jdG9raXRDYWxsTWV0aG9kc1xuXG4gICAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBzdGF0dXM6IG51bWJlciwgc291cmNlOiBrZXlvZiBPY3Rva2l0Q2FsbE1ldGhvZHMpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdIdHRwRXJyb3InO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2VcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBGaXQgaW1wbGVtZW50cyBJRml0IHtcbiAgICBvd25lcjogc3RyaW5nXG4gICAgcmVwbzogc3RyaW5nXG4gICAgYXV0aDogc3RyaW5nIHwgdW5kZWZpbmVkXG4gICAgYnJhbmNoOiBzdHJpbmdcbiAgICBzeW5jUGF0aDogc3RyaW5nXG4gICAgaGVhZGVyczoge1trOiBzdHJpbmddOiBzdHJpbmd9XG4gICAgZGV2aWNlTmFtZTogc3RyaW5nXG4gICAgbG9jYWxTaGE6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgICBsYXN0RmV0Y2hlZENvbW1pdFNoYTogc3RyaW5nIHwgbnVsbFxuICAgIGxhc3RGZXRjaGVkUmVtb3RlU2hhOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gICAgb2N0b2tpdDogT2N0b2tpdFxuICAgIHZhdWx0T3BzOiBWYXVsdE9wZXJhdGlvbnNcbiAgICBleGNsdWRlczogc3RyaW5nW11cblxuXG4gICAgY29uc3RydWN0b3IocmVwbzogUmVwb3NpdG9yeSwgdmF1bHRPcHM6IFZhdWx0T3BlcmF0aW9ucykge1xuICAgICAgICB0aGlzLmxvYWRTZXR0aW5ncyhyZXBvKVxuICAgICAgICB0aGlzLnZhdWx0T3BzID0gdmF1bHRPcHNcbiAgICAgICAgdGhpcy5oZWFkZXJzID0ge1xuICAgICAgICAgICAgLy8gSGFjayB0byBkaXNhYmxlIGNhY2hpbmcgd2hpY2ggbGVhZHMgdG8gaW5jb25zaXN0ZW5jeSBmb3JcbiAgICAgICAgICAgIC8vIHJlYWQgYWZ0ZXIgd3JpdGUgaHR0cHM6Ly9naXRodWIuY29tL29jdG9raXQvb2N0b2tpdC5qcy9pc3N1ZXMvODkwXG4gICAgICAgICAgICBcIklmLU5vbmUtTWF0Y2hcIjogJycsXG4gICAgICAgICAgICAnWC1HaXRIdWItQXBpLVZlcnNpb24nOiAnMjAyMi0xMS0yOCdcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxvYWRTZXR0aW5ncyhyZXBvOiBSZXBvc2l0b3J5KSB7XG4gICAgICAgIGNvbnN0IHtzZXR0aW5ncywgbG9jYWxTdG9yZX0gPSByZXBvXG4gICAgICAgIHRoaXMucmVwbyA9IHNldHRpbmdzLnJlcG9cbiAgICAgICAgdGhpcy5vd25lciA9IHNldHRpbmdzLm93bmVyXG4gICAgICAgIHRoaXMuYnJhbmNoID0gc2V0dGluZ3MuYnJhbmNoXG4gICAgICAgIHRoaXMuZXhjbHVkZXMgPSBzZXR0aW5ncy5leGNsdWRlc1xuICAgICAgICB0aGlzLnN5bmNQYXRoID0gc2V0dGluZ3Muc3luY1BhdGhcbiAgICAgICAgdGhpcy5kZXZpY2VOYW1lID0gc2V0dGluZ3MuZGV2aWNlTmFtZVxuXG4gICAgICAgIHRoaXMub2N0b2tpdCA9IG5ldyBPY3Rva2l0KHthdXRoOiBzZXR0aW5ncy5wYXR9KVxuXG4gICAgICAgIC8vIFx1MDQyMlx1MDQzMFx1MDQzQVx1MDQzNlx1MDQzNSBcdTA0M0RcdTA0NDNcdTA0MzZcdTA0M0RcdTA0M0UgXHUwNDQxXHUwNDNFXHUwNDQ1XHUwNDQwXHUwNDMwXHUwNDNEXHUwNDM4XHUwNDQyXHUwNDRDIFx1MDQzNFx1MDQ0MFx1MDQ0M1x1MDQzM1x1MDQzOFx1MDQzNSBcdTA0M0ZcdTA0M0VcdTA0M0JcdTA0NEYgXHUwNDM1XHUwNDQxXHUwNDNCXHUwNDM4IFx1MDQzRVx1MDQzRFx1MDQzOCBcdTA0MzhcdTA0NDFcdTA0M0ZcdTA0M0VcdTA0M0JcdTA0NENcdTA0MzdcdTA0NDNcdTA0NEVcdTA0NDJcdTA0NDFcdTA0NEYgXHUwNDMyIFx1MDQzQVx1MDQzQlx1MDQzMFx1MDQ0MVx1MDQ0MVx1MDQzNSBGaXRcbiAgICAgICAgLy8gdGhpcy5wYXQgPSBzZXR0aW5nLnBhdDtcbiAgICAgICAgLy8gdGhpcy5hdmF0YXJVcmwgPSBzZXR0aW5nLmF2YXRhclVybDtcbiAgICAgICAgLy8gdGhpcy5zeW5jUGF0aCA9IHNldHRpbmcuc3luY1BhdGg7XG5cbiAgICAgICAgdGhpcy5sb2NhbFNoYSA9IGxvY2FsU3RvcmUubG9jYWxTaGFcbiAgICAgICAgdGhpcy5sYXN0RmV0Y2hlZENvbW1pdFNoYSA9IGxvY2FsU3RvcmUubGFzdEZldGNoZWRDb21taXRTaGFcbiAgICAgICAgdGhpcy5sYXN0RmV0Y2hlZFJlbW90ZVNoYSA9IGxvY2FsU3RvcmUubGFzdEZldGNoZWRSZW1vdGVTaGFcbiAgICB9XG5cbiAgICBhc3luYyBmaWxlU2hhMShmaWxlQ29udGVudDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3QgZW5jID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICAgIGNvbnN0IGhhc2hCdWYgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmRpZ2VzdCgnU0hBLTEnLCBlbmMuZW5jb2RlKGZpbGVDb250ZW50KSlcbiAgICAgICAgY29uc3QgaGFzaEFycmF5ID0gQXJyYXkuZnJvbShuZXcgVWludDhBcnJheShoYXNoQnVmKSk7XG4gICAgICAgIGNvbnN0IGhhc2hIZXggPSBoYXNoQXJyYXkubWFwKGIgPT4gYi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignJyk7XG4gICAgICAgIHJldHVybiBoYXNoSGV4O1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgY29tcHV0ZUZpbGVMb2NhbFNoYShwYXRoOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZ3xudWxsPiB7XG4gICAgICAgIGNvbnN0IGZ1bGxQYXRoID0gdGhpcy5zeW5jUGF0aCArIHBhdGhcblxuICAgICAgICAvLyBjb21wdXRlIHNoYTEgYmFzZWQgb24gcGF0aCBhbmQgZmlsZSBjb250ZW50XG4gICAgICAgIGxldCBjb250ZW50OiBzdHJpbmc7XG5cbiAgICAgICAgLy8gVE9ETyByZWZhY3RvclxuICAgICAgICAvLyBOb3RlOiBvbmx5IHN1cHBvcnQgVEZpbGUgbm93LCBpbnZlc3RpZ2F0ZSBuZWVkIGZvciBzdXBwb3J0aW5nIFRGb2xkZXIgbGF0ZXIgb25cbiAgICAgICAgY29uc3QgZmlsZSA9IGF3YWl0IHRoaXMudmF1bHRPcHMuZ2V0VEZpbGUoZnVsbFBhdGgpXG4gICAgICAgIGlmIChmaWxlKSB7XG4gICAgICAgICAgICBpZiAoUkVDT0dOSVpFRF9UWFRfRVhULmluY2x1ZGVzKGZpbGUuZXh0ZW5zaW9uKSkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBhd2FpdCB0aGlzLnZhdWx0T3BzLnZhdWx0LnJlYWQoZmlsZSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IGFycmF5QnVmZmVyVG9CYXNlNjQoYXdhaXQgdGhpcy52YXVsdE9wcy52YXVsdC5yZWFkQmluYXJ5KGZpbGUpKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0gZXh0cmFjdEV4dGVuc2lvbihwYXRoKVxuICAgICAgICAgICAgaWYgKCFleHRlbnNpb24gfHwgIVJFQ09HTklaRURfVFhUX0VYVC5pbmNsdWRlcyhleHRlbnNpb24pKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IGFycmF5QnVmZmVyVG9CYXNlNjQoXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudmF1bHRPcHMudmF1bHQuYWRhcHRlci5yZWFkQmluYXJ5KGZ1bGxQYXRoKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IGF3YWl0IHRoaXMudmF1bHRPcHMudmF1bHQuYWRhcHRlci5yZWFkKGZ1bGxQYXRoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZmlsZVNoYTEocGF0aCArIGNvbnRlbnQpXG4gICAgfVxuXG4gICAgYXN5bmMgY29tcHV0ZUxvY2FsU2hhKCk6IFByb21pc2U8e1trOnN0cmluZ106c3RyaW5nfT4ge1xuICAgICAgICBjb25zdCBhbGxQYXRocyA9IGF3YWl0IHRoaXMudmF1bHRPcHMuZ2V0RmlsZXNJblZhdWx0KClcbiAgICAgICAgY29uc3QgcGF0aHMgPSBbXVxuICAgICAgICBmb3IgKGxldCBwYXRoIG9mIGFsbFBhdGhzKSB7XG4gICAgICAgICAgICAvLyBUT0RPIFx1MDQzRFx1MDQ0M1x1MDQzNlx1MDQzRFx1MDQ0QiBcdTA0M0JcdTA0MzggXHUwNDNDXHUwNDNEXHUwNDM1IFx1MDQ0RFx1MDQ0Mlx1MDQzOCBcdTA0NDRcdTA0MzBcdTA0MzlcdTA0M0JcdTA0NEIgXHUwNDMyIFx1MDQzMVx1MDQ0M1x1MDQzNFx1MDQ0M1x1MDQ0OVx1MDQzNVx1MDQzQz9cbiAgICAgICAgICAgIGxldCBpc0V4Y2x1ZGVkID0gcGF0aC5zdGFydHNXaXRoKHJvb3RGaXRGb2xkZXIpXG4gICAgICAgICAgICAgICAgfHwgIXBhdGguc3RhcnRzV2l0aCh0aGlzLnN5bmNQYXRoKVxuICAgICAgICAgICAgICAgIHx8IHRoaXMuZXhjbHVkZXMuY29udGFpbnMocGF0aClcblxuICAgICAgICAgICAgICAgIHx8IHRoaXMuZXhjbHVkZXMuc29tZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGUgPT4gcGF0aC5zdGFydHNXaXRoKGV4Y2x1ZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgIXRoaXMuc3luY1BhdGguc3RhcnRzV2l0aChleGNsdWRlKSAvLyBOT1RFIGlmIG9uZSBzeW5jUGF0aCBuZXN0ZWQgaW4gYW5vdGhlciBzeW5jUGF0aFxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBwYXRoLnJlcGxhY2UodGhpcy5zeW5jUGF0aCwgXCJcIilcblxuICAgICAgICAgICAgaWYgKCFpc0V4Y2x1ZGVkKVxuICAgICAgICAgICAgICAgIHBhdGhzLnB1c2gocmVzdWx0KVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFzeW5jQ29tcHV0ZSA9IHBhdGhzLm1hcChcbiAgICAgICAgICAgIGFzeW5jIChwYXRoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2hhID0gYXdhaXQgdGhpcy5jb21wdXRlRmlsZUxvY2FsU2hhKHBhdGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtwYXRoLCBzaGFdXG4gICAgICAgICAgICB9XG4gICAgICAgIClcblxuICAgICAgICBjb25zdCBjb21wdXRlZCA9IGF3YWl0IFByb21pc2UuYWxsKGFzeW5jQ29tcHV0ZSlcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gY29tcHV0ZWQuZmlsdGVyKGVsID0+ICEhZWxbMV0pXG5cbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhyZXN1bHQpXG4gICAgfVxuXG4gICAgYXN5bmMgcmVtb3RlVXBkYXRlZCgpOiBQcm9taXNlPHtyZW1vdGVDb21taXRTaGE6IHN0cmluZywgdXBkYXRlZDogYm9vbGVhbn0+IHtcbiAgICAgICAgY29uc3QgcmVtb3RlQ29tbWl0U2hhID0gYXdhaXQgdGhpcy5nZXRSZWYoKVxuICAgICAgICByZXR1cm4ge3JlbW90ZUNvbW1pdFNoYSwgdXBkYXRlZDogcmVtb3RlQ29tbWl0U2hhICE9PSB0aGlzLmxhc3RGZXRjaGVkQ29tbWl0U2hhfVxuICAgIH1cblxuICAgIGFzeW5jIGdldExvY2FsQ2hhbmdlcyhjdXJyZW50TG9jYWxTaGE/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KTogUHJvbWlzZTxMb2NhbENoYW5nZVtdPiB7XG4gICAgICAgIGlmICghY3VycmVudExvY2FsU2hhKSB7XG4gICAgICAgICAgICBjdXJyZW50TG9jYWxTaGEgPSBhd2FpdCB0aGlzLmNvbXB1dGVMb2NhbFNoYSgpXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG9jYWxDaGFuZ2VzID0gY29tcGFyZVNoYShjdXJyZW50TG9jYWxTaGEsIHRoaXMubG9jYWxTaGEsIFwibG9jYWxcIilcbiAgICAgICAgcmV0dXJuIGxvY2FsQ2hhbmdlc1xuICAgIH1cblxuICAgIGFzeW5jIGdldFJlbW90ZUNoYW5nZXMocmVtb3RlVHJlZVNoYToge1trOiBzdHJpbmddOiBzdHJpbmd9KTogUHJvbWlzZTxSZW1vdGVDaGFuZ2VbXT4ge1xuICAgICAgICBjb25zdCByZW1vdGVDaGFuZ2VzID0gY29tcGFyZVNoYShyZW1vdGVUcmVlU2hhLCB0aGlzLmxhc3RGZXRjaGVkUmVtb3RlU2hhLCBcInJlbW90ZVwiKVxuICAgICAgICByZXR1cm4gcmVtb3RlQ2hhbmdlc1xuICAgIH1cblxuICAgIGdldENsYXNoZWRDaGFuZ2VzKGxvY2FsQ2hhbmdlczogTG9jYWxDaGFuZ2VbXSwgcmVtb3RlQ2hhbmdlczpSZW1vdGVDaGFuZ2VbXSk6XG4gICAgICAgIEFycmF5PHtwYXRoOiBzdHJpbmcsIGxvY2FsU3RhdHVzOiBMb2NhbEZpbGVTdGF0dXMsIHJlbW90ZVN0YXR1czogUmVtb3RlQ2hhbmdlVHlwZX0+XG4gICAge1xuICAgICAgICAvLyBUT0RPIGZmZXp0X2NoZWNraW5nIFx1MDQzN1x1MDQzNFx1MDQzNVx1MDQ0MVx1MDQ0QyBcdTA0MzJcdTA0NDBcdTA0M0VcdTA0MzRcdTA0MzUgXHUwNDNEXHUwNDM1XHUwNDQxXHUwNDNFXHUwNDMyXHUwNDNDXHUwNDM1XHUwNDQxXHUwNDQyXHUwNDM4XHUwNDNDXHUwNDRCXHUwNDM1IFx1MDQzOFx1MDQzN1x1MDQzQ1x1MDQzNVx1MDQzRFx1MDQzNVx1MDQzRFx1MDQzOFx1MDQ0RiBcdTA0M0ZcdTA0M0VcdTA0NEZcdTA0MzJcdTA0M0JcdTA0NEZcdTA0NEVcdTA0NDJcdTA0NDFcdTA0NEZcblxuICAgICAgICBjb25zdCBsb2NhbENoYW5nZVBhdGhzID0gbG9jYWxDaGFuZ2VzLm1hcChcbiAgICAgICAgICAgIGMgPT4gYy5wYXRoLnJlcGxhY2UodGhpcy5zeW5jUGF0aCwgJycpXG4gICAgICAgIClcbiAgICAgICAgY29uc3QgcmVtb3RlQ2hhbmdlUGF0aHMgPSByZW1vdGVDaGFuZ2VzLm1hcChjPT5jLnBhdGgpXG5cbiAgICAgICAgY29uc3QgY2xhc2hlZEZpbGVzID0gbG9jYWxDaGFuZ2VQYXRocy5tYXAoXG4gICAgICAgICAgICAocGF0aCwgbG9jYWxJbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbW90ZUluZGV4ID0gcmVtb3RlQ2hhbmdlUGF0aHMuaW5kZXhPZihwYXRoKVxuICAgICAgICAgICAgICAgIGlmIChyZW1vdGVJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtwYXRoLCBsb2NhbEluZGV4LCByZW1vdGVJbmRleH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgKS5maWx0ZXIoQm9vbGVhbikgYXMgQXJyYXk8e3BhdGg6IHN0cmluZywgbG9jYWxJbmRleDogbnVtYmVyLCByZW1vdGVJbmRleDpudW1iZXJ9PlxuXG4gICAgICAgIHJldHVybiBjbGFzaGVkRmlsZXMubWFwKFxuICAgICAgICAgICAgKHtwYXRoLCBsb2NhbEluZGV4LCByZW1vdGVJbmRleH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbFN0YXR1czogbG9jYWxDaGFuZ2VzW2xvY2FsSW5kZXhdLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlU3RhdHVzOiByZW1vdGVDaGFuZ2VzW3JlbW90ZUluZGV4XS5zdGF0dXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgIH1cblxuICAgIGFzeW5jIGdldFJlcG9zKCk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICAgICAgY29uc3QgYWxsUmVwb3M6IHN0cmluZ1tdID0gW107XG4gICAgICAgIGxldCBwYWdlID0gMTtcbiAgICAgICAgY29uc3QgcGVyUGFnZSA9IDEwMDsgLy8gU2V0IHRvIHRoZSBtYXhpbXVtIHZhbHVlIG9mIDEwMFxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgaGFzTW9yZVBhZ2VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHdoaWxlIChoYXNNb3JlUGFnZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHJlc3BvbnNlIH0gPSBhd2FpdCB0aGlzLm9jdG9raXQucmVxdWVzdChcbiAgICAgICAgICAgICAgICAgICAgYEdFVCAvdXNlci9yZXBvc2AsIHtcbiAgICAgICAgICAgICAgICAgICAgYWZmaWxpYXRpb246IFwib3duZXJcIixcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBwZXJfcGFnZTogcGVyUGFnZSwgLy8gTnVtYmVyIG9mIHJlcG9zaXRvcmllcyB0byBpbXBvcnQgcGVyIHBhZ2UgKHVwIHRvIDEwMClcbiAgICAgICAgICAgICAgICAgICAgcGFnZTogcGFnZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGFsbFJlcG9zLnB1c2goLi4ucmVzcG9uc2UubWFwKHIgPT4gci5uYW1lKSk7XG5cbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgeW91IGhhdmUgdGhlIGZvbGxvd2luZyBwYWdlc1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5sZW5ndGggPCBwZXJQYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc01vcmVQYWdlcyA9IGZhbHNlOyAvLyBFeGl0IHdoZW4gdGhlcmUgYXJlIG5vIG1vcmUgcmVwb3NpdG9yaWVzXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcGFnZSsrOyAvLyBHbyB0byB0aGUgbmV4dCBwYWdlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhbGxSZXBvcztcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPY3Rva2l0SHR0cEVycm9yKGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YXR1cywgXCJnZXRSZXBvc1wiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGdldEJyYW5jaGVzKCk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHtkYXRhOiByZXNwb25zZX0gPSBhd2FpdCB0aGlzLm9jdG9raXQucmVxdWVzdChcbiAgICAgICAgICAgICAgICBgR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlc2AsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBvd25lcjogdGhpcy5vd25lcixcbiAgICAgICAgICAgICAgICAgICAgcmVwbzogdGhpcy5yZXBvLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnNcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UubWFwKHIgPT4gci5uYW1lKVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9jdG9raXRIdHRwRXJyb3IoZXJyb3IubWVzc2FnZSwgZXJyb3Iuc3RhdHVzLCBcImdldFJlcG9zXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gR2V0IHRoZSBzaGEgb2YgdGhlIGxhdGVzdCBjb21taXQgaW4gdGhlIGRlZmF1bHQgYnJhbmNoIChzZXQgYnkgdXNlciBpbiBzZXR0aW5nKVxuICAgIGFzeW5jIGdldFJlZihyZWY6IHN0cmluZyA9IGBoZWFkcy8ke3RoaXMuYnJhbmNofWApOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qge2RhdGE6IHJlc3BvbnNlfSA9IGF3YWl0IHRoaXMub2N0b2tpdC5yZXF1ZXN0KFxuICAgICAgICAgICAgICAgIGBHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2dpdC9yZWYve3JlZn1gLCB7XG4gICAgICAgICAgICAgICAgICAgIG93bmVyOiB0aGlzLm93bmVyLFxuICAgICAgICAgICAgICAgICAgICByZXBvOiB0aGlzLnJlcG8sXG4gICAgICAgICAgICAgICAgICAgIHJlZjogcmVmLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnNcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2Uub2JqZWN0LnNoYVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9jdG9raXRIdHRwRXJyb3IoZXJyb3IubWVzc2FnZSwgZXJyb3Iuc3RhdHVzLCBcImdldFJlZlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlZiBDYW4gYmUgYSBjb21taXQgU0hBLCBicmFuY2ggbmFtZSAoaGVhZHMvQlJBTkNIX05BTUUpLCBvciB0YWcgbmFtZSAodGFncy9UQUdfTkFNRSksXG4gICAgLy8gcmVmZXJzIHRvIGh0dHBzOi8vZ2l0LXNjbS5jb20vYm9vay9lbi92Mi9HaXQtSW50ZXJuYWxzLUdpdC1SZWZlcmVuY2VzXG4gICAgYXN5bmMgZ2V0Q29tbWl0VHJlZVNoYShyZWY6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIGNvbnN0IHtkYXRhOiBjb21taXR9ID0gIGF3YWl0IHRoaXMub2N0b2tpdC5yZXF1ZXN0KFxuICAgICAgICAgICAgYEdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29tbWl0cy97cmVmfWAsIHtcbiAgICAgICAgICAgIG93bmVyOiB0aGlzLm93bmVyLFxuICAgICAgICAgICAgcmVwbzogdGhpcy5yZXBvLFxuICAgICAgICAgICAgcmVmLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBjb21taXQuY29tbWl0LnRyZWUuc2hhXG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0VHJlZSh0cmVlX3NoYTogc3RyaW5nKTogUHJvbWlzZTxUcmVlTm9kZVtdPiB7XG4gICAgICAgIGNvbnN0IHsgZGF0YTogdHJlZSB9ID0gIGF3YWl0IHRoaXMub2N0b2tpdC5yZXF1ZXN0KFxuICAgICAgICAgICAgYEdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vZ2l0L3RyZWVzL3t0cmVlX3NoYX1gLCB7XG4gICAgICAgICAgICBvd25lcjogdGhpcy5vd25lcixcbiAgICAgICAgICAgIHJlcG86IHRoaXMucmVwbyxcbiAgICAgICAgICAgIHRyZWVfc2hhLFxuICAgICAgICAgICAgcmVjdXJzaXZlOiAndHJ1ZScsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnNcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIHRyZWUudHJlZSBhcyBUcmVlTm9kZVtdXG4gICAgfVxuXG4gICAgLy8gZ2V0IHRoZSByZW1vdGUgdHJlZSBzaGEgaW4gdGhlIGZvcm1hdCBjb21wYXRpYmxlIHdpdGggbG9jYWwgc3RvcmVcbiAgICBhc3luYyBnZXRSZW1vdGVUcmVlU2hhKHRyZWVfc2hhOiBzdHJpbmcpOiBQcm9taXNlPHtbazpzdHJpbmddOiBzdHJpbmd9PiB7XG4gICAgICAgIGNvbnN0IHJlbW90ZVRyZWUgPSBhd2FpdCB0aGlzLmdldFRyZWUodHJlZV9zaGEpXG4gICAgICAgIGNvbnN0IHJlbW90ZVNoYSA9IE9iamVjdC5mcm9tRW50cmllcyhyZW1vdGVUcmVlLm1hcCgobm9kZTogVHJlZU5vZGUpIDogW3N0cmluZywgc3RyaW5nXSB8IG51bGw9PntcbiAgICAgICAgICAgIC8vIGN1cnJlbnRseSBpZ25vcmluZyBkaXJlY3RvcnkgY2hhbmdlcywgaWYgeW91J2QgbGlrZSB0byB1cGxvYWQgYSBuZXcgZGlyZWN0b3J5LFxuICAgICAgICAgICAgLy8gYSBxdWljayBoYWNrIHdvdWxkIGJlIGNyZWF0aW5nIGFuIGVtcHR5IGZpbGUgaW5zaWRlXG4gICAgICAgICAgICBpZiAobm9kZS50eXBlPT1cImJsb2JcIikge1xuICAgICAgICAgICAgICAgIGlmICghbm9kZS5wYXRoIHx8ICFub2RlLnNoYSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXRoIG9yIHNoYSBub3QgZm91bmQgZm9yIGJsb2Igbm9kZSBpbiByZW1vdGVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBjaGFuZ2VzIGluIHRoZSBfZml0LyBkaXJlY3RvcnlcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5wYXRoLnN0YXJ0c1dpdGgoY29uZmxpY3RSZXNvbHV0aW9uRm9sZGVyKSkge3JldHVybiBudWxsfVxuICAgICAgICAgICAgICAgIHJldHVybiBbbm9kZS5wYXRoLCBub2RlLnNoYV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH0pLmZpbHRlcihCb29sZWFuKSBhcyBbc3RyaW5nLCBzdHJpbmddW10pXG4gICAgICAgIHJldHVybiByZW1vdGVTaGFcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVCbG9iKGNvbnRlbnQ6IHN0cmluZywgZW5jb2Rpbmc6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIGNvbnN0IHtkYXRhOiBibG9ifSA9IGF3YWl0IHRoaXMub2N0b2tpdC5yZXF1ZXN0KFxuICAgICAgICAgICAgYFBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2dpdC9ibG9ic2AsIHtcbiAgICAgICAgICAgIG93bmVyOiB0aGlzLm93bmVyLFxuICAgICAgICAgICAgcmVwbzogdGhpcy5yZXBvLFxuICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgICAgIGVuY29kaW5nLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBibG9iLnNoYVxuICAgIH1cblxuXG4gICAgYXN5bmMgY3JlYXRlVHJlZU5vZGVGcm9tRmlsZSh7cGF0aCwgc3RhdHVzLCBleHRlbnNpb259OiBMb2NhbENoYW5nZSwgcmVtb3RlVHJlZTogQXJyYXk8VHJlZU5vZGU+KTogUHJvbWlzZTxUcmVlTm9kZXxudWxsPiB7XG4gICAgICAgIGlmIChzdGF0dXMgPT09IFwiZGVsZXRlZFwiKSB7XG4gICAgICAgICAgICAvLyBza2lwIGNyZWF0aW5nIGRlbGV0aW9uIG5vZGUgaWYgZmlsZSBub3QgZm91bmQgb24gcmVtb3RlXG4gICAgICAgICAgICBpZiAocmVtb3RlVHJlZS5ldmVyeShub2RlID0+IG5vZGUucGF0aCAhPT0gcGF0aCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgIG1vZGU6ICcxMDA2NDQnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdibG9iJyxcbiAgICAgICAgICAgICAgICBzaGE6IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmdWxsUGF0aCA9IHRoaXMuc3luY1BhdGggKyBwYXRoXG4gICAgICAgIC8vIGNvbnN0IGZpbGUgPSBhd2FpdCB0aGlzLnZhdWx0T3BzLmdldFRGaWxlKHRoaXMuc3luY1BhdGggKyBwYXRoKVxuICAgICAgICAvLyBpZiAoIWZpbGUpXG4gICAgICAgIC8vICAgICByZXR1cm4gbnVsbFxuXG4gICAgICAgIGxldCBlbmNvZGluZzogc3RyaW5nO1xuICAgICAgICBsZXQgY29udGVudDogc3RyaW5nXG4gICAgICAgIC8vIFRPRE8gY2hlY2sgd2hldGhlciBldmVyeSBmaWxlcyBpbmNsdWRpbmcgbWQgY2FuIGJlIHJlYWQgdXNpbmcgcmVhZEJpbmFyeSB0byByZWR1Y2UgY29kZSBjb21wbGV4aXR5XG4gICAgICAgIC8vIFRPRE8gXHUwNDM1XHUwNDQxXHUwNDQyXHUwNDRDIFx1MDQ0NFx1MDQ0M1x1MDQzRFx1MDQzQVx1MDQ0Nlx1MDQzOFx1MDQ0RiwgZ2V0RmlsZUVuY29kaW5nXG4gICAgICAgIGlmIChleHRlbnNpb24gJiYgIVJFQ09HTklaRURfVFhUX0VYVC5pbmNsdWRlcyhleHRlbnNpb24pKSB7XG4gICAgICAgICAgICBlbmNvZGluZyA9IFwiYmFzZTY0XCJcblxuICAgICAgICAgICAgY29uc3QgZmlsZUFycmF5QnVmID0gYXdhaXQgdGhpcy52YXVsdE9wcy52YXVsdC5hZGFwdGVyLnJlYWRCaW5hcnkoZnVsbFBhdGgpXG4gICAgICAgICAgICAvLyBjb25zdCBmaWxlQXJyYXlCdWYgPSBhd2FpdCB0aGlzLnZhdWx0T3BzLnZhdWx0LnJlYWRCaW5hcnkoZmlsZSlcbiAgICAgICAgICAgIGNvbnN0IHVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShmaWxlQXJyYXlCdWYpO1xuICAgICAgICAgICAgbGV0IGJpbmFyeVN0cmluZyA9ICcnO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1aW50OEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYmluYXJ5U3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodWludDhBcnJheVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZW50ID0gYnRvYShiaW5hcnlTdHJpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW5jb2RpbmcgPSAndXRmLTgnXG4gICAgICAgICAgICAvLyBjb250ZW50ID0gYXdhaXQgdGhpcy52YXVsdE9wcy52YXVsdC5yZWFkKGZpbGUpXG4gICAgICAgICAgICBjb250ZW50ID0gYXdhaXQgdGhpcy52YXVsdE9wcy52YXVsdC5hZGFwdGVyLnJlYWQoZnVsbFBhdGgpXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmxvYlNoYSA9IGF3YWl0IHRoaXMuY3JlYXRlQmxvYihjb250ZW50LCBlbmNvZGluZylcbiAgICAgICAgLy8gc2tpcCBjcmVhdGluZyBub2RlIGlmIGZpbGUgZm91bmQgb24gcmVtb3RlIGlzIHRoZSBzYW1lIGFzIHRoZSBjcmVhdGVkIGJsb2JcbiAgICAgICAgaWYgKHJlbW90ZVRyZWUuc29tZShub2RlID0+IG5vZGUucGF0aCA9PT0gcGF0aCAmJiBub2RlLnNoYSA9PT0gYmxvYlNoYSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICBtb2RlOiAnMTAwNjQ0JyxcbiAgICAgICAgICAgIHR5cGU6ICdibG9iJyxcbiAgICAgICAgICAgIHNoYTogYmxvYlNoYSxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZVRyZWUoXG4gICAgICAgIHRyZWVOb2RlczogQXJyYXk8VHJlZU5vZGU+LFxuICAgICAgICBiYXNlX3RyZWVfc2hhOiBzdHJpbmcpOlxuICAgICAgICBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICAgICAgY29uc3Qge2RhdGE6IG5ld1RyZWV9ID0gYXdhaXQgdGhpcy5vY3Rva2l0LnJlcXVlc3QoXG4gICAgICAgICAgICAgICAgYFBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2dpdC90cmVlc2AsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBvd25lcjogdGhpcy5vd25lcixcbiAgICAgICAgICAgICAgICAgICAgcmVwbzogdGhpcy5yZXBvLFxuICAgICAgICAgICAgICAgICAgICB0cmVlOiB0cmVlTm9kZXMsXG4gICAgICAgICAgICAgICAgICAgIGJhc2VfdHJlZTogYmFzZV90cmVlX3NoYSxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuIG5ld1RyZWUuc2hhXG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlQ29tbWl0KHRyZWVTaGE6IHN0cmluZywgcGFyZW50U2hhOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gYENvbW1pdCBmcm9tICR7dGhpcy5kZXZpY2VOYW1lfSBvbiAke25ldyBEYXRlKCkudG9Mb2NhbGVTdHJpbmcoKX1gXG4gICAgICAgIGNvbnN0IHsgZGF0YTogY3JlYXRlZENvbW1pdCB9ID0gYXdhaXQgdGhpcy5vY3Rva2l0LnJlcXVlc3QoXG4gICAgICAgICAgICBgUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vZ2l0L2NvbW1pdHNgICwge1xuICAgICAgICAgICAgb3duZXI6IHRoaXMub3duZXIsXG4gICAgICAgICAgICByZXBvOiB0aGlzLnJlcG8sXG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgdHJlZTogdHJlZVNoYSxcbiAgICAgICAgICAgIHBhcmVudHM6IFtwYXJlbnRTaGFdLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBjcmVhdGVkQ29tbWl0LnNoYVxuICAgIH1cblxuICAgIGFzeW5jIHVwZGF0ZVJlZihzaGE6IHN0cmluZywgcmVmID0gYGhlYWRzLyR7dGhpcy5icmFuY2h9YCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIGNvbnN0IHsgZGF0YTp1cGRhdGVkUmVmIH0gPSBhd2FpdCB0aGlzLm9jdG9raXQucmVxdWVzdChcbiAgICAgICAgICAgIGBQQVRDSCAvcmVwb3Mve293bmVyfS97cmVwb30vZ2l0L3JlZnMve3JlZn1gLCB7XG4gICAgICAgICAgICBvd25lcjogdGhpcy5vd25lcixcbiAgICAgICAgICAgIHJlcG86IHRoaXMucmVwbyxcbiAgICAgICAgICAgIHJlZixcbiAgICAgICAgICAgIHNoYSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVyc1xuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gdXBkYXRlZFJlZi5vYmplY3Quc2hhXG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0QmxvYihmaWxlX3NoYTpzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBjb25zdCB7IGRhdGE6IGJsb2IgfSA9IGF3YWl0IHRoaXMub2N0b2tpdC5yZXF1ZXN0KFxuICAgICAgICAgICAgYEdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vZ2l0L2Jsb2JzL3tmaWxlX3NoYX1gLCB7XG4gICAgICAgICAgICBvd25lcjogdGhpcy5vd25lcixcbiAgICAgICAgICAgIHJlcG86IHRoaXMucmVwbyxcbiAgICAgICAgICAgIGZpbGVfc2hhLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBibG9iLmNvbnRlbnRcbiAgICB9XG5cbiAgICBnZXRBZGRUb0xvY2FsKGFkZFRvTG9jYWxfOiBBZGRUb0xvY2FsW10pOiBBZGRUb0xvY2FsW10ge1xuICAgICAgICBjb25zdCBiYXNlcGF0aCA9IHRoaXMuc3luY1BhdGhcbiAgICAgICAgY29uc3QgYWRkVG9Mb2NhbDogQWRkVG9Mb2NhbFtdID0gc3RydWN0dXJlZENsb25lKGFkZFRvTG9jYWxfKVxuXG4gICAgICAgIHJldHVybiBhZGRUb0xvY2FsLm1hcChcbiAgICAgICAgICAgICh7cGF0aCwgY29udGVudH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBwYXRoOiBiYXNlcGF0aCtwYXRoLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICApXG4gICAgICAgIC5maWx0ZXIoXG4gICAgICAgICAgICBmaWxlID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBleGNsdWRlcyA9IHRoaXMuZXhjbHVkZXNcbiAgICAgICAgICAgICAgICBpZiAoIWV4Y2x1ZGVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhjbHVkZXMuc29tZShcbiAgICAgICAgICAgICAgICAgICAgZXhjbHVkZSA9PiAhZmlsZS5wYXRoLnN0YXJ0c1dpdGgoZXhjbHVkZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IHRoaXMuc3luY1BhdGguc3RhcnRzV2l0aChleGNsdWRlKSAvLyBOT1RFIGlmIG9uZSBzeW5jUGF0aCBuZXN0ZWQgaW4gYW5vdGhlciBzeW5jUGF0aFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgIH1cblxuICAgIGdldERlbGV0ZUZyb21Mb2NhbChkZWxldGVGcm9tTG9jYWxfOiBzdHJpbmdbXSk6IHN0cmluZ1tdIHtcbiAgICAgICAgY29uc3QgYmFzZXBhdGggPSB0aGlzLnN5bmNQYXRoXG4gICAgICAgIGNvbnN0IGRlbGV0ZUZyb21Mb2NhbDogc3RyaW5nW10gPSBzdHJ1Y3R1cmVkQ2xvbmUoZGVsZXRlRnJvbUxvY2FsXylcblxuICAgICAgICByZXR1cm4gZGVsZXRlRnJvbUxvY2FsXG4gICAgICAgICAgICAubWFwKFxuICAgICAgICAgICAgICAgIHBhdGggPT4gYmFzZXBhdGggKyBwYXRoXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuZmlsdGVyKFxuICAgICAgICAgICAgICAgIHBhdGggPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleGNsdWRlcyA9IHRoaXMuZXhjbHVkZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFleGNsdWRlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBleGNsdWRlcy5zb21lKFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhjbHVkZSA9PiAhcGF0aC5zdGFydHNXaXRoKGV4Y2x1ZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgdGhpcy5zeW5jUGF0aC5zdGFydHNXaXRoKGV4Y2x1ZGUpICAvLyBOT1RFIGlmIG9uZSBzeW5jUGF0aCBuZXN0ZWQgaW4gYW5vdGhlciBzeW5jUGF0aFxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgIH1cblxufVxuIiwgImltcG9ydCB7IE5vdGljZSB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgRml0IH0gZnJvbSBcIi4vZml0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpdE5vdGljZSB7XG4gICAgZml0OiBGaXRcbiAgICBtdXRlZDogYm9vbGVhblxuICAgIG5vdGljZTogbnVsbCB8IE5vdGljZVxuICAgIGNsYXNzZXM6IEFycmF5PHN0cmluZz5cblxuICAgIGNvbnN0cnVjdG9yKGFkZENsYXNzZXM6IEFycmF5PHN0cmluZz4gPSBbXSwgaW5pdGlhbE1lc3NhZ2U/OiBzdHJpbmcsIGR1cmF0aW9uID0gMCwgbXV0ZWQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLm11dGVkID0gbXV0ZWRcbiAgICAgICAgdGhpcy5jbGFzc2VzID0gWydmaXQtbm90aWNlJ11cbiAgICAgICAgaWYgKGluaXRpYWxNZXNzYWdlICYmICF0aGlzLm11dGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNob3coaW5pdGlhbE1lc3NhZ2UsIGFkZENsYXNzZXMsIGR1cmF0aW9uKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jbGFzc2VzID0gWy4uLnRoaXMuY2xhc3NlcywgLi4uYWRkQ2xhc3Nlc11cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG11dGUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMubXV0ZWQgPSB0cnVlXG4gICAgICAgIGlmICh0aGlzLm5vdGljZSkge1xuICAgICAgICAgICAgdGhpcy5ub3RpY2UuaGlkZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1bm11dGUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMubXV0ZWQgPSBmYWxzZVxuICAgIH1cblxuICAgIHNob3coaW5pdGlhbE1lc3NhZ2U/OiBzdHJpbmcsIGFkZENsYXNzZXM6IEFycmF5PHN0cmluZz4gPSBbXSwgZHVyYXRpb24gPSAwKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5ub3RpY2UgJiYgIXRoaXMubXV0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAoaW5pdGlhbE1lc3NhZ2UgJiYgaW5pdGlhbE1lc3NhZ2UubGVuZ3RoID4gMCk/IGluaXRpYWxNZXNzYWdlIDogXCIgXCJcbiAgICAgICAgICAgIHRoaXMubm90aWNlID0gbmV3IE5vdGljZShtZXNzYWdlLCBkdXJhdGlvbilcbiAgICAgICAgICAgIHRoaXMubm90aWNlLm5vdGljZUVsLmFkZENsYXNzZXMoWy4uLnRoaXMuY2xhc3NlcywgLi4uYWRkQ2xhc3Nlc10pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVDbGFzc2VzKGFkZENsYXNzZXM6IEFycmF5PHN0cmluZz4gPSBbXSwgcmVtb3ZlQ2xhc3NlczogQXJyYXk8c3RyaW5nPiA9IFtdKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLm11dGVkKSB7cmV0dXJufVxuICAgICAgICB0aGlzLmNsYXNzZXMgPSB0aGlzLmNsYXNzZXMuZmlsdGVyKGMgPT4gIXJlbW92ZUNsYXNzZXMuaW5jbHVkZXMoYykpXG4gICAgICAgIGlmICh0aGlzLm5vdGljZSkge1xuICAgICAgICAgICAgdGhpcy5ub3RpY2Uubm90aWNlRWwucmVtb3ZlQ2xhc3NlcyhyZW1vdmVDbGFzc2VzKVxuICAgICAgICAgICAgdGhpcy5ub3RpY2Uubm90aWNlRWwuYWRkQ2xhc3NlcyhhZGRDbGFzc2VzKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xhc3NlcyA9IFsuLi50aGlzLmNsYXNzZXMsIC4uLmFkZENsYXNzZXNdXG4gICAgfVxuXG4gICAgLy8gYWxsb3dzIGVycm9yIGRpc3BsYXkgdG8gb3ZlcnJpZGUgbXV0ZWRcbiAgICBzZXRNZXNzYWdlKG1lc3NhZ2U6IHN0cmluZywgaXNFcnJvcj86IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgaWYgKGlzRXJyb3IpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5ub3RpY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGljZSA9IG5ldyBOb3RpY2UobWVzc2FnZSwgMClcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGljZS5ub3RpY2VFbC5hZGRDbGFzc2VzKFsnZml0LW5vdGljZScsICdlcnJvciddKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGljZS5zZXRNZXNzYWdlKG1lc3NhZ2UpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ub3RpY2UgJiYgIXRoaXMubXV0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGljZS5zZXRNZXNzYWdlKG1lc3NhZ2UpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW1vdmUoZmluYWxDbGFzcz86IHN0cmluZywgZHVyYXRpb24gPSA1MDAwKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLm11dGVkKSB7cmV0dXJufVxuICAgICAgICB0aGlzLm5vdGljZT8ubm90aWNlRWwucmVtb3ZlQ2xhc3Nlcyh0aGlzLmNsYXNzZXMuZmlsdGVyKGMgPT4gYyAhPT0gXCJmaXQtbm90aWNlXCIpKVxuICAgICAgICBpZiAoZmluYWxDbGFzcykge1xuICAgICAgICAgICAgdGhpcy5ub3RpY2U/Lm5vdGljZUVsLmFkZENsYXNzKGZpbmFsQ2xhc3MpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5vdGljZT8ubm90aWNlRWwuYWRkQ2xhc3MoXCJkb25lXCIpXG4gICAgICAgIH1cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLm5vdGljZT8uaGlkZSgpLCBkdXJhdGlvbilcbiAgICB9XG5cbn1cbiIsICJpbXBvcnQgRml0UGx1Z2luLCB7IERFRkFVTFRfUkVQT1NJVE9SWSwgU3luY1NldHRpbmcsIERFRkFVTFRfTE9DQUxfU1RPUkUgfSBmcm9tIFwibWFpblwiO1xuaW1wb3J0IHsgQXBwLCBQbHVnaW5TZXR0aW5nVGFiLCBTZXR0aW5nLCBOb3RpY2UgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IGRpZmZlcmVuY2UsIGludGVyc2VjdGlvbiwgc2V0RXF1YWwgfSBmcm9tIFwiLi91dGlsc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaXRTZXR0aW5nVGFiIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XG4gICAgcGx1Z2luOiBGaXRQbHVnaW47XG4gICAgLy8gYXV0aGVudGljYXRpbmc6IGJvb2xlYW47XG4gICAgYXV0aFVzZXJBdmF0YXI6IEhUTUxEaXZFbGVtZW50O1xuICAgIGF1dGhVc2VySGFuZGxlOiBIVE1MU3BhbkVsZW1lbnQ7XG4gICAgLy8gcGF0U2V0dGluZzogU2V0dGluZztcbiAgICAvLyBvd25lclNldHRpbmc6IFNldHRpbmc7XG4gICAgLy8gcmVwb1NldHRpbmc6IFNldHRpbmc7XG4gICAgLy8gYnJhbmNoU2V0dGluZzogU2V0dGluZztcbiAgICAvLyBzeW5jUGF0aFNldHRpbmc6IFNldHRpbmc7XG4gICAgLy8gZXhpc3RpbmdSZXBvczogQXJyYXk8c3RyaW5nPjtcbiAgICAvLyBleGlzdGluZ0JyYW5jaGVzOiBBcnJheTxzdHJpbmc+O1xuICAgIC8vIHJlcG9MaW5rOiBzdHJpbmc7XG4gICAgLy8gc3luY1BhdGg6IHN0cmluZztcbiAgICBjdXJyZW50U3luY0luZGV4OiBudW1iZXIgPSAwO1xuXG4gICAgY29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogRml0UGx1Z2luKSB7XG4gICAgICAgIHN1cGVyKGFwcCwgcGx1Z2luKTtcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG4gICAgICAgIC8vIHRoaXMuY3VycmVudFN5bmNJbmRleCA9IHBsdWdpbi5zZXR0aW5ncy5jdXJyZW50U3luY0luZGV4IHx8IDA7XG4gICAgICAgIC8vIHRoaXMucmVwb0xpbmsgPSB0aGlzLmdldExhdGVzdExpbmsoKTtcbiAgICAgICAgLy8gdGhpcy5hdXRoZW50aWNhdGluZyA9IGZhbHNlO1xuICAgICAgICAvLyB0aGlzLmV4aXN0aW5nUmVwb3MgPSBbXTtcbiAgICAgICAgLy8gdGhpcy5leGlzdGluZ0JyYW5jaGVzID0gW107XG4gICAgfVxuXG4gICAgZ2V0Q3VycmVudFN5bmNTZXR0aW5nKCk6IFN5bmNTZXR0aW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGx1Z2luLnN0b3JhZ2UucmVwb1t0aGlzLmN1cnJlbnRTeW5jSW5kZXhdLnNldHRpbmdzO1xuICAgIH1cblxuICAgIGdldExhdGVzdExpbmsgPSAoKTogc3RyaW5nID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudFNldHRpbmcgPSB0aGlzLmdldEN1cnJlbnRTeW5jU2V0dGluZygpO1xuICAgICAgICBjb25zdCB7b3duZXIsIHJlcG8sIGJyYW5jaH0gPSBjdXJyZW50U2V0dGluZztcbiAgICAgICAgaWYgKG93bmVyLmxlbmd0aCA+IDAgJiYgcmVwby5sZW5ndGggPiAwICYmIGJyYW5jaC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYGh0dHBzOi8vZ2l0aHViLmNvbS8ke293bmVyfS8ke3JlcG99L3RyZWUvJHticmFuY2h9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG5cbiAgICBhc3luYyBnaXRodWJVc2VySW5mb0Jsb2NrKCkge1xuICAgICAgICBjb25zdCB7Y29udGFpbmVyRWx9ID0gdGhpcztcbiAgICAgICAgY29uc3QgY3VycmVudFNldHRpbmcgPSB0aGlzLmdldEN1cnJlbnRTeW5jU2V0dGluZygpO1xuXG4gICAgICAgIGNvbnN0IGFsbEl0ZW1zID0gYXdhaXQgdGhpcy5wbHVnaW4udmF1bHRPcHMuZ2V0QWxsSW5WYXVsdCgpO1xuICAgICAgICBjb25zdCBhbGxQYXRocyA9IFsuLi5hbGxJdGVtcy5mb2xkZXJzLCAuLi5hbGxJdGVtcy5maWxlc107XG4gICAgICAgIGNvbnN0IHtmb2xkZXJzLCBmaWxlc30gPSBhbGxJdGVtc1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKS5zZXRIZWFkaW5nKClcbiAgICAgICAgICAgIC5zZXROYW1lKGBHaXRIdWIgdXNlciBpbmZvIChSZXBvc2l0b3J5ICR7dGhpcy5jdXJyZW50U3luY0luZGV4ICsgMX0pYClcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdHaXRodWIgdXNlcm5hbWUnKVxuICAgICAgICAgICAgLnNldERlc2MoJ0VudGVyIHlvdXIgbmFtZSBvbiBHaXRodWInKVxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdHaXRIdWIgdXNlcm5hbWUnKVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShjdXJyZW50U2V0dGluZy5vd25lcilcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXR0aW5nLm93bmVyID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pKVxuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ0dpdGh1YiBwZXJzb25hbCBhY2Nlc3MgdG9rZW4nKVxuICAgICAgICAgICAgLnNldERlc2MoJ1JlbWVtYmVyIHRvIGdpdmUgaXQgYWNjZXNzIGZvciByZWFkaW5nIGFuZCB3cml0aW5nIHRvIHRoZSBzdG9yYWdlIHJlcG8uJylcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignR2l0SHViIHBlcnNvbmFsIGFjY2VzcyB0b2tlbicpXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKGN1cnJlbnRTZXR0aW5nLnBhdClcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXR0aW5nLnBhdCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIC5hZGRFeHRyYUJ1dHRvbihidXR0b249PmJ1dHRvblxuICAgICAgICAgICAgICAgIC5zZXRJY29uKCdleHRlcm5hbC1saW5rJylcbiAgICAgICAgICAgICAgICAuc2V0VG9vbHRpcChcIkNyZWF0ZSBhIHRva2VuXCIpXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCk9PntcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Lm9wZW4oXCJodHRwczovL2dpdGh1Yi5jb20vc2V0dGluZ3MvdG9rZW5zL25ld1wiLCAnX2JsYW5rJyk7XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ0RldmljZSBuYW1lJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdTaWduIGNvbW1pdCBtZXNzYWdlIHdpdGggdGhpcyBkZXZpY2UgbmFtZS4nKVxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdEZXZpY2UgbmFtZScpXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKGN1cnJlbnRTZXR0aW5nLmRldmljZU5hbWUpXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2V0dGluZy5kZXZpY2VOYW1lID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdSZXBvc2l0b3J5IG5hbWUnKVxuICAgICAgICAgICAgLnNldERlc2MoJ1NlbGVjdCBhIHJlcG8uJylcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignUmVwb3NpdG9yeScpXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKGN1cnJlbnRTZXR0aW5nLnJlcG8pXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2V0dGluZy5yZXBvID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdCcmFuY2ggbmFtZScpXG4gICAgICAgICAgICAuc2V0RGVzYygnU2VsZWN0IGEgYnJhbmNoLicpXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ0JyYW5jaCcpXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKGN1cnJlbnRTZXR0aW5nLmJyYW5jaClcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXR0aW5nLmJyYW5jaCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnU3luYyBwYXRoJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdTZWxlY3QgYSBsb2NhbCBwYXRoIHRvIHN5bmMgd2l0aCB0aGUgcmVwby4gSWYgdGhlIGZpZWxkIGlzIGVtcHR5LCB0aGUgZW50aXJlIHZhdWx0IHdpbGwgYmUgc3luY2VkLicpXG4gICAgICAgICAgICAuYWRkVGV4dChhc3luYyAodGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgIHRleHQuc2V0UGxhY2Vob2xkZXIoJ0VudGVyIGZvbGRlciBwYXRoJylcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKGN1cnJlbnRTZXR0aW5nLnN5bmNQYXRoIHx8ICcnKVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZvbGRlcnMuY29udGFpbnModmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2V0dGluZy5zeW5jUGF0aCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YUxpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkYXRhbGlzdCcpO1xuICAgICAgICAgICAgICAgIGRhdGFMaXN0LmlkID0gYGZvbGRlci1zdWdnZXN0aW9uc2A7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvdGhlclN5bmNQYXRoID0gbmV3IFNldCgpXG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc3RvcmFnZS5yZXBvLmZvckVhY2goXG4gICAgICAgICAgICAgICAgICAgIChlbCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gdGhpcy5jdXJyZW50U3luY0luZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgICAgICAgICAgICAgICAgICBvdGhlclN5bmNQYXRoLmFkZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5zZXR0aW5ncy5zeW5jUGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAgICAgY29uc3QgYWxsRm9sZGVycyA9IG5ldyBTZXQoXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnZhdWx0T3BzLmdldEZvbGRlcnNJblZhdWx0KClcbiAgICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgICBjb25zdCBmb2xkZXJzID0gQXJyYXkuZnJvbShcbiAgICAgICAgICAgICAgICAgICAgZGlmZmVyZW5jZShhbGxGb2xkZXJzLCBvdGhlclN5bmNQYXRoKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpIGluIGZvbGRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9sZGVyID0gZm9sZGVyc1tpXVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb24udmFsdWUgPSBmb2xkZXI7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFMaXN0LmFwcGVuZENoaWxkKG9wdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGV4dC5pbnB1dEVsLnNldEF0dHJpYnV0ZSgnbGlzdCcsIGBmb2xkZXItc3VnZ2VzdGlvbnNgKTtcbiAgICAgICAgICAgICAgICB0ZXh0LmlucHV0RWwucGFyZW50RWxlbWVudD8uYXBwZW5kQ2hpbGQoZGF0YUxpc3QpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZShcIlZpZXcgeW91ciB2YXVsdCBvbiBHaXRIdWJcIilcbiAgICAgICAgICAgIC5hZGRFeHRyYUJ1dHRvbihidXR0b24gPT4gYnV0dG9uXG4gICAgICAgICAgICAgICAgLnNldFRvb2x0aXAoXCJPcGVuIG9uIEdpdEh1YlwiKVxuICAgICAgICAgICAgICAgIC5zZXRJY29uKCdleHRlcm5hbC1saW5rJylcbiAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbmsgPSB0aGlzLmdldExhdGVzdExpbmsoKTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgb3BlbmluZyAke2xpbmt9YCk7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5vcGVuKGxpbmspO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuZGVzY0VsLmFkZENsYXNzKFwibGluay1kZXNjXCIpO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ0V4Y2x1ZGVkIGZpbGVzL2ZvbGRlcnMnKVxuICAgICAgICAgICAgLnNldERlc2MoJ0ZpbGVzIG9yIGZvbGRlcnMgd2l0aGluIHN5bmMgcGF0aCB0aGF0IHdpbGwgbm90IGJlIHN5bmNlZCcpXG4gICAgICAgICAgICAuYWRkQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cbiAgICAgICAgICAgICAgICAuc2V0QnV0dG9uVGV4dCgnQWRkIGV4Y2x1c2lvbicpXG4gICAgICAgICAgICAgICAgLnNldEN0YSgpXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRTZXR0aW5nLmV4Y2x1ZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2V0dGluZy5leGNsdWRlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXR0aW5nLmV4Y2x1ZGVzLnB1c2goJycpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5kaXNwbGF5KCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgIGZvciAobGV0IGluZGV4XyBpbiBjdXJyZW50U2V0dGluZy5leGNsdWRlcykge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBOdW1iZXIoaW5kZXhfKVxuICAgICAgICAgICAgY29uc3QgZXhjbHVkZSA9IGN1cnJlbnRTZXR0aW5nLmV4Y2x1ZGVzW2luZGV4XVxuXG4gICAgICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgICAgICAuc2V0TmFtZShgRXhjbHVzaW9uICR7aW5kZXggKyAxfWApXG4gICAgICAgICAgICAgICAgLy8gLnNldERlc2MoJ1BhdGggcmVsYXRpdmUgdG8gc3luYyBwYXRoJylcbiAgICAgICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dC5zZXRQbGFjZWhvbGRlcigncGF0aC90by9leGNsdWRlJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShleGNsdWRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZm9sZGVycy5jb250YWlucyh2YWx1ZSkgJiYgIWZpbGVzLmNvbnRhaW5zKHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2V0dGluZy5leGNsdWRlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIFx1MDQzOCBcdTA0MzhcdTA0NDFcdTA0M0FcdTA0M0JcdTA0NEVcdTA0NDdcdTA0MzVcdTA0M0RcdTA0MzhcdTA0NEYgXHUwNDNEXHUwNDM1IFx1MDQzNFx1MDQzRVx1MDQzQlx1MDQzNlx1MDQzRFx1MDQ0QiBcdTA0M0ZcdTA0M0VcdTA0MzJcdTA0NDJcdTA0M0VcdTA0NDBcdTA0NEZcdTA0NDJcdTA0NENcdTA0NDFcdTA0NEYsIFx1MDQzRFx1MDQzRSBcdTA0NERcdTA0NDJcdTA0M0UgXHUwNDNGXHUwNDNFXHUwNDQ0XHUwNDM4XHUwNDMzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBcdTA0MTRcdTA0M0VcdTA0MzFcdTA0MzBcdTA0MzJcdTA0M0JcdTA0NEZcdTA0MzVcdTA0M0MgZGF0YWxpc3QgXHUwNDM0XHUwNDNCXHUwNDRGIFx1MDQzMFx1MDQzMlx1MDQ0Mlx1MDQzRVx1MDQzNFx1MDQzRVx1MDQzRlx1MDQzRVx1MDQzQlx1MDQzRFx1MDQzNVx1MDQzRFx1MDQzOFx1MDQ0RlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhTGlzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RhdGFsaXN0Jyk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFMaXN0LmlkID0gYGV4Y2x1ZGUtc3VnZ2VzdGlvbnMtJHtpbmRleH1gO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFx1MDQyNFx1MDQzOFx1MDQzQlx1MDQ0Q1x1MDQ0Mlx1MDQ0MFx1MDQ0M1x1MDQzNVx1MDQzQyBcdTA0M0ZcdTA0NDNcdTA0NDJcdTA0Mzg6IFx1MDQ0Mlx1MDQzRVx1MDQzQlx1MDQ0Q1x1MDQzQVx1MDQzRSBcdTA0NDJcdTA0MzUsIFx1MDQzQVx1MDQzRVx1MDQ0Mlx1MDQzRVx1MDQ0MFx1MDQ0Qlx1MDQzNSBcdTA0M0RcdTA0MzBcdTA0NDVcdTA0M0VcdTA0MzRcdTA0NEZcdTA0NDJcdTA0NDFcdTA0NEYgXHUwNDMyXHUwNDNEXHUwNDQzXHUwNDQyXHUwNDQwXHUwNDM4IHN5bmNQYXRoIChcdTA0MzVcdTA0NDFcdTA0M0JcdTA0MzggXHUwNDNFXHUwNDNEIFx1MDQzN1x1MDQzMFx1MDQzNFx1MDQzMFx1MDQzRClcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZpbHRlcmVkUGF0aHMgPSBhbGxQYXRocztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTZXR0aW5nLnN5bmNQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZFBhdGhzID0gYWxsUGF0aHMuZmlsdGVyKHBhdGggPT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoLnN0YXJ0c1dpdGgoY3VycmVudFNldHRpbmcuc3luY1BhdGggKyAnLycpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9PT0gY3VycmVudFNldHRpbmcuc3luY1BhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZFBhdGhzLmZvckVhY2gocGF0aCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbi52YWx1ZSA9IHBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhTGlzdC5hcHBlbmRDaGlsZChvcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICB0ZXh0LmlucHV0RWwuc2V0QXR0cmlidXRlKCdsaXN0JywgYGV4Y2x1ZGUtc3VnZ2VzdGlvbnMtJHtpbmRleH1gKTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dC5pbnB1dEVsLnBhcmVudEVsZW1lbnQ/LmFwcGVuZENoaWxkKGRhdGFMaXN0KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5hZGRCdXR0b24oYnV0dG9uID0+IGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAuc2V0SWNvbigndHJhc2gnKVxuICAgICAgICAgICAgICAgICAgICAuc2V0VG9vbHRpcCgnUmVtb3ZlIHRoaXMgZXhjbHVzaW9uJylcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFNldHRpbmcuZXhjbHVkZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5kaXNwbGF5KClcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBhc3luYyBnZXRJdGVtc0luU3luY1BhdGgoKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50U2V0dGluZyA9IHRoaXMuZ2V0Q3VycmVudFN5bmNTZXR0aW5nKCk7XG4gICAgICAgIGlmICghY3VycmVudFNldHRpbmcuc3luY1BhdGgpIHJldHVybiBbXTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc3luY1BhdGggPSBjdXJyZW50U2V0dGluZy5zeW5jUGF0aDtcbiAgICAgICAgICAgIGNvbnN0IGFsbEl0ZW1zOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgICAgICAgICBjb25zdCBhbGwgPSBhd2FpdCB0aGlzLnBsdWdpbi52YXVsdE9wcy5nZXRBbGxJblZhdWx0KClcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmlsZSBpbiBhbGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3luY1BhdGggPT0gXCJcIlxuICAgICAgICAgICAgICAgICAgICB8fCBmaWxlLnN0YXJ0c1dpdGgoc3luY1BhdGggKyAnLycpXG4gICAgICAgICAgICAgICAgICAgIHx8IGZpbGUgPT09IHN5bmNQYXRoKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsSXRlbXMucHVzaChmaWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhbGxJdGVtcy5zb3J0KCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZ2V0dGluZyBpdGVtcyBpbiBzeW5jIHBhdGg6XCIsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxvY2FsQ29uZmlnQmxvY2sgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHtjb250YWluZXJFbH0gPSB0aGlzO1xuICAgICAgICAvLyBjb25zdCBjdXJyZW50U2V0dGluZyA9IHRoaXMuZ2V0Q3VycmVudFN5bmNTZXR0aW5nKCk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpLnNldEhlYWRpbmcoKS5zZXROYW1lKFwiTG9jYWwgY29uZmlndXJhdGlvbnNcIik7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZShcIkF1dG8gc3luY1wiKVxuICAgICAgICAgICAgLnNldERlc2MoYEF1dG9tYXRpY2FsbHkgc3luYyB5b3VyIHZhdWx0IHdoZW4gcmVtb3RlIGhhcyB1cGRhdGVzLiAoTXV0ZWQ6IHN5bmMgaW4gdGhlIGJhY2tncm91bmQgd2l0aG91dCBkaXNwbGF5aW5nIG5vdGljZXMsIGV4Y2VwdCBmb3IgZmlsZSBjaGFuZ2VzIGFuZCBjb25mbGljdHMgbm90aWNlKWApXG4gICAgICAgICAgICAuYWRkRHJvcGRvd24oZHJvcGRvd24gPT4ge1xuICAgICAgICAgICAgICAgIGRyb3Bkb3duXG4gICAgICAgICAgICAgICAgLmFkZE9wdGlvbignb2ZmJywgJ09mZicpXG4gICAgICAgICAgICAgICAgLmFkZE9wdGlvbignbXV0ZWQnLCAnTXV0ZWQnKVxuICAgICAgICAgICAgICAgIC5hZGRPcHRpb24oJ3JlbWluZCcsICdSZW1pbmQgb25seScpXG4gICAgICAgICAgICAgICAgLmFkZE9wdGlvbignb24nLCAnT24nKVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zdG9yYWdlLmF1dG9TeW5jID8gdGhpcy5wbHVnaW4uc3RvcmFnZS5hdXRvU3luYyA6ICdvZmYnKVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc3RvcmFnZS5hdXRvU3luYyA9IHZhbHVlIGFzIFwib2ZmXCIgfCBcIm11dGVkXCIgfCBcInJlbWluZFwiIHwgXCJvblwiO1xuICAgICAgICAgICAgICAgICAgICBjaGVja0ludGVydmFsU2xpZGVyLnNldHRpbmdFbC5hZGRDbGFzcyh2YWx1ZSA9PT0gXCJvZmZcIiA/IFwiY2xlYXJcIiA6IFwicmVzdG9yZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tJbnRlcnZhbFNsaWRlci5zZXR0aW5nRWwucmVtb3ZlQ2xhc3ModmFsdWUgPT09IFwib2ZmXCIgPyBcInJlc3RvcmVcIiA6IFwiY2xlYXJcIik7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIGNvbnN0IGNoZWNrSW50ZXJ2YWxTbGlkZXIgPSBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdBdXRvIGNoZWNrIGludGVydmFsJylcbiAgICAgICAgICAgIC5zZXREZXNjKGBBdXRvbWF0aWNhbGx5IGNoZWNrIGZvciByZW1vdGUgY2hhbmdlcyBpbiB0aGUgYmFja2dyb3VuZCBldmVyeSAke3RoaXMucGx1Z2luLnN0b3JhZ2UuY2hlY2tFdmVyeVhNaW51dGVzfSBtaW51dGVzLmApXG4gICAgICAgICAgICAuYWRkU2xpZGVyKHNsaWRlciA9PiBzbGlkZXJcbiAgICAgICAgICAgICAgICAuc2V0TGltaXRzKDEsIDYwLCAxKVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zdG9yYWdlLmNoZWNrRXZlcnlYTWludXRlcylcbiAgICAgICAgICAgICAgICAuc2V0RHluYW1pY1Rvb2x0aXAoKVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc3RvcmFnZS5jaGVja0V2ZXJ5WE1pbnV0ZXMgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrSW50ZXJ2YWxTbGlkZXIuc2V0RGVzYyhgQXV0b21hdGljYWxseSBjaGVjayBmb3IgcmVtb3RlIGNoYW5nZXMgaW4gdGhlIGJhY2tncm91bmQgZXZlcnkgJHt2YWx1ZX0gbWludXRlcy5gKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApXG5cbiAgICAgICAgaWYgKHRoaXMucGx1Z2luLnN0b3JhZ2UuYXV0b1N5bmMgPT09IFwib2ZmXCIpIHtcbiAgICAgICAgICAgIGNoZWNrSW50ZXJ2YWxTbGlkZXIuc2V0dGluZ0VsLmFkZENsYXNzKFwiY2xlYXJcIilcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5vdGljZUNvbmZpZ0Jsb2NrID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB7Y29udGFpbmVyRWx9ID0gdGhpcztcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRDb2wgPSBcInZhcigtLWludGVyYWN0aXZlLWFjY2VudClcIjtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRUeHRDb2wgPSBcInZhcigtLXRleHQtb24tYWNjZW50KVwiO1xuICAgICAgICBjb25zdCB1bnNlbGVjdGVkQ29sb3IgPSBcInZhcigtLWludGVyYWN0aXZlLW5vcm1hbClcIjtcbiAgICAgICAgY29uc3QgdW5zZWxlY3RlZFR4dENvbCA9IFwidmFyKC0tdGV4dC1ub3JtYWwpXCI7XG4gICAgICAgIGNvbnN0IHN0YXRlVGV4dE1hcCA9IChub3RpZnlDb25mbGljdHM6IGJvb2xlYW4sIG5vdGlmeUNoYW5nZXM6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgICAgIGlmIChub3RpZnlDb25mbGljdHMgJiYgbm90aWZ5Q2hhbmdlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIkRpc3BsYXlpbmcgZmlsZSBjaGFuZ2VzIGFuZCBjb25mbGljdHMgXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFub3RpZnlDb25mbGljdHMgJiYgbm90aWZ5Q2hhbmdlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIkRpc3BsYXlpbmcgZmlsZSBjaGFuZ2VzIFwiO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChub3RpZnlDb25mbGljdHMgJiYgIW5vdGlmeUNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJEaXNwbGF5aW5nIGNoYW5nZSBjb25mbGljdHMgXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIk5vIG5vdGljZSBkaXNwbGF5ZWQgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG5vdGljZURpc3BsYXkgPSBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKFwiTm90aWNlIGRpc3BsYXlcIilcbiAgICAgICAgICAgIC5zZXREZXNjKGAke3N0YXRlVGV4dE1hcCh0aGlzLnBsdWdpbi5zdG9yYWdlLm5vdGlmeUNvbmZsaWN0cywgdGhpcy5wbHVnaW4uc3RvcmFnZS5ub3RpZnlDaGFuZ2VzKX0gYWZ0ZXIgc3luYy5gKVxuICAgICAgICAgICAgLmFkZEJ1dHRvbihidXR0b24gPT4ge1xuICAgICAgICAgICAgICAgIGJ1dHRvbi5zZXRCdXR0b25UZXh0KFwiQ2hhbmdlIGNvbmZsaWN0c1wiKTtcbiAgICAgICAgICAgICAgICBidXR0b24ub25DbGljayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vdGlmeUNvbmZsaWN0cyA9ICF0aGlzLnBsdWdpbi5zdG9yYWdlLm5vdGlmeUNvbmZsaWN0cztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc3RvcmFnZS5ub3RpZnlDb25mbGljdHMgPSBub3RpZnlDb25mbGljdHM7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICBidXR0b24uYnV0dG9uRWwuc2V0Q3NzU3R5bGVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZFwiOiBub3RpZnlDb25mbGljdHMgPyBzZWxlY3RlZENvbCA6IHVuc2VsZWN0ZWRDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiY29sb3JcIjogbm90aWZ5Q29uZmxpY3RzID8gc2VsZWN0ZWRUeHRDb2wgOiB1bnNlbGVjdGVkVHh0Q29sLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgbm90aWNlRGlzcGxheS5zZXREZXNjKGAke3N0YXRlVGV4dE1hcChub3RpZnlDb25mbGljdHMsIHRoaXMucGx1Z2luLnN0b3JhZ2Uubm90aWZ5Q2hhbmdlcyl9IGFmdGVyIHN5bmMuYCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnV0dG9uLmJ1dHRvbkVsLnNldENzc1N0eWxlcyh7XG4gICAgICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZFwiOiB0aGlzLnBsdWdpbi5zdG9yYWdlLm5vdGlmeUNvbmZsaWN0cyA/IHNlbGVjdGVkQ29sIDogdW5zZWxlY3RlZENvbG9yLFxuICAgICAgICAgICAgICAgICAgICBcImNvbG9yXCI6IHRoaXMucGx1Z2luLnN0b3JhZ2Uubm90aWZ5Q29uZmxpY3RzID8gc2VsZWN0ZWRUeHRDb2wgOiB1bnNlbGVjdGVkVHh0Q29sLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5hZGRCdXR0b24oYnV0dG9uID0+IHtcbiAgICAgICAgICAgICAgICBidXR0b24uc2V0QnV0dG9uVGV4dChcIkZpbGUgY2hhbmdlc1wiKTtcbiAgICAgICAgICAgICAgICBidXR0b24ub25DbGljayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vdGlmeUNoYW5nZXMgPSAhdGhpcy5wbHVnaW4uc3RvcmFnZS5ub3RpZnlDaGFuZ2VzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zdG9yYWdlLm5vdGlmeUNoYW5nZXMgPSBub3RpZnlDaGFuZ2VzO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uLmJ1dHRvbkVsLnNldENzc1N0eWxlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImJhY2tncm91bmRcIjogbm90aWZ5Q2hhbmdlcyA/IHNlbGVjdGVkQ29sIDogdW5zZWxlY3RlZENvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJjb2xvclwiOiBub3RpZnlDaGFuZ2VzID8gc2VsZWN0ZWRUeHRDb2wgOiB1bnNlbGVjdGVkVHh0Q29sLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgbm90aWNlRGlzcGxheS5zZXREZXNjKGAke3N0YXRlVGV4dE1hcCh0aGlzLnBsdWdpbi5zdG9yYWdlLm5vdGlmeUNvbmZsaWN0cywgbm90aWZ5Q2hhbmdlcyl9IGFmdGVyIHN5bmMuYCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnV0dG9uLmJ1dHRvbkVsLnNldENzc1N0eWxlcyh7XG4gICAgICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZFwiOiB0aGlzLnBsdWdpbi5zdG9yYWdlLm5vdGlmeUNoYW5nZXMgPyBzZWxlY3RlZENvbCA6IHVuc2VsZWN0ZWRDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgXCJjb2xvclwiOiB0aGlzLnBsdWdpbi5zdG9yYWdlLm5vdGlmeUNoYW5nZXMgPyBzZWxlY3RlZFR4dENvbCA6IHVuc2VsZWN0ZWRUeHRDb2wsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjb3VudGVyUmVwb0Jsb2NrID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB7Y29udGFpbmVyRWx9ID0gdGhpcztcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdNYW5hZ2UgcmVwb3NpdG9yaWVzJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdBZGQgb3IgcmVtb3ZlIHJlcG9zaXRvcnkgY29uZmlndXJhdGlvbnMnKVxuICAgICAgICAgICAgLmFkZEJ1dHRvbihidXR0b24gPT4gYnV0dG9uXG4gICAgICAgICAgICAgICAgLnNldEJ1dHRvblRleHQoJ0FkZCBSZXBvc2l0b3J5JylcbiAgICAgICAgICAgICAgICAuc2V0Q3RhKClcbiAgICAgICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnN0b3JhZ2UucmVwby5wdXNoKERFRkFVTFRfUkVQT1NJVE9SWSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmRpc3BsYXkoKTtcbiAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIC5hZGRCdXR0b24oYnV0dG9uID0+IGJ1dHRvblxuICAgICAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KCdSZW1vdmUgUmVwb3NpdG9yeScpXG4gICAgICAgICAgICAgICAgLnNldFdhcm5pbmcoKVxuICAgICAgICAgICAgICAgIC5zZXREaXNhYmxlZCh0aGlzLnBsdWdpbi5zdG9yYWdlLnJlcG8ubGVuZ3RoIDw9IDEpXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wbHVnaW4uc3RvcmFnZS5yZXBvLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnN0b3JhZ2UucmVwby5zcGxpY2UodGhpcy5jdXJyZW50U3luY0luZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRTeW5jSW5kZXggPj0gdGhpcy5wbHVnaW4uc3RvcmFnZS5yZXBvLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFN5bmNJbmRleCA9IHRoaXMucGx1Z2luLnN0b3JhZ2UucmVwby5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmRpc3BsYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdDdXJyZW50IHJlcG9zaXRvcnknKVxuICAgICAgICAgICAgLnNldERlc2MoJ1NlbGVjdCB3aGljaCByZXBvc2l0b3J5IGNvbmZpZ3VyYXRpb24gdG8gZWRpdCcpXG4gICAgICAgICAgICAuYWRkRHJvcGRvd24oZHJvcGRvd24gPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnN0b3JhZ2UucmVwby5mb3JFYWNoKChfLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBkcm9wZG93bi5hZGRPcHRpb24oaW5kZXgudG9TdHJpbmcoKSwgYFJlcG9zaXRvcnkgJHtpbmRleCArIDF9YCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZHJvcGRvd24uc2V0VmFsdWUodGhpcy5jdXJyZW50U3luY0luZGV4LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIGRyb3Bkb3duLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTeW5jSW5kZXggPSBwYXJzZUludCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmRpc3BsYXkoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlc2V0QmxvY2sgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHtjb250YWluZXJFbH0gPSB0aGlzO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ1Jlc2V0IHNldHRpbmdzJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdSZW1vdmUgU3luYyBzdG9yYWdlIG9yIFNldHRpbmdzJylcbiAgICAgICAgICAgIC5hZGRCdXR0b24oYnV0dG9uID0+IGJ1dHRvblxuICAgICAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KCdSZXNldCBzdG9yYWdlJylcbiAgICAgICAgICAgICAgICAuc2V0V2FybmluZygpXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBzdG9yYWdlIG9mIHRoaXMucGx1Z2luLnN0b3JhZ2UucmVwbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmFnZS5sb2NhbFN0b3JlID0gREVGQVVMVF9MT0NBTF9TVE9SRVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gYWRkIG5vdGljZShcIkRvbmVcIilcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZGlzcGxheSgpO1xuICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgLmFkZEJ1dHRvbihidXR0b24gPT4gYnV0dG9uXG4gICAgICAgICAgICAgICAgLnNldEJ1dHRvblRleHQoJ1Jlc2V0IFNldHRpbmdzJylcbiAgICAgICAgICAgICAgICAuc2V0V2FybmluZygpXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zdG9yYWdlLnJlcG8gPSBbREVGQVVMVF9SRVBPU0lUT1JZXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBhZGQgbm90aWNlKFwiRG9uZVwiKVxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5kaXNwbGF5KCk7XG4gICAgICAgICAgICAgICAgfSkpXG5cbiAgICB9XG5cbiAgICBpbXBvcnRFeHBvcnQoKSB7XG4gICAgICAgIGNvbnN0IHtjb250YWluZXJFbH0gPSB0aGlzO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ0ltcG9ydC9FeHBvcnQgc2V0dGluZ3MnKVxuICAgICAgICAgICAgLnNldERlc2MoJ0JhY2t1cCBvciByZXN0b3JlIHlvdXIgcGx1Z2luIGNvbmZpZ3VyYXRpb24nKVxuICAgICAgICAgICAgLnNldEhlYWRpbmcoKTtcblxuICAgICAgICAvLyBcdTA0MjJcdTA0MzVcdTA0M0FcdTA0NDFcdTA0NDJcdTA0M0VcdTA0MzJcdTA0M0VcdTA0MzUgXHUwNDNGXHUwNDNFXHUwNDNCXHUwNDM1IFx1MDQzNFx1MDQzQlx1MDQ0RiBcdTA0M0VcdTA0NDJcdTA0M0VcdTA0MzFcdTA0NDBcdTA0MzBcdTA0MzZcdTA0MzVcdTA0M0RcdTA0MzhcdTA0NEYvXHUwNDMyXHUwNDMyXHUwNDNFXHUwNDM0XHUwNDMwIFx1MDQzQVx1MDQzRVx1MDQzRFx1MDQ0NFx1MDQzOFx1MDQzM1x1MDQ0M1x1MDQ0MFx1MDQzMFx1MDQ0Nlx1MDQzOFx1MDQzOFxuICAgICAgICBjb25zdCB0ZXh0QXJlYUNvbnRhaW5lciA9IGNvbnRhaW5lckVsLmNyZWF0ZURpdignaW1wb3J0LWV4cG9ydC1jb250YWluZXInKTtcbiAgICAgICAgY29uc3QgdGV4dEFyZWEgPSB0ZXh0QXJlYUNvbnRhaW5lci5jcmVhdGVFbCgndGV4dGFyZWEnLCB7XG4gICAgICAgICAgICBhdHRyOiB7XG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICdDb25maWd1cmF0aW9uIEpTT04gd2lsbCBhcHBlYXIgaGVyZS4uLicsXG4gICAgICAgICAgICAgICAgcm93czogJzEwJyxcbiAgICAgICAgICAgICAgICBzdHlsZTogJ3dpZHRoOiAxMDAlOyBmb250LWZhbWlseTogbW9ub3NwYWNlOydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbHM6ICdpbXBvcnQtZXhwb3J0LXRleHRhcmVhJ1xuICAgICAgICB9KTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5hZGRCdXR0b24oYnV0dG9uID0+IGJ1dHRvblxuICAgICAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KCdFeHBvcnQgdG8gVGV4dCBGaWVsZCcpXG4gICAgICAgICAgICAgICAgLnNldEN0YSgpXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cG9ydFRvVGV4dEZpZWxkKHRleHRBcmVhKTtcbiAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIC5hZGRCdXR0b24oYnV0dG9uID0+IGJ1dHRvblxuICAgICAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KCdJbXBvcnQgZnJvbSBUZXh0IEZpZWxkJylcbiAgICAgICAgICAgICAgICAuc2V0V2FybmluZygpXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmltcG9ydEZyb21UZXh0RmllbGQodGV4dEFyZWEpO1xuICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgLmFkZEJ1dHRvbihidXR0b24gPT4gYnV0dG9uXG4gICAgICAgICAgICAgICAgLnNldEJ1dHRvblRleHQoJ0NsZWFyIEZpZWxkJylcbiAgICAgICAgICAgICAgICAuc2V0SWNvbigndHJhc2gnKVxuICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dEFyZWEudmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBleHBvcnRUb1RleHRGaWVsZCh0ZXh0QXJlYTogSFRNTFRleHRBcmVhRWxlbWVudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0OiBhbnkgPSBzdHJ1Y3R1cmVkQ2xvbmUodGhpcy5wbHVnaW4uc3RvcmFnZSlcbiAgICAgICAgICAgIGZvcihsZXQgaSBpbiByZXN1bHQucmVwbykge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN1bHQucmVwb1tpXS5sb2NhbFN0b3JlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzSnNvbiA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdCwgbnVsbCwgNCk7XG5cbiAgICAgICAgICAgIHRleHRBcmVhLnZhbHVlID0gc2V0dGluZ3NKc29uO1xuICAgICAgICAgICAgdGV4dEFyZWEuZm9jdXMoKTtcbiAgICAgICAgICAgIHRleHRBcmVhLnNlbGVjdCgpO1xuXG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBleHBvcnRpbmcgc2V0dGluZ3M6JywgZXJyb3IpO1xuICAgICAgICAgICAgbmV3IE5vdGljZSgnRXJyb3IgZXhwb3J0aW5nIGNvbmZpZ3VyYXRpb24nLCAzMDAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgaW1wb3J0RnJvbVRleHRGaWVsZCh0ZXh0QXJlYTogSFRNTFRleHRBcmVhRWxlbWVudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QganNvbkNvbnRlbnQgPSB0ZXh0QXJlYS52YWx1ZS50cmltKCk7XG5cbiAgICAgICAgICAgIGlmICghanNvbkNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdUZXh0IGZpZWxkIGlzIGVtcHR5JywgMzAwMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBpbXBvcnRlZFNldHRpbmdzID0gSlNPTi5wYXJzZShqc29uQ29udGVudCk7XG5cbiAgICAgICAgICAgIC8vIFx1MDQxMlx1MDQzMFx1MDQzQlx1MDQzOFx1MDQzNFx1MDQzMFx1MDQ0Nlx1MDQzOFx1MDQ0RiBcdTA0MzhcdTA0M0NcdTA0M0ZcdTA0M0VcdTA0NDBcdTA0NDJcdTA0MzhcdTA0NDBcdTA0M0VcdTA0MzJcdTA0MzBcdTA0M0RcdTA0M0RcdTA0NEJcdTA0NDUgXHUwNDNEXHUwNDMwXHUwNDQxXHUwNDQyXHUwNDQwXHUwNDNFXHUwNDM1XHUwNDNBXG4gICAgICAgICAgICBpZiAodGhpcy52YWxpZGF0ZUltcG9ydGVkU2V0dGluZ3MoaW1wb3J0ZWRTZXR0aW5ncykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCByZXBvIG9mIGltcG9ydGVkU2V0dGluZ3MucmVwbykge1xuICAgICAgICAgICAgICAgICAgICByZXBvLmxvY2FsU3RvcmUgPSBERUZBVUxUX0xPQ0FMX1NUT1JFXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc3RvcmFnZSA9IGltcG9ydGVkU2V0dGluZ3NcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblxuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ1NldHRpbmdzIGltcG9ydGVkIHN1Y2Nlc3NmdWxseSEnLCAzMDAwKTtcblxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZGlzcGxheSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdJbnZhbGlkIHNldHRpbmdzIGZvcm1hdCBpbiB0ZXh0IGZpZWxkJywgNDAwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbXBvcnRpbmcgc2V0dGluZ3MgZnJvbSB0ZXh0IGZpZWxkOicsIGVycm9yKTtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ0Vycm9yIHBhcnNpbmcgSlNPTiBjb25maWd1cmF0aW9uJywgNDAwMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHZhbGlkYXRlSW1wb3J0ZWRTZXR0aW5ncyhzZXR0aW5nczogYW55KTogYm9vbGVhbiB7XG4gICAgICAgIC8vIEJhc2ljIHZhbGlkYXRpb25cbiAgICAgICAgcmV0dXJuIHNldHRpbmdzICYmXG4gICAgICAgICAgICB0eXBlb2Ygc2V0dGluZ3MgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHNldHRpbmdzLnJlcG8pICYmXG4gICAgICAgICAgICBzZXR0aW5ncy5yZXBvLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIHNldHRpbmdzLnJlcG9bMF0uc2V0dGluZ3MgJiZcbiAgICAgICAgICAgIHR5cGVvZiBzZXR0aW5ncy5yZXBvWzBdLnNldHRpbmdzID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgJ3N5bmNQYXRoJyBpbiBzZXR0aW5ncy5yZXBvWzBdLnNldHRpbmdzO1xuICAgIH1cblxuICAgIGFzeW5jIGRpc3BsYXkoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IHtjb250YWluZXJFbH0gPSB0aGlzO1xuXG4gICAgICAgIGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cblxuICAgICAgICB0aGlzLmxvY2FsQ29uZmlnQmxvY2soKTtcbiAgICAgICAgdGhpcy5ub3RpY2VDb25maWdCbG9jaygpO1xuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbCgnaHInKTtcblxuICAgICAgICBhd2FpdCB0aGlzLmltcG9ydEV4cG9ydCgpXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdocicpO1xuXG4gICAgICAgIHRoaXMuY291bnRlclJlcG9CbG9jaygpO1xuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbCgnaHInKTtcblxuICAgICAgICAvLyBUT0RPIFx1MDQzRFx1MDQzMFx1MDQzRlx1MDQzOFx1MDQ0MVx1MDQzMFx1MDQ0Mlx1MDQ0QywgXHUwNDQ3XHUwNDQyXHUwNDNFIFx1MDQ0Mlx1MDQ0M1x1MDQ0MiBcdTA0MzRcdTA0M0JcdTA0NEYgYWxsU2V0dGluZ3MsIFx1MDQzMCBcdTA0M0RcdTA0MzUgXHUwNDNFXHUwNDQyXHUwNDM0XHUwNDM1XHUwNDNCXHUwNDRDXHUwNDNEXHUwNDRCXHUwNDM5IFx1MDQ0MFx1MDQzNVx1MDQzRlx1MDQzRVx1MDQzN1x1MDQzOFx1MDQ0Mlx1MDQzRVx1MDQ0MFx1MDQzOFx1MDQzOVxuICAgICAgICAvLyBUT0RPIGFkZCBwcnVuZSBzZXR0aW5ncyBleGFjdGx5IGZvciBvbmUgcmVwb1xuICAgICAgICB0aGlzLnJlc2V0QmxvY2soKVxuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbCgnaHInKTtcblxuICAgICAgICBhd2FpdCB0aGlzLmdpdGh1YlVzZXJJbmZvQmxvY2soKTtcbiAgICB9XG59XG5cbi8vIGNsYXNzIEZvbGRlclN1Z2dlc3RNb2RhbCBleHRlbmRzIFN1Z2dlc3RNb2RhbDxzdHJpbmc+IHtcbi8vICAgICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcHJpdmF0ZSBmb2xkZXJzOiBzdHJpbmdbXSwgcHJpdmF0ZSBjYWxsYmFjazogKGZvbGRlcjogc3RyaW5nKSA9PiB2b2lkKSB7XG4vLyAgICAgICAgIHN1cGVyKGFwcCk7XG4vLyAgICAgfVxuXG4vLyAgICAgZ2V0U3VnZ2VzdGlvbnMocXVlcnk6IHN0cmluZyk6IHN0cmluZ1tdIHtcbi8vICAgICAgICAgcmV0dXJuIHRoaXMuZm9sZGVycy5maWx0ZXIoZm9sZGVyID0+XG4vLyAgICAgICAgICAgICBmb2xkZXIudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhxdWVyeS50b0xvd2VyQ2FzZSgpKVxuLy8gICAgICAgICApO1xuLy8gICAgIH1cblxuLy8gICAgIHJlbmRlclN1Z2dlc3Rpb24oZm9sZGVyOiBzdHJpbmcsIGVsOiBIVE1MRWxlbWVudCkge1xuLy8gICAgICAgICBlbC5jcmVhdGVFbCgnZGl2JywgeyB0ZXh0OiBmb2xkZXIgfSk7XG4vLyAgICAgfVxuXG4vLyAgICAgb25DaG9vc2VTdWdnZXN0aW9uKGZvbGRlcjogc3RyaW5nLCBldnQ6IE1vdXNlRXZlbnQgfCBLZXlib2FyZEV2ZW50KSB7XG4vLyAgICAgICAgIHRoaXMuY2FsbGJhY2soZm9sZGVyKTtcbi8vICAgICB9XG4vLyB9XG4iLCAiaW1wb3J0IHsgYXJyYXlCdWZmZXJUb0Jhc2U2NCB9IGZyb20gXCJvYnNpZGlhblwiXG5pbXBvcnQgeyBGaXQgfSBmcm9tIFwiLi9maXRcIlxuaW1wb3J0IHsgQ2xhc2hTdGF0dXMsIENvbmZsaWN0UmVwb3J0LCBDb25mbGljdFJlc29sdXRpb25SZXN1bHQsIEZpbGVPcFJlY29yZCwgTG9jYWxDaGFuZ2UsIExvY2FsVXBkYXRlLCBSZW1vdGVDaGFuZ2UsIFJlbW90ZVVwZGF0ZSB9IGZyb20gXCIuL2ZpdFR5cGVzXCJcbmltcG9ydCB7IFJFQ09HTklaRURfVFhUX0VYVCwgZXh0cmFjdEV4dGVuc2lvbiwgcmVtb3ZlTGluZUVuZGluZ3NGcm9tQmFzZTY0U3RyaW5nIH0gZnJvbSBcIi4vdXRpbHNcIlxuaW1wb3J0IHsgRml0UHVsbCB9IGZyb20gXCIuL2ZpdFB1bGxcIlxuaW1wb3J0IHsgRml0UHVzaCB9IGZyb20gXCIuL2ZpdFB1c2hcIlxuaW1wb3J0IHsgVmF1bHRPcGVyYXRpb25zIH0gZnJvbSBcIi4vdmF1bHRPcHNcIlxuaW1wb3J0IHsgTG9jYWxTdG9yZXMgfSBmcm9tIFwibWFpblwiXG5pbXBvcnQgRml0Tm90aWNlIGZyb20gXCIuL2ZpdE5vdGljZVwiXG5pbXBvcnQgeyBjb25mbGljdFJlc29sdXRpb25Gb2xkZXIgfSBmcm9tIFwiLi9jb25zdFwiXG5cbmV4cG9ydCBpbnRlcmZhY2UgSUZpdFN5bmMge1xuICAgIGZpdDogRml0XG59XG5cbmV4cG9ydCB0eXBlIFJlc29sdmVDb25mbGljdCA9IHtcbiAgICBub0NvbmZsaWN0OiBib29sZWFuLFxuICAgIHVucmVzb2x2ZWRGaWxlczogQ2xhc2hTdGF0dXNbXSxcbiAgICBmaWxlT3BzUmVjb3JkOiBGaWxlT3BSZWNvcmRbXSxcbiAgICAvLyBkaWZmOiBhbnlcbn1cblxudHlwZSBQcmVTeW5jQ2hlY2tSZXN1bHQgPSAge1xuICAgIHN0YXR1czogXCJpblN5bmNcIlxufSB8IHtcbiAgICBzdGF0dXM6IEV4Y2x1ZGU8UHJlU3luY0NoZWNrUmVzdWx0VHlwZSwgXCJpblN5bmNcIj5cbiAgICByZW1vdGVVcGRhdGU6IFJlbW90ZVVwZGF0ZVxuICAgIGxvY2FsQ2hhbmdlczogTG9jYWxDaGFuZ2VbXVxuICAgIGxvY2FsVHJlZVNoYTogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxufVxuXG50eXBlIFByZVN5bmNDaGVja1Jlc3VsdFR5cGUgPSAoXG4gICAgXCJpblN5bmNcIiB8XG4gICAgXCJvbmx5TG9jYWxDaGFuZ2VkXCIgfFxuICAgIFwib25seVJlbW90ZUNoYW5nZWRcIiB8XG4gICAgXCJvbmx5UmVtb3RlQ29tbWl0U2hhQ2hhbmdlZFwiIHxcbiAgICBcImxvY2FsQW5kUmVtb3RlQ2hhbmdlc0NvbXBhdGlibGVcIiB8XG4gICAgXCJsb2NhbEFuZFJlbW90ZUNoYW5nZXNDbGFzaGVkXCJcbilcblxuZXhwb3J0IGNsYXNzIEZpdFN5bmMgaW1wbGVtZW50cyBJRml0U3luYyB7XG4gICAgZml0OiBGaXRcbiAgICBmaXRQdWxsOiBGaXRQdWxsXG4gICAgZml0UHVzaDogRml0UHVzaFxuICAgIHZhdWx0T3BzOiBWYXVsdE9wZXJhdGlvbnNcbiAgICBzYXZlTG9jYWxTdG9yZUNhbGxiYWNrOiAocGF0aDogc3RyaW5nLCBsb2NhbFN0b3JlOiBQYXJ0aWFsPExvY2FsU3RvcmVzPikgPT4gUHJvbWlzZTx2b2lkPlxuXG5cbiAgICBjb25zdHJ1Y3RvcihmaXQ6IEZpdCxcbiAgICAgICAgdmF1bHRPcHM6IFZhdWx0T3BlcmF0aW9ucyxcbiAgICAgICAgc2F2ZUxvY2FsU3RvcmVDYWxsYmFjazogKHBhdGg6IHN0cmluZywgbG9jYWxTdG9yZTogUGFydGlhbDxMb2NhbFN0b3Jlcz4pXG4gICAgICAgICAgICA9PiBQcm9taXNlPHZvaWQ+KVxuICAgIHtcbiAgICAgICAgdGhpcy5maXQgPSBmaXRcbiAgICAgICAgdGhpcy5maXRQdWxsID0gbmV3IEZpdFB1bGwoZml0KVxuICAgICAgICB0aGlzLmZpdFB1c2ggPSBuZXcgRml0UHVzaChmaXQpXG4gICAgICAgIHRoaXMudmF1bHRPcHMgPSB2YXVsdE9wc1xuICAgICAgICB0aGlzLnNhdmVMb2NhbFN0b3JlQ2FsbGJhY2sgPSBzYXZlTG9jYWxTdG9yZUNhbGxiYWNrXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBwZXJmb3JtUHJlU3luY0NoZWNrcygpOiBQcm9taXNlPFByZVN5bmNDaGVja1Jlc3VsdD4ge1xuICAgICAgICBjb25zdCBjdXJyZW50TG9jYWxTaGEgPSBhd2FpdCB0aGlzLmZpdC5jb21wdXRlTG9jYWxTaGEoKVxuICAgICAgICBjb25zdCBsb2NhbENoYW5nZXMgPSBhd2FpdCB0aGlzLmZpdC5nZXRMb2NhbENoYW5nZXMoY3VycmVudExvY2FsU2hhKVxuICAgICAgICBjb25zdCB7cmVtb3RlQ29tbWl0U2hhLCB1cGRhdGVkOiByZW1vdGVVcGRhdGVkfSA9IGF3YWl0IHRoaXMuZml0LnJlbW90ZVVwZGF0ZWQoKTtcbiAgICAgICAgaWYgKGxvY2FsQ2hhbmdlcy5sZW5ndGggPT09IDAgJiYgIXJlbW90ZVVwZGF0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7c3RhdHVzOiBcImluU3luY1wifVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVtb3RlVHJlZVNoYSA9IGF3YWl0IHRoaXMuZml0LmdldFJlbW90ZVRyZWVTaGEocmVtb3RlQ29tbWl0U2hhKVxuICAgICAgICBjb25zdCByZW1vdGVDaGFuZ2VzID0gYXdhaXQgdGhpcy5maXQuZ2V0UmVtb3RlQ2hhbmdlcyhyZW1vdGVUcmVlU2hhKVxuICAgICAgICBsZXQgY2xhc2hlczogQ2xhc2hTdGF0dXNbXSA9IFtdO1xuICAgICAgICBsZXQgc3RhdHVzOiBQcmVTeW5jQ2hlY2tSZXN1bHRUeXBlXG5cbiAgICAgICAgaWYgKGxvY2FsQ2hhbmdlcy5sZW5ndGggPiAwICYmICFyZW1vdGVVcGRhdGVkKSB7XG4gICAgICAgICAgICBzdGF0dXMgPSBcIm9ubHlMb2NhbENoYW5nZWRcIlxuICAgICAgICB9IGVsc2UgaWYgKHJlbW90ZVVwZGF0ZWQgJiYgbG9jYWxDaGFuZ2VzLmxlbmd0aCA9PT0gMCAmJiByZW1vdGVDaGFuZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgc3RhdHVzID0gXCJvbmx5UmVtb3RlQ29tbWl0U2hhQ2hhbmdlZFwiXG4gICAgICAgIH0gZWxzZSBpZiAobG9jYWxDaGFuZ2VzLmxlbmd0aCA9PT0gMCAmJiByZW1vdGVVcGRhdGVkKSB7XG4gICAgICAgICAgICBzdGF0dXMgPSBcIm9ubHlSZW1vdGVDaGFuZ2VkXCJcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsYXNoZXMgPSB0aGlzLmZpdC5nZXRDbGFzaGVkQ2hhbmdlcyhsb2NhbENoYW5nZXMsIHJlbW90ZUNoYW5nZXMpXG4gICAgICAgICAgICBpZiAoY2xhc2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBcImxvY2FsQW5kUmVtb3RlQ2hhbmdlc0NvbXBhdGlibGVcIlxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSAgXCJsb2NhbEFuZFJlbW90ZUNoYW5nZXNDbGFzaGVkXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgICAgcmVtb3RlVXBkYXRlOiB7XG4gICAgICAgICAgICAgICAgcmVtb3RlQ2hhbmdlcyxcbiAgICAgICAgICAgICAgICByZW1vdGVUcmVlU2hhLFxuICAgICAgICAgICAgICAgIGxhdGVzdFJlbW90ZUNvbW1pdFNoYTogcmVtb3RlQ29tbWl0U2hhLFxuICAgICAgICAgICAgICAgIGNsYXNoZWRGaWxlczogY2xhc2hlc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxvY2FsQ2hhbmdlcyxcbiAgICAgICAgICAgIGxvY2FsVHJlZVNoYTogY3VycmVudExvY2FsU2hhXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGdlbmVyYXRlQ29uZmxpY3RSZXBvcnQocGF0aDogc3RyaW5nLCBsb2NhbENvbnRlbnQ6IHN0cmluZywgcmVtb3RlQ29udGVudDogc3RyaW5nKTogQ29uZmxpY3RSZXBvcnQge1xuICAgICAgICBjb25zdCBkZXRlY3RlZEV4dGVuc2lvbiA9IGV4dHJhY3RFeHRlbnNpb24ocGF0aClcblxuICAgICAgICAvLyBhc3N1bWUgZmlsZSBlbmNvZGluZyBpcyB1dGY4IGlmIGV4dGVuc2lvbiBpcyBub3Qga25vd25cbiAgICAgICAgbGV0IHJlc29sdXRpb25TdHJhdGVneTogXCJ1dGYtOFwiIHwgXCJiaW5hcnlcIiA9IFwidXRmLThcIlxuXG4gICAgICAgIC8vIFRPRE8gXHUwNDM1XHUwNDQxXHUwNDQyXHUwNDRDIGdldEZpbGVFbmNvZGluZ1xuICAgICAgICBpZiAoZGV0ZWN0ZWRFeHRlbnNpb24gJiYgIVJFQ09HTklaRURfVFhUX0VYVC5pbmNsdWRlcyhkZXRlY3RlZEV4dGVuc2lvbikpXG4gICAgICAgICAgICByZXNvbHV0aW9uU3RyYXRlZ3kgPSBcImJpbmFyeVwiXG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICByZXNvbHV0aW9uU3RyYXRlZ3k6IHJlc29sdXRpb25TdHJhdGVneSxcbiAgICAgICAgICAgIGxvY2FsQ29udGVudCxcbiAgICAgICAgICAgIHJlbW90ZUNvbnRlbnQsXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIGhhbmRsZUJpbmFyeUNvbmZsaWN0KHBhdGg6IHN0cmluZywgbG9jYWxDb250ZW50OiBzdHJpbmcsIHJlbW90ZUNvbnRlbnQ6IHN0cmluZyk6IFByb21pc2U8RmlsZU9wUmVjb3JkfG51bGw+IHtcblxuICAgICAgICBjb25zdCBjb25mbGljdFBhdGggPSB0aGlzLmZpdC5zeW5jUGF0aCtwYXRoXG4gICAgICAgIGNvbnN0IGNvbmZsaWN0UmVzb2x1dGlvblBhdGggPSBjb25mbGljdFJlc29sdXRpb25Gb2xkZXIgKyBjb25mbGljdFBhdGhcblxuICAgICAgICBjb25zdCBleGNsdWRlcyA9IHRoaXMuZml0LmV4Y2x1ZGVzXG5cbiAgICAgICAgbGV0IGlzRXhjbHVkZWQgPSBmYWxzZVxuICAgICAgICBpZiAoZXhjbHVkZXMubGVuZ3RoKSB7XG4gICAgICAgICAgaXNFeGNsdWRlZCA9IGV4Y2x1ZGVzLnNvbWUoZWwgPT4gY29uZmxpY3RSZXNvbHV0aW9uUGF0aC5zdGFydHNXaXRoKGVsKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0V4Y2x1ZGVkKVxuICAgICAgICAgICAgcmV0dXJuIG51bGxcblxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICB0aGlzLmZpdC52YXVsdE9wcy53cml0ZVRvTG9jYWwoY29uZmxpY3RQYXRoLCByZW1vdGVDb250ZW50KSxcbiAgICAgICAgICAgIHRoaXMuZml0LnZhdWx0T3BzLndyaXRlVG9Mb2NhbChjb25mbGljdFJlc29sdXRpb25QYXRoLCBsb2NhbENvbnRlbnQpLFxuICAgICAgICBdKVxuXG4gICAgICAgIC8vIFRPRE8gYWRkXG4gICAgICAgIC8qXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBhdGg6IGNvbmZsaWN0UGF0aCxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IFwiY2hhbmdlZFwiXG4gICAgICAgICAgICB9XG4gICAgICAgICovXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXRoOiBjb25mbGljdFJlc29sdXRpb25QYXRoLFxuICAgICAgICAgICAgc3RhdHVzOiBcImNyZWF0ZWRcIlxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBoYW5kbGVVVEY4Q29uZmxpY3QocGF0aDogc3RyaW5nLCBsb2NhbENvbnRlbnQ6IHN0cmluZywgcmVtb3RlQ29udGVudDogc3RyaW5nKTogUHJvbWlzZTxGaWxlT3BSZWNvcmR8bnVsbD4ge1xuICAgICAgICBjb25zdCBjb25mbGljdFBhdGggPSB0aGlzLmZpdC5zeW5jUGF0aCArIHBhdGhcbiAgICAgICAgY29uc3QgY29uZmxpY3RSZXNvbHV0aW9uUGF0aCA9IGNvbmZsaWN0UmVzb2x1dGlvbkZvbGRlciArIGNvbmZsaWN0UGF0aFxuXG4gICAgICAgIGNvbnN0IGV4Y2x1ZGVzID0gdGhpcy5maXQuZXhjbHVkZXNcblxuICAgICAgICBsZXQgaXNFeGNsdWRlZCA9IGZhbHNlXG4gICAgICAgIGlmIChleGNsdWRlcy5sZW5ndGgpIHtcbiAgICAgICAgICBpc0V4Y2x1ZGVkID0gZXhjbHVkZXMuc29tZShlbCA9PiBjb25mbGljdFJlc29sdXRpb25QYXRoLnN0YXJ0c1dpdGgoZWwpKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRXhjbHVkZWQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHRoaXMuZml0LnZhdWx0T3BzLndyaXRlVG9Mb2NhbChjb25mbGljdFBhdGgsIHJlbW90ZUNvbnRlbnQpLFxuICAgICAgICAgICAgdGhpcy5maXQudmF1bHRPcHMud3JpdGVUb0xvY2FsKGNvbmZsaWN0UmVzb2x1dGlvblBhdGgsIGxvY2FsQ29udGVudCksXG4gICAgICAgIF0pXG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhdGg6IGNvbmZsaWN0UmVzb2x1dGlvblBhdGgsXG4gICAgICAgICAgICBzdGF0dXM6IFwiY3JlYXRlZFwiXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIGhhbmRsZUxvY2FsRGVsZXRpb25Db25mbGljdChwYXRoOiBzdHJpbmcsIHJlbW90ZUNvbnRlbnQ6IHN0cmluZyk6IFByb21pc2U8RmlsZU9wUmVjb3JkfG51bGw+IHtcbiAgICAgICAgLy8gY29uc3QgY29uZmxpY3RSZXNvbHV0aW9uUGF0aCA9IGNvbmZsaWN0UmVzb2x1dGlvbkZvbGRlciArIGNvbmZsaWN0UGF0aFxuICAgICAgICBjb25zdCBjb25mbGljdFJlc29sdXRpb25QYXRoID0gdGhpcy5maXQuc3luY1BhdGggKyBwYXRoXG5cbiAgICAgICAgY29uc3QgZXhjbHVkZXMgPSB0aGlzLmZpdC5leGNsdWRlc1xuXG4gICAgICAgIGxldCBpc0V4Y2x1ZGVkID0gZmFsc2VcbiAgICAgICAgaWYgKGV4Y2x1ZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgaXNFeGNsdWRlZCA9IGV4Y2x1ZGVzLnNvbWUoZWwgPT4gY29uZmxpY3RSZXNvbHV0aW9uUGF0aC5zdGFydHNXaXRoKGVsKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0V4Y2x1ZGVkKVxuICAgICAgICAgICAgcmV0dXJuIG51bGxcblxuICAgICAgICBhd2FpdCB0aGlzLmZpdC52YXVsdE9wcy53cml0ZVRvTG9jYWwoY29uZmxpY3RSZXNvbHV0aW9uUGF0aCwgcmVtb3RlQ29udGVudClcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGF0aDogY29uZmxpY3RSZXNvbHV0aW9uUGF0aCxcbiAgICAgICAgICAgIHN0YXR1czogXCJjcmVhdGVkXCJcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgcmVzb2x2ZUZpbGVDb25mbGljdChjbGFzaDogQ2xhc2hTdGF0dXMsIGxhdGVzdFJlbW90ZUZpbGVTaGE6IHN0cmluZyk6IFByb21pc2U8Q29uZmxpY3RSZXNvbHV0aW9uUmVzdWx0IHwgbnVsbD4ge1xuICAgICAgICBpZiAoY2xhc2gubG9jYWxTdGF0dXMgPT09IFwiZGVsZXRlZFwiICYmIGNsYXNoLnJlbW90ZVN0YXR1cyA9PT0gXCJSRU1PVkVEXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7cGF0aDogY2xhc2gucGF0aCwgbm9EaWZmOiB0cnVlfVxuICAgICAgICB9IGVsc2UgaWYgKGNsYXNoLmxvY2FsU3RhdHVzID09PSBcImRlbGV0ZWRcIikge1xuICAgICAgICAgICAgY29uc3QgcmVtb3RlQ29udGVudCA9IGF3YWl0IHRoaXMuZml0LmdldEJsb2IobGF0ZXN0UmVtb3RlRmlsZVNoYSlcbiAgICAgICAgICAgIGNvbnN0IGZpbGVPcCA9IGF3YWl0IHRoaXMuaGFuZGxlTG9jYWxEZWxldGlvbkNvbmZsaWN0KGNsYXNoLnBhdGgsIHJlbW90ZUNvbnRlbnQpXG4gICAgICAgICAgICAvLyBOT1RFIGRpZG4ndCBkZWxldGUgc2luY2UgaXQncyBpbiBleGNsdWRlXG4gICAgICAgICAgICBpZiAoIWZpbGVPcClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuXG4gICAgICAgICAgICByZXR1cm4ge3BhdGg6IGNsYXNoLnBhdGgsIG5vRGlmZjogZmFsc2UsIGZpbGVPcDogZmlsZU9wfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGF0aCA9IHRoaXMuZml0LnN5bmNQYXRoICsgY2xhc2gucGF0aFxuXG4gICAgICAgIC8vIE5PVEUgdXNlIGFkYXB0ZXIgZm9yIGZpbGVzIGluIHRoZSAub2JzaWRpYW4vLi4uXG4gICAgICAgIGNvbnN0IGxvY2FsRmlsZUNvbnRlbnQgPSBhcnJheUJ1ZmZlclRvQmFzZTY0KFxuICAgICAgICAgICAgYXdhaXQgdGhpcy5maXQudmF1bHRPcHMudmF1bHQuYWRhcHRlci5yZWFkQmluYXJ5KHBhdGgpXG4gICAgICAgIClcblxuICAgICAgICBpZiAoIWxhdGVzdFJlbW90ZUZpbGVTaGEpXG4gICAgICAgICAgICAvLyBhc3N1bWVzIHJlbW90ZSBmaWxlIGlzIGRlbGV0ZWQgaWYgc2hhIG5vdCBmb3VuZCBpbiBsYXRlc3RSZW1vdGVUcmVlU2hhLlxuICAgICAgICAgICAgcmV0dXJuIHsgcGF0aDogY2xhc2gucGF0aCwgbm9EaWZmOiBmYWxzZSB9XG5cblxuICAgICAgICBjb25zdCByZW1vdGVDb250ZW50ID0gYXdhaXQgdGhpcy5maXQuZ2V0QmxvYihsYXRlc3RSZW1vdGVGaWxlU2hhKVxuICAgICAgICBpZiAocmVtb3ZlTGluZUVuZGluZ3NGcm9tQmFzZTY0U3RyaW5nKHJlbW90ZUNvbnRlbnQpICE9PSByZW1vdmVMaW5lRW5kaW5nc0Zyb21CYXNlNjRTdHJpbmcobG9jYWxGaWxlQ29udGVudCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcG9ydCA9IHRoaXMuZ2VuZXJhdGVDb25mbGljdFJlcG9ydChjbGFzaC5wYXRoLCBsb2NhbEZpbGVDb250ZW50LCByZW1vdGVDb250ZW50KVxuXG4gICAgICAgICAgICBsZXQgZmlsZU9wOiBGaWxlT3BSZWNvcmQgfCBudWxsXG4gICAgICAgICAgICBpZiAocmVwb3J0LnJlc29sdXRpb25TdHJhdGVneSA9PT0gXCJiaW5hcnlcIikge1xuICAgICAgICAgICAgICAgIGZpbGVPcCA9IGF3YWl0IHRoaXMuaGFuZGxlQmluYXJ5Q29uZmxpY3QoY2xhc2gucGF0aCwgcmVwb3J0LmxvY2FsQ29udGVudCwgcmVwb3J0LnJlbW90ZUNvbnRlbnQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWxlT3AgPSBhd2FpdCB0aGlzLmhhbmRsZVVURjhDb25mbGljdChjbGFzaC5wYXRoLCByZXBvcnQubG9jYWxDb250ZW50LCByZXBvcnQucmVtb3RlQ29udGVudClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTk9URSBkaWRuJ3QgZGVsZXRlIHNpbmNlIGl0J3MgaW4gZXhjbHVkZVxuICAgICAgICAgICAgaWYgKCFmaWxlT3ApXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGxcblxuICAgICAgICAgICAgcmV0dXJuIHtwYXRoOiBjbGFzaC5wYXRoLCBub0RpZmY6IGZhbHNlLCBmaWxlT3A6IGZpbGVPcH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBwYXRoOiBjbGFzaC5wYXRoLCBub0RpZmY6IHRydWUgfVxuICAgIH1cblxuICAgIGFzeW5jIHJlc29sdmVDb25mbGljdHMoXG4gICAgICAgIGNsYXNoZWRGaWxlczogQXJyYXk8Q2xhc2hTdGF0dXM+LCBsYXRlc3RSZW1vdGVUcmVlU2hhOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KVxuICAgICAgICAgICAgOiBQcm9taXNlPFJlc29sdmVDb25mbGljdD5cbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgZmlsZVJlc29sdXRpb25zID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICAgICAgY2xhc2hlZEZpbGVzLm1hcChcbiAgICAgICAgICAgICAgICAgICAgYXN5bmMgKGNsYXNoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5yZXNvbHZlRmlsZUNvbmZsaWN0KGNsYXNoLCBsYXRlc3RSZW1vdGVUcmVlU2hhW2NsYXNoLnBhdGhdKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICBjb25zdCB1bnJlc29sdmVkRmlsZXMgPSBmaWxlUmVzb2x1dGlvbnMubWFwKChyZXMsIGkpPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcmVzPy5ub0RpZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsYXNoZWRGaWxlc1tpXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgICAgfSkuZmlsdGVyKEJvb2xlYW4pIGFzIEFycmF5PENsYXNoU3RhdHVzPlxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5vQ29uZmxpY3Q6IGZpbGVSZXNvbHV0aW9ucy5ldmVyeShyZXM9PnJlcz8ubm9EaWZmKSxcbiAgICAgICAgICAgICAgICB1bnJlc29sdmVkRmlsZXMsXG4gICAgICAgICAgICAgICAgZmlsZU9wc1JlY29yZDogZmlsZVJlc29sdXRpb25zLm1hcChyID0+IHI/LmZpbGVPcCkuZmlsdGVyKEJvb2xlYW4pIGFzIEZpbGVPcFJlY29yZFtdXG4gICAgICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgc3luY0NvbXBhdGlibGVDaGFuZ2VzKFxuICAgICAgICBsb2NhbFVwZGF0ZTogTG9jYWxVcGRhdGUsXG4gICAgICAgIHJlbW90ZVVwZGF0ZTogUmVtb3RlVXBkYXRlLFxuICAgICAgICBzeW5jTm90aWNlOiBGaXROb3RpY2UpOiBQcm9taXNlPHtsb2NhbE9wczogTG9jYWxDaGFuZ2VbXSwgcmVtb3RlT3BzOiBGaWxlT3BSZWNvcmRbXX0+IHtcbiAgICAgICAgICAgIGxldCB7YWRkVG9Mb2NhbCwgZGVsZXRlRnJvbUxvY2FsfSA9IGF3YWl0IHRoaXMuZml0UHVsbC5wcmVwYXJlQ2hhbmdlc1RvRXhlY3V0ZShcbiAgICAgICAgICAgICAgICByZW1vdGVVcGRhdGUucmVtb3RlQ2hhbmdlcylcbiAgICAgICAgICAgIHN5bmNOb3RpY2Uuc2V0TWVzc2FnZShcIlVwbG9hZGluZyBsb2NhbCBjaGFuZ2VzXCIpXG4gICAgICAgICAgICBjb25zdCByZW1vdGVUcmVlID0gYXdhaXQgdGhpcy5maXQuZ2V0VHJlZShsb2NhbFVwZGF0ZS5wYXJlbnRDb21taXRTaGEpXG4gICAgICAgICAgICBjb25zdCBjcmVhdGVDb21taXRSZXN1bHQgPSBhd2FpdCB0aGlzLmZpdFB1c2guY3JlYXRlQ29tbWl0RnJvbUxvY2FsVXBkYXRlKGxvY2FsVXBkYXRlLCByZW1vdGVUcmVlKVxuICAgICAgICAgICAgbGV0IGxhdGVzdFJlbW90ZVRyZWVTaGE6IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gICAgICAgICAgICBsZXQgbGF0ZXN0Q29tbWl0U2hhOiBzdHJpbmc7XG4gICAgICAgICAgICBsZXQgcHVzaGVkQ2hhbmdlczogQXJyYXk8TG9jYWxDaGFuZ2U+O1xuICAgICAgICAgICAgaWYgKGNyZWF0ZUNvbW1pdFJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHtjcmVhdGVkQ29tbWl0U2hhfSA9IGNyZWF0ZUNvbW1pdFJlc3VsdFxuICAgICAgICAgICAgICAgIGNvbnN0IGxhdGVzdFJlZlNoYSA9IGF3YWl0IHRoaXMuZml0LnVwZGF0ZVJlZihjcmVhdGVkQ29tbWl0U2hhKVxuICAgICAgICAgICAgICAgIGxhdGVzdFJlbW90ZVRyZWVTaGEgPSBhd2FpdCB0aGlzLmZpdC5nZXRSZW1vdGVUcmVlU2hhKGxhdGVzdFJlZlNoYSlcbiAgICAgICAgICAgICAgICBsYXRlc3RDb21taXRTaGEgPSBjcmVhdGVkQ29tbWl0U2hhXG4gICAgICAgICAgICAgICAgcHVzaGVkQ2hhbmdlcyA9IGNyZWF0ZUNvbW1pdFJlc3VsdC5wdXNoZWRDaGFuZ2VzXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxhdGVzdFJlbW90ZVRyZWVTaGEgPSByZW1vdGVVcGRhdGUucmVtb3RlVHJlZVNoYVxuICAgICAgICAgICAgICAgIGxhdGVzdENvbW1pdFNoYSA9IHJlbW90ZVVwZGF0ZS5sYXRlc3RSZW1vdGVDb21taXRTaGFcbiAgICAgICAgICAgICAgICBwdXNoZWRDaGFuZ2VzID0gW11cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3luY05vdGljZS5zZXRNZXNzYWdlKFwiV3JpdGluZyByZW1vdGUgY2hhbmdlcyB0byBsb2NhbFwiKVxuXG4gICAgICAgICAgICBjb25zdCBiYXNlcGF0aCA9IHRoaXMuZml0LnN5bmNQYXRoXG4gICAgICAgICAgICBhZGRUb0xvY2FsID0gdGhpcy5maXQuZ2V0QWRkVG9Mb2NhbChhZGRUb0xvY2FsKVxuICAgICAgICAgICAgZGVsZXRlRnJvbUxvY2FsID0gdGhpcy5maXQuZ2V0RGVsZXRlRnJvbUxvY2FsKGRlbGV0ZUZyb21Mb2NhbClcblxuXG4gICAgICAgICAgICBjb25zdCBsb2NhbEZpbGVPcHNSZWNvcmQgPSBhd2FpdCB0aGlzLnZhdWx0T3BzLnVwZGF0ZUxvY2FsRmlsZXMoYWRkVG9Mb2NhbCwgZGVsZXRlRnJvbUxvY2FsKVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zYXZlTG9jYWxTdG9yZUNhbGxiYWNrKFxuICAgICAgICAgICAgICAgIGJhc2VwYXRoLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdEZldGNoZWRSZW1vdGVTaGE6IGxhdGVzdFJlbW90ZVRyZWVTaGEsXG4gICAgICAgICAgICAgICAgICAgIGxhc3RGZXRjaGVkQ29tbWl0U2hhOiBsYXRlc3RDb21taXRTaGEsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU2hhOiBhd2FpdCB0aGlzLmZpdC5jb21wdXRlTG9jYWxTaGEoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIHN5bmNOb3RpY2Uuc2V0TWVzc2FnZShcIlN5bmMgc3VjY2Vzc2Z1bFwiKVxuICAgICAgICAgICAgcmV0dXJuIHtsb2NhbE9wczogbG9jYWxGaWxlT3BzUmVjb3JkLCByZW1vdGVPcHM6IHB1c2hlZENoYW5nZXN9XG4gICAgfVxuXG5cbiAgICBhc3luYyBzeW5jV2l0aENvbmZsaWN0cyhcbiAgICAgICAgbG9jYWxDaGFuZ2VzOiBMb2NhbENoYW5nZVtdLFxuICAgICAgICByZW1vdGVVcGRhdGU6IFJlbW90ZVVwZGF0ZSxcbiAgICAgICAgc3luY05vdGljZTogRml0Tm90aWNlKSA6IFByb21pc2U8e3VucmVzb2x2ZWRGaWxlczogQ2xhc2hTdGF0dXNbXSwgbG9jYWxPcHM6IExvY2FsQ2hhbmdlW10sIHJlbW90ZU9wczogTG9jYWxDaGFuZ2VbXX0gfCBudWxsPlxuICAgIHtcbiAgICAgICAgY29uc3Qge2xhdGVzdFJlbW90ZUNvbW1pdFNoYSwgY2xhc2hlZEZpbGVzLCByZW1vdGVUcmVlU2hhOiBsYXRlc3RSZW1vdGVUcmVlU2hhfSA9IHJlbW90ZVVwZGF0ZVxuICAgICAgICBjb25zdCB7bm9Db25mbGljdCwgdW5yZXNvbHZlZEZpbGVzLCBmaWxlT3BzUmVjb3JkfSA9IGF3YWl0IHRoaXMucmVzb2x2ZUNvbmZsaWN0cyhjbGFzaGVkRmlsZXMsIGxhdGVzdFJlbW90ZVRyZWVTaGEpXG4gICAgICAgIGxldCBsb2NhbENoYW5nZXNUb1B1c2g6IEFycmF5PExvY2FsQ2hhbmdlPjtcbiAgICAgICAgbGV0IHJlbW90ZUNoYW5nZXNUb1dyaXRlOiBBcnJheTxSZW1vdGVDaGFuZ2U+XG4gICAgICAgIGlmIChub0NvbmZsaWN0KSB7XG4gICAgICAgICAgICAvLyBubyBjb25mbGljdCBkZXRlY3RlZCBhbW9uZyBjbGFzaGVkIGZpbGVzLCBqdXN0IHB1bGwgY2hhbmdlcyBvbmx5IG1hZGUgb24gcmVtb3RlIGFuZCBwdXNoIGNoYW5nZXMgb25seSBtYWRlIG9uIGxvY2FsXG4gICAgICAgICAgICByZW1vdGVDaGFuZ2VzVG9Xcml0ZSA9IHJlbW90ZVVwZGF0ZS5yZW1vdGVDaGFuZ2VzLmZpbHRlcihjID0+ICFsb2NhbENoYW5nZXMuc29tZShsID0+IGwucGF0aCA9PT0gYy5wYXRoKSlcbiAgICAgICAgICAgIGxvY2FsQ2hhbmdlc1RvUHVzaCA9IGxvY2FsQ2hhbmdlcy5maWx0ZXIoYyA9PiAhcmVtb3RlVXBkYXRlLnJlbW90ZUNoYW5nZXMuc29tZShyID0+IHIucGF0aCA9PT0gYy5wYXRoKSlcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3luY05vdGljZS5zZXRNZXNzYWdlKGBDaGFuZ2UgY29uZmxpY3RzIGRldGVjdGVkYClcbiAgICAgICAgICAgIC8vIGRvIG5vdCBtb2RpZnkgdW5yZXNvbHZlZCBmaWxlcyBsb2NhbGx5XG4gICAgICAgICAgICByZW1vdGVDaGFuZ2VzVG9Xcml0ZSA9IHJlbW90ZVVwZGF0ZS5yZW1vdGVDaGFuZ2VzLmZpbHRlcihjID0+ICF1bnJlc29sdmVkRmlsZXMuc29tZShsID0+IGwucGF0aCA9PT0gYy5wYXRoKSlcbiAgICAgICAgICAgIC8vIHB1c2ggY2hhbmdlIGV2ZW4gaWYgdGhleSBhcmUgaW4gdW5yZXNvbHZlZCBmaWxlcywgc28gcmVtb3RlIGhhcyBhIHJlY29yZCBvZiB0aGVtLFxuICAgICAgICAgICAgLy8gc28gdXNlciBjYW4gcmVzb2x2ZSBsYXRlciBieSBtb2RpZnlpbmcgbG9jYWwgYW5kIHB1c2ggYWdhaW5cbiAgICAgICAgICAgIGxvY2FsQ2hhbmdlc1RvUHVzaCA9IGxvY2FsQ2hhbmdlc1xuICAgICAgICB9XG4gICAgICAgIGxldCB7YWRkVG9Mb2NhbCwgZGVsZXRlRnJvbUxvY2FsfSA9IGF3YWl0IHRoaXMuZml0UHVsbC5wcmVwYXJlQ2hhbmdlc1RvRXhlY3V0ZShyZW1vdGVDaGFuZ2VzVG9Xcml0ZSlcbiAgICAgICAgY29uc3Qgc3luY0xvY2FsVXBkYXRlID0ge1xuICAgICAgICAgICAgbG9jYWxDaGFuZ2VzOiBsb2NhbENoYW5nZXNUb1B1c2gsXG4gICAgICAgICAgICBwYXJlbnRDb21taXRTaGE6IGxhdGVzdFJlbW90ZUNvbW1pdFNoYVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHB1c2hSZXN1bHQgPSBhd2FpdCB0aGlzLmZpdFB1c2gucHVzaENoYW5nZWRGaWxlc1RvUmVtb3RlKHN5bmNMb2NhbFVwZGF0ZSlcbiAgICAgICAgbGV0IHB1c2hlZENoYW5nZXM6IExvY2FsQ2hhbmdlW107XG4gICAgICAgIGxldCBsYXN0RmV0Y2hlZENvbW1pdFNoYTogc3RyaW5nO1xuICAgICAgICBsZXQgbGFzdEZldGNoZWRSZW1vdGVTaGE6IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gICAgICAgIGlmIChwdXNoUmVzdWx0KSB7XG4gICAgICAgICAgICBwdXNoZWRDaGFuZ2VzID0gcHVzaFJlc3VsdC5wdXNoZWRDaGFuZ2VzXG4gICAgICAgICAgICBsYXN0RmV0Y2hlZENvbW1pdFNoYSA9IHB1c2hSZXN1bHQubGFzdEZldGNoZWRDb21taXRTaGFcbiAgICAgICAgICAgIGxhc3RGZXRjaGVkUmVtb3RlU2hhID0gcHVzaFJlc3VsdC5sYXN0RmV0Y2hlZFJlbW90ZVNoYVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZGlkIG5vdCBwdXNoIGFueSBjaGFuZ2VzXG4gICAgICAgICAgICBwdXNoZWRDaGFuZ2VzID0gW11cbiAgICAgICAgICAgIGxhc3RGZXRjaGVkQ29tbWl0U2hhID0gcmVtb3RlVXBkYXRlLmxhdGVzdFJlbW90ZUNvbW1pdFNoYVxuICAgICAgICAgICAgbGFzdEZldGNoZWRSZW1vdGVTaGEgPSByZW1vdGVVcGRhdGUucmVtb3RlVHJlZVNoYVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYmFzZXBhdGggPSB0aGlzLmZpdC5zeW5jUGF0aFxuICAgICAgICBhZGRUb0xvY2FsID0gdGhpcy5maXQuZ2V0QWRkVG9Mb2NhbChhZGRUb0xvY2FsKVxuICAgICAgICBkZWxldGVGcm9tTG9jYWwgPSB0aGlzLmZpdC5nZXREZWxldGVGcm9tTG9jYWwoZGVsZXRlRnJvbUxvY2FsKVxuXG4gICAgICAgIGNvbnN0IGxvY2FsRmlsZU9wc1JlY29yZCA9IGF3YWl0IHRoaXMudmF1bHRPcHMudXBkYXRlTG9jYWxGaWxlcyhcbiAgICAgICAgICAgIGFkZFRvTG9jYWwsXG4gICAgICAgICAgICBkZWxldGVGcm9tTG9jYWxcbiAgICAgICAgKVxuXG4gICAgICAgIGF3YWl0IHRoaXMuc2F2ZUxvY2FsU3RvcmVDYWxsYmFjayhcbiAgICAgICAgICAgIGJhc2VwYXRoLFxuICAgICAgICB7XG4gICAgICAgICAgICBsYXN0RmV0Y2hlZFJlbW90ZVNoYSxcbiAgICAgICAgICAgIGxhc3RGZXRjaGVkQ29tbWl0U2hhLFxuICAgICAgICAgICAgbG9jYWxTaGE6IGF3YWl0IHRoaXMuZml0LmNvbXB1dGVMb2NhbFNoYSgpXG4gICAgICAgIH0pXG4gICAgICAgIGNvbnN0IG9wcyA9IGxvY2FsRmlsZU9wc1JlY29yZC5jb25jYXQoZmlsZU9wc1JlY29yZClcbiAgICAgICAgaWYgKHVucmVzb2x2ZWRGaWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHN5bmNOb3RpY2Uuc2V0TWVzc2FnZShgU3luYyBzdWNjZXNzZnVsYClcbiAgICAgICAgfSBlbHNlIGlmICh1bnJlc29sdmVkRmlsZXMuc29tZShmID0+IGYucmVtb3RlU3RhdHVzICE9PSBcIlJFTU9WRURcIikpIHtcbiAgICAgICAgICAgIC8vIGxldCB1c2VyIGtub3dzIHJlbW90ZSBmaWxlIGNoYW5nZXMgaGF2ZSBiZWVuIHdyaXR0ZW4gdG8gX2ZpdCBpZiBub24tZGVsZXRpb24gY2hhbmdlIG9uIHJlbW90ZSBjbGFzaGVkIHdpdGggbG9jYWwgY2hhbmdlc1xuICAgICAgICAgICAgc3luY05vdGljZS5zZXRNZXNzYWdlKGBTeW5jZWQgd2l0aCByZW1vdGUsIHVucmVzb2x2ZWQgY29uZmxpY3RzIHdyaXR0ZW4gdG8gJHtjb25mbGljdFJlc29sdXRpb25Gb2xkZXJ9YClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN5bmNOb3RpY2Uuc2V0TWVzc2FnZShgU3luY2VkIHdpdGggcmVtb3RlLCBpZ25vcmVkIHJlbW90ZSBkZWxldGlvbiBvZiBsb2NhbGx5IGNoYW5nZWQgZmlsZXNgKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7dW5yZXNvbHZlZEZpbGVzLCBsb2NhbE9wczogb3BzLCByZW1vdGVPcHM6IHB1c2hlZENoYW5nZXN9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyB1bnJlc29sdmVkQ2hhbmdlc0NvbmZsaWN0cygpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudmF1bHRPcHMudmF1bHQuYWRhcHRlci5leGlzdHMoY29uZmxpY3RSZXNvbHV0aW9uRm9sZGVyKVxuICAgIH1cblxuICAgIGFzeW5jIHN5bmMoc3luY05vdGljZTogRml0Tm90aWNlKTpcbiAgICAgICAgICAgIFByb21pc2U8e1xuICAgICAgICAgICAgICAgICAgICBvcHM6IEFycmF5PHtoZWFkaW5nOiBzdHJpbmcsIG9wczogRmlsZU9wUmVjb3JkW119PixcbiAgICAgICAgICAgICAgICAgICAgY2xhc2g6IENsYXNoU3RhdHVzW10sXG4gICAgICAgICAgICAgICAgICAgIC8vIGJhc2VwYXRoOiBzdHJpbmdcbiAgICAgICAgICAgICAgICB9IHwgdm9pZFxuICAgICAgICAgICAgPlxuICAgIHtcbiAgICAgICAgc3luY05vdGljZS5zZXRNZXNzYWdlKFwiUGVyZm9ybWluZyBwcmUgc3luYyBjaGVja3MuXCIpXG4gICAgICAgIGlmIChhd2FpdCB0aGlzLnVucmVzb2x2ZWRDaGFuZ2VzQ29uZmxpY3RzKCkpIHtcbiAgICAgICAgICAgIHN5bmNOb3RpY2Uuc2V0TWVzc2FnZShgVGhlcmUgYXJlIHVucmVzb2x2ZWQgZmlsZXM6IHBscywgcmVzb2x2ZSBmaWxlcyBpbjogJHtjb25mbGljdFJlc29sdXRpb25Gb2xkZXJ9LmApXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHByZVN5bmNDaGVja1Jlc3VsdCA9IGF3YWl0IHRoaXMucGVyZm9ybVByZVN5bmNDaGVja3MoKTtcblxuICAgICAgICAvLyBjb252ZXJ0IHRvIHN3aXRjaCBzdGF0ZW1lbnQgbGF0ZXIgb24gZm9yIGJldHRlciBtYWludGFpbmFiaWxpdHlcbiAgICAgICAgaWYgKHByZVN5bmNDaGVja1Jlc3VsdC5zdGF0dXMgPT09IFwiaW5TeW5jXCIpIHtcbiAgICAgICAgICAgIHN5bmNOb3RpY2Uuc2V0TWVzc2FnZShcIlN5bmMgc3VjY2Vzc2Z1bFwiKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJlU3luY0NoZWNrUmVzdWx0LnN0YXR1cyA9PT0gXCJvbmx5UmVtb3RlQ29tbWl0U2hhQ2hhbmdlZFwiKSB7XG4gICAgICAgICAgICBjb25zdCB7IGxhdGVzdFJlbW90ZUNvbW1pdFNoYSB9ID0gcHJlU3luY0NoZWNrUmVzdWx0LnJlbW90ZVVwZGF0ZVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zYXZlTG9jYWxTdG9yZUNhbGxiYWNrKFxuICAgICAgICAgICAgICAgIHRoaXMuZml0LnN5bmNQYXRoLFxuICAgICAgICAgICAgICAgIHtsYXN0RmV0Y2hlZENvbW1pdFNoYTogbGF0ZXN0UmVtb3RlQ29tbWl0U2hhfVxuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICBzeW5jTm90aWNlLnNldE1lc3NhZ2UoXCJTeW5jIHN1Y2Nlc3NmdWxcIilcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVtb3RlVXBkYXRlID0gcHJlU3luY0NoZWNrUmVzdWx0LnJlbW90ZVVwZGF0ZVxuICAgICAgICBpZiAocHJlU3luY0NoZWNrUmVzdWx0LnN0YXR1cyA9PT0gXCJvbmx5UmVtb3RlQ2hhbmdlZFwiKSB7XG4gICAgICAgICAgICBjb25zdCBmaWxlT3BzUmVjb3JkID0gYXdhaXQgdGhpcy5maXRQdWxsLnB1bGxSZW1vdGVUb0xvY2FsKFxuICAgICAgICAgICAgICAgIHJlbW90ZVVwZGF0ZSxcbiAgICAgICAgICAgICAgICB0aGlzLnNhdmVMb2NhbFN0b3JlQ2FsbGJhY2tcbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgc3luY05vdGljZS5zZXRNZXNzYWdlKFwiU3luYyBzdWNjZXNzZnVsXCIpXG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb3BzOiBbe2hlYWRpbmc6IFwiTG9jYWwgZmlsZSB1cGRhdGVzOlwiLCBvcHM6IGZpbGVPcHNSZWNvcmR9XSxcbiAgICAgICAgICAgICAgICBjbGFzaDogW10sXG4gICAgICAgICAgICAgICAgLy8gYmFzZXBhdGg6IHRoaXMuZml0LnN5bmNQYXRoXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7bG9jYWxDaGFuZ2VzLCBsb2NhbFRyZWVTaGF9ID0gcHJlU3luY0NoZWNrUmVzdWx0XG4gICAgICAgIGNvbnN0IGxvY2FsVXBkYXRlID0ge1xuICAgICAgICAgICAgbG9jYWxDaGFuZ2VzLFxuICAgICAgICAgICAgcGFyZW50Q29tbWl0U2hhOiByZW1vdGVVcGRhdGUubGF0ZXN0UmVtb3RlQ29tbWl0U2hhXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZVN5bmNDaGVja1Jlc3VsdC5zdGF0dXMgPT09IFwib25seUxvY2FsQ2hhbmdlZFwiKSB7XG4gICAgICAgICAgICBzeW5jTm90aWNlLnNldE1lc3NhZ2UoXCJVcGxvYWRpbmcgbG9jYWwgY2hhbmdlc1wiKVxuICAgICAgICAgICAgY29uc3QgcHVzaFJlc3VsdCA9IGF3YWl0IHRoaXMuZml0UHVzaC5wdXNoQ2hhbmdlZEZpbGVzVG9SZW1vdGUobG9jYWxVcGRhdGUpXG4gICAgICAgICAgICBzeW5jTm90aWNlLnNldE1lc3NhZ2UoXCJTeW5jIHN1Y2Nlc3NmdWxcIilcbiAgICAgICAgICAgIGlmIChwdXNoUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zYXZlTG9jYWxTdG9yZUNhbGxiYWNrKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpdC5zeW5jUGF0aCxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTaGE6IGxvY2FsVHJlZVNoYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RGZXRjaGVkUmVtb3RlU2hhOiBwdXNoUmVzdWx0Lmxhc3RGZXRjaGVkUmVtb3RlU2hhLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEZldGNoZWRDb21taXRTaGE6IHB1c2hSZXN1bHQubGFzdEZldGNoZWRDb21taXRTaGFcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBvcHM6IFt7aGVhZGluZzogXCJMb2NhbCBmaWxlIHVwZGF0ZXM6XCIsIG9wczogcHVzaFJlc3VsdC5wdXNoZWRDaGFuZ2VzfV0sXG4gICAgICAgICAgICAgICAgICAgIGNsYXNoOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgLy8gYmFzZXBhdGg6IHRoaXMuZml0LnN5bmNQYXRoXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBkbyBib3RoIHB1bGwgYW5kIHB1c2ggKG9yZGVycyBvZiBleGVjdXRpb24gZGlmZmVyZW50IGZyb20gcHVsbFJlbW90ZVRvTG9jYWwgYW5kXG4gICAgICAgIC8vIHB1c2hDaGFuZ2VkRmlsZXNUb1JlbW90ZSB0byBtYWtlIHRoaXMgbW9yZSB0cmFuc2FjdGlvbiBsaWtlLCBpLmUuIG1haW50YWluIG9yaWdpbmFsXG4gICAgICAgIC8vIHN0YXRlIGlmIHRoZSB0cmFuc2FjdGlvbiBmYWlsZWQpIElmIHlvdSBoYXZlIGlkZWFzIG9uIGhvdyB0byBtYWtlIHRoaXMgbW9yZSB0cmFuc2FjdGlvbi1saWtlLFxuICAgICAgICAvLyAgcGxlYXNlIG9wZW4gYW4gaXNzdWUgb24gdGhlIGZpdCByZXBvXG4gICAgICAgIGlmIChwcmVTeW5jQ2hlY2tSZXN1bHQuc3RhdHVzID09PSBcImxvY2FsQW5kUmVtb3RlQ2hhbmdlc0NvbXBhdGlibGVcIikge1xuICAgICAgICAgICAgY29uc3Qge2xvY2FsT3BzLCByZW1vdGVPcHN9ID0gYXdhaXQgdGhpcy5zeW5jQ29tcGF0aWJsZUNoYW5nZXMoXG4gICAgICAgICAgICAgICAgbG9jYWxVcGRhdGUsIHJlbW90ZVVwZGF0ZSwgc3luY05vdGljZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICAgICAgb3BzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7aGVhZGluZzogXCJMb2NhbCBmaWxlIHVwZGF0ZXM6XCIsIG9wczogbG9jYWxPcHN9LFxuICAgICAgICAgICAgICAgICAgICAgICAge2hlYWRpbmc6IFwiUmVtb3RlIGZpbGUgdXBkYXRlczpcIiwgb3BzOiByZW1vdGVPcHN9LFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBjbGFzaDogW10sXG4gICAgICAgICAgICAgICAgICAgIC8vIGJhc2VwYXRoOiB0aGlzLmZpdC5zeW5jUGF0aFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJlU3luY0NoZWNrUmVzdWx0LnN0YXR1cyA9PT0gXCJsb2NhbEFuZFJlbW90ZUNoYW5nZXNDbGFzaGVkXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmZsaWN0UmVzb2x1dGlvblJlc3VsdCA9IGF3YWl0IHRoaXMuc3luY1dpdGhDb25mbGljdHMoXG4gICAgICAgICAgICAgICAgbG9jYWxVcGRhdGUubG9jYWxDaGFuZ2VzLCByZW1vdGVVcGRhdGUsIHN5bmNOb3RpY2VcbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgaWYgKGNvbmZsaWN0UmVzb2x1dGlvblJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHt1bnJlc29sdmVkRmlsZXMsIGxvY2FsT3BzLCByZW1vdGVPcHN9ID0gY29uZmxpY3RSZXNvbHV0aW9uUmVzdWx0XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICAgICAgb3BzOltcbiAgICAgICAgICAgICAgICAgICAgICAgIHtoZWFkaW5nOiBcIkxvY2FsIGZpbGUgdXBkYXRlczpcIiwgb3BzOiBsb2NhbE9wc30sXG4gICAgICAgICAgICAgICAgICAgICAgICB7aGVhZGluZzogXCJSZW1vdGUgZmlsZSB1cGRhdGVzOlwiLCBvcHM6IHJlbW90ZU9wc30sXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIGNsYXNoOiB1bnJlc29sdmVkRmlsZXMsXG4gICAgICAgICAgICAgICAgICAgIC8vIGJhc2VwYXRoOiB0aGlzLmZpdC5zeW5jUGF0aFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgRml0IH0gZnJvbSBcIi4vZml0XCI7XG5pbXBvcnQgeyBMb2NhbFN0b3JlcyB9IGZyb20gXCJtYWluXCI7XG5pbXBvcnQgeyBGaWxlT3BSZWNvcmQsIExvY2FsQ2hhbmdlLCBSZW1vdGVDaGFuZ2UsIFJlbW90ZVVwZGF0ZSB9IGZyb20gXCIuL2ZpdFR5cGVzXCI7XG5cbnR5cGUgUHJlUHVsbENoZWNrUmVzdWx0VHlwZSA9IChcbiAgICBcImxvY2FsQ29weVVwVG9EYXRlXCIgfFxuICAgIFwibG9jYWxDaGFuZ2VzQ2xhc2hXaXRoUmVtb3RlQ2hhbmdlc1wiIHxcbiAgICBcInJlbW90ZUNoYW5nZXNDYW5CZU1lcmdlZFwiIHxcbiAgICBcIm5vUmVtb3RlQ2hhbmdlc0RldGVjdGVkXCJcbilcblxudHlwZSBQcmVQdWxsQ2hlY2tSZXN1bHQgPSAoXG4gICAgeyBzdGF0dXM6IFwibG9jYWxDb3B5VXBUb0RhdGVcIiwgcmVtb3RlVXBkYXRlOiBudWxsIH0gfFxuICAgIHsgc3RhdHVzOiBFeGNsdWRlPFByZVB1bGxDaGVja1Jlc3VsdFR5cGUsIFwibG9jYWxDb3B5VXBUb0RhdGVcIj4sIHJlbW90ZVVwZGF0ZTogUmVtb3RlVXBkYXRlIH1cbik7XG5cbnR5cGUgU2F2ZUNhbGxiYWNrID0gKHBhdGg6IHN0cmluZywgbG9jYWxTdG9yZTogUGFydGlhbDxMb2NhbFN0b3Jlcz4pID0+IFByb21pc2U8dm9pZD5cblxuZXhwb3J0IGludGVyZmFjZSBJRml0UHVsbCB7XG4gICAgZml0OiBGaXRcbn1cblxuZXhwb3J0IGNsYXNzIEZpdFB1bGwgaW1wbGVtZW50cyBJRml0UHVsbCB7XG4gICAgZml0OiBGaXRcblxuXG4gICAgY29uc3RydWN0b3IoZml0OiBGaXQpIHtcbiAgICAgICAgdGhpcy5maXQgPSBmaXRcbiAgICB9XG5cbiAgICBhc3luYyBwZXJmb3JtUHJlUHVsbENoZWNrcyhsb2NhbENoYW5nZXM/OiBMb2NhbENoYW5nZVtdKTogUHJvbWlzZTxQcmVQdWxsQ2hlY2tSZXN1bHQ+IHtcbiAgICAgICAgY29uc3Qge3JlbW90ZUNvbW1pdFNoYSwgdXBkYXRlZH0gPSBhd2FpdCB0aGlzLmZpdC5yZW1vdGVVcGRhdGVkKClcbiAgICAgICAgaWYgKCF1cGRhdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4ge3N0YXR1czogXCJsb2NhbENvcHlVcFRvRGF0ZVwiLCByZW1vdGVVcGRhdGU6IG51bGx9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsb2NhbENoYW5nZXMpIHtcbiAgICAgICAgICAgIGxvY2FsQ2hhbmdlcyA9IGF3YWl0IHRoaXMuZml0LmdldExvY2FsQ2hhbmdlcygpXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVtb3RlVHJlZVNoYSA9IGF3YWl0IHRoaXMuZml0LmdldFJlbW90ZVRyZWVTaGEocmVtb3RlQ29tbWl0U2hhKVxuICAgICAgICBjb25zdCByZW1vdGVDaGFuZ2VzID0gYXdhaXQgdGhpcy5maXQuZ2V0UmVtb3RlQ2hhbmdlcyhyZW1vdGVUcmVlU2hhKVxuICAgICAgICBjb25zdCBjbGFzaGVkRmlsZXMgPSB0aGlzLmZpdC5nZXRDbGFzaGVkQ2hhbmdlcyhsb2NhbENoYW5nZXMsIHJlbW90ZUNoYW5nZXMpXG4gICAgICAgIC8vIFRPRE8gaGFuZGxlIGNsYXNoZXMgd2l0aG91dCBjb21wbGV0ZWx5IGJsb2NraW5nIHB1bGxcbiAgICAgICAgY29uc3QgcHJlUHVsbENoZWNrU3RhdHVzID0gKFxuICAgICAgICAgICAgKHJlbW90ZUNoYW5nZXMubGVuZ3RoID4gMCkgPyAoXG4gICAgICAgICAgICAgICAgKGNsYXNoZWRGaWxlcy5sZW5ndGggPiAwKSA/IFwibG9jYWxDaGFuZ2VzQ2xhc2hXaXRoUmVtb3RlQ2hhbmdlc1wiIDogXCJyZW1vdGVDaGFuZ2VzQ2FuQmVNZXJnZWRcIik6XG4gICAgICAgICAgICAgICAgXCJub1JlbW90ZUNoYW5nZXNEZXRlY3RlZFwiKVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0dXM6IHByZVB1bGxDaGVja1N0YXR1cyxcbiAgICAgICAgICAgIHJlbW90ZVVwZGF0ZToge1xuICAgICAgICAgICAgICAgIHJlbW90ZUNoYW5nZXMsIHJlbW90ZVRyZWVTaGEsIGxhdGVzdFJlbW90ZUNvbW1pdFNoYTogcmVtb3RlQ29tbWl0U2hhLCBjbGFzaGVkRmlsZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEdldCBjaGFuZ2VzIGZyb20gcmVtb3RlLCBwYXRoU2hhTWFwIGlzIGNvdXBsZWQgdG8gdGhlIEZpdCBwbHVnaW4gZGVzaWduXG4gICAgYXN5bmMgZ2V0UmVtb3RlTm9uRGVsZXRpb25DaGFuZ2VzQ29udGVudChwYXRoU2hhTWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KSB7XG4gICAgICAgIGNvbnN0IHJlbW90ZUNoYW5nZXMgPSBPYmplY3QuZW50cmllcyhwYXRoU2hhTWFwKS5tYXAoYXN5bmMgKFtwYXRoLCBmaWxlX3NoYV0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLmZpdC5nZXRCbG9iKGZpbGVfc2hhKTtcbiAgICAgICAgICAgIHJldHVybiB7cGF0aCwgY29udGVudH07XG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChyZW1vdGVDaGFuZ2VzKVxuICAgIH1cblxuICAgIGFzeW5jIHByZXBhcmVDaGFuZ2VzVG9FeGVjdXRlKHJlbW90ZUNoYW5nZXM6IFJlbW90ZUNoYW5nZVtdKSB7XG4gICAgICAgIGNvbnN0IGRlbGV0ZUZyb21Mb2NhbCA9IHJlbW90ZUNoYW5nZXMuZmlsdGVyKGM9PmMuc3RhdHVzPT1cIlJFTU9WRURcIikubWFwKGM9PmMucGF0aClcbiAgICAgICAgY29uc3QgY2hhbmdlc1RvUHJvY2VzcyA9IHJlbW90ZUNoYW5nZXMuZmlsdGVyKGM9PmMuc3RhdHVzIT1cIlJFTU9WRURcIikucmVkdWNlKFxuICAgICAgICAgICAgKGFjYywgY2hhbmdlKSA9PiB7XG4gICAgICAgICAgICAgICAgYWNjW2NoYW5nZS5wYXRoXSA9IGNoYW5nZS5jdXJyZW50U2hhIGFzIHN0cmluZztcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30gYXMgUmVjb3JkPHN0cmluZywgc3RyaW5nPik7XG5cbiAgICAgICAgY29uc3QgYWRkVG9Mb2NhbCA9IGF3YWl0IHRoaXMuZ2V0UmVtb3RlTm9uRGVsZXRpb25DaGFuZ2VzQ29udGVudChjaGFuZ2VzVG9Qcm9jZXNzKVxuXG4gICAgICAgIHJldHVybiB7YWRkVG9Mb2NhbCwgZGVsZXRlRnJvbUxvY2FsfVxuICAgIH1cblxuICAgIGFzeW5jIHB1bGxSZW1vdGVUb0xvY2FsKFxuICAgICAgICByZW1vdGVVcGRhdGU6IFJlbW90ZVVwZGF0ZSxcbiAgICAgICAgc2F2ZUxvY2FsU3RvcmVDYWxsYmFjazogU2F2ZUNhbGxiYWNrXG4gICAgKSA6IFByb21pc2U8RmlsZU9wUmVjb3JkW10+XG4gICAge1xuICAgICAgICAgICAgY29uc3Qge3JlbW90ZUNoYW5nZXMsIHJlbW90ZVRyZWVTaGEsIGxhdGVzdFJlbW90ZUNvbW1pdFNoYX0gPSByZW1vdGVVcGRhdGVcbiAgICAgICAgICAgIGxldCB7YWRkVG9Mb2NhbCwgZGVsZXRlRnJvbUxvY2FsfSA9IGF3YWl0IHRoaXMucHJlcGFyZUNoYW5nZXNUb0V4ZWN1dGUocmVtb3RlQ2hhbmdlcylcblxuICAgICAgICAgICAgY29uc3QgYmFzZXBhdGggPSB0aGlzLmZpdC5zeW5jUGF0aFxuICAgICAgICAgICAgYWRkVG9Mb2NhbCA9IHRoaXMuZml0LmdldEFkZFRvTG9jYWwoYWRkVG9Mb2NhbClcbiAgICAgICAgICAgIGRlbGV0ZUZyb21Mb2NhbCA9IHRoaXMuZml0LmdldERlbGV0ZUZyb21Mb2NhbChkZWxldGVGcm9tTG9jYWwpXG5cbiAgICAgICAgICAgIGNvbnN0IGZpbGVPcHNSZWNvcmQgPSBhd2FpdCB0aGlzLmZpdC52YXVsdE9wcy51cGRhdGVMb2NhbEZpbGVzKFxuICAgICAgICAgICAgICAgIGFkZFRvTG9jYWwsXG4gICAgICAgICAgICAgICAgZGVsZXRlRnJvbUxvY2FsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBhd2FpdCBzYXZlTG9jYWxTdG9yZUNhbGxiYWNrKFxuICAgICAgICAgICAgICAgIGJhc2VwYXRoLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdEZldGNoZWRSZW1vdGVTaGE6IHJlbW90ZVRyZWVTaGEsXG4gICAgICAgICAgICAgICAgICAgIGxhc3RGZXRjaGVkQ29tbWl0U2hhOiBsYXRlc3RSZW1vdGVDb21taXRTaGEsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU2hhOiBhd2FpdCB0aGlzLmZpdC5jb21wdXRlTG9jYWxTaGEoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiBmaWxlT3BzUmVjb3JkXG4gICAgfVxufVxuIiwgImltcG9ydCB7IEZpdCwgVHJlZU5vZGUgfSBmcm9tIFwiLi9maXRcIjtcbmltcG9ydCB7IExvY2FsQ2hhbmdlLCBMb2NhbFVwZGF0ZSB9IGZyb20gXCIuL2ZpdFR5cGVzXCI7XG5cblxuZXhwb3J0IGludGVyZmFjZSBJRml0UHVzaCB7XG4gICAgbG9jYWxTaGE6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgICBmaXQ6IEZpdFxufVxuXG5leHBvcnQgY2xhc3MgRml0UHVzaCBpbXBsZW1lbnRzIElGaXRQdXNoIHtcbiAgICBsb2NhbFNoYTogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgICBmaXQ6IEZpdFxuXG5cbiAgICBjb25zdHJ1Y3RvcihmaXQ6IEZpdCkge1xuICAgICAgICB0aGlzLmZpdCA9IGZpdFxuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZUNvbW1pdEZyb21Mb2NhbFVwZGF0ZShsb2NhbFVwZGF0ZTogTG9jYWxVcGRhdGUsIHJlbW90ZVRyZWU6IEFycmF5PFRyZWVOb2RlPik6IFByb21pc2U8e2NyZWF0ZWRDb21taXRTaGE6IHN0cmluZywgcHVzaGVkQ2hhbmdlczogTG9jYWxDaGFuZ2VbXX0gfCBudWxsPiB7XG4gICAgICAgIGNvbnN0IHtsb2NhbENoYW5nZXMsIHBhcmVudENvbW1pdFNoYX0gPSBsb2NhbFVwZGF0ZVxuICAgICAgICBjb25zdCBwdXNoZWRDaGFuZ2VzOiBMb2NhbENoYW5nZVtdID0gW107XG4gICAgICAgIGNvbnN0IHRyZWVOb2RlcyA9IChhd2FpdCBQcm9taXNlLmFsbChsb2NhbENoYW5nZXMubWFwKGFzeW5jIChmLCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gIGF3YWl0IHRoaXMuZml0LmNyZWF0ZVRyZWVOb2RlRnJvbUZpbGUoZiwgcmVtb3RlVHJlZSlcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgcHVzaGVkQ2hhbmdlcy5wdXNoKGxvY2FsQ2hhbmdlc1tpXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSkpLmZpbHRlcihCb29sZWFuKSBhcyBBcnJheTxUcmVlTm9kZT5cbiAgICAgICAgY29uc29sZS5sb2codHJlZU5vZGVzKVxuICAgICAgICBpZiAodHJlZU5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXRlc3RSZW1vdGVDb21taXRUcmVlU2hhID0gYXdhaXQgdGhpcy5maXQuZ2V0Q29tbWl0VHJlZVNoYShwYXJlbnRDb21taXRTaGEpXG4gICAgICAgIGNvbnN0IGNyZWF0ZWRUcmVlU2hhID0gYXdhaXQgdGhpcy5maXQuY3JlYXRlVHJlZSh0cmVlTm9kZXMsIGxhdGVzdFJlbW90ZUNvbW1pdFRyZWVTaGEpXG4gICAgICAgIGNvbnN0IGNyZWF0ZWRDb21taXRTaGEgPSBhd2FpdCB0aGlzLmZpdC5jcmVhdGVDb21taXQoY3JlYXRlZFRyZWVTaGEsIHBhcmVudENvbW1pdFNoYSlcbiAgICAgICAgcmV0dXJuIHtjcmVhdGVkQ29tbWl0U2hhLCBwdXNoZWRDaGFuZ2VzfVxuICAgIH1cblxuXG5cbiAgICBhc3luYyBwdXNoQ2hhbmdlZEZpbGVzVG9SZW1vdGUoXG4gICAgICAgIGxvY2FsVXBkYXRlOiBMb2NhbFVwZGF0ZSxcbiAgICAgICAgKTogUHJvbWlzZTx7cHVzaGVkQ2hhbmdlczogTG9jYWxDaGFuZ2VbXSwgbGFzdEZldGNoZWRSZW1vdGVTaGE6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4sIGxhc3RGZXRjaGVkQ29tbWl0U2hhOiBzdHJpbmd9fG51bGw+IHtcbiAgICAgICAgICAgIGlmIChsb2NhbFVwZGF0ZS5sb2NhbENoYW5nZXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBkaWQgbm90IHVwZGF0ZSByZWZcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29uc3Qge2xvY2FsVHJlZVNoYX0gPSBsb2NhbFVwZGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IHJlbW90ZVRyZWUgPSBhd2FpdCB0aGlzLmZpdC5nZXRUcmVlKGxvY2FsVXBkYXRlLnBhcmVudENvbW1pdFNoYSlcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZUNvbW1pdFJlc3VsdCA9IGF3YWl0IHRoaXMuY3JlYXRlQ29tbWl0RnJvbUxvY2FsVXBkYXRlKGxvY2FsVXBkYXRlLCByZW1vdGVUcmVlKVxuICAgICAgICAgICAgaWYgKCFjcmVhdGVDb21taXRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAvLyBkaWQgbm90IHVwZGF0ZSByZWZcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qge2NyZWF0ZWRDb21taXRTaGEsIHB1c2hlZENoYW5nZXN9ID0gY3JlYXRlQ29tbWl0UmVzdWx0XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkUmVmU2hhID0gYXdhaXQgdGhpcy5maXQudXBkYXRlUmVmKGNyZWF0ZWRDb21taXRTaGEpXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkUmVtb3RlVHJlZVNoYSA9IGF3YWl0IHRoaXMuZml0LmdldFJlbW90ZVRyZWVTaGEodXBkYXRlZFJlZlNoYSlcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcHVzaGVkQ2hhbmdlcyxcbiAgICAgICAgICAgICAgICBsYXN0RmV0Y2hlZFJlbW90ZVNoYTogdXBkYXRlZFJlbW90ZVRyZWVTaGEsXG4gICAgICAgICAgICAgICAgbGFzdEZldGNoZWRDb21taXRTaGE6IGNyZWF0ZWRDb21taXRTaGEsXG4gICAgICAgICAgICB9XG4gICAgfVxufVxuIiwgImltcG9ydCB7IExpc3RlZEZpbGVzLCBURmlsZSwgVEZvbGRlciwgVmF1bHQsIGJhc2U2NFRvQXJyYXlCdWZmZXIgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IEZpbGVPcFJlY29yZCB9IGZyb20gXCIuL2ZpdFR5cGVzXCI7XG5pbXBvcnQgeyBjb25mbGljdFJlc29sdXRpb25Gb2xkZXIgfSBmcm9tIFwiLi9jb25zdFwiO1xuXG50eXBlIEZpbGVzRm9sZGVycyA9IHtcbiAgICBmb2xkZXJzOiBzdHJpbmdbXVxuICAgIGZpbGVzOiBzdHJpbmdbXVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElWYXVsdE9wZXJhdGlvbnMge1xuICAgIHZhdWx0OiBWYXVsdFxuICAgIGRlbGV0ZUZyb21Mb2NhbDogKHBhdGg6IHN0cmluZykgPT4gUHJvbWlzZTxGaWxlT3BSZWNvcmQgfCBudWxsPlxuICAgIHdyaXRlVG9Mb2NhbDogKHBhdGg6IHN0cmluZywgY29udGVudDogc3RyaW5nKSA9PiBQcm9taXNlPEZpbGVPcFJlY29yZD5cbiAgICB1cGRhdGVMb2NhbEZpbGVzOiAoXG4gICAgICAgIGFkZFRvTG9jYWw6IHtwYXRoOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZ31bXSxcbiAgICAgICAgZGVsZXRlRnJvbUxvY2FsOiBBcnJheTxzdHJpbmc+XG4gICAgKSA9PiBQcm9taXNlPEZpbGVPcFJlY29yZFtdPlxuXG4gICAgY3JlYXRlQ29weUluRGlyOiAocGF0aDogc3RyaW5nLCBjb3B5RGlyOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD5cbn1cblxuZXhwb3J0IGNsYXNzIFZhdWx0T3BlcmF0aW9ucyBpbXBsZW1lbnRzIElWYXVsdE9wZXJhdGlvbnMge1xuICAgIHZhdWx0OiBWYXVsdFxuXG4gICAgY29uc3RydWN0b3IodmF1bHQ6IFZhdWx0KSB7XG4gICAgICAgIHRoaXMudmF1bHQgPSB2YXVsdFxuICAgIH1cblxuICAgIGFzeW5jIGdldFRGaWxlKHBhdGg6IHN0cmluZyk6IFByb21pc2U8VEZpbGUgfCBudWxsPiB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwYXRoKVxuICAgICAgICBpZiAoZmlsZSAmJiBmaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWxlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKGBBdHRlbXB0aW5nIHRvIHJlYWQgJHtwYXRofSBmcm9tIGxvY2FsIGRyaXZlIGFzIFRGaWxlIGJ1dCBub3Qgc3VjY2Vzc2Z1bCxcbiAgICAgICAgICAgIC8vIGZpbGUgaXMgb2YgdHlwZSAke3R5cGVvZiBmaWxlfS5gKVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZGVsZXRlRnJvbUxvY2FsKHBhdGg6IHN0cmluZyk6IFByb21pc2U8RmlsZU9wUmVjb3JkIHwgbnVsbD4ge1xuICAgICAgICAvLyBhZG9wdGVkIGdldEFic3RyYWN0RmlsZUJ5UGF0aCBmb3IgbW9iaWxlIGNvbXBhdGlhYmlsaXR5XG4gICAgICAgIC8vIHVzZSBhZGFwdGVyIGZvciBmaWxlcyBpbiB0aGUgLm9ic2lkaWFuXG4gICAgICAgIC8vIGNvbnN0IGZpbGUgPSB0aGlzLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwYXRoKVxuICAgICAgICBjb25zdCBpc0V4aXN0cyA9IGF3YWl0IHRoaXMudmF1bHQuYWRhcHRlci5leGlzdHMocGF0aClcbiAgICAgICAgaWYgKCFpc0V4aXN0cykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQXR0ZW1wdGluZyB0byByZWFkICR7cGF0aH0gZnJvbSBsb2NhbCBkcml2ZSBidXQgbm90IHN1Y2Nlc3NmdWw6XG4gICAgICAgICAgICAgICAgdGhlIGZpbGUgZG9lc24ndCBleGlzdHNgKVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgdGhpcy52YXVsdC5hZGFwdGVyLnJlbW92ZShwYXRoKTtcbiAgICAgICAgcmV0dXJuIHtwYXRoLCBzdGF0dXM6IFwiZGVsZXRlZFwifVxuICAgIH1cblxuICAgIC8vIGlmIGNoZWNraW5nIGEgZm9sZGVyLCByZXF1aXJlIGluY2x1ZGluZyB0aGUgbGFzdCAvIGluIHRoZSBwYXRoIHBhcmFtXG4gICAgYXN5bmMgZW5zdXJlRm9sZGVyRXhpc3RzKHBhdGg6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICAvLyBleHRyYWN0IGZvbGRlciBwYXRoLCByZXR1cm4gZW1wdHkgc3RyaW5nIGlzIG5vIGZvbGRlciBwYXRoIGlzIG1hdGNoZWQgKGV4Y2x1ZGUgdGhlIGxhc3QgLylcbiAgICAgICAgY29uc3QgZm9sZGVyUGF0aCA9IHBhdGgubWF0Y2goL14oLiopXFwvLyk/LlsxXSB8fCAnJztcbiAgICAgICAgaWYgKGZvbGRlclBhdGggPT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAvLyBjb25zdCBmb2xkZXIgPSB0aGlzLnZhdWx0LmFkYXB0ZXIuZXhpc3RzKGZvbGRlclBhdGgpXG4gICAgICAgICAgICAvLyBpZiAoIWZvbGRlcikge1xuICAgICAgICAgICAgLy8gICAgIC8vIFRPRE8gXHUwNDQ3XHUwNDQyXHUwNDNFIFx1MDQzNVx1MDQ0MVx1MDQzQlx1MDQzOCBcdTA0M0RcdTA0MzVcdTA0NDFcdTA0M0FcdTA0M0VcdTA0M0JcdTA0NENcdTA0M0FcdTA0M0UgXHUwNDMyXHUwNDNCXHUwNDNFXHUwNDM2XHUwNDM1XHUwNDNEXHUwNDNEXHUwNDRCXHUwNDQ1IFx1MDQzRlx1MDQzMFx1MDQzRlx1MDQzRVx1MDQzQSAobWtkaXIgLXAgLi4uLilcbiAgICAgICAgICAgIC8vICAgICBhd2FpdCB0aGlzLnZhdWx0LmFkYXB0ZXIubWtkaXIoZm9sZGVyUGF0aClcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJ0cyA9IGZvbGRlclBhdGguc3BsaXQoJy8nKTtcbiAgICAgICAgbGV0IGN1cnJlbnRQYXRoID0gJyc7XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgICAgICAgICAgY3VycmVudFBhdGggKz0gcGFydCArICcvJztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNFeGlzdHMgPSBhd2FpdCB0aGlzLnZhdWx0LmFkYXB0ZXIuZXhpc3RzKGN1cnJlbnRQYXRoLCB0cnVlKVxuXG4gICAgICAgICAgICAgICAgaWYgKGlzRXhpc3RzKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy52YXVsdC5hZGFwdGVyLm1rZGlyKGN1cnJlbnRQYXRoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGFzeW5jIHdyaXRlVG9Mb2NhbChwYXRoOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyk6IFByb21pc2U8RmlsZU9wUmVjb3JkPiB7XG4gICAgICAgIC8vIFRPRE86IGFkZCBjYXBhYmlsaXR5IGZvciBjcmVhdGluZyBmb2xkZXIgZnJvbSByZW1vdGVcbiAgICAgICAgY29uc3QgZmlsZSA9IGF3YWl0IHRoaXMudmF1bHQuYWRhcHRlci5leGlzdHMocGF0aClcblxuICAgICAgICAvLyBUT0RPIHJlZmFjdG9yIGlmIGVsc2VcbiAgICAgICAgaWYgKGZpbGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudmF1bHQuYWRhcHRlci53cml0ZUJpbmFyeShwYXRoLCBiYXNlNjRUb0FycmF5QnVmZmVyKGNvbnRlbnQpKVxuICAgICAgICAgICAgcmV0dXJuIHtwYXRoLCBzdGF0dXM6IFwiY2hhbmdlZFwifVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5lbnN1cmVGb2xkZXJFeGlzdHMocGF0aClcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudmF1bHQuYWRhcHRlci53cml0ZUJpbmFyeShwYXRoLCBiYXNlNjRUb0FycmF5QnVmZmVyKGNvbnRlbnQpKVxuICAgICAgICAgICAgcmV0dXJuIHtwYXRoLCBzdGF0dXM6IFwiY3JlYXRlZFwifVxuICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoYCR7cGF0aH06IHdyaXRlVG9Mb2NhbCBvcGVyYXRpb24gdW5zdWNjZXNzZnVsYCk7XG4gICAgfVxuXG4gICAgYXN5bmMgdXBkYXRlTG9jYWxGaWxlcyhcbiAgICAgICAgYWRkVG9Mb2NhbDoge3BhdGg6IHN0cmluZywgY29udGVudDogc3RyaW5nfVtdLFxuICAgICAgICBkZWxldGVGcm9tTG9jYWw6IEFycmF5PHN0cmluZz4pOiBQcm9taXNlPEZpbGVPcFJlY29yZFtdPlxuICAgIHtcbiAgICAgICAgLy8gUHJvY2VzcyBmaWxlIGFkZGl0aW9ucyBvciB1cGRhdGVzXG4gICAgICAgIGNvbnN0IHdyaXRlT3BlcmF0aW9ucyA9IGFkZFRvTG9jYWwubWFwKGFzeW5jICh7cGF0aCwgY29udGVudH0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLndyaXRlVG9Mb2NhbChwYXRoLCBjb250ZW50KVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBQcm9jZXNzIGZpbGUgZGVsZXRpb25zXG4gICAgICAgIGNvbnN0IGRlbGV0aW9uT3BlcmF0aW9ucyA9IGRlbGV0ZUZyb21Mb2NhbC5tYXAoYXN5bmMgKHBhdGgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmRlbGV0ZUZyb21Mb2NhbChwYXRoKVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZmlsZU9wcyA9IGF3YWl0IFByb21pc2UuYWxsKFsuLi53cml0ZU9wZXJhdGlvbnMsIC4uLmRlbGV0aW9uT3BlcmF0aW9uc10pO1xuXG4gICAgICAgIHJldHVybiBmaWxlT3BzIGFzIEZpbGVPcFJlY29yZFtdXG4gICAgfVxuXG4gICAgLy8gVE9ETyBcdTA0NDVcdTA0M0VcdTA0NDJcdTA0NEYgXHUwNDNEXHUwNDM4XHUwNDMzXHUwNDM0XHUwNDM1IFx1MDQzRFx1MDQzNSBcdTA0MzhcdTA0NDFcdTA0M0ZcdTA0M0VcdTA0M0JcdTA0NENcdTA0MzdcdTA0NDNcdTA0MzVcdTA0NDJcdTA0NDFcdTA0NEYsIFx1MDQzQ1x1MDQzMSBcdTA0NDNcdTA0MzRcdTA0MzBcdTA0M0JcdTA0MzhcdTA0NDJcdTA0NEMgXHUwNDNEXHUwNDMwXHUwNDM0XHUwNDNFXG4gICAgYXN5bmMgY3JlYXRlQ29weUluRGlyKHBhdGg6IHN0cmluZywgY29weURpciA9IGNvbmZsaWN0UmVzb2x1dGlvbkZvbGRlcik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBmaWxlID0gYXdhaXQgdGhpcy52YXVsdC5hZGFwdGVyLmV4aXN0cyhwYXRoKVxuICAgICAgICBpZiAoZmlsZSkge1xuICAgICAgICAgICAgY29uc3QgY29weVBhdGggPSBjb3B5RGlyICsgcGF0aFxuXG4gICAgICAgICAgICBjb25zdCBjb3B5ID0gYXdhaXQgdGhpcy52YXVsdC5hZGFwdGVyLnJlYWRCaW5hcnkocGF0aClcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlRm9sZGVyRXhpc3RzKGNvcHlQYXRoKVxuXG4gICAgICAgICAgICAvLyBjb25zdCBjb3B5RmlsZSA9IGF3YWl0IHRoaXMudmF1bHQuYWRhcHRlci5leGlzdHMocGF0aClcbiAgICAgICAgICAgIC8vIGlmIChjb3B5RmlsZSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudmF1bHQuYWRhcHRlci53cml0ZUJpbmFyeShjb3B5UGF0aCwgY29weSlcbiAgICAgICAgICAgIC8vIH0gZWxzZSBpZiAoIWNvcHlGaWxlKSB7XG4gICAgICAgICAgICAvLyAgICAgYXdhaXQgdGhpcy52YXVsdC5jcmVhdGVCaW5hcnkoY29weVBhdGgsIGNvcHkpXG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gICAgIHRoaXMudmF1bHQuYWRhcHRlci5yZW1vdmUoY29weUZpbGUpIC8vIFRPRE8gYWRkIHdhcm5pbmcgdG8gbGV0IHVzZXIga25vdyBmaWxlcyBpbiBfZml0IHdpbGwgYmUgb3ZlcndyaXR0ZW5cbiAgICAgICAgICAgIC8vICAgICBhd2FpdCB0aGlzLnZhdWx0LmNyZWF0ZUJpbmFyeShjb3B5UGF0aCwgY29weSlcbiAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgYXdhaXQgdGhpcy52YXVsdC5hZGFwdGVyLndyaXRlQmluYXJ5KGNvcHlQYXRoLCBjb3B5KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdHRlbXB0aW5nIHRvIGNyZWF0ZSBjb3B5IG9mICR7cGF0aH0gZnJvbSBsb2NhbCBkcml2ZSBhcyBURmlsZSBidXQgbm90IHN1Y2Nlc3NmdWwsXG4gICAgICAgICAgICBmaWxlIGlzIG9mIHR5cGUgJHt0eXBlb2YgZmlsZX0uYClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGdldEFsbEluT2JzaWRpYW4oKTogUHJvbWlzZTxGaWxlc0ZvbGRlcnM+IHtcbiAgICAgICAgY29uc3Qgcm9vdFBhdGggPSB0aGlzLnZhdWx0LmNvbmZpZ0RpcjtcblxuICAgICAgICBjb25zdCBmb2xkZXJzOiBzdHJpbmdbXSA9IFtyb290UGF0aCArIFwiL1wiXTtcbiAgICAgICAgY29uc3QgZmlsZXM6IHN0cmluZ1tdID0gW107XG5cbiAgICAgICAgY29uc3QgdHJhdmVyc2VEaXJlY3RvcnkgPSBhc3luYyAocGF0aDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICBsZXQgaXRlbXM6IExpc3RlZEZpbGVzXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGl0ZW1zID0gYXdhaXQgdGhpcy52YXVsdC5hZGFwdGVyLmxpc3QocGF0aCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoYEVycm9yIHRyYXZlcnNpbmcgZGlyZWN0b3J5ICR7cGF0aH06YCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgZm9sZGVyIG9mIGl0ZW1zLmZvbGRlcnMpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0cmF2ZXJzZURpcmVjdG9yeShmb2xkZXIpO1xuXG4gICAgICAgICAgICAgICAgbGV0IGZvbGRlclBhdGggPSBmb2xkZXIuc3RhcnRzV2l0aCgnLycpID8gZm9sZGVyLnNsaWNlKDEpIDogZm9sZGVyO1xuICAgICAgICAgICAgICAgIGZvbGRlclBhdGggPSBmb2xkZXJQYXRoID09PSBcIlwiID8gXCJcIiA6IGAke2ZvbGRlclBhdGh9L2A7XG5cbiAgICAgICAgICAgICAgICBmb2xkZXJzLnB1c2goZm9sZGVyUGF0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgZmlsZSBvZiBpdGVtcy5maWxlcykge1xuICAgICAgICAgICAgICAgIGxldCBmaWxlUGF0aCA9IGZpbGUuc3RhcnRzV2l0aCgnLycpID8gZmlsZS5zbGljZSgxKSA6IGZpbGU7XG5cbiAgICAgICAgICAgICAgICBmaWxlcy5wdXNoKGZpbGVQYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBhd2FpdCB0cmF2ZXJzZURpcmVjdG9yeShyb290UGF0aCk7XG5cbiAgICAgICAgcmV0dXJuIHtmb2xkZXJzLCBmaWxlc31cbiAgICB9XG5cbiAgICBhc3luYyBnZXRBbGxJblZhdWx0KCk6IFByb21pc2U8RmlsZXNGb2xkZXJzPiB7XG4gICAgICAgIGNvbnN0IGFsbCA9IHRoaXMudmF1bHQuZ2V0QWxsTG9hZGVkRmlsZXMoKTtcblxuICAgICAgICBjb25zdCBmb2xkZXJzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBjb25zdCBmaWxlczogc3RyaW5nW10gPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBmaWxlIG9mIGFsbCkge1xuICAgICAgICAgICAgaWYgKGZpbGUgaW5zdGFuY2VvZiBURm9sZGVyKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhdGggPSBmaWxlLnBhdGguc3RhcnRzV2l0aCgnLycpID8gZmlsZS5wYXRoLnNsaWNlKDEpIDogZmlsZS5wYXRoO1xuICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoID09IFwiXCIgPyBcIlwiIDogYCR7cGF0aH0vYFxuICAgICAgICAgICAgICAgIGZvbGRlcnMucHVzaChwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSBmaWxlLnBhdGguc3RhcnRzV2l0aCgnLycpID8gZmlsZS5wYXRoLnNsaWNlKDEpIDogZmlsZS5wYXRoO1xuICAgICAgICAgICAgICAgIGZpbGVzLnB1c2gocGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyAub2JzaWRpYW4gZm9sZGVyXG4gICAgICAgIGNvbnN0IG9ic2lkaWFuSXRlbXMgPSBhd2FpdCB0aGlzLmdldEFsbEluT2JzaWRpYW4oKVxuICAgICAgICBjb25zdCBbb2JzaWRpYW5GaWxlcywgb2JzaWRpYW5Gb2xkZXJzXSA9IFtvYnNpZGlhbkl0ZW1zLmZpbGVzLCBvYnNpZGlhbkl0ZW1zLmZvbGRlcnNdXG5cbiAgICAgICAgZm9sZGVycy5wdXNoKC4uLm9ic2lkaWFuRm9sZGVycylcbiAgICAgICAgZmlsZXMucHVzaCguLi5vYnNpZGlhbkZpbGVzKVxuXG4gICAgICAgIHJldHVybiB7Zm9sZGVycywgZmlsZXN9O1xuICAgIH1cblxuICAgIGFzeW5jIGdldEZvbGRlcnNJblZhdWx0KCk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICAgICAgY29uc3Qge2ZvbGRlcnN9ID0gYXdhaXQgdGhpcy5nZXRBbGxJblZhdWx0KClcblxuICAgICAgICByZXR1cm4gZm9sZGVycztcbiAgICB9XG5cbiAgICBhc3luYyBnZXRGaWxlc0luVmF1bHQoKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgICAgICBjb25zdCB7ZmlsZXN9ID0gYXdhaXQgdGhpcy5nZXRBbGxJblZhdWx0KClcblxuICAgICAgICByZXR1cm4gZmlsZXM7XG4gICAgfVxufVxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGlCQUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxtQkFBeUQ7OztBQ0FsRCxJQUFNLGdCQUFnQjtBQUV0QixJQUFNLHFCQUFxQixnQkFBZ0I7QUFDM0MsSUFBTSwyQkFBMkIsZ0JBQWdCO0FBRWpELElBQU0sd0JBQXdCOzs7QUNMOUIsU0FBUyxlQUFlO0FBQzdCLE1BQUksT0FBTyxjQUFjLFlBQVksZUFBZSxXQUFXO0FBQzdELFdBQU8sVUFBVTtBQUFBLEVBQ25CO0FBRUEsTUFBSSxPQUFPLFlBQVksWUFBWSxRQUFRLFlBQVksUUFBVztBQUNoRSxXQUFPLFdBQVcsUUFBUSxRQUFRLE9BQU8sQ0FBQyxNQUFNLFFBQVEsYUFDdEQsUUFBUTtBQUFBLEVBRVo7QUFFQSxTQUFPO0FBQ1Q7OztBQ1ZPLFNBQVMsU0FB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S0FBSyxPQUFPLFdBQVc7QUFBQSxRQUM3RDtBQUFBLE1BQ0o7QUFDQSxnQkFBVTtBQUVWLGdCQUFVLHdCQUF3QixjQUFjLE9BQU8sY0FBYztBQUNyRSxnQkFBVTtBQUFBLElBQ2Q7QUFFQSxXQUFPO0FBQUEsRUFFWDtBQUVKOyIsCiAgIm5hbWVzIjogWyJGaXRQbHVnaW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgIm5hbWUiLCAibWV0aG9kIiwgImhvb2siLCAiaG9vayIsICJnZXRVc2VyQWdlbnQiLCAiZ2V0VXNlckFnZW50IiwgImdldFVzZXJBZ2VudCIsICJWRVJTSU9OIiwgImlzUGxhaW5PYmplY3QiLCAid2l0aERlZmF1bHRzIiwgImdldFVzZXJBZ2VudCIsICJnZXRVc2VyQWdlbnQiLCAiVkVSU0lPTiIsICJ3aXRoRGVmYXVsdHMiLCAiZ2V0VXNlckFnZW50IiwgInJlcXVlc3QiLCAiZW5kcG9pbnQiLCAiVkVSU0lPTiIsICJWRVJTSU9OIiwgImhvb2siLCAiYXV0aCIsICJ2YWx1ZSIsICJoZWFkaW5nIiwgImltcG9ydF9vYnNpZGlhbiIsICJyZXN1bHQiLCAiaW1wb3J0X29ic2lkaWFuIiwgIl9hIiwgImltcG9ydF9vYnNpZGlhbiIsICJmb2xkZXJzIiwgImltcG9ydF9vYnNpZGlhbiIsICJyZW1vdGVDb250ZW50IiwgImltcG9ydF9vYnNpZGlhbiIsICJGaXRQbHVnaW4iXQp9Cg==
