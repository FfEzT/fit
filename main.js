/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// main.ts
var main_exports = {};
__export(main_exports, {
  DEFAULT_LOCAL_STORE: () => DEFAULT_LOCAL_STORE,
  DEFAULT_REPOSITORY: () => DEFAULT_REPOSITORY,
  default: () => FitPlugin2
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// node_modules/@octokit/core/node_modules/universal-user-agent/index.js
function getUserAgent() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && process.version !== void 0) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}

// node_modules/before-after-hook/lib/register.js
function register(state, name, method, options) {
  if (typeof method !== "function") {
    throw new Error("method for before hook must be a function");
  }
  if (!options) {
    options = {};
  }
  if (Array.isArray(name)) {
    return name.reverse().reduce((callback, name2) => {
      return register.bind(null, state, name2, callback, options);
    }, method)();
  }
  return Promise.resolve().then(() => {
    if (!state.registry[name]) {
      return method(options);
    }
    return state.registry[name].reduce((method2, registered) => {
      return registered.hook.bind(null, method2, options);
    }, method)();
  });
}

// node_modules/before-after-hook/lib/add.js
function addHook(state, kind, name, hook2) {
  const orig = hook2;
  if (!state.registry[name]) {
    state.registry[name] = [];
  }
  if (kind === "before") {
    hook2 = (method, options) => {
      return Promise.resolve().then(orig.bind(null, options)).then(method.bind(null, options));
    };
  }
  if (kind === "after") {
    hook2 = (method, options) => {
      let result;
      return Promise.resolve().then(method.bind(null, options)).then((result_) => {
        result = result_;
        return orig(result, options);
      }).then(() => {
        return result;
      });
    };
  }
  if (kind === "error") {
    hook2 = (method, options) => {
      return Promise.resolve().then(method.bind(null, options)).catch((error) => {
        return orig(error, options);
      });
    };
  }
  state.registry[name].push({
    hook: hook2,
    orig
  });
}

// node_modules/before-after-hook/lib/remove.js
function removeHook(state, name, method) {
  if (!state.registry[name]) {
    return;
  }
  const index = state.registry[name].map((registered) => {
    return registered.orig;
  }).indexOf(method);
  if (index === -1) {
    return;
  }
  state.registry[name].splice(index, 1);
}

// node_modules/before-after-hook/index.js
var bind = Function.bind;
var bindable = bind.bind(bind);
function bindApi(hook2, state, name) {
  const removeHookRef = bindable(removeHook, null).apply(
    null,
    name ? [state, name] : [state]
  );
  hook2.api = { remove: removeHookRef };
  hook2.remove = removeHookRef;
  ["before", "error", "after", "wrap"].forEach((kind) => {
    const args = name ? [state, kind, name] : [state, kind];
    hook2[kind] = hook2.api[kind] = bindable(addHook, null).apply(null, args);
  });
}
function Singular() {
  const singularHookName = Symbol("Singular");
  const singularHookState = {
    registry: {}
  };
  const singularHook = register.bind(null, singularHookState, singularHookName);
  bindApi(singularHook, singularHookState, singularHookName);
  return singularHook;
}
function Collection() {
  const state = {
    registry: {}
  };
  const hook2 = register.bind(null, state);
  bindApi(hook2, state);
  return hook2;
}
var before_after_hook_default = { Singular, Collection };

// node_modules/@octokit/endpoint/node_modules/universal-user-agent/index.js
function getUserAgent2() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && process.version !== void 0) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}

// node_modules/@octokit/endpoint/dist-bundle/index.js
var VERSION = "0.0.0-development";
var userAgent = `octokit-endpoint.js/${VERSION} ${getUserAgent2()}`;
var DEFAULTS = {
  method: "GET",
  baseUrl: "https://api.github.com",
  headers: {
    accept: "application/vnd.github.v3+json",
    "user-agent": userAgent
  },
  mediaType: {
    format: ""
  }
};
function lowercaseKeys(object) {
  if (!object) {
    return {};
  }
  return Object.keys(object).reduce((newObj, key) => {
    newObj[key.toLowerCase()] = object[key];
    return newObj;
  }, {});
}
function isPlainObject(value) {
  if (typeof value !== "object" || value === null)
    return false;
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
function mergeDeep(defaults, options) {
  const result = Object.assign({}, defaults);
  Object.keys(options).forEach((key) => {
    if (isPlainObject(options[key])) {
      if (!(key in defaults))
        Object.assign(result, { [key]: options[key] });
      else
        result[key] = mergeDeep(defaults[key], options[key]);
    } else {
      Object.assign(result, { [key]: options[key] });
    }
  });
  return result;
}
function removeUndefinedProperties(obj) {
  for (const key in obj) {
    if (obj[key] === void 0) {
      delete obj[key];
    }
  }
  return obj;
}
function merge(defaults, route, options) {
  var _a;
  if (typeof route === "string") {
    let [method, url] = route.split(" ");
    options = Object.assign(url ? { method, url } : { url: method }, options);
  } else {
    options = Object.assign({}, route);
  }
  options.headers = lowercaseKeys(options.headers);
  removeUndefinedProperties(options);
  removeUndefinedProperties(options.headers);
  const mergedOptions = mergeDeep(defaults || {}, options);
  if (options.url === "/graphql") {
    if (defaults && ((_a = defaults.mediaType.previews) == null ? void 0 : _a.length)) {
      mergedOptions.mediaType.previews = defaults.mediaType.previews.filter(
        (preview) => !mergedOptions.mediaType.previews.includes(preview)
      ).concat(mergedOptions.mediaType.previews);
    }
    mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview) => preview.replace(/-preview/, ""));
  }
  return mergedOptions;
}
function addQueryParameters(url, parameters) {
  const separator = /\?/.test(url) ? "&" : "?";
  const names = Object.keys(parameters);
  if (names.length === 0) {
    return url;
  }
  return url + separator + names.map((name) => {
    if (name === "q") {
      return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
    }
    return `${name}=${encodeURIComponent(parameters[name])}`;
  }).join("&");
}
var urlVariableRegex = /\{[^}]+\}/g;
function removeNonChars(variableName) {
  return variableName.replace(/^\W+|\W+$/g, "").split(/,/);
}
function extractUrlVariableNames(url) {
  const matches = url.match(urlVariableRegex);
  if (!matches) {
    return [];
  }
  return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
}
function omit(object, keysToOmit) {
  const result = { __proto__: null };
  for (const key of Object.keys(object)) {
    if (keysToOmit.indexOf(key) === -1) {
      result[key] = object[key];
    }
  }
  return result;
}
function encodeReserved(str) {
  return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
    if (!/%[0-9A-Fa-f]/.test(part)) {
      part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
    }
    return part;
  }).join("");
}
function encodeUnreserved(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
    return "%" + c.charCodeAt(0).toString(16).toUpperCase();
  });
}
function encodeValue(operator, value, key) {
  value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);
  if (key) {
    return encodeUnreserved(key) + "=" + value;
  } else {
    return value;
  }
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isKeyOperator(operator) {
  return operator === ";" || operator === "&" || operator === "?";
}
function getValues(context, operator, key, modifier) {
  var value = context[key], result = [];
  if (isDefined(value) && value !== "") {
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      value = value.toString();
      if (modifier && modifier !== "*") {
        value = value.substring(0, parseInt(modifier, 10));
      }
      result.push(
        encodeValue(operator, value, isKeyOperator(operator) ? key : "")
      );
    } else {
      if (modifier === "*") {
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            result.push(
              encodeValue(operator, value2, isKeyOperator(operator) ? key : "")
            );
          });
        } else {
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k])) {
              result.push(encodeValue(operator, value[k], k));
            }
          });
        }
      } else {
        const tmp = [];
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            tmp.push(encodeValue(operator, value2));
          });
        } else {
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k])) {
              tmp.push(encodeUnreserved(k));
              tmp.push(encodeValue(operator, value[k].toString()));
            }
          });
        }
        if (isKeyOperator(operator)) {
          result.push(encodeUnreserved(key) + "=" + tmp.join(","));
        } else if (tmp.length !== 0) {
          result.push(tmp.join(","));
        }
      }
    }
  } else {
    if (operator === ";") {
      if (isDefined(value)) {
        result.push(encodeUnreserved(key));
      }
    } else if (value === "" && (operator === "&" || operator === "?")) {
      result.push(encodeUnreserved(key) + "=");
    } else if (value === "") {
      result.push("");
    }
  }
  return result;
}
function parseUrl(template) {
  return {
    expand: expand.bind(null, template)
  };
}
function expand(template, context) {
  var operators = ["+", "#", ".", "/", ";", "?", "&"];
  template = template.replace(
    /\{([^\{\}]+)\}|([^\{\}]+)/g,
    function(_, expression, literal) {
      if (expression) {
        let operator = "";
        const values = [];
        if (operators.indexOf(expression.charAt(0)) !== -1) {
          operator = expression.charAt(0);
          expression = expression.substr(1);
        }
        expression.split(/,/g).forEach(function(variable) {
          var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
          values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
        });
        if (operator && operator !== "+") {
          var separator = ",";
          if (operator === "?") {
            separator = "&";
          } else if (operator !== "#") {
            separator = operator;
          }
          return (values.length !== 0 ? operator : "") + values.join(separator);
        } else {
          return values.join(",");
        }
      } else {
        return encodeReserved(literal);
      }
    }
  );
  if (template === "/") {
    return template;
  } else {
    return template.replace(/\/$/, "");
  }
}
function parse(options) {
  var _a;
  let method = options.method.toUpperCase();
  let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
  let headers = Object.assign({}, options.headers);
  let body;
  let parameters = omit(options, [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "mediaType"
  ]);
  const urlVariableNames = extractUrlVariableNames(url);
  url = parseUrl(url).expand(parameters);
  if (!/^http/.test(url)) {
    url = options.baseUrl + url;
  }
  const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
  const remainingParameters = omit(parameters, omittedParameters);
  const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
  if (!isBinaryRequest) {
    if (options.mediaType.format) {
      headers.accept = headers.accept.split(/,/).map(
        (format) => format.replace(
          /application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/,
          `application/vnd$1$2.${options.mediaType.format}`
        )
      ).join(",");
    }
    if (url.endsWith("/graphql")) {
      if ((_a = options.mediaType.previews) == null ? void 0 : _a.length) {
        const previewsFromAcceptHeader = headers.accept.match(/[\w-]+(?=-preview)/g) || [];
        headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
          const format = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
          return `application/vnd.github.${preview}-preview${format}`;
        }).join(",");
      }
    }
  }
  if (["GET", "HEAD"].includes(method)) {
    url = addQueryParameters(url, remainingParameters);
  } else {
    if ("data" in remainingParameters) {
      body = remainingParameters.data;
    } else {
      if (Object.keys(remainingParameters).length) {
        body = remainingParameters;
      }
    }
  }
  if (!headers["content-type"] && typeof body !== "undefined") {
    headers["content-type"] = "application/json; charset=utf-8";
  }
  if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
    body = "";
  }
  return Object.assign(
    { method, url, headers },
    typeof body !== "undefined" ? { body } : null,
    options.request ? { request: options.request } : null
  );
}
function endpointWithDefaults(defaults, route, options) {
  return parse(merge(defaults, route, options));
}
function withDefaults(oldDefaults, newDefaults) {
  const DEFAULTS2 = merge(oldDefaults, newDefaults);
  const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
  return Object.assign(endpoint2, {
    DEFAULTS: DEFAULTS2,
    defaults: withDefaults.bind(null, DEFAULTS2),
    merge: merge.bind(null, DEFAULTS2),
    parse
  });
}
var endpoint = withDefaults(null, DEFAULTS);

// node_modules/@octokit/request/node_modules/universal-user-agent/index.js
function getUserAgent3() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && process.version !== void 0) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}

// node_modules/@octokit/request/node_modules/@octokit/request-error/dist-src/index.js
var RequestError = class extends Error {
  constructor(message, statusCode, options) {
    super(message);
    __publicField(this, "name");
    /**
     * http status code
     */
    __publicField(this, "status");
    /**
     * Request options that lead to the error.
     */
    __publicField(this, "request");
    /**
     * Response object if a response was received
     */
    __publicField(this, "response");
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = "HttpError";
    this.status = statusCode;
    if ("response" in options) {
      this.response = options.response;
    }
    const requestCopy = Object.assign({}, options.request);
    if (options.request.headers.authorization) {
      requestCopy.headers = Object.assign({}, options.request.headers, {
        authorization: options.request.headers.authorization.replace(
          / .*$/,
          " [REDACTED]"
        )
      });
    }
    requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
    this.request = requestCopy;
  }
};

// node_modules/@octokit/request/dist-bundle/index.js
var VERSION2 = "0.0.0-development";
function isPlainObject2(value) {
  if (typeof value !== "object" || value === null)
    return false;
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
function getBufferResponse(response) {
  return response.arrayBuffer();
}
function fetchWrapper(requestOptions) {
  var _a, _b, _c;
  const log = requestOptions.request && requestOptions.request.log ? requestOptions.request.log : console;
  const parseSuccessResponseBody = ((_a = requestOptions.request) == null ? void 0 : _a.parseSuccessResponseBody) !== false;
  if (isPlainObject2(requestOptions.body) || Array.isArray(requestOptions.body)) {
    requestOptions.body = JSON.stringify(requestOptions.body);
  }
  let headers = {};
  let status;
  let url;
  let { fetch } = globalThis;
  if ((_b = requestOptions.request) == null ? void 0 : _b.fetch) {
    fetch = requestOptions.request.fetch;
  }
  if (!fetch) {
    throw new Error(
      "fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing"
    );
  }
  return fetch(requestOptions.url, {
    method: requestOptions.method,
    body: requestOptions.body,
    // Header values must be `string`
    headers: Object.fromEntries(
      Object.entries(requestOptions.headers).map(([name, value]) => [
        name,
        String(value)
      ])
    ),
    signal: (_c = requestOptions.request) == null ? void 0 : _c.signal,
    // duplex must be set if request.body is ReadableStream or Async Iterables.
    // See https://fetch.spec.whatwg.org/#dom-requestinit-duplex.
    ...requestOptions.body && { duplex: "half" }
  }).then(async (response) => {
    url = response.url;
    status = response.status;
    for (const keyAndValue of response.headers) {
      headers[keyAndValue[0]] = keyAndValue[1];
    }
    if ("deprecation" in headers) {
      const matches = headers.link && headers.link.match(/<([^>]+)>; rel="deprecation"/);
      const deprecationLink = matches && matches.pop();
      log.warn(
        `[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`
      );
    }
    if (status === 204 || status === 205) {
      return;
    }
    if (requestOptions.method === "HEAD") {
      if (status < 400) {
        return;
      }
      throw new RequestError(response.statusText, status, {
        response: {
          url,
          status,
          headers,
          data: void 0
        },
        request: requestOptions
      });
    }
    if (status === 304) {
      throw new RequestError("Not modified", status, {
        response: {
          url,
          status,
          headers,
          data: await getResponseData(response)
        },
        request: requestOptions
      });
    }
    if (status >= 400) {
      const data = await getResponseData(response);
      const error = new RequestError(toErrorMessage(data), status, {
        response: {
          url,
          status,
          headers,
          data
        },
        request: requestOptions
      });
      throw error;
    }
    return parseSuccessResponseBody ? await getResponseData(response) : response.body;
  }).then((data) => {
    return {
      status,
      url,
      headers,
      data
    };
  }).catch((error) => {
    if (error instanceof RequestError)
      throw error;
    else if (error.name === "AbortError")
      throw error;
    let message = error.message;
    if (error.name === "TypeError" && "cause" in error) {
      if (error.cause instanceof Error) {
        message = error.cause.message;
      } else if (typeof error.cause === "string") {
        message = error.cause;
      }
    }
    throw new RequestError(message, 500, {
      request: requestOptions
    });
  });
}
async function getResponseData(response) {
  const contentType = response.headers.get("content-type");
  if (/application\/json/.test(contentType)) {
    return response.json().catch(() => response.text()).catch(() => "");
  }
  if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) {
    return response.text();
  }
  return getBufferResponse(response);
}
function toErrorMessage(data) {
  if (typeof data === "string")
    return data;
  let suffix;
  if ("documentation_url" in data) {
    suffix = ` - ${data.documentation_url}`;
  } else {
    suffix = "";
  }
  if ("message" in data) {
    if (Array.isArray(data.errors)) {
      return `${data.message}: ${data.errors.map(JSON.stringify).join(", ")}${suffix}`;
    }
    return `${data.message}${suffix}`;
  }
  return `Unknown error: ${JSON.stringify(data)}`;
}
function withDefaults2(oldEndpoint, newDefaults) {
  const endpoint2 = oldEndpoint.defaults(newDefaults);
  const newApi = function(route, parameters) {
    const endpointOptions = endpoint2.merge(route, parameters);
    if (!endpointOptions.request || !endpointOptions.request.hook) {
      return fetchWrapper(endpoint2.parse(endpointOptions));
    }
    const request2 = (route2, parameters2) => {
      return fetchWrapper(
        endpoint2.parse(endpoint2.merge(route2, parameters2))
      );
    };
    Object.assign(request2, {
      endpoint: endpoint2,
      defaults: withDefaults2.bind(null, endpoint2)
    });
    return endpointOptions.request.hook(request2, endpointOptions);
  };
  return Object.assign(newApi, {
    endpoint: endpoint2,
    defaults: withDefaults2.bind(null, endpoint2)
  });
}
var request = withDefaults2(endpoint, {
  headers: {
    "user-agent": `octokit-request.js/${VERSION2} ${getUserAgent3()}`
  }
});

// node_modules/@octokit/graphql/node_modules/universal-user-agent/index.js
function getUserAgent4() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && process.version !== void 0) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}

// node_modules/@octokit/graphql/dist-bundle/index.js
var VERSION3 = "0.0.0-development";
function _buildMessageForResponseErrors(data) {
  return `Request failed due to following response errors:
` + data.errors.map((e) => ` - ${e.message}`).join("\n");
}
var GraphqlResponseError = class extends Error {
  constructor(request2, headers, response) {
    super(_buildMessageForResponseErrors(response));
    __publicField(this, "name", "GraphqlResponseError");
    __publicField(this, "errors");
    __publicField(this, "data");
    this.request = request2;
    this.headers = headers;
    this.response = response;
    this.errors = response.errors;
    this.data = response.data;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
};
var NON_VARIABLE_OPTIONS = [
  "method",
  "baseUrl",
  "url",
  "headers",
  "request",
  "query",
  "mediaType"
];
var FORBIDDEN_VARIABLE_OPTIONS = ["query", "method", "url"];
var GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
function graphql(request2, query, options) {
  if (options) {
    if (typeof query === "string" && "query" in options) {
      return Promise.reject(
        new Error(`[@octokit/graphql] "query" cannot be used as variable name`)
      );
    }
    for (const key in options) {
      if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key))
        continue;
      return Promise.reject(
        new Error(
          `[@octokit/graphql] "${key}" cannot be used as variable name`
        )
      );
    }
  }
  const parsedOptions = typeof query === "string" ? Object.assign({ query }, options) : query;
  const requestOptions = Object.keys(
    parsedOptions
  ).reduce((result, key) => {
    if (NON_VARIABLE_OPTIONS.includes(key)) {
      result[key] = parsedOptions[key];
      return result;
    }
    if (!result.variables) {
      result.variables = {};
    }
    result.variables[key] = parsedOptions[key];
    return result;
  }, {});
  const baseUrl = parsedOptions.baseUrl || request2.endpoint.DEFAULTS.baseUrl;
  if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
    requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
  }
  return request2(requestOptions).then((response) => {
    if (response.data.errors) {
      const headers = {};
      for (const key of Object.keys(response.headers)) {
        headers[key] = response.headers[key];
      }
      throw new GraphqlResponseError(
        requestOptions,
        headers,
        response.data
      );
    }
    return response.data.data;
  });
}
function withDefaults3(request2, newDefaults) {
  const newRequest = request2.defaults(newDefaults);
  const newApi = (query, options) => {
    return graphql(newRequest, query, options);
  };
  return Object.assign(newApi, {
    defaults: withDefaults3.bind(null, newRequest),
    endpoint: newRequest.endpoint
  });
}
var graphql2 = withDefaults3(request, {
  headers: {
    "user-agent": `octokit-graphql.js/${VERSION3} ${getUserAgent4()}`
  },
  method: "POST",
  url: "/graphql"
});
function withCustomRequest(customRequest) {
  return withDefaults3(customRequest, {
    method: "POST",
    url: "/graphql"
  });
}

// node_modules/@octokit/auth-token/dist-bundle/index.js
var REGEX_IS_INSTALLATION_LEGACY = /^v1\./;
var REGEX_IS_INSTALLATION = /^ghs_/;
var REGEX_IS_USER_TO_SERVER = /^ghu_/;
async function auth(token) {
  const isApp = token.split(/\./).length === 3;
  const isInstallation = REGEX_IS_INSTALLATION_LEGACY.test(token) || REGEX_IS_INSTALLATION.test(token);
  const isUserToServer = REGEX_IS_USER_TO_SERVER.test(token);
  const tokenType = isApp ? "app" : isInstallation ? "installation" : isUserToServer ? "user-to-server" : "oauth";
  return {
    type: "token",
    token,
    tokenType
  };
}
function withAuthorizationPrefix(token) {
  if (token.split(/\./).length === 3) {
    return `bearer ${token}`;
  }
  return `token ${token}`;
}
async function hook(token, request2, route, parameters) {
  const endpoint2 = request2.endpoint.merge(
    route,
    parameters
  );
  endpoint2.headers.authorization = withAuthorizationPrefix(token);
  return request2(endpoint2);
}
var createTokenAuth = function createTokenAuth2(token) {
  if (!token) {
    throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
  }
  if (typeof token !== "string") {
    throw new Error(
      "[@octokit/auth-token] Token passed to createTokenAuth is not a string"
    );
  }
  token = token.replace(/^(token|bearer) +/i, "");
  return Object.assign(auth.bind(null, token), {
    hook: hook.bind(null, token)
  });
};

// node_modules/@octokit/core/dist-src/version.js
var VERSION4 = "6.0.1";

// node_modules/@octokit/core/dist-src/index.js
var noop = () => {
};
var consoleWarn = console.warn.bind(console);
var consoleError = console.error.bind(console);
var userAgentTrail = `octokit-core.js/${VERSION4} ${getUserAgent()}`;
var Octokit = class {
  constructor(options = {}) {
    // assigned during constructor
    __publicField(this, "request");
    __publicField(this, "graphql");
    __publicField(this, "log");
    __publicField(this, "hook");
    // TODO: type `octokit.auth` based on passed options.authStrategy
    __publicField(this, "auth");
    const hook2 = new before_after_hook_default.Collection();
    const requestDefaults = {
      baseUrl: request.endpoint.DEFAULTS.baseUrl,
      headers: {},
      request: Object.assign({}, options.request, {
        // @ts-ignore internal usage only, no need to type
        hook: hook2.bind(null, "request")
      }),
      mediaType: {
        previews: [],
        format: ""
      }
    };
    requestDefaults.headers["user-agent"] = options.userAgent ? `${options.userAgent} ${userAgentTrail}` : userAgentTrail;
    if (options.baseUrl) {
      requestDefaults.baseUrl = options.baseUrl;
    }
    if (options.previews) {
      requestDefaults.mediaType.previews = options.previews;
    }
    if (options.timeZone) {
      requestDefaults.headers["time-zone"] = options.timeZone;
    }
    this.request = request.defaults(requestDefaults);
    this.graphql = withCustomRequest(this.request).defaults(requestDefaults);
    this.log = Object.assign(
      {
        debug: noop,
        info: noop,
        warn: consoleWarn,
        error: consoleError
      },
      options.log
    );
    this.hook = hook2;
    if (!options.authStrategy) {
      if (!options.auth) {
        this.auth = async () => ({
          type: "unauthenticated"
        });
      } else {
        const auth2 = createTokenAuth(options.auth);
        hook2.wrap("request", auth2.hook);
        this.auth = auth2;
      }
    } else {
      const { authStrategy, ...otherOptions } = options;
      const auth2 = authStrategy(
        Object.assign(
          {
            request: this.request,
            log: this.log,
            // we pass the current octokit instance as well as its constructor options
            // to allow for authentication strategies that return a new octokit instance
            // that shares the same internal state as the current one. The original
            // requirement for this was the "event-octokit" authentication strategy
            // of https://github.com/probot/octokit-auth-probot.
            octokit: this,
            octokitOptions: otherOptions
          },
          options.auth
        )
      );
      hook2.wrap("request", auth2.hook);
      this.auth = auth2;
    }
    const classConstructor = this.constructor;
    for (let i = 0; i < classConstructor.plugins.length; ++i) {
      Object.assign(this, classConstructor.plugins[i](this, options));
    }
  }
  static defaults(defaults) {
    const OctokitWithDefaults = class extends this {
      constructor(...args) {
        const options = args[0] || {};
        if (typeof defaults === "function") {
          super(defaults(options));
          return;
        }
        super(
          Object.assign(
            {},
            defaults,
            options,
            options.userAgent && defaults.userAgent ? {
              userAgent: `${options.userAgent} ${defaults.userAgent}`
            } : null
          )
        );
      }
    };
    return OctokitWithDefaults;
  }
  /**
   * Attach a plugin (or many) to your Octokit instance.
   *
   * @example
   * const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
   */
  static plugin(...newPlugins) {
    var _a;
    const currentPlugins = this.plugins;
    const NewOctokit = (_a = class extends this {
    }, __publicField(_a, "plugins", currentPlugins.concat(
      newPlugins.filter((plugin) => !currentPlugins.includes(plugin))
    )), _a);
    return NewOctokit;
  }
};
__publicField(Octokit, "VERSION", VERSION4);
__publicField(Octokit, "plugins", []);

// src/utils.ts
var import_obsidian = require("obsidian");
function getValueOrNull(obj, key) {
  return obj.hasOwnProperty(key) ? obj[key] : null;
}
function compareSha(currentShaMap, storedShaMap, env) {
  const determineStatus = (currentSha, storedSha) => {
    if (currentSha && storedSha && currentSha !== storedSha) {
      return env === "local" ? "changed" : "MODIFIED";
    } else if (currentSha && !storedSha) {
      return env === "local" ? "created" : "ADDED";
    } else if (!currentSha && storedSha) {
      return env === "local" ? "deleted" : "REMOVED";
    }
    return null;
  };
  return Object.keys({ ...currentShaMap, ...storedShaMap }).flatMap((path) => {
    const [currentSha, storedSha] = [getValueOrNull(currentShaMap, path), getValueOrNull(storedShaMap, path)];
    const status = determineStatus(currentSha, storedSha);
    if (status) {
      return [{
        path,
        status,
        currentSha: currentSha != null ? currentSha : void 0,
        extension: extractExtension(path)
      }];
    }
    return [];
  });
}
var RECOGNIZED_BINARY_EXT = ["png", "jpg", "jpeg", "pdf"];
function extractExtension(path) {
  var _a;
  return (_a = path.match(/[^.]+$/)) == null ? void 0 : _a[0];
}
function removeLineEndingsFromBase64String(content) {
  return content.replace(/\r?\n|\r|\n/g, "");
}
function showFileOpsRecord(records) {
  if (records.length === 0 || records.every((r) => r.ops.length === 0)) {
    return;
  }
  const fileOpsNotice = new import_obsidian.Notice("", 0);
  records.map((recordSet) => {
    if (recordSet.ops.length === 0) {
      return;
    }
    const heading = fileOpsNotice.noticeEl.createEl("span", {
      cls: "file-changes-heading"
    });
    heading.setText(`${recordSet.heading}
`);
    const fileChanges = {
      created: [],
      changed: [],
      deleted: []
    };
    for (const op of recordSet.ops) {
      fileChanges[op.status].push(op.path);
    }
    for (const [changeType, paths] of Object.entries(fileChanges)) {
      if (paths.length === 0) {
        continue;
      }
      const heading2 = fileOpsNotice.noticeEl.createEl("span");
      heading2.setText(`${changeType.charAt(0).toUpperCase() + changeType.slice(1)}
`);
      heading2.addClass(`file-changes-subheading`);
      for (const path of paths) {
        const listItem = fileOpsNotice.noticeEl.createEl("li", {
          cls: "file-update-row"
        });
        listItem.setText(`${path}`);
        listItem.addClass(`file-${changeType}`);
      }
    }
  });
}
function showUnappliedConflicts(clashedFiles) {
  if (clashedFiles.length === 0) {
    return;
  }
  const localStatusMap = {
    created: "create",
    changed: "change",
    deleted: "delete"
  };
  const remoteStatusMap = {
    ADDED: "create",
    MODIFIED: "change",
    REMOVED: "delete"
  };
  const conflictNotice = new import_obsidian.Notice("", 0);
  const heading = conflictNotice.noticeEl.createEl("span");
  heading.setText(`Change conflicts:
`);
  heading.addClass(`file-changes-subheading`);
  const conflictStatus = conflictNotice.noticeEl.createDiv({
    cls: "file-conflict-row"
  });
  conflictStatus.createDiv().setText("Local");
  conflictStatus.createDiv().setText("Remote");
  for (const clash of clashedFiles) {
    const conflictItem = conflictNotice.noticeEl.createDiv({
      cls: "file-conflict-row"
    });
    conflictItem.createDiv({
      cls: `file-conflict-${localStatusMap[clash.localStatus]}`
    });
    conflictItem.createDiv("div").setText(clash.path);
    conflictItem.createDiv({
      cls: `file-conflict-${remoteStatusMap[clash.remoteStatus]}`
    });
  }
  const footer = conflictNotice.noticeEl.createDiv({
    cls: "file-conflict-row"
  });
  footer.setText("Note:");
  footer.style.fontWeight = "bold";
  conflictNotice.noticeEl.createEl("li", { cls: "file-conflict-note" }).setText("Remote changes in _fit");
  conflictNotice.noticeEl.createEl("li", { cls: "file-conflict-note" }).setText("_fit folder is overwritten on conflict, copy needed changes outside _fit.");
}
function difference(setA, setB) {
  return new Set([...setA].filter((x) => !setB.has(x)));
}

// src/fit.ts
var import_obsidian2 = require("obsidian");
var OctokitHttpError = class extends Error {
  constructor(message, status, source) {
    super(message);
    this.name = "HttpError";
    this.status = status;
    this.source = source;
  }
};
var Fit = class {
  constructor(repo, vaultOps) {
    this.loadSettings(repo);
    this.vaultOps = vaultOps;
    this.headers = {
      // Hack to disable caching which leads to inconsistency for
      // read after write https://github.com/octokit/octokit.js/issues/890
      "If-None-Match": "",
      "X-GitHub-Api-Version": "2022-11-28"
    };
  }
  loadSettings(repo) {
    const { settings, localStore } = repo;
    this.repo = settings.repo;
    this.owner = settings.owner;
    this.branch = settings.branch;
    this.excludes = settings.excludes;
    this.syncPath = settings.syncPath;
    this.deviceName = settings.deviceName;
    this.octokit = new Octokit({ auth: settings.pat });
    this.localSha = localStore.localSha;
    this.lastFetchedCommitSha = localStore.lastFetchedCommitSha;
    this.lastFetchedRemoteSha = localStore.lastFetchedRemoteSha;
  }
  async fileSha1(fileContent) {
    const enc = new TextEncoder();
    const hashBuf = await crypto.subtle.digest("SHA-1", enc.encode(fileContent));
    const hashArray = Array.from(new Uint8Array(hashBuf));
    const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
    return hashHex;
  }
  async computeFileLocalSha(path) {
    const fullPath = this.syncPath + path;
    let content;
    const file = await this.vaultOps.getTFile(fullPath);
    if (file) {
      if (RECOGNIZED_BINARY_EXT.includes(file.extension)) {
        content = (0, import_obsidian2.arrayBufferToBase64)(await this.vaultOps.vault.readBinary(file));
      } else {
        content = await this.vaultOps.vault.read(file);
      }
    } else {
      const extension = extractExtension(path);
      if (!extension || RECOGNIZED_BINARY_EXT.includes(extension)) {
        content = (0, import_obsidian2.arrayBufferToBase64)(
          await this.vaultOps.vault.adapter.readBinary(fullPath)
        );
      } else {
        content = await this.vaultOps.vault.adapter.read(fullPath);
      }
    }
    return await this.fileSha1(path + content);
  }
  async computeLocalSha() {
    const allPaths = await this.vaultOps.getFilesInVault();
    const paths = [];
    for (let path of allPaths) {
      let isExcluded = path.startsWith("_fit/") || !path.startsWith(this.syncPath) || this.excludes.contains(path);
      for (let exclude of this.excludes) {
        isExcluded || (isExcluded = path.startsWith(exclude));
        if (isExcluded)
          break;
      }
      const result2 = path.replace(this.syncPath, "");
      if (!isExcluded)
        paths.push(result2);
    }
    const asyncCompute = paths.map(
      async (path) => {
        const sha = await this.computeFileLocalSha(path);
        return [path, sha];
      }
    );
    const computed = await Promise.all(asyncCompute);
    const result = computed.filter((el) => !!el[1]);
    return Object.fromEntries(result);
  }
  async remoteUpdated() {
    const remoteCommitSha = await this.getRef();
    return { remoteCommitSha, updated: remoteCommitSha !== this.lastFetchedCommitSha };
  }
  async getLocalChanges(currentLocalSha) {
    if (!currentLocalSha) {
      currentLocalSha = await this.computeLocalSha();
    }
    const localChanges = compareSha(currentLocalSha, this.localSha, "local");
    return localChanges;
  }
  async getRemoteChanges(remoteTreeSha) {
    const remoteChanges = compareSha(remoteTreeSha, this.lastFetchedRemoteSha, "remote");
    return remoteChanges;
  }
  getClashedChanges(localChanges, remoteChanges) {
    const localChangePaths = localChanges.map(
      (c) => c.path.replace(this.syncPath, "")
    );
    const remoteChangePaths = remoteChanges.map((c) => c.path);
    const clashedFiles = localChangePaths.map(
      (path, localIndex) => {
        const remoteIndex = remoteChangePaths.indexOf(path);
        if (remoteIndex !== -1) {
          return { path, localIndex, remoteIndex };
        }
        return null;
      }
    ).filter(Boolean);
    return clashedFiles.map(
      ({ path, localIndex, remoteIndex }) => {
        return {
          path,
          localStatus: localChanges[localIndex].status,
          remoteStatus: remoteChanges[remoteIndex].status
        };
      }
    );
  }
  async getRepos() {
    const allRepos = [];
    let page = 1;
    const perPage = 100;
    try {
      let hasMorePages = true;
      while (hasMorePages) {
        const { data: response } = await this.octokit.request(
          `GET /user/repos`,
          {
            affiliation: "owner",
            headers: this.headers,
            per_page: perPage,
            // Number of repositories to import per page (up to 100)
            page
          }
        );
        allRepos.push(...response.map((r) => r.name));
        if (response.length < perPage) {
          hasMorePages = false;
        }
        page++;
      }
      return allRepos;
    } catch (error) {
      throw new OctokitHttpError(error.message, error.status, "getRepos");
    }
  }
  async getBranches() {
    try {
      const { data: response } = await this.octokit.request(
        `GET /repos/{owner}/{repo}/branches`,
        {
          owner: this.owner,
          repo: this.repo,
          headers: this.headers
        }
      );
      return response.map((r) => r.name);
    } catch (error) {
      throw new OctokitHttpError(error.message, error.status, "getRepos");
    }
  }
  // Get the sha of the latest commit in the default branch (set by user in setting)
  async getRef(ref = `heads/${this.branch}`) {
    try {
      const { data: response } = await this.octokit.request(
        `GET /repos/{owner}/{repo}/git/ref/{ref}`,
        {
          owner: this.owner,
          repo: this.repo,
          ref,
          headers: this.headers
        }
      );
      return response.object.sha;
    } catch (error) {
      throw new OctokitHttpError(error.message, error.status, "getRef");
    }
  }
  // ref Can be a commit SHA, branch name (heads/BRANCH_NAME), or tag name (tags/TAG_NAME),
  // refers to https://git-scm.com/book/en/v2/Git-Internals-Git-References
  async getCommitTreeSha(ref) {
    const { data: commit } = await this.octokit.request(
      `GET /repos/{owner}/{repo}/commits/{ref}`,
      {
        owner: this.owner,
        repo: this.repo,
        ref,
        headers: this.headers
      }
    );
    return commit.commit.tree.sha;
  }
  async getTree(tree_sha) {
    const { data: tree } = await this.octokit.request(
      `GET /repos/{owner}/{repo}/git/trees/{tree_sha}`,
      {
        owner: this.owner,
        repo: this.repo,
        tree_sha,
        recursive: "true",
        headers: this.headers
      }
    );
    return tree.tree;
  }
  // get the remote tree sha in the format compatible with local store
  async getRemoteTreeSha(tree_sha) {
    const remoteTree = await this.getTree(tree_sha);
    const remoteSha = Object.fromEntries(remoteTree.map((node) => {
      if (node.type == "blob") {
        if (!node.path || !node.sha) {
          throw new Error("Path or sha not found for blob node in remote");
        }
        if (node.path.startsWith("_fit/")) {
          return null;
        }
        return [node.path, node.sha];
      }
      return null;
    }).filter(Boolean));
    return remoteSha;
  }
  async createBlob(content, encoding) {
    const { data: blob } = await this.octokit.request(
      `POST /repos/{owner}/{repo}/git/blobs`,
      {
        owner: this.owner,
        repo: this.repo,
        content,
        encoding,
        headers: this.headers
      }
    );
    return blob.sha;
  }
  async createTreeNodeFromFile({ path, status, extension }, remoteTree) {
    if (status === "deleted") {
      if (remoteTree.every((node) => node.path !== path)) {
        return null;
      }
      return {
        path,
        mode: "100644",
        type: "blob",
        sha: null
      };
    }
    const fullPath = this.syncPath + path;
    let encoding;
    let content;
    if (extension && RECOGNIZED_BINARY_EXT.includes(extension)) {
      encoding = "base64";
      const fileArrayBuf = await this.vaultOps.vault.adapter.readBinary(fullPath);
      const uint8Array = new Uint8Array(fileArrayBuf);
      let binaryString = "";
      for (let i = 0; i < uint8Array.length; i++) {
        binaryString += String.fromCharCode(uint8Array[i]);
      }
      content = btoa(binaryString);
    } else {
      encoding = "utf-8";
      content = await this.vaultOps.vault.adapter.read(fullPath);
    }
    const blobSha = await this.createBlob(content, encoding);
    if (remoteTree.some((node) => node.path === path && node.sha === blobSha)) {
      return null;
    }
    return {
      path,
      mode: "100644",
      type: "blob",
      sha: blobSha
    };
  }
  async createTree(treeNodes, base_tree_sha) {
    const { data: newTree } = await this.octokit.request(
      `POST /repos/{owner}/{repo}/git/trees`,
      {
        owner: this.owner,
        repo: this.repo,
        tree: treeNodes,
        base_tree: base_tree_sha,
        headers: this.headers
      }
    );
    return newTree.sha;
  }
  async createCommit(treeSha, parentSha) {
    const message = `Commit from ${this.deviceName} on ${new Date().toLocaleString()}`;
    const { data: createdCommit } = await this.octokit.request(
      `POST /repos/{owner}/{repo}/git/commits`,
      {
        owner: this.owner,
        repo: this.repo,
        message,
        tree: treeSha,
        parents: [parentSha],
        headers: this.headers
      }
    );
    return createdCommit.sha;
  }
  async updateRef(sha, ref = `heads/${this.branch}`) {
    const { data: updatedRef } = await this.octokit.request(
      `PATCH /repos/{owner}/{repo}/git/refs/{ref}`,
      {
        owner: this.owner,
        repo: this.repo,
        ref,
        sha,
        headers: this.headers
      }
    );
    return updatedRef.object.sha;
  }
  async getBlob(file_sha) {
    const { data: blob } = await this.octokit.request(
      `GET /repos/{owner}/{repo}/git/blobs/{file_sha}`,
      {
        owner: this.owner,
        repo: this.repo,
        file_sha,
        headers: this.headers
      }
    );
    return blob.content;
  }
};

// src/fitNotice.ts
var import_obsidian3 = require("obsidian");
var FitNotice = class {
  constructor(addClasses = [], initialMessage, duration = 0, muted = false) {
    this.muted = muted;
    this.classes = ["fit-notice"];
    if (initialMessage && !this.muted) {
      this.show(initialMessage, addClasses, duration);
    } else {
      this.classes = [...this.classes, ...addClasses];
    }
  }
  mute() {
    this.muted = true;
    if (this.notice) {
      this.notice.hide();
    }
  }
  unmute() {
    this.muted = false;
  }
  show(initialMessage, addClasses = [], duration = 0) {
    if (!this.notice && !this.muted) {
      const message = initialMessage && initialMessage.length > 0 ? initialMessage : " ";
      this.notice = new import_obsidian3.Notice(message, duration);
      this.notice.noticeEl.addClasses([...this.classes, ...addClasses]);
    }
  }
  updateClasses(addClasses = [], removeClasses = []) {
    if (this.muted) {
      return;
    }
    this.classes = this.classes.filter((c) => !removeClasses.includes(c));
    if (this.notice) {
      this.notice.noticeEl.removeClasses(removeClasses);
      this.notice.noticeEl.addClasses(addClasses);
    }
    this.classes = [...this.classes, ...addClasses];
  }
  // allows error display to override muted
  setMessage(message, isError) {
    if (isError) {
      if (!this.notice) {
        this.notice = new import_obsidian3.Notice(message, 0);
        this.notice.noticeEl.addClasses(["fit-notice", "error"]);
      } else {
        this.notice.setMessage(message);
      }
    } else {
      if (this.notice && !this.muted) {
        this.notice.setMessage(message);
      }
    }
  }
  remove(finalClass, duration = 5e3) {
    var _a, _b, _c;
    if (this.muted) {
      return;
    }
    (_a = this.notice) == null ? void 0 : _a.noticeEl.removeClasses(this.classes.filter((c) => c !== "fit-notice"));
    if (finalClass) {
      (_b = this.notice) == null ? void 0 : _b.noticeEl.addClass(finalClass);
    } else {
      (_c = this.notice) == null ? void 0 : _c.noticeEl.addClass("done");
    }
    setTimeout(() => {
      var _a2;
      return (_a2 = this.notice) == null ? void 0 : _a2.hide();
    }, duration);
  }
};

// src/fitSetting.ts
var import_obsidian4 = require("obsidian");
var FitSettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    // patSetting: Setting;
    // ownerSetting: Setting;
    // repoSetting: Setting;
    // branchSetting: Setting;
    // syncPathSetting: Setting;
    // existingRepos: Array<string>;
    // existingBranches: Array<string>;
    // repoLink: string;
    // syncPath: string;
    this.currentSyncIndex = 0;
    this.getLatestLink = () => {
      const currentSetting = this.getCurrentSyncSetting();
      const { owner, repo, branch } = currentSetting;
      if (owner.length > 0 && repo.length > 0 && branch.length > 0) {
        return `https://github.com/${owner}/${repo}/tree/${branch}`;
      }
      return "";
    };
    this.localConfigBlock = () => {
      const { containerEl } = this;
      new import_obsidian4.Setting(containerEl).setHeading().setName("Local configurations");
      new import_obsidian4.Setting(containerEl).setName("Auto sync").setDesc(`Automatically sync your vault when remote has updates. (Muted: sync in the background without displaying notices, except for file changes and conflicts notice)`).addDropdown((dropdown) => {
        dropdown.addOption("off", "Off").addOption("muted", "Muted").addOption("remind", "Remind only").addOption("on", "On").setValue(this.plugin.storage.autoSync ? this.plugin.storage.autoSync : "off").onChange(async (value) => {
          this.plugin.storage.autoSync = value;
          checkIntervalSlider.settingEl.addClass(value === "off" ? "clear" : "restore");
          checkIntervalSlider.settingEl.removeClass(value === "off" ? "restore" : "clear");
          await this.plugin.saveSettings();
        });
      });
      const checkIntervalSlider = new import_obsidian4.Setting(containerEl).setName("Auto check interval").setDesc(`Automatically check for remote changes in the background every ${this.plugin.storage.checkEveryXMinutes} minutes.`).addSlider(
        (slider) => slider.setLimits(1, 60, 1).setValue(this.plugin.storage.checkEveryXMinutes).setDynamicTooltip().onChange(async (value) => {
          this.plugin.storage.checkEveryXMinutes = value;
          await this.plugin.saveSettings();
          checkIntervalSlider.setDesc(`Automatically check for remote changes in the background every ${value} minutes.`);
        })
      );
      if (this.plugin.storage.autoSync === "off") {
        checkIntervalSlider.settingEl.addClass("clear");
      }
    };
    this.noticeConfigBlock = () => {
      const { containerEl } = this;
      const selectedCol = "var(--interactive-accent)";
      const selectedTxtCol = "var(--text-on-accent)";
      const unselectedColor = "var(--interactive-normal)";
      const unselectedTxtCol = "var(--text-normal)";
      const stateTextMap = (notifyConflicts, notifyChanges) => {
        if (notifyConflicts && notifyChanges) {
          return "Displaying file changes and conflicts ";
        } else if (!notifyConflicts && notifyChanges) {
          return "Displaying file changes ";
        } else if (notifyConflicts && !notifyChanges) {
          return "Displaying change conflicts ";
        } else {
          return "No notice displayed ";
        }
      };
      const noticeDisplay = new import_obsidian4.Setting(containerEl).setName("Notice display").setDesc(`${stateTextMap(this.plugin.storage.notifyConflicts, this.plugin.storage.notifyChanges)} after sync.`).addButton((button) => {
        button.setButtonText("Change conflicts");
        button.onClick(async () => {
          const notifyConflicts = !this.plugin.storage.notifyConflicts;
          this.plugin.storage.notifyConflicts = notifyConflicts;
          await this.plugin.saveSettings();
          button.buttonEl.setCssStyles({
            "background": notifyConflicts ? selectedCol : unselectedColor,
            "color": notifyConflicts ? selectedTxtCol : unselectedTxtCol
          });
          noticeDisplay.setDesc(`${stateTextMap(notifyConflicts, this.plugin.storage.notifyChanges)} after sync.`);
        });
        button.buttonEl.setCssStyles({
          "background": this.plugin.storage.notifyConflicts ? selectedCol : unselectedColor,
          "color": this.plugin.storage.notifyConflicts ? selectedTxtCol : unselectedTxtCol
        });
      }).addButton((button) => {
        button.setButtonText("File changes");
        button.onClick(async () => {
          const notifyChanges = !this.plugin.storage.notifyChanges;
          this.plugin.storage.notifyChanges = notifyChanges;
          await this.plugin.saveSettings();
          button.buttonEl.setCssStyles({
            "background": notifyChanges ? selectedCol : unselectedColor,
            "color": notifyChanges ? selectedTxtCol : unselectedTxtCol
          });
          noticeDisplay.setDesc(`${stateTextMap(this.plugin.storage.notifyConflicts, notifyChanges)} after sync.`);
        });
        button.buttonEl.setCssStyles({
          "background": this.plugin.storage.notifyChanges ? selectedCol : unselectedColor,
          "color": this.plugin.storage.notifyChanges ? selectedTxtCol : unselectedTxtCol
        });
      });
    };
    this.counterRepoBlock = () => {
      const { containerEl } = this;
      new import_obsidian4.Setting(containerEl).setName("Manage repositories").setDesc("Add or remove repository configurations").addButton((button) => button.setButtonText("Add Repository").setCta().onClick(async () => {
        this.plugin.storage.repo.push(DEFAULT_REPOSITORY);
        await this.plugin.saveSettings();
        this.display();
      })).addButton((button) => button.setButtonText("Remove Repository").setWarning().setDisabled(this.plugin.storage.repo.length <= 1).onClick(async () => {
        if (this.plugin.storage.repo.length > 1) {
          this.plugin.storage.repo.splice(this.currentSyncIndex, 1);
          if (this.currentSyncIndex >= this.plugin.storage.repo.length) {
            this.currentSyncIndex = this.plugin.storage.repo.length - 1;
          }
          await this.plugin.saveSettings();
          this.display();
        }
      }));
      new import_obsidian4.Setting(containerEl).setName("Current repository").setDesc("Select which repository configuration to edit").addDropdown((dropdown) => {
        this.plugin.storage.repo.forEach((_, index) => {
          dropdown.addOption(index.toString(), `Repository ${index + 1}`);
        });
        dropdown.setValue(this.currentSyncIndex.toString());
        dropdown.onChange(async (value) => {
          this.currentSyncIndex = parseInt(value);
          await this.plugin.saveSettings();
          this.display();
        });
      });
    };
    this.resetBlock = () => {
      const { containerEl } = this;
      new import_obsidian4.Setting(containerEl).setName("Reset settings").setDesc("Remove Sync storage or Settings").addButton((button) => button.setButtonText("Reset storage").setWarning().onClick(async () => {
        for (let storage of this.plugin.storage.repo) {
          storage.localStore = DEFAULT_LOCAL_STORE;
        }
        await this.plugin.saveSettings();
        this.display();
      })).addButton((button) => button.setButtonText("Reset Settings").setWarning().onClick(async () => {
        this.plugin.storage.repo = [DEFAULT_REPOSITORY];
        await this.plugin.saveSettings();
        this.display();
      }));
    };
    this.plugin = plugin;
  }
  getCurrentSyncSetting() {
    return this.plugin.storage.repo[this.currentSyncIndex].settings;
  }
  async githubUserInfoBlock() {
    var _a;
    const { containerEl } = this;
    const currentSetting = this.getCurrentSyncSetting();
    const { folders, files } = await this.plugin.vaultOps.getAllInVault();
    new import_obsidian4.Setting(containerEl).setHeading().setName(`GitHub user info (Repository ${this.currentSyncIndex + 1})`);
    new import_obsidian4.Setting(containerEl).setName("Github username").setDesc("Enter your name on Github").addText((text) => text.setPlaceholder("GitHub username").setValue(currentSetting.owner).onChange(async (value) => {
      currentSetting.owner = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Github personal access token").setDesc("Remember to give it access for reading and writing to the storage repo.").addText((text) => text.setPlaceholder("GitHub personal access token").setValue(currentSetting.pat).onChange(async (value) => {
      currentSetting.pat = value;
      await this.plugin.saveSettings();
    })).addExtraButton((button) => button.setIcon("external-link").setTooltip("Create a token").onClick(async () => {
      window.open("https://github.com/settings/tokens/new", "_blank");
    }));
    new import_obsidian4.Setting(containerEl).setName("Device name").setDesc("Sign commit message with this device name.").addText((text) => text.setPlaceholder("Device name").setValue(currentSetting.deviceName).onChange(async (value) => {
      currentSetting.deviceName = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Repository name").setDesc("Select a repo.").addText((text) => text.setPlaceholder("Repository").setValue(currentSetting.repo).onChange(async (value) => {
      currentSetting.repo = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Branch name").setDesc("Select a branch.").addText((text) => text.setPlaceholder("Branch").setValue(currentSetting.branch).onChange(async (value) => {
      currentSetting.branch = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Sync path").setDesc("Select a local path to sync with the repo. If the field is empty, the entire vault will be synced.").addText(async (text) => {
      var _a2;
      text.setPlaceholder("Enter folder path").setValue(currentSetting.syncPath || "").onChange(async (value) => {
        if (!folders2.contains(value))
          return;
        currentSetting.syncPath = value;
        await this.plugin.saveSettings();
      });
      const dataList = document.createElement("datalist");
      dataList.id = `folder-suggestions`;
      const otherSyncPath = /* @__PURE__ */ new Set();
      this.plugin.storage.repo.forEach(
        (el, i) => {
          if (i == this.currentSyncIndex)
            return;
          otherSyncPath.add(
            el.settings.syncPath
          );
        }
      );
      const allFolders = new Set(
        await this.plugin.vaultOps.getFoldersInVault()
      );
      const folders2 = Array.from(
        difference(allFolders, otherSyncPath)
      );
      for (let i in folders2) {
        const folder = folders2[i];
        const option = document.createElement("option");
        option.value = folder;
        dataList.appendChild(option);
      }
      text.inputEl.setAttribute("list", `folder-suggestions`);
      (_a2 = text.inputEl.parentElement) == null ? void 0 : _a2.appendChild(dataList);
    });
    new import_obsidian4.Setting(containerEl).setName("View your vault on GitHub").addExtraButton(
      (button) => button.setTooltip("Open on GitHub").setIcon("external-link").onClick(() => {
        const link = this.getLatestLink();
        console.log(`opening ${link}`);
        window.open(link);
      })
    ).descEl.addClass("link-desc");
    new import_obsidian4.Setting(containerEl).setName("Excluded files/folders").setDesc("Files or folders within sync path that will not be synced").addButton((button) => button.setButtonText("Add exclusion").setCta().onClick(async () => {
      if (!currentSetting.excludes) {
        currentSetting.excludes = [];
      }
      currentSetting.excludes.push("");
      await this.plugin.saveSettings();
      this.display();
    }));
    const allItems = await this.plugin.vaultOps.getAllInVault();
    const allPaths = [...allItems.folders, ...allItems.files];
    if (((_a = currentSetting.excludes) == null ? void 0 : _a.length) > 0) {
      currentSetting.excludes.forEach((exclude, index) => {
        new import_obsidian4.Setting(containerEl).setName(`Exclusion ${index + 1}`).addText((text) => {
          var _a2;
          text.setPlaceholder("path/to/exclude").setValue(exclude).onChange(async (value) => {
            if (!folders.contains(value) && !files.contains(value))
              return;
            currentSetting.excludes[index] = value;
            await this.plugin.saveSettings();
          });
          const dataList = document.createElement("datalist");
          dataList.id = `exclude-suggestions-${index}`;
          let filteredPaths = allPaths;
          if (currentSetting.syncPath) {
            filteredPaths = allPaths.filter(
              (path) => path.startsWith(currentSetting.syncPath + "/") || path === currentSetting.syncPath
            );
          }
          filteredPaths.forEach((path) => {
            const option = document.createElement("option");
            option.value = path;
            dataList.appendChild(option);
          });
          text.inputEl.setAttribute("list", `exclude-suggestions-${index}`);
          (_a2 = text.inputEl.parentElement) == null ? void 0 : _a2.appendChild(dataList);
        }).addButton((button) => button.setIcon("trash").setTooltip("Remove this exclusion").onClick(async () => {
          currentSetting.excludes.splice(index, 1);
          await this.plugin.saveSettings();
          this.display();
        }));
      });
    }
  }
  async getItemsInSyncPath() {
    const currentSetting = this.getCurrentSyncSetting();
    if (!currentSetting.syncPath)
      return [];
    try {
      const syncPath = currentSetting.syncPath;
      const allItems = [];
      const all = await this.plugin.vaultOps.getAllInVault();
      for (const file in all) {
        if (syncPath == "" || file.startsWith(syncPath + "/") || file === syncPath) {
          allItems.push(file);
        }
      }
      return allItems.sort();
    } catch (error) {
      console.error("Error getting items in sync path:", error);
      return [];
    }
  }
  importExport() {
    const { containerEl } = this;
    new import_obsidian4.Setting(containerEl).setName("Import/Export settings").setDesc("Backup or restore your plugin configuration").setHeading();
    const textAreaContainer = containerEl.createDiv("import-export-container");
    const textArea = textAreaContainer.createEl("textarea", {
      attr: {
        placeholder: "Configuration JSON will appear here...",
        rows: "10",
        style: "width: 100%; font-family: monospace;"
      },
      cls: "import-export-textarea"
    });
    new import_obsidian4.Setting(containerEl).addButton((button) => button.setButtonText("Export to Text Field").setCta().onClick(async () => {
      this.exportToTextField(textArea);
    })).addButton((button) => button.setButtonText("Import from Text Field").setWarning().onClick(async () => {
      await this.importFromTextField(textArea);
    })).addButton((button) => button.setButtonText("Clear Field").setIcon("trash").onClick(() => {
      textArea.value = "";
    }));
  }
  exportToTextField(textArea) {
    try {
      const result = structuredClone(this.plugin.storage);
      for (let i in result.repo) {
        delete result.repo[i].localStore;
      }
      const settingsJson = JSON.stringify(result, null, 4);
      textArea.value = settingsJson;
      textArea.focus();
      textArea.select();
    } catch (error) {
      console.error("Error exporting settings:", error);
      new import_obsidian4.Notice("Error exporting configuration", 3e3);
    }
  }
  async importFromTextField(textArea) {
    try {
      const jsonContent = textArea.value.trim();
      if (!jsonContent) {
        new import_obsidian4.Notice("Text field is empty", 3e3);
        return;
      }
      const importedSettings = JSON.parse(jsonContent);
      if (this.validateImportedSettings(importedSettings)) {
        for (let repo of importedSettings.repo) {
          repo.localStore = DEFAULT_LOCAL_STORE;
        }
        this.plugin.storage = importedSettings;
        await this.plugin.saveSettings();
        new import_obsidian4.Notice("Settings imported successfully!", 3e3);
        await this.display();
      } else {
        new import_obsidian4.Notice("Invalid settings format in text field", 4e3);
      }
    } catch (error) {
      console.error("Error importing settings from text field:", error);
      new import_obsidian4.Notice("Error parsing JSON configuration", 4e3);
    }
  }
  validateImportedSettings(settings) {
    return settings && typeof settings === "object" && Array.isArray(settings.repo) && settings.repo.length > 0 && settings.repo[0].settings && typeof settings.repo[0].settings === "object" && "syncPath" in settings.repo[0].settings;
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    this.localConfigBlock();
    this.noticeConfigBlock();
    containerEl.createEl("hr");
    this.counterRepoBlock();
    containerEl.createEl("hr");
    this.resetBlock();
    containerEl.createEl("hr");
    await this.githubUserInfoBlock();
    containerEl.createEl("hr");
    this.importExport();
  }
};

// src/fitSync.ts
var import_obsidian5 = require("obsidian");

// src/fitPull.ts
var FitPull = class {
  constructor(fit) {
    this.fit = fit;
  }
  async performPrePullChecks(localChanges) {
    const { remoteCommitSha, updated } = await this.fit.remoteUpdated();
    if (!updated) {
      return { status: "localCopyUpToDate", remoteUpdate: null };
    }
    if (!localChanges) {
      localChanges = await this.fit.getLocalChanges();
    }
    const remoteTreeSha = await this.fit.getRemoteTreeSha(remoteCommitSha);
    const remoteChanges = await this.fit.getRemoteChanges(remoteTreeSha);
    const clashedFiles = this.fit.getClashedChanges(localChanges, remoteChanges);
    const prePullCheckStatus = remoteChanges.length > 0 ? clashedFiles.length > 0 ? "localChangesClashWithRemoteChanges" : "remoteChangesCanBeMerged" : "noRemoteChangesDetected";
    return {
      status: prePullCheckStatus,
      remoteUpdate: {
        remoteChanges,
        remoteTreeSha,
        latestRemoteCommitSha: remoteCommitSha,
        clashedFiles
      }
    };
  }
  // Get changes from remote, pathShaMap is coupled to the Fit plugin design
  async getRemoteNonDeletionChangesContent(pathShaMap) {
    const remoteChanges = Object.entries(pathShaMap).map(async ([path, file_sha]) => {
      const content = await this.fit.getBlob(file_sha);
      return { path, content };
    });
    return await Promise.all(remoteChanges);
  }
  async prepareChangesToExecute(remoteChanges) {
    const deleteFromLocal = remoteChanges.filter((c) => c.status == "REMOVED").map((c) => c.path);
    const changesToProcess = remoteChanges.filter((c) => c.status != "REMOVED").reduce(
      (acc, change) => {
        acc[change.path] = change.currentSha;
        return acc;
      },
      {}
    );
    const addToLocal = await this.getRemoteNonDeletionChangesContent(changesToProcess);
    return { addToLocal, deleteFromLocal };
  }
  async pullRemoteToLocal(remoteUpdate, saveLocalStoreCallback) {
    const { remoteChanges, remoteTreeSha, latestRemoteCommitSha } = remoteUpdate;
    let { addToLocal, deleteFromLocal } = await this.prepareChangesToExecute(remoteChanges);
    const basepath = this.fit.syncPath;
    addToLocal = addToLocal.map(
      ({ path, content }) => {
        return {
          path: basepath + path,
          content
        };
      }
    ).filter(
      (file) => {
        const excludes = this.fit.excludes;
        if (!excludes.length)
          return true;
        return excludes.some(
          (exclude) => !file.path.startsWith(exclude)
        );
      }
    );
    deleteFromLocal = deleteFromLocal.map(
      (path) => basepath + path
    ).filter(
      (path) => {
        const excludes = this.fit.excludes;
        if (!excludes.length)
          return true;
        return excludes.some(
          (exclude) => !path.startsWith(exclude)
        );
      }
    );
    const fileOpsRecord = await this.fit.vaultOps.updateLocalFiles(
      addToLocal,
      deleteFromLocal
    );
    await saveLocalStoreCallback(
      basepath,
      {
        lastFetchedRemoteSha: remoteTreeSha,
        lastFetchedCommitSha: latestRemoteCommitSha,
        localSha: await this.fit.computeLocalSha()
      }
    );
    return fileOpsRecord;
  }
};

// src/fitPush.ts
var FitPush = class {
  constructor(fit) {
    this.fit = fit;
  }
  async createCommitFromLocalUpdate(localUpdate, remoteTree) {
    const { localChanges, parentCommitSha } = localUpdate;
    const pushedChanges = [];
    const treeNodes = (await Promise.all(localChanges.map(async (f, i) => {
      const node = await this.fit.createTreeNodeFromFile(f, remoteTree);
      if (node) {
        pushedChanges.push(localChanges[i]);
        return node;
      }
    }))).filter(Boolean);
    console.log(treeNodes);
    if (treeNodes.length === 0) {
      return null;
    }
    const latestRemoteCommitTreeSha = await this.fit.getCommitTreeSha(parentCommitSha);
    const createdTreeSha = await this.fit.createTree(treeNodes, latestRemoteCommitTreeSha);
    const createdCommitSha = await this.fit.createCommit(createdTreeSha, parentCommitSha);
    return { createdCommitSha, pushedChanges };
  }
  async pushChangedFilesToRemote(localUpdate) {
    if (localUpdate.localChanges.length == 0) {
      return null;
    }
    const remoteTree = await this.fit.getTree(localUpdate.parentCommitSha);
    const createCommitResult = await this.createCommitFromLocalUpdate(localUpdate, remoteTree);
    if (!createCommitResult) {
      return null;
    }
    const { createdCommitSha, pushedChanges } = createCommitResult;
    const updatedRefSha = await this.fit.updateRef(createdCommitSha);
    const updatedRemoteTreeSha = await this.fit.getRemoteTreeSha(updatedRefSha);
    return {
      pushedChanges,
      lastFetchedRemoteSha: updatedRemoteTreeSha,
      lastFetchedCommitSha: createdCommitSha
    };
  }
};

// src/fitSync.ts
var FitSync = class {
  constructor(fit, vaultOps, saveLocalStoreCallback) {
    this.fit = fit;
    this.fitPull = new FitPull(fit);
    this.fitPush = new FitPush(fit);
    this.vaultOps = vaultOps;
    this.saveLocalStoreCallback = saveLocalStoreCallback;
  }
  async performPreSyncChecks() {
    const currentLocalSha = await this.fit.computeLocalSha();
    const localChanges = await this.fit.getLocalChanges(currentLocalSha);
    const { remoteCommitSha, updated: remoteUpdated } = await this.fit.remoteUpdated();
    if (localChanges.length === 0 && !remoteUpdated) {
      return { status: "inSync" };
    }
    const remoteTreeSha = await this.fit.getRemoteTreeSha(remoteCommitSha);
    const remoteChanges = await this.fit.getRemoteChanges(remoteTreeSha);
    let clashes = [];
    let status;
    if (localChanges.length > 0 && !remoteUpdated) {
      status = "onlyLocalChanged";
    } else if (remoteUpdated && localChanges.length === 0 && remoteChanges.length === 0) {
      status = "onlyRemoteCommitShaChanged";
    } else if (localChanges.length === 0 && remoteUpdated) {
      status = "onlyRemoteChanged";
    } else {
      clashes = this.fit.getClashedChanges(localChanges, remoteChanges);
      if (clashes.length === 0) {
        status = "localAndRemoteChangesCompatible";
      } else {
        status = "localAndRemoteChangesClashed";
      }
    }
    return {
      status,
      remoteUpdate: {
        remoteChanges,
        remoteTreeSha,
        latestRemoteCommitSha: remoteCommitSha,
        clashedFiles: clashes
      },
      localChanges,
      localTreeSha: currentLocalSha
    };
  }
  generateConflictReport(path, localContent, remoteContent) {
    const detectedExtension = extractExtension(path);
    if (detectedExtension && RECOGNIZED_BINARY_EXT.includes(detectedExtension)) {
      return {
        path,
        resolutionStrategy: "binary",
        remoteContent
      };
    }
    return {
      path,
      resolutionStrategy: "utf-8",
      localContent,
      remoteContent
    };
  }
  async handleBinaryConflict(path, remoteContent) {
    const conflictResolutionFolder = "_fit";
    const conflictResolutionPath = `${conflictResolutionFolder}/${this.fit.syncPath + path}`;
    const excludes = this.fit.excludes;
    let isExcluded = false;
    if (excludes.length) {
      isExcluded = excludes.some((el) => conflictResolutionPath.startsWith(el));
    }
    if (isExcluded)
      return null;
    await this.fit.vaultOps.ensureFolderExists(conflictResolutionPath);
    await this.fit.vaultOps.writeToLocal(conflictResolutionPath, remoteContent);
    return {
      path: conflictResolutionPath,
      status: "created"
    };
  }
  async handleUTF8Conflict(path, localContent, remoteConent) {
    const conflictResolutionFolder = "_fit";
    const conflictResolutionPath = `${conflictResolutionFolder}/${this.fit.syncPath + path}`;
    const excludes = this.fit.excludes;
    let isExcluded = false;
    if (excludes.length) {
      isExcluded = excludes.some((el) => conflictResolutionPath.startsWith(el));
    }
    if (isExcluded)
      return null;
    await this.fit.vaultOps.ensureFolderExists(conflictResolutionPath);
    this.fit.vaultOps.writeToLocal(conflictResolutionPath, remoteConent);
    return {
      path: conflictResolutionPath,
      status: "created"
    };
  }
  async handleLocalDeletionConflict(path, remoteContent) {
    const conflictResolutionFolder = "_fit";
    const conflictResolutionPath = `${conflictResolutionFolder}/${this.fit.syncPath + path}`;
    const excludes = this.fit.excludes;
    let isExcluded = false;
    if (excludes.length) {
      isExcluded = excludes.some((el) => conflictResolutionPath.startsWith(el));
    }
    if (isExcluded)
      return null;
    await this.fit.vaultOps.ensureFolderExists(conflictResolutionFolder);
    this.fit.vaultOps.writeToLocal(conflictResolutionPath, remoteContent);
    return {
      path: conflictResolutionPath,
      status: "created"
    };
  }
  async resolveFileConflict(clash, latestRemoteFileSha) {
    if (clash.localStatus === "deleted" && clash.remoteStatus === "REMOVED") {
      return { path: clash.path, noDiff: true };
    } else if (clash.localStatus === "deleted") {
      const remoteContent = await this.fit.getBlob(latestRemoteFileSha);
      const fileOp = await this.handleLocalDeletionConflict(clash.path, remoteContent);
      if (!fileOp)
        return null;
      return { path: clash.path, noDiff: false, fileOp };
    }
    const path = this.fit.syncPath + clash.path;
    const localFileContent = (0, import_obsidian5.arrayBufferToBase64)(await this.fit.vaultOps.vault.adapter.readBinary(path));
    if (latestRemoteFileSha) {
      const remoteContent = await this.fit.getBlob(latestRemoteFileSha);
      if (removeLineEndingsFromBase64String(remoteContent) !== removeLineEndingsFromBase64String(localFileContent)) {
        const report = this.generateConflictReport(clash.path, localFileContent, remoteContent);
        let fileOp;
        if (report.resolutionStrategy === "binary") {
          fileOp = await this.handleBinaryConflict(clash.path, report.remoteContent);
          if (!fileOp)
            return null;
        } else {
          fileOp = await this.handleUTF8Conflict(clash.path, report.localContent, report.remoteContent);
          if (!fileOp)
            return null;
        }
        return { path: clash.path, noDiff: false, fileOp };
      }
      return { path: clash.path, noDiff: true };
    } else {
      return { path: clash.path, noDiff: false };
    }
  }
  async resolveConflicts(clashedFiles, latestRemoteTreeSha) {
    const fileResolutions = await Promise.all(
      clashedFiles.map(
        async (clash) => {
          return await this.resolveFileConflict(clash, latestRemoteTreeSha[clash.path]);
        }
      )
    );
    const unresolvedFiles = fileResolutions.map((res, i) => {
      if (!(res == null ? void 0 : res.noDiff)) {
        return clashedFiles[i];
      }
      return null;
    }).filter(Boolean);
    return {
      noConflict: fileResolutions.every((res) => res == null ? void 0 : res.noDiff),
      unresolvedFiles,
      fileOpsRecord: fileResolutions.map((r) => r == null ? void 0 : r.fileOp).filter(Boolean)
    };
  }
  async syncCompatibleChanges(localUpdate, remoteUpdate, syncNotice) {
    let { addToLocal, deleteFromLocal } = await this.fitPull.prepareChangesToExecute(
      remoteUpdate.remoteChanges
    );
    syncNotice.setMessage("Uploading local changes");
    const remoteTree = await this.fit.getTree(localUpdate.parentCommitSha);
    const createCommitResult = await this.fitPush.createCommitFromLocalUpdate(localUpdate, remoteTree);
    let latestRemoteTreeSha;
    let latestCommitSha;
    let pushedChanges;
    if (createCommitResult) {
      const { createdCommitSha } = createCommitResult;
      const latestRefSha = await this.fit.updateRef(createdCommitSha);
      latestRemoteTreeSha = await this.fit.getRemoteTreeSha(latestRefSha);
      latestCommitSha = createdCommitSha;
      pushedChanges = createCommitResult.pushedChanges;
    } else {
      latestRemoteTreeSha = remoteUpdate.remoteTreeSha;
      latestCommitSha = remoteUpdate.latestRemoteCommitSha;
      pushedChanges = [];
    }
    syncNotice.setMessage("Writing remote changes to local");
    const basepath = this.fit.syncPath;
    addToLocal = addToLocal.map(
      ({ path, content }) => {
        return {
          path: basepath + path,
          content
        };
      }
    ).filter(
      (file) => {
        const excludes = this.fit.excludes;
        if (!excludes.length)
          return true;
        return excludes.some(
          (exclude) => !file.path.startsWith(exclude)
        );
      }
    );
    deleteFromLocal = deleteFromLocal.map((path) => basepath + path).filter(
      (path) => {
        const excludes = this.fit.excludes;
        if (!excludes.length)
          return true;
        return excludes.some(
          (exclude) => !path.startsWith(exclude)
        );
      }
    );
    const localFileOpsRecord = await this.vaultOps.updateLocalFiles(addToLocal, deleteFromLocal);
    await this.saveLocalStoreCallback(
      basepath,
      {
        lastFetchedRemoteSha: latestRemoteTreeSha,
        lastFetchedCommitSha: latestCommitSha,
        localSha: await this.fit.computeLocalSha()
      }
    );
    syncNotice.setMessage("Sync successful");
    return { localOps: localFileOpsRecord, remoteOps: pushedChanges };
  }
  async syncWithConflicts(localChanges, remoteUpdate, syncNotice) {
    const { latestRemoteCommitSha, clashedFiles, remoteTreeSha: latestRemoteTreeSha } = remoteUpdate;
    const { noConflict, unresolvedFiles, fileOpsRecord } = await this.resolveConflicts(clashedFiles, latestRemoteTreeSha);
    let localChangesToPush;
    let remoteChangesToWrite;
    if (noConflict) {
      remoteChangesToWrite = remoteUpdate.remoteChanges.filter((c) => !localChanges.some((l) => l.path === c.path));
      localChangesToPush = localChanges.filter((c) => !remoteUpdate.remoteChanges.some((r) => r.path === c.path));
    } else {
      syncNotice.setMessage(`Change conflicts detected`);
      remoteChangesToWrite = remoteUpdate.remoteChanges.filter((c) => !unresolvedFiles.some((l) => l.path === c.path));
      localChangesToPush = localChanges;
    }
    let { addToLocal, deleteFromLocal } = await this.fitPull.prepareChangesToExecute(remoteChangesToWrite);
    const syncLocalUpdate = {
      localChanges: localChangesToPush,
      parentCommitSha: latestRemoteCommitSha
    };
    const pushResult = await this.fitPush.pushChangedFilesToRemote(syncLocalUpdate);
    let pushedChanges;
    let lastFetchedCommitSha;
    let lastFetchedRemoteSha;
    if (pushResult) {
      pushedChanges = pushResult.pushedChanges;
      lastFetchedCommitSha = pushResult.lastFetchedCommitSha;
      lastFetchedRemoteSha = pushResult.lastFetchedRemoteSha;
    } else {
      pushedChanges = [];
      lastFetchedCommitSha = remoteUpdate.latestRemoteCommitSha;
      lastFetchedRemoteSha = remoteUpdate.remoteTreeSha;
    }
    const basepath = this.fit.syncPath;
    addToLocal = addToLocal.map(
      ({ path, content }) => {
        return {
          path: basepath + path,
          content
        };
      }
    ).filter(
      (file) => {
        const excludes = this.fit.excludes;
        if (!excludes.length)
          return true;
        return excludes.some(
          (exclude) => !file.path.startsWith(exclude)
        );
      }
    );
    deleteFromLocal = deleteFromLocal.map((path) => basepath + path).filter(
      (path) => {
        const excludes = this.fit.excludes;
        if (!excludes.length)
          return true;
        return excludes.some(
          (exclude) => !path.startsWith(exclude)
        );
      }
    );
    const localFileOpsRecord = await this.vaultOps.updateLocalFiles(
      addToLocal,
      deleteFromLocal
    );
    await this.saveLocalStoreCallback(
      basepath,
      {
        lastFetchedRemoteSha,
        lastFetchedCommitSha,
        localSha: await this.fit.computeLocalSha()
      }
    );
    const ops = localFileOpsRecord.concat(fileOpsRecord);
    if (unresolvedFiles.length === 0) {
      syncNotice.setMessage(`Sync successful`);
    } else if (unresolvedFiles.some((f) => f.remoteStatus !== "REMOVED")) {
      syncNotice.setMessage(`Synced with remote, unresolved conflicts written to _fit`);
    } else {
      syncNotice.setMessage(`Synced with remote, ignored remote deletion of locally changed files`);
    }
    return { unresolvedFiles, localOps: ops, remoteOps: pushedChanges };
  }
  async sync(syncNotice) {
    syncNotice.setMessage("Performing pre sync checks.");
    const preSyncCheckResult = await this.performPreSyncChecks();
    if (preSyncCheckResult.status === "inSync") {
      syncNotice.setMessage("Sync successful");
      return;
    }
    if (preSyncCheckResult.status === "onlyRemoteCommitShaChanged") {
      const { latestRemoteCommitSha } = preSyncCheckResult.remoteUpdate;
      await this.saveLocalStoreCallback(
        this.fit.syncPath,
        { lastFetchedCommitSha: latestRemoteCommitSha }
      );
      syncNotice.setMessage("Sync successful");
      return;
    }
    const remoteUpdate = preSyncCheckResult.remoteUpdate;
    if (preSyncCheckResult.status === "onlyRemoteChanged") {
      const fileOpsRecord = await this.fitPull.pullRemoteToLocal(
        remoteUpdate,
        this.saveLocalStoreCallback
      );
      syncNotice.setMessage("Sync successful");
      return {
        ops: [{ heading: "Local file updates:", ops: fileOpsRecord }],
        clash: []
        // basepath: this.fit.syncPath
      };
    }
    const { localChanges, localTreeSha } = preSyncCheckResult;
    const localUpdate = {
      localChanges,
      parentCommitSha: remoteUpdate.latestRemoteCommitSha
    };
    if (preSyncCheckResult.status === "onlyLocalChanged") {
      syncNotice.setMessage("Uploading local changes");
      const pushResult = await this.fitPush.pushChangedFilesToRemote(localUpdate);
      syncNotice.setMessage("Sync successful");
      if (pushResult) {
        await this.saveLocalStoreCallback(
          this.fit.syncPath,
          {
            localSha: localTreeSha,
            lastFetchedRemoteSha: pushResult.lastFetchedRemoteSha,
            lastFetchedCommitSha: pushResult.lastFetchedCommitSha
          }
        );
        return {
          ops: [{ heading: "Local file updates:", ops: pushResult.pushedChanges }],
          clash: []
          // basepath: this.fit.syncPath
        };
      }
      return;
    }
    if (preSyncCheckResult.status === "localAndRemoteChangesCompatible") {
      const { localOps, remoteOps } = await this.syncCompatibleChanges(
        localUpdate,
        remoteUpdate,
        syncNotice
      );
      return {
        ops: [
          { heading: "Local file updates:", ops: localOps },
          { heading: "Remote file updates:", ops: remoteOps }
        ],
        clash: []
        // basepath: this.fit.syncPath
      };
    }
    if (preSyncCheckResult.status === "localAndRemoteChangesClashed") {
      const conflictResolutionResult = await this.syncWithConflicts(
        localUpdate.localChanges,
        remoteUpdate,
        syncNotice
      );
      if (conflictResolutionResult) {
        const { unresolvedFiles, localOps, remoteOps } = conflictResolutionResult;
        return {
          ops: [
            { heading: "Local file updates:", ops: localOps },
            { heading: "Remote file updates:", ops: remoteOps }
          ],
          clash: unresolvedFiles
          // basepath: this.fit.syncPath
        };
      }
    }
  }
};

// src/vaultOps.ts
var import_obsidian6 = require("obsidian");
var VaultOperations = class {
  constructor(vault) {
    this.vault = vault;
  }
  async getTFile(path) {
    const file = this.vault.getAbstractFileByPath(path);
    if (file && file instanceof import_obsidian6.TFile) {
      return file;
    } else {
      return null;
    }
  }
  async deleteFromLocal(path) {
    const isExists = await this.vault.adapter.exists(path);
    if (!isExists) {
      console.error(`Attempting to read ${path} from local drive but not successful:
				the file doesn't exists`);
      return null;
    }
    await this.vault.adapter.remove(path);
    return { path, status: "deleted" };
  }
  // if checking a folder, require including the last / in the path param
  async ensureFolderExists(path) {
    var _a;
    const folderPath = ((_a = path.match(/^(.*)\//)) == null ? void 0 : _a[1]) || "";
    if (folderPath == "") {
      return false;
    }
    const parts = folderPath.split("/");
    let currentPath = "";
    for (const part of parts) {
      currentPath += part + "/";
      try {
        const isExists = await this.vault.adapter.exists(currentPath, true);
        if (isExists)
          continue;
        await this.vault.adapter.mkdir(currentPath);
      } catch (e) {
        return false;
      }
    }
    return true;
  }
  async writeToLocal(path, content) {
    const file = await this.vault.adapter.exists(path);
    if (file) {
      await this.vault.adapter.writeBinary(path, (0, import_obsidian6.base64ToArrayBuffer)(content));
      return { path, status: "changed" };
    } else {
      await this.ensureFolderExists(path);
      await this.vault.adapter.writeBinary(path, (0, import_obsidian6.base64ToArrayBuffer)(content));
      return { path, status: "created" };
    }
  }
  async updateLocalFiles(addToLocal, deleteFromLocal) {
    const writeOperations = addToLocal.map(async ({ path, content }) => {
      return await this.writeToLocal(path, content);
    });
    const deletionOperations = deleteFromLocal.map(async (path) => {
      return await this.deleteFromLocal(path);
    });
    const fileOps = await Promise.all([...writeOperations, ...deletionOperations]);
    return fileOps;
  }
  // TODO хотя нигде не используется, мб удалить надо
  async createCopyInDir(path, copyDir = "_fit") {
    const file = await this.vault.adapter.exists(path);
    if (file) {
      const copyPath = `${copyDir}/${path}`;
      const copy = await this.vault.adapter.readBinary(path);
      await this.ensureFolderExists(copyPath);
      const copyFile = await this.vault.adapter.exists(path);
      await this.vault.adapter.writeBinary(copyPath, copy);
      await this.vault.adapter.writeBinary(copyPath, copy);
    } else {
      throw new Error(`Attempting to create copy of ${path} from local drive as TFile but not successful,
            file is of type ${typeof file}.`);
    }
  }
  async getAllInObsidian() {
    const rootPath = this.vault.configDir;
    const folders = [rootPath + "/"];
    const files = [];
    const traverseDirectory = async (path) => {
      let items;
      try {
        items = await this.vault.adapter.list(path);
      } catch (error) {
        return null;
      }
      for (const folder of items.folders) {
        await traverseDirectory(folder);
        let folderPath = folder.startsWith("/") ? folder.slice(1) : folder;
        folderPath = folderPath === "" ? "" : `${folderPath}/`;
        folders.push(folderPath);
      }
      for (const file of items.files) {
        let filePath = file.startsWith("/") ? file.slice(1) : file;
        files.push(filePath);
      }
    };
    await traverseDirectory(rootPath);
    return { folders, files };
  }
  async getAllInVault() {
    const all = this.vault.getAllLoadedFiles();
    const folders = [];
    const files = [];
    for (let file of all) {
      if (file instanceof import_obsidian6.TFolder) {
        let path = file.path.startsWith("/") ? file.path.slice(1) : file.path;
        path = path == "" ? "" : `${path}/`;
        folders.push(path);
      } else if (file instanceof import_obsidian6.TFile) {
        const path = file.path.startsWith("/") ? file.path.slice(1) : file.path;
        files.push(path);
      }
    }
    const obsidianItems = await this.getAllInObsidian();
    const [obsidianFiles, obsidianFolders] = [obsidianItems.files, obsidianItems.folders];
    folders.push(...obsidianFolders);
    files.push(...obsidianFiles);
    return { folders, files };
  }
  async getFoldersInVault() {
    const { folders } = await this.getAllInVault();
    return folders;
  }
  async getFilesInVault() {
    const { files } = await this.getAllInVault();
    return files;
  }
};

// main.ts
var DEFAULT_LOCAL_STORE = {
  localSha: {},
  lastFetchedCommitSha: null,
  lastFetchedRemoteSha: {}
};
var DEFAULT_REPOSITORY = {
  settings: {
    pat: "",
    owner: "",
    avatarUrl: "",
    repo: "",
    branch: "",
    syncPath: "",
    deviceName: "",
    excludes: []
  },
  localStore: { ...DEFAULT_LOCAL_STORE }
};
var DEFAULT_SETTINGS = {
  repo: [DEFAULT_REPOSITORY],
  checkEveryXMinutes: 5,
  autoSync: "off",
  notifyChanges: true,
  notifyConflicts: true
};
var FitPlugin2 = class extends import_obsidian7.Plugin {
  constructor() {
    super(...arguments);
    // localStore: LocalStores
    this.fits = [];
    this.fitSync = [];
    // use of arrow functions to ensure this refers to the FitPlugin class
    this.saveLocalStoreCallback = async (path, localStore) => {
      const i = this.storage.repo.findIndex(
        (storage, _) => storage.settings.syncPath === path
      );
      if (i < 0) {
        return;
      }
      await this.loadSettings();
      this.storage.repo[i].localStore = {
        ...this.storage.repo[i].localStore,
        ...localStore
      };
      await this.saveSettings();
    };
    this.sync = async (syncNotice) => {
      if (!this.checkSettingsConfigured()) {
        return;
      }
      for (let i in this.fitSync) {
        const fitSync = this.fitSync[i];
        const syncRecords = await fitSync.sync(syncNotice);
        if (!syncRecords)
          continue;
        let { ops, clash } = syncRecords;
        const basepath = this.storage.repo[i].settings.syncPath;
        clash = clash.map(
          (el) => {
            return {
              ...el,
              path: basepath + el.path
            };
          }
        );
        if (this.storage.notifyConflicts)
          showUnappliedConflicts(clash);
        if (this.storage.notifyChanges)
          showFileOpsRecord(ops);
      }
    };
    // wrapper to convert error to notice, return true if error is caught
    this.catchErrorAndNotify = async (func, notice, ...args) => {
      try {
        const result = await func(notice, ...args);
        return result;
      } catch (error) {
        if (error instanceof OctokitHttpError) {
          console.log("error.status");
          console.log(error.status);
          switch (error.source) {
            case "getTree":
            case "getRef":
              console.error("Caught error from getRef: ", error.message);
              if (error.status === 404) {
                notice.setMessage("Failed to get ref, make sure your repo name and branch name are set correctly.", true);
                return true;
              }
              notice.setMessage("Unknown error in getting ref, refers to console for details.", true);
              return true;
            case "getCommitTreeSha":
            case "getRemoteTreeSha":
            case "createBlob":
            case "createTreeNodeFromFile":
            case "createCommit":
            case "updateRef":
            case "getBlob":
          }
          return true;
        }
        console.error("Caught unknown error: ", error);
        notice.setMessage("Unable to sync, if you are not connected to the internet, turn off auto sync.", true);
        return true;
      }
    };
  }
  // if settings not configured, open settings to let user quickly setup
  // Note: this is not a stable feature and might be disabled at any point in the future
  openPluginSettings() {
    const appWithSetting = this.app;
    appWithSetting.setting.open();
    appWithSetting.setting.openTabById("fit");
  }
  async checkSettingsConfigured() {
    const actionItems = [];
    const settings = this.storage.repo;
    const { files, folders } = await this.vaultOps.getAllInVault();
    const setSyncPath = /* @__PURE__ */ new Set();
    for (let i in settings) {
      const currentSetting = settings[i].settings;
      if (currentSetting.pat === "") {
        actionItems.push(`provide GitHub personal access token for repository: ${i + 1}`);
      }
      if (currentSetting.owner === "") {
        actionItems.push(`enter your Github nickname for repository: ${i + 1}`);
      }
      if (currentSetting.repo === "") {
        actionItems.push(`enter a repository to sync: ${i + 1}`);
      }
      if (currentSetting.branch === "") {
        actionItems.push(`enter a branch to sync: ${i + 1}`);
      }
      if (!folders.contains(currentSetting.syncPath)) {
        actionItems.push(`enter a directory (syncPath): ${i + 1}`);
      }
      for (let exlude of currentSetting.excludes) {
        if (exlude.startsWith(currentSetting.syncPath)) {
          continue;
        }
        actionItems.push(`enter a proper exlude (in syncPath) for repository: ${i + 1}`);
        break;
      }
      setSyncPath.add(currentSetting.syncPath);
    }
    if (setSyncPath.size != settings.length) {
      actionItems.push("Remove duplicate syncPaths");
    }
    if (actionItems.length > 0) {
      const initialMessage = "Settings not configured, please complete the following action items:\n" + actionItems.join("\n");
      const settingsNotice = new FitNotice(["static"], initialMessage);
      settingsNotice.remove("static");
      return false;
    }
    return true;
  }
  loadRibbonIcons() {
    this.fitSyncRibbonIconEl = this.addRibbonIcon("github", "Fit Sync", async (evt) => {
      if (this.syncing || this.autoSyncing) {
        return;
      }
      this.syncing = true;
      this.fitSyncRibbonIconEl.addClass("animate-icon");
      const syncNotice = new FitNotice(["loading"], "Initiating sync");
      const errorCaught = await this.catchErrorAndNotify(this.sync, syncNotice);
      this.fitSyncRibbonIconEl.removeClass("animate-icon");
      if (errorCaught === true) {
        syncNotice.remove("error");
        this.syncing = false;
        return;
      }
      syncNotice.remove("done");
      this.syncing = false;
    });
    this.fitSyncRibbonIconEl.addClass("fit-sync-ribbon-el");
  }
  async autoSync() {
    if (this.syncing || this.autoSyncing) {
      return;
    }
    this.autoSyncing = true;
    const syncNotice = new FitNotice(
      ["loading"],
      "Auto syncing",
      0,
      this.storage.autoSync === "muted"
    );
    const errorCaught = await this.catchErrorAndNotify(this.sync, syncNotice);
    if (errorCaught === true) {
      syncNotice.remove("error");
    } else {
      syncNotice.remove();
    }
    this.autoSyncing = false;
  }
  async autoUpdate() {
    if (!(this.storage.autoSync === "off") && !this.syncing && !this.autoSyncing && await this.checkSettingsConfigured()) {
      if (this.storage.autoSync === "on" || this.storage.autoSync === "muted") {
        await this.autoSync();
      } else if (this.storage.autoSync === "remind") {
        for (let fit of this.fits) {
          const { updated } = await fit.remoteUpdated();
          if (updated) {
            const initialMessage = "Remote update detected, please pull the latest changes.";
            const intervalNotice = new FitNotice(["static"], initialMessage);
            intervalNotice.remove("static");
          }
        }
      }
    }
  }
  async startOrUpdateAutoSyncInterval() {
    if (this.autoSyncIntervalId !== null) {
      window.clearInterval(this.autoSyncIntervalId);
      this.autoSyncIntervalId = null;
    }
    this.autoSyncIntervalId = window.setInterval(async () => {
      await this.autoUpdate();
    }, this.storage.checkEveryXMinutes * 60 * 1e3);
  }
  async onload() {
    await this.loadSettings();
    this.vaultOps = new VaultOperations(this.app.vault);
    const excludes = this.getExcludes();
    for (let repo_ of this.storage.repo) {
      let repo = structuredClone(repo_);
      for (let exclude of excludes) {
        if (exclude === repo.settings.syncPath)
          continue;
        repo.settings.excludes.push(exclude);
      }
      const fit = new Fit(repo, this.vaultOps);
      this.fits.push(fit);
      this.fitSync.push(
        new FitSync(fit, this.vaultOps, this.saveLocalStoreCallback)
      );
    }
    this.syncing = false;
    this.autoSyncing = false;
    this.settingTab = new FitSettingTab(this.app, this);
    this.loadRibbonIcons();
    this.addSettingTab(new FitSettingTab(this.app, this));
    await this.startOrUpdateAutoSyncInterval();
  }
  onunload() {
    if (this.autoSyncIntervalId !== null) {
      window.clearInterval(this.autoSyncIntervalId);
      this.autoSyncIntervalId = null;
    }
  }
  async loadSettings() {
    const userSetting = await this.loadData();
    const settings = Object.assign({}, DEFAULT_SETTINGS, userSetting);
    const settingsObj = Object.keys(DEFAULT_SETTINGS).reduce(
      (obj, key) => {
        if (settings.hasOwnProperty(key)) {
          if (key == "checkEveryXMinutes") {
            obj[key] = Number(settings[key]);
          } else if (key === "notifyChanges" || key === "notifyConflicts") {
            obj[key] = Boolean(settings[key]);
          } else {
            obj[key] = settings[key];
          }
        }
        return obj;
      },
      {}
    );
    this.storage = settingsObj;
  }
  // allow saving of local stores property, passed in properties will override existing stored value
  async saveSettings() {
    const data = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    const result = { ...data, ...this.storage };
    await this.saveData(result);
    const excludes = this.getExcludes();
    for (let i in this.fits) {
      let repo = structuredClone(this.storage.repo[i]);
      for (let exclude of excludes) {
        if (exclude === repo.settings.syncPath)
          continue;
        repo.settings.excludes.push(exclude);
      }
      this.fits[i].loadSettings(repo);
    }
    this.startOrUpdateAutoSyncInterval();
  }
  getExcludes() {
    const excludes = [];
    for (let repo of this.storage.repo) {
      const path = repo.settings.syncPath;
      if (path)
        excludes.push(path);
    }
    return excludes;
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyIsICJub2RlX21vZHVsZXMvQG9jdG9raXQvY29yZS9ub2RlX21vZHVsZXMvdW5pdmVyc2FsLXVzZXItYWdlbnQvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL2JlZm9yZS1hZnRlci1ob29rL2xpYi9yZWdpc3Rlci5qcyIsICJub2RlX21vZHVsZXMvYmVmb3JlLWFmdGVyLWhvb2svbGliL2FkZC5qcyIsICJub2RlX21vZHVsZXMvYmVmb3JlLWFmdGVyLWhvb2svbGliL3JlbW92ZS5qcyIsICJub2RlX21vZHVsZXMvYmVmb3JlLWFmdGVyLWhvb2svaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BvY3Rva2l0L2VuZHBvaW50L25vZGVfbW9kdWxlcy91bml2ZXJzYWwtdXNlci1hZ2VudC9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQG9jdG9raXQvZW5kcG9pbnQvZGlzdC1idW5kbGUvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BvY3Rva2l0L3JlcXVlc3Qvbm9kZV9tb2R1bGVzL3VuaXZlcnNhbC11c2VyLWFnZW50L2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ab2N0b2tpdC9yZXF1ZXN0L25vZGVfbW9kdWxlcy9Ab2N0b2tpdC9yZXF1ZXN0LWVycm9yL2Rpc3Qtc3JjL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ab2N0b2tpdC9yZXF1ZXN0L2Rpc3QtYnVuZGxlL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ab2N0b2tpdC9ncmFwaHFsL25vZGVfbW9kdWxlcy91bml2ZXJzYWwtdXNlci1hZ2VudC9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQG9jdG9raXQvZ3JhcGhxbC9kaXN0LWJ1bmRsZS9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQG9jdG9raXQvYXV0aC10b2tlbi9kaXN0LWJ1bmRsZS9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQG9jdG9raXQvY29yZS9kaXN0LXNyYy92ZXJzaW9uLmpzIiwgIm5vZGVfbW9kdWxlcy9Ab2N0b2tpdC9jb3JlL2Rpc3Qtc3JjL2luZGV4LmpzIiwgInNyYy91dGlscy50cyIsICJzcmMvZml0LnRzIiwgInNyYy9maXROb3RpY2UudHMiLCAic3JjL2ZpdFNldHRpbmcudHMiLCAic3JjL2ZpdFN5bmMudHMiLCAic3JjL2ZpdFB1bGwudHMiLCAic3JjL2ZpdFB1c2gudHMiLCAic3JjL3ZhdWx0T3BzLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgeyBQbHVnaW4sIFNldHRpbmdUYWIgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBGaXQsIE9jdG9raXRIdHRwRXJyb3IgfSBmcm9tICdzcmMvZml0JztcbmltcG9ydCBGaXROb3RpY2UgZnJvbSAnc3JjL2ZpdE5vdGljZSc7XG5pbXBvcnQgRml0U2V0dGluZ1RhYiBmcm9tICdzcmMvZml0U2V0dGluZyc7XG5pbXBvcnQgeyBGaXRTeW5jIH0gZnJvbSAnc3JjL2ZpdFN5bmMnO1xuaW1wb3J0IHsgc2hvd0ZpbGVPcHNSZWNvcmQsIHNob3dVbmFwcGxpZWRDb25mbGljdHMgfSBmcm9tICdzcmMvdXRpbHMnO1xuaW1wb3J0IHsgVmF1bHRPcGVyYXRpb25zIH0gZnJvbSAnc3JjL3ZhdWx0T3BzJztcblxuZXhwb3J0IGludGVyZmFjZSBTeW5jU2V0dGluZyB7XG5cdHBhdDogc3RyaW5nO1xuXHRvd25lcjogc3RyaW5nO1xuXHRhdmF0YXJVcmw6IHN0cmluZztcblx0cmVwbzogc3RyaW5nO1xuXHRicmFuY2g6IHN0cmluZztcblx0c3luY1BhdGg6IHN0cmluZztcblx0ZGV2aWNlTmFtZTogc3RyaW5nO1xuXHRleGNsdWRlczogc3RyaW5nW11cbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2NhbFN0b3JlcyB7XG5cdGxvY2FsU2hhOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG5cdGxhc3RGZXRjaGVkQ29tbWl0U2hhOiBzdHJpbmcgfCBudWxsXG5cdGxhc3RGZXRjaGVkUmVtb3RlU2hhOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVwb3NpdG9yeSB7XG5cdHNldHRpbmdzOiBTeW5jU2V0dGluZ1xuXHRsb2NhbFN0b3JlOiBMb2NhbFN0b3Jlc1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpdFN0b3JhZ2Uge1xuXHRyZXBvOiBSZXBvc2l0b3J5W11cblxuXHRjaGVja0V2ZXJ5WE1pbnV0ZXM6IG51bWJlcjtcblx0YXV0b1N5bmM6IFwib25cIiB8IFwib2ZmXCIgfCBcIm11dGVkXCIgfCBcInJlbWluZFwiO1xuXHRub3RpZnlDaGFuZ2VzOiBib29sZWFuO1xuXHRub3RpZnlDb25mbGljdHM6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0xPQ0FMX1NUT1JFOiBMb2NhbFN0b3JlcyA9IHtcblx0bG9jYWxTaGE6IHt9LFxuXHRsYXN0RmV0Y2hlZENvbW1pdFNoYTogbnVsbCxcblx0bGFzdEZldGNoZWRSZW1vdGVTaGE6IHt9XG59XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1JFUE9TSVRPUlkgPSB7XG5cdHNldHRpbmdzOiB7XG5cdFx0cGF0OiBcIlwiLFxuXHRcdG93bmVyOiBcIlwiLFxuXHRcdGF2YXRhclVybDogXCJcIixcblx0XHRyZXBvOiBcIlwiLFxuXHRcdGJyYW5jaDogXCJcIixcblx0XHRzeW5jUGF0aDogXCJcIixcblx0XHRkZXZpY2VOYW1lOiBcIlwiLFxuXHRcdGV4Y2x1ZGVzOiBbXVxuXHR9LFxuXHRsb2NhbFN0b3JlOiB7Li4uREVGQVVMVF9MT0NBTF9TVE9SRX1cbn1cblxuXG5jb25zdCBERUZBVUxUX1NFVFRJTkdTOiBGaXRTdG9yYWdlID0ge1xuXHRyZXBvOiBbREVGQVVMVF9SRVBPU0lUT1JZXSxcblx0Y2hlY2tFdmVyeVhNaW51dGVzOiA1LFxuXHRhdXRvU3luYzogXCJvZmZcIixcblx0bm90aWZ5Q2hhbmdlczogdHJ1ZSxcblx0bm90aWZ5Q29uZmxpY3RzOiB0cnVlLFxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpdFBsdWdpbiBleHRlbmRzIFBsdWdpbiB7XG5cdHN0b3JhZ2U6IEZpdFN0b3JhZ2U7XG5cblx0c2V0dGluZ1RhYjogRml0U2V0dGluZ1RhYlxuXHQvLyBsb2NhbFN0b3JlOiBMb2NhbFN0b3Jlc1xuXG5cdGZpdHM6IEZpdFtdID0gW107XG5cdGZpdFN5bmM6IEZpdFN5bmNbXSA9IFtdXG5cblx0dmF1bHRPcHM6IFZhdWx0T3BlcmF0aW9ucztcblx0YXV0b1N5bmNpbmc6IGJvb2xlYW5cblx0c3luY2luZzogYm9vbGVhblxuXHRhdXRvU3luY0ludGVydmFsSWQ6IG51bWJlciB8IG51bGxcblx0Zml0UHVsbFJpYmJvbkljb25FbDogSFRNTEVsZW1lbnRcblx0Zml0UHVzaFJpYmJvbkljb25FbDogSFRNTEVsZW1lbnRcblx0Zml0U3luY1JpYmJvbkljb25FbDogSFRNTEVsZW1lbnRcblxuXHQvLyBpZiBzZXR0aW5ncyBub3QgY29uZmlndXJlZCwgb3BlbiBzZXR0aW5ncyB0byBsZXQgdXNlciBxdWlja2x5IHNldHVwXG5cdC8vIE5vdGU6IHRoaXMgaXMgbm90IGEgc3RhYmxlIGZlYXR1cmUgYW5kIG1pZ2h0IGJlIGRpc2FibGVkIGF0IGFueSBwb2ludCBpbiB0aGUgZnV0dXJlXG5cdG9wZW5QbHVnaW5TZXR0aW5ncygpIHtcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXHRcdGNvbnN0IGFwcFdpdGhTZXR0aW5nID0gdGhpcy5hcHAgYXMgYW55IGFzIHtcblx0XHRcdHNldHRpbmc6IHtcblx0XHRcdFx0b3BlbigpOiB2b2lkO1xuXHRcdFx0XHRvcGVuVGFiQnlJZChpZDogc3RyaW5nKTogU2V0dGluZ1RhYiB8IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGFwcFdpdGhTZXR0aW5nLnNldHRpbmcub3BlbigpXG5cdFx0YXBwV2l0aFNldHRpbmcuc2V0dGluZy5vcGVuVGFiQnlJZChcImZpdFwiKVxuXHR9XG5cblx0YXN5bmMgY2hlY2tTZXR0aW5nc0NvbmZpZ3VyZWQoKTogUHJvbWlzZTxib29sZWFuPiB7XG5cdFx0Y29uc3QgYWN0aW9uSXRlbXM6IEFycmF5PHN0cmluZz4gPSBbXVxuXHRcdGNvbnN0IHNldHRpbmdzID0gdGhpcy5zdG9yYWdlLnJlcG87XG5cblx0XHRjb25zdCB7ZmlsZXMsIGZvbGRlcnN9ID0gYXdhaXQgdGhpcy52YXVsdE9wcy5nZXRBbGxJblZhdWx0KClcblx0XHRjb25zdCBzZXRTeW5jUGF0aCA9IG5ldyBTZXQoKVxuXG5cdFx0Zm9yIChsZXQgaSBpbiBzZXR0aW5ncykge1xuXHRcdFx0Y29uc3QgY3VycmVudFNldHRpbmcgPSBzZXR0aW5nc1tpXS5zZXR0aW5nc1xuXG5cdFx0XHRpZiAoY3VycmVudFNldHRpbmcucGF0ID09PSBcIlwiKSB7XG5cdFx0XHRcdGFjdGlvbkl0ZW1zLnB1c2goYHByb3ZpZGUgR2l0SHViIHBlcnNvbmFsIGFjY2VzcyB0b2tlbiBmb3IgcmVwb3NpdG9yeTogJHtpKzF9YClcblx0XHRcdH1cblx0XHRcdGlmIChjdXJyZW50U2V0dGluZy5vd25lciA9PT0gXCJcIikge1xuXHRcdFx0XHRhY3Rpb25JdGVtcy5wdXNoKGBlbnRlciB5b3VyIEdpdGh1YiBuaWNrbmFtZSBmb3IgcmVwb3NpdG9yeTogJHtpKzF9YClcblx0XHRcdH1cblx0XHRcdGlmIChjdXJyZW50U2V0dGluZy5yZXBvID09PSBcIlwiKSB7XG5cdFx0XHRcdGFjdGlvbkl0ZW1zLnB1c2goYGVudGVyIGEgcmVwb3NpdG9yeSB0byBzeW5jOiAke2krMX1gKVxuXHRcdFx0fVxuXHRcdFx0aWYgKGN1cnJlbnRTZXR0aW5nLmJyYW5jaCA9PT0gXCJcIikge1xuXHRcdFx0XHRhY3Rpb25JdGVtcy5wdXNoKGBlbnRlciBhIGJyYW5jaCB0byBzeW5jOiAke2krMX1gKVxuXHRcdFx0fVxuXHRcdFx0aWYgKCAhZm9sZGVycy5jb250YWlucyhjdXJyZW50U2V0dGluZy5zeW5jUGF0aCkgKSB7XG5cdFx0XHRcdGFjdGlvbkl0ZW1zLnB1c2goYGVudGVyIGEgZGlyZWN0b3J5IChzeW5jUGF0aCk6ICR7aSsxfWApXG5cdFx0XHR9XG5cdFx0XHRmb3IgKGxldCBleGx1ZGUgb2YgY3VycmVudFNldHRpbmcuZXhjbHVkZXMpIHtcblx0XHRcdFx0aWYgKGV4bHVkZS5zdGFydHNXaXRoKGN1cnJlbnRTZXR0aW5nLnN5bmNQYXRoKSkge1xuXHRcdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHRcdH1cblx0XHRcdFx0YWN0aW9uSXRlbXMucHVzaChgZW50ZXIgYSBwcm9wZXIgZXhsdWRlIChpbiBzeW5jUGF0aCkgZm9yIHJlcG9zaXRvcnk6ICR7aSsxfWApXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHR9XG5cblx0XHRcdHNldFN5bmNQYXRoLmFkZChjdXJyZW50U2V0dGluZy5zeW5jUGF0aClcblx0XHR9XG5cblx0XHRpZiAoc2V0U3luY1BhdGguc2l6ZSAhPSBzZXR0aW5ncy5sZW5ndGgpIHtcblx0XHRcdGFjdGlvbkl0ZW1zLnB1c2goXCJSZW1vdmUgZHVwbGljYXRlIHN5bmNQYXRoc1wiKVxuXHRcdH1cblxuXG5cdFx0aWYgKGFjdGlvbkl0ZW1zLmxlbmd0aCA+IDApIHtcblx0XHRcdGNvbnN0IGluaXRpYWxNZXNzYWdlID0gXCJTZXR0aW5ncyBub3QgY29uZmlndXJlZCwgcGxlYXNlIGNvbXBsZXRlIHRoZSBmb2xsb3dpbmcgYWN0aW9uIGl0ZW1zOlxcblwiICsgYWN0aW9uSXRlbXMuam9pbihcIlxcblwiKVxuXHRcdFx0Y29uc3Qgc2V0dGluZ3NOb3RpY2UgPSBuZXcgRml0Tm90aWNlKFtcInN0YXRpY1wiXSwgaW5pdGlhbE1lc3NhZ2UpXG5cdFx0XHQvLyB0aGlzLm9wZW5QbHVnaW5TZXR0aW5ncygpXG5cdFx0XHRzZXR0aW5nc05vdGljZS5yZW1vdmUoXCJzdGF0aWNcIilcblx0XHRcdHJldHVybiBmYWxzZVxuXHRcdH1cblxuXHRcdC8vIHRoaXMuZml0LmxvYWRTZXR0aW5ncyhjdXJyZW50U2V0dGluZylcblx0XHRyZXR1cm4gdHJ1ZVxuXHR9XG5cblx0Ly8gdXNlIG9mIGFycm93IGZ1bmN0aW9ucyB0byBlbnN1cmUgdGhpcyByZWZlcnMgdG8gdGhlIEZpdFBsdWdpbiBjbGFzc1xuXHRzYXZlTG9jYWxTdG9yZUNhbGxiYWNrID0gYXN5bmMgKHBhdGg6IHN0cmluZywgbG9jYWxTdG9yZTogUGFydGlhbDxMb2NhbFN0b3Jlcz4pOiBQcm9taXNlPHZvaWQ+ID0+IHtcblx0XHRjb25zdCBpID0gdGhpcy5zdG9yYWdlLnJlcG8uZmluZEluZGV4KFxuXHRcdFx0KHN0b3JhZ2UsIF8pID0+IHN0b3JhZ2Uuc2V0dGluZ3Muc3luY1BhdGggPT09IHBhdGhcblx0XHQpXG5cblx0XHRpZiAoaSA8IDApIHtcblx0XHRcdC8vIFRPRE8gc2hvdyBlcnJvclxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0YXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKVxuXG5cdFx0dGhpcy5zdG9yYWdlLnJlcG9baV0ubG9jYWxTdG9yZSA9IHtcblx0XHRcdC4uLnRoaXMuc3RvcmFnZS5yZXBvW2ldLmxvY2FsU3RvcmUsXG5cdFx0XHQuLi5sb2NhbFN0b3JlXG5cdFx0fVxuXG5cdFx0YXdhaXQgdGhpcy5zYXZlU2V0dGluZ3MoKVxuXHR9XG5cblx0c3luYyA9IGFzeW5jIChzeW5jTm90aWNlOiBGaXROb3RpY2UpOiBQcm9taXNlPHZvaWQ+ID0+IHtcblx0XHRpZiAoIXRoaXMuY2hlY2tTZXR0aW5nc0NvbmZpZ3VyZWQoKSkgeyByZXR1cm4gfVxuXHRcdC8vIGF3YWl0IHRoaXMubG9hZExvY2FsU3RvcmUoKVxuXHRcdGZvciAobGV0IGkgaW4gdGhpcy5maXRTeW5jKSB7XG5cdFx0XHRjb25zdCBmaXRTeW5jID0gdGhpcy5maXRTeW5jW2ldXG5cblx0XHRcdGNvbnN0IHN5bmNSZWNvcmRzID0gYXdhaXQgZml0U3luYy5zeW5jKHN5bmNOb3RpY2UpXG5cdFx0XHRpZiAoIXN5bmNSZWNvcmRzKVxuXHRcdFx0XHRjb250aW51ZVxuXG5cdFx0XHRsZXQgeyBvcHMsIGNsYXNoIH0gPSBzeW5jUmVjb3Jkc1xuXHRcdFx0Y29uc3QgYmFzZXBhdGggPSB0aGlzLnN0b3JhZ2UucmVwb1tpXS5zZXR0aW5ncy5zeW5jUGF0aFxuXHRcdFx0Y2xhc2ggPSBjbGFzaC5tYXAoXG5cdFx0XHRcdGVsID0+IHtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0Li4uZWwsXG5cdFx0XHRcdFx0XHRwYXRoOiBiYXNlcGF0aCArIGVsLnBhdGhcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdClcblx0XHRcdGlmICh0aGlzLnN0b3JhZ2Uubm90aWZ5Q29uZmxpY3RzKVxuXHRcdFx0XHRzaG93VW5hcHBsaWVkQ29uZmxpY3RzKGNsYXNoKVxuXG5cdFx0XHRpZiAodGhpcy5zdG9yYWdlLm5vdGlmeUNoYW5nZXMpXG5cdFx0XHRcdHNob3dGaWxlT3BzUmVjb3JkKG9wcylcblx0XHR9XG5cdH1cblxuXHQvLyB3cmFwcGVyIHRvIGNvbnZlcnQgZXJyb3IgdG8gbm90aWNlLCByZXR1cm4gdHJ1ZSBpZiBlcnJvciBpcyBjYXVnaHRcblx0Y2F0Y2hFcnJvckFuZE5vdGlmeSA9IGFzeW5jIDxQIGV4dGVuZHMgdW5rbm93bltdLCBSPihmdW5jOiAobm90aWNlOiBGaXROb3RpY2UsIC4uLmFyZ3M6IFApID0+IFByb21pc2U8Uj4sIG5vdGljZTogRml0Tm90aWNlLCAuLi5hcmdzOiBQKTogUHJvbWlzZTxSIHwgdHJ1ZT4gPT4ge1xuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCByZXN1bHQgPSBhd2FpdCBmdW5jKG5vdGljZSwgLi4uYXJncylcblx0XHRcdHJldHVybiByZXN1bHRcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKGVycm9yIGluc3RhbmNlb2YgT2N0b2tpdEh0dHBFcnJvcikge1xuXHRcdFx0XHRjb25zb2xlLmxvZyhcImVycm9yLnN0YXR1c1wiKVxuXHRcdFx0XHRjb25zb2xlLmxvZyhlcnJvci5zdGF0dXMpXG5cdFx0XHRcdHN3aXRjaCAoZXJyb3Iuc291cmNlKSB7XG5cdFx0XHRcdFx0Y2FzZSAnZ2V0VHJlZSc6XG5cdFx0XHRcdFx0Y2FzZSAnZ2V0UmVmJzpcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoXCJDYXVnaHQgZXJyb3IgZnJvbSBnZXRSZWY6IFwiLCBlcnJvci5tZXNzYWdlKVxuXHRcdFx0XHRcdFx0aWYgKGVycm9yLnN0YXR1cyA9PT0gNDA0KSB7XG5cdFx0XHRcdFx0XHRcdG5vdGljZS5zZXRNZXNzYWdlKFwiRmFpbGVkIHRvIGdldCByZWYsIG1ha2Ugc3VyZSB5b3VyIHJlcG8gbmFtZSBhbmQgYnJhbmNoIG5hbWUgYXJlIHNldCBjb3JyZWN0bHkuXCIsIHRydWUpXG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRub3RpY2Uuc2V0TWVzc2FnZShcIlVua25vd24gZXJyb3IgaW4gZ2V0dGluZyByZWYsIHJlZmVycyB0byBjb25zb2xlIGZvciBkZXRhaWxzLlwiLCB0cnVlKVxuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWVcblx0XHRcdFx0XHRjYXNlICdnZXRDb21taXRUcmVlU2hhJzpcblx0XHRcdFx0XHRjYXNlICdnZXRSZW1vdGVUcmVlU2hhJzpcblx0XHRcdFx0XHRjYXNlICdjcmVhdGVCbG9iJzpcblx0XHRcdFx0XHRjYXNlICdjcmVhdGVUcmVlTm9kZUZyb21GaWxlJzpcblx0XHRcdFx0XHRjYXNlICdjcmVhdGVDb21taXQnOlxuXHRcdFx0XHRcdGNhc2UgJ3VwZGF0ZVJlZic6XG5cdFx0XHRcdFx0Y2FzZSAnZ2V0QmxvYic6XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWVcblx0XHRcdH1cblx0XHRcdGNvbnNvbGUuZXJyb3IoXCJDYXVnaHQgdW5rbm93biBlcnJvcjogXCIsIGVycm9yKVxuXHRcdFx0bm90aWNlLnNldE1lc3NhZ2UoXCJVbmFibGUgdG8gc3luYywgaWYgeW91IGFyZSBub3QgY29ubmVjdGVkIHRvIHRoZSBpbnRlcm5ldCwgdHVybiBvZmYgYXV0byBzeW5jLlwiLCB0cnVlKVxuXHRcdFx0cmV0dXJuIHRydWVcblx0XHR9XG5cdH1cblxuXHRsb2FkUmliYm9uSWNvbnMoKSB7XG5cdFx0Ly8gUHVsbCBmcm9tIHJlbW90ZSB0aGVuIFB1c2ggdG8gcmVtb3RlIGlmIG5vIGNsYXNoaW5nIGNoYW5nZXMgZGV0ZWN0ZWQgZHVyaW5nIHB1bGxcblx0XHR0aGlzLmZpdFN5bmNSaWJib25JY29uRWwgPSB0aGlzLmFkZFJpYmJvbkljb24oJ2dpdGh1YicsICdGaXQgU3luYycsIGFzeW5jIChldnQ6IE1vdXNlRXZlbnQpID0+IHtcblx0XHRcdGlmICh0aGlzLnN5bmNpbmcgfHwgdGhpcy5hdXRvU3luY2luZykgeyByZXR1cm4gfVxuXHRcdFx0dGhpcy5zeW5jaW5nID0gdHJ1ZVxuXHRcdFx0dGhpcy5maXRTeW5jUmliYm9uSWNvbkVsLmFkZENsYXNzKCdhbmltYXRlLWljb24nKTtcblx0XHRcdGNvbnN0IHN5bmNOb3RpY2UgPSBuZXcgRml0Tm90aWNlKFtcImxvYWRpbmdcIl0sIFwiSW5pdGlhdGluZyBzeW5jXCIpO1xuXHRcdFx0Y29uc3QgZXJyb3JDYXVnaHQgPSBhd2FpdCB0aGlzLmNhdGNoRXJyb3JBbmROb3RpZnkodGhpcy5zeW5jLCBzeW5jTm90aWNlKTtcblx0XHRcdHRoaXMuZml0U3luY1JpYmJvbkljb25FbC5yZW1vdmVDbGFzcygnYW5pbWF0ZS1pY29uJyk7XG5cdFx0XHRpZiAoZXJyb3JDYXVnaHQgPT09IHRydWUpIHtcblx0XHRcdFx0c3luY05vdGljZS5yZW1vdmUoXCJlcnJvclwiKVxuXHRcdFx0XHR0aGlzLnN5bmNpbmcgPSBmYWxzZVxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdHN5bmNOb3RpY2UucmVtb3ZlKFwiZG9uZVwiKVxuXHRcdFx0dGhpcy5zeW5jaW5nID0gZmFsc2Vcblx0XHR9KTtcblx0XHR0aGlzLmZpdFN5bmNSaWJib25JY29uRWwuYWRkQ2xhc3MoJ2ZpdC1zeW5jLXJpYmJvbi1lbCcpO1xuXHR9XG5cblx0YXN5bmMgYXV0b1N5bmMoKSB7XG5cdFx0aWYgKHRoaXMuc3luY2luZyB8fCB0aGlzLmF1dG9TeW5jaW5nKSB7IHJldHVybiB9XG5cdFx0dGhpcy5hdXRvU3luY2luZyA9IHRydWVcblx0XHRjb25zdCBzeW5jTm90aWNlID0gbmV3IEZpdE5vdGljZShcblx0XHRcdFtcImxvYWRpbmdcIl0sXG5cdFx0XHRcIkF1dG8gc3luY2luZ1wiLFxuXHRcdFx0MCxcblx0XHRcdHRoaXMuc3RvcmFnZS5hdXRvU3luYyA9PT0gXCJtdXRlZFwiXG5cdFx0KTtcblx0XHRjb25zdCBlcnJvckNhdWdodCA9IGF3YWl0IHRoaXMuY2F0Y2hFcnJvckFuZE5vdGlmeSh0aGlzLnN5bmMsIHN5bmNOb3RpY2UpO1xuXHRcdGlmIChlcnJvckNhdWdodCA9PT0gdHJ1ZSkge1xuXHRcdFx0c3luY05vdGljZS5yZW1vdmUoXCJlcnJvclwiKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzeW5jTm90aWNlLnJlbW92ZSgpXG5cdFx0fVxuXHRcdHRoaXMuYXV0b1N5bmNpbmcgPSBmYWxzZVxuXHR9XG5cblx0YXN5bmMgYXV0b1VwZGF0ZSgpIHtcblx0XHRpZiAoISh0aGlzLnN0b3JhZ2UuYXV0b1N5bmMgPT09IFwib2ZmXCIpICYmICF0aGlzLnN5bmNpbmcgJiYgIXRoaXMuYXV0b1N5bmNpbmcgJiYgYXdhaXQgdGhpcy5jaGVja1NldHRpbmdzQ29uZmlndXJlZCgpKSB7XG5cdFx0XHRpZiAodGhpcy5zdG9yYWdlLmF1dG9TeW5jID09PSBcIm9uXCIgfHwgdGhpcy5zdG9yYWdlLmF1dG9TeW5jID09PSBcIm11dGVkXCIpIHtcblx0XHRcdFx0YXdhaXQgdGhpcy5hdXRvU3luYygpO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLnN0b3JhZ2UuYXV0b1N5bmMgPT09IFwicmVtaW5kXCIpIHtcblx0XHRcdFx0Zm9yIChsZXQgZml0IG9mIHRoaXMuZml0cykge1xuXHRcdFx0XHRcdGNvbnN0IHsgdXBkYXRlZCB9ID0gYXdhaXQgZml0LnJlbW90ZVVwZGF0ZWQoKTtcblxuXHRcdFx0XHRcdGlmICh1cGRhdGVkKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBpbml0aWFsTWVzc2FnZSA9IFwiUmVtb3RlIHVwZGF0ZSBkZXRlY3RlZCwgcGxlYXNlIHB1bGwgdGhlIGxhdGVzdCBjaGFuZ2VzLlwiO1xuXHRcdFx0XHRcdFx0Y29uc3QgaW50ZXJ2YWxOb3RpY2UgPSBuZXcgRml0Tm90aWNlKFtcInN0YXRpY1wiXSwgaW5pdGlhbE1lc3NhZ2UpO1xuXHRcdFx0XHRcdFx0aW50ZXJ2YWxOb3RpY2UucmVtb3ZlKFwic3RhdGljXCIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cblx0YXN5bmMgc3RhcnRPclVwZGF0ZUF1dG9TeW5jSW50ZXJ2YWwoKSB7XG5cdFx0Ly8gQ2xlYXIgZXhpc3RpbmcgaW50ZXJ2YWwgaWYgaXQgZXhpc3RzXG5cdFx0aWYgKHRoaXMuYXV0b1N5bmNJbnRlcnZhbElkICE9PSBudWxsKSB7XG5cdFx0XHR3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLmF1dG9TeW5jSW50ZXJ2YWxJZCk7XG5cdFx0XHR0aGlzLmF1dG9TeW5jSW50ZXJ2YWxJZCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgcmVtb3RlIGV2ZXJ5IFggbWludXRlcyAoc2V0IGluIHNldHRpbmdzKVxuXHRcdHRoaXMuYXV0b1N5bmNJbnRlcnZhbElkID0gd2luZG93LnNldEludGVydmFsKGFzeW5jICgpID0+IHtcblx0XHRcdGF3YWl0IHRoaXMuYXV0b1VwZGF0ZSgpO1xuXHRcdH0sIHRoaXMuc3RvcmFnZS5jaGVja0V2ZXJ5WE1pbnV0ZXMgKiA2MCAqIDEwMDApO1xuXHR9XG5cblx0YXN5bmMgb25sb2FkKCkge1xuXHRcdGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XG5cblx0XHR0aGlzLnZhdWx0T3BzID0gbmV3IFZhdWx0T3BlcmF0aW9ucyh0aGlzLmFwcC52YXVsdClcblxuXHRcdGNvbnN0IGV4Y2x1ZGVzID0gdGhpcy5nZXRFeGNsdWRlcygpXG5cdFx0Zm9yIChsZXQgcmVwb18gb2YgdGhpcy5zdG9yYWdlLnJlcG8pIHtcblx0XHRcdGxldCByZXBvID0gc3RydWN0dXJlZENsb25lKHJlcG9fKVxuXG5cdFx0XHRmb3IgKGxldCBleGNsdWRlIG9mIGV4Y2x1ZGVzKSB7XG5cdFx0XHRcdGlmIChleGNsdWRlID09PSByZXBvLnNldHRpbmdzLnN5bmNQYXRoKVxuXHRcdFx0XHRcdGNvbnRpbnVlXG5cblx0XHRcdFx0cmVwby5zZXR0aW5ncy5leGNsdWRlcy5wdXNoKGV4Y2x1ZGUpXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGZpdCA9IG5ldyBGaXQocmVwbywgdGhpcy52YXVsdE9wcylcblxuXHRcdFx0dGhpcy5maXRzLnB1c2goZml0KVxuXHRcdFx0dGhpcy5maXRTeW5jLnB1c2goXG5cdFx0XHRcdG5ldyBGaXRTeW5jKGZpdCwgdGhpcy52YXVsdE9wcywgdGhpcy5zYXZlTG9jYWxTdG9yZUNhbGxiYWNrKVxuXHRcdFx0KVxuXHRcdH1cblxuXHRcdHRoaXMuc3luY2luZyA9IGZhbHNlXG5cdFx0dGhpcy5hdXRvU3luY2luZyA9IGZhbHNlXG5cdFx0dGhpcy5zZXR0aW5nVGFiID0gbmV3IEZpdFNldHRpbmdUYWIodGhpcy5hcHAsIHRoaXMpXG5cdFx0dGhpcy5sb2FkUmliYm9uSWNvbnMoKTtcblxuXHRcdC8vIFRoaXMgYWRkcyBhIHNldHRpbmdzIHRhYiBzbyB0aGUgdXNlciBjYW4gY29uZmlndXJlIHZhcmlvdXMgYXNwZWN0cyBvZiB0aGUgcGx1Z2luXG5cdFx0dGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBGaXRTZXR0aW5nVGFiKHRoaXMuYXBwLCB0aGlzKSk7XG5cblx0XHQvLyByZWdpc3RlciBpbnRlcnZhbCB0byByZXBlYXQgYXV0byBjaGVja1xuXHRcdGF3YWl0IHRoaXMuc3RhcnRPclVwZGF0ZUF1dG9TeW5jSW50ZXJ2YWwoKTtcblx0fVxuXG5cdG9udW5sb2FkKCkge1xuXHRcdGlmICh0aGlzLmF1dG9TeW5jSW50ZXJ2YWxJZCAhPT0gbnVsbCkge1xuXHRcdFx0d2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy5hdXRvU3luY0ludGVydmFsSWQpO1xuXHRcdFx0dGhpcy5hdXRvU3luY0ludGVydmFsSWQgPSBudWxsO1xuXHRcdH1cblx0fVxuXG5cdGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcblx0XHRjb25zdCB1c2VyU2V0dGluZyA9IGF3YWl0IHRoaXMubG9hZERhdGEoKVxuXHRcdGNvbnN0IHNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9TRVRUSU5HUywgdXNlclNldHRpbmcpO1xuXHRcdGNvbnN0IHNldHRpbmdzT2JqOiBGaXRTdG9yYWdlID0gT2JqZWN0LmtleXMoREVGQVVMVF9TRVRUSU5HUykucmVkdWNlKFxuXHRcdFx0KG9iaiwga2V5OiBrZXlvZiBGaXRTdG9yYWdlKSA9PiB7XG5cdFx0XHRcdGlmIChzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdFx0aWYgKGtleSA9PSBcImNoZWNrRXZlcnlYTWludXRlc1wiKSB7XG5cdFx0XHRcdFx0XHRvYmpba2V5XSA9IE51bWJlcihzZXR0aW5nc1trZXldKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoa2V5ID09PSBcIm5vdGlmeUNoYW5nZXNcIiB8fCBrZXkgPT09IFwibm90aWZ5Q29uZmxpY3RzXCIpIHtcblx0XHRcdFx0XHRcdG9ialtrZXldID0gQm9vbGVhbihzZXR0aW5nc1trZXldKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRvYmpba2V5XSA9IHNldHRpbmdzW2tleV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHR9LCB7fSBhcyBGaXRTdG9yYWdlKTtcblx0XHR0aGlzLnN0b3JhZ2UgPSBzZXR0aW5nc09ialxuXHR9XG5cblx0Ly8gYWxsb3cgc2F2aW5nIG9mIGxvY2FsIHN0b3JlcyBwcm9wZXJ0eSwgcGFzc2VkIGluIHByb3BlcnRpZXMgd2lsbCBvdmVycmlkZSBleGlzdGluZyBzdG9yZWQgdmFsdWVcblx0YXN5bmMgc2F2ZVNldHRpbmdzKCkge1xuXHRcdGNvbnN0IGRhdGEgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xuXHRcdC8vIGNvbnN0IGRhdGEgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCB0aGlzLnN0b3JhZ2UpO1xuXHRcdGNvbnN0IHJlc3VsdDogRml0U3RvcmFnZSA9IHsgLi4uZGF0YSwgLi4udGhpcy5zdG9yYWdlIH1cblxuXHRcdGF3YWl0IHRoaXMuc2F2ZURhdGEocmVzdWx0KTtcblxuXHRcdGNvbnN0IGV4Y2x1ZGVzID0gdGhpcy5nZXRFeGNsdWRlcygpXG5cblx0XHQvLyBzeW5jIHNldHRpbmdzIHRvIEZpdCBjbGFzcyBhcyB3ZWxsIHVwb24gc2F2aW5nXG5cdFx0Zm9yIChsZXQgaSBpbiB0aGlzLmZpdHMpIHtcblx0XHRcdGxldCByZXBvID0gc3RydWN0dXJlZENsb25lKHRoaXMuc3RvcmFnZS5yZXBvW2ldKVxuXG5cdFx0XHRmb3IgKGxldCBleGNsdWRlIG9mIGV4Y2x1ZGVzKSB7XG5cdFx0XHRcdGlmIChleGNsdWRlID09PSByZXBvLnNldHRpbmdzLnN5bmNQYXRoKVxuXHRcdFx0XHRcdGNvbnRpbnVlXG5cblx0XHRcdFx0cmVwby5zZXR0aW5ncy5leGNsdWRlcy5wdXNoKGV4Y2x1ZGUpXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZml0c1tpXS5sb2FkU2V0dGluZ3MocmVwbylcblx0XHR9XG5cblx0XHQvLyB1cGRhdGUgYXV0byBzeW5jIGludGVydmFsIHdpdGggbmV3IHNldHRpbmdcblx0XHR0aGlzLnN0YXJ0T3JVcGRhdGVBdXRvU3luY0ludGVydmFsKCk7XG5cdH1cblxuXHRnZXRFeGNsdWRlcygpOiBzdHJpbmdbXSB7XG5cdFx0Y29uc3QgZXhjbHVkZXMgPSBbXVxuXHRcdGZvciAobGV0IHJlcG8gb2YgdGhpcy5zdG9yYWdlLnJlcG8pIHtcblx0XHRcdGNvbnN0IHBhdGggPSByZXBvLnNldHRpbmdzLnN5bmNQYXRoXG5cdFx0XHRpZiAocGF0aClcblx0XHRcdFx0ZXhjbHVkZXMucHVzaChwYXRoKVxuXHRcdH1cblxuXHRcdHJldHVybiBleGNsdWRlc1xuXHR9XG5cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gZ2V0VXNlckFnZW50KCkge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gXCJvYmplY3RcIiAmJiBcInVzZXJBZ2VudFwiIGluIG5hdmlnYXRvcikge1xuICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MudmVyc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGBOb2RlLmpzLyR7cHJvY2Vzcy52ZXJzaW9uLnN1YnN0cigxKX0gKCR7cHJvY2Vzcy5wbGF0Zm9ybX07ICR7XG4gICAgICBwcm9jZXNzLmFyY2hcbiAgICB9KWA7XG4gIH1cblxuICByZXR1cm4gXCI8ZW52aXJvbm1lbnQgdW5kZXRlY3RhYmxlPlwiO1xufVxuIiwgIi8vIEB0cy1jaGVja1xuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXIoc3RhdGUsIG5hbWUsIG1ldGhvZCwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibWV0aG9kIGZvciBiZWZvcmUgaG9vayBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShuYW1lKSkge1xuICAgIHJldHVybiBuYW1lLnJldmVyc2UoKS5yZWR1Y2UoKGNhbGxiYWNrLCBuYW1lKSA9PiB7XG4gICAgICByZXR1cm4gcmVnaXN0ZXIuYmluZChudWxsLCBzdGF0ZSwgbmFtZSwgY2FsbGJhY2ssIG9wdGlvbnMpO1xuICAgIH0sIG1ldGhvZCkoKTtcbiAgfVxuXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICBpZiAoIXN0YXRlLnJlZ2lzdHJ5W25hbWVdKSB7XG4gICAgICByZXR1cm4gbWV0aG9kKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBzdGF0ZS5yZWdpc3RyeVtuYW1lXS5yZWR1Y2UoKG1ldGhvZCwgcmVnaXN0ZXJlZCkgPT4ge1xuICAgICAgcmV0dXJuIHJlZ2lzdGVyZWQuaG9vay5iaW5kKG51bGwsIG1ldGhvZCwgb3B0aW9ucyk7XG4gICAgfSwgbWV0aG9kKSgpO1xuICB9KTtcbn1cbiIsICIvLyBAdHMtY2hlY2tcblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEhvb2soc3RhdGUsIGtpbmQsIG5hbWUsIGhvb2spIHtcbiAgY29uc3Qgb3JpZyA9IGhvb2s7XG4gIGlmICghc3RhdGUucmVnaXN0cnlbbmFtZV0pIHtcbiAgICBzdGF0ZS5yZWdpc3RyeVtuYW1lXSA9IFtdO1xuICB9XG5cbiAgaWYgKGtpbmQgPT09IFwiYmVmb3JlXCIpIHtcbiAgICBob29rID0gKG1ldGhvZCwgb3B0aW9ucykgPT4ge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgIC50aGVuKG9yaWcuYmluZChudWxsLCBvcHRpb25zKSlcbiAgICAgICAgLnRoZW4obWV0aG9kLmJpbmQobnVsbCwgb3B0aW9ucykpO1xuICAgIH07XG4gIH1cblxuICBpZiAoa2luZCA9PT0gXCJhZnRlclwiKSB7XG4gICAgaG9vayA9IChtZXRob2QsIG9wdGlvbnMpID0+IHtcbiAgICAgIGxldCByZXN1bHQ7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgLnRoZW4obWV0aG9kLmJpbmQobnVsbCwgb3B0aW9ucykpXG4gICAgICAgIC50aGVuKChyZXN1bHRfKSA9PiB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0XztcbiAgICAgICAgICByZXR1cm4gb3JpZyhyZXN1bHQsIG9wdGlvbnMpO1xuICAgICAgICB9KVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChraW5kID09PSBcImVycm9yXCIpIHtcbiAgICBob29rID0gKG1ldGhvZCwgb3B0aW9ucykgPT4ge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgIC50aGVuKG1ldGhvZC5iaW5kKG51bGwsIG9wdGlvbnMpKVxuICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIG9yaWcoZXJyb3IsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICB9XG5cbiAgc3RhdGUucmVnaXN0cnlbbmFtZV0ucHVzaCh7XG4gICAgaG9vazogaG9vayxcbiAgICBvcmlnOiBvcmlnLFxuICB9KTtcbn1cbiIsICIvLyBAdHMtY2hlY2tcblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUhvb2soc3RhdGUsIG5hbWUsIG1ldGhvZCkge1xuICBpZiAoIXN0YXRlLnJlZ2lzdHJ5W25hbWVdKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgaW5kZXggPSBzdGF0ZS5yZWdpc3RyeVtuYW1lXVxuICAgIC5tYXAoKHJlZ2lzdGVyZWQpID0+IHtcbiAgICAgIHJldHVybiByZWdpc3RlcmVkLm9yaWc7XG4gICAgfSlcbiAgICAuaW5kZXhPZihtZXRob2QpO1xuXG4gIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzdGF0ZS5yZWdpc3RyeVtuYW1lXS5zcGxpY2UoaW5kZXgsIDEpO1xufVxuIiwgIi8vIEB0cy1jaGVja1xuXG5pbXBvcnQgeyByZWdpc3RlciB9IGZyb20gXCIuL2xpYi9yZWdpc3Rlci5qc1wiO1xuaW1wb3J0IHsgYWRkSG9vayB9IGZyb20gXCIuL2xpYi9hZGQuanNcIjtcbmltcG9ydCB7IHJlbW92ZUhvb2sgfSBmcm9tIFwiLi9saWIvcmVtb3ZlLmpzXCI7XG5cbi8vIGJpbmQgd2l0aCBhcnJheSBvZiBhcmd1bWVudHM6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMTc5MjkxM1xuY29uc3QgYmluZCA9IEZ1bmN0aW9uLmJpbmQ7XG5jb25zdCBiaW5kYWJsZSA9IGJpbmQuYmluZChiaW5kKTtcblxuZnVuY3Rpb24gYmluZEFwaShob29rLCBzdGF0ZSwgbmFtZSkge1xuICBjb25zdCByZW1vdmVIb29rUmVmID0gYmluZGFibGUocmVtb3ZlSG9vaywgbnVsbCkuYXBwbHkoXG4gICAgbnVsbCxcbiAgICBuYW1lID8gW3N0YXRlLCBuYW1lXSA6IFtzdGF0ZV1cbiAgKTtcbiAgaG9vay5hcGkgPSB7IHJlbW92ZTogcmVtb3ZlSG9va1JlZiB9O1xuICBob29rLnJlbW92ZSA9IHJlbW92ZUhvb2tSZWY7XG4gIFtcImJlZm9yZVwiLCBcImVycm9yXCIsIFwiYWZ0ZXJcIiwgXCJ3cmFwXCJdLmZvckVhY2goKGtpbmQpID0+IHtcbiAgICBjb25zdCBhcmdzID0gbmFtZSA/IFtzdGF0ZSwga2luZCwgbmFtZV0gOiBbc3RhdGUsIGtpbmRdO1xuICAgIGhvb2tba2luZF0gPSBob29rLmFwaVtraW5kXSA9IGJpbmRhYmxlKGFkZEhvb2ssIG51bGwpLmFwcGx5KG51bGwsIGFyZ3MpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gU2luZ3VsYXIoKSB7XG4gIGNvbnN0IHNpbmd1bGFySG9va05hbWUgPSBTeW1ib2woXCJTaW5ndWxhclwiKTtcbiAgY29uc3Qgc2luZ3VsYXJIb29rU3RhdGUgPSB7XG4gICAgcmVnaXN0cnk6IHt9LFxuICB9O1xuICBjb25zdCBzaW5ndWxhckhvb2sgPSByZWdpc3Rlci5iaW5kKG51bGwsIHNpbmd1bGFySG9va1N0YXRlLCBzaW5ndWxhckhvb2tOYW1lKTtcbiAgYmluZEFwaShzaW5ndWxhckhvb2ssIHNpbmd1bGFySG9va1N0YXRlLCBzaW5ndWxhckhvb2tOYW1lKTtcbiAgcmV0dXJuIHNpbmd1bGFySG9vaztcbn1cblxuZnVuY3Rpb24gQ29sbGVjdGlvbigpIHtcbiAgY29uc3Qgc3RhdGUgPSB7XG4gICAgcmVnaXN0cnk6IHt9LFxuICB9O1xuXG4gIGNvbnN0IGhvb2sgPSByZWdpc3Rlci5iaW5kKG51bGwsIHN0YXRlKTtcbiAgYmluZEFwaShob29rLCBzdGF0ZSk7XG5cbiAgcmV0dXJuIGhvb2s7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHsgU2luZ3VsYXIsIENvbGxlY3Rpb24gfTtcbiIsICJleHBvcnQgZnVuY3Rpb24gZ2V0VXNlckFnZW50KCkge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gXCJvYmplY3RcIiAmJiBcInVzZXJBZ2VudFwiIGluIG5hdmlnYXRvcikge1xuICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MudmVyc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGBOb2RlLmpzLyR7cHJvY2Vzcy52ZXJzaW9uLnN1YnN0cigxKX0gKCR7cHJvY2Vzcy5wbGF0Zm9ybX07ICR7XG4gICAgICBwcm9jZXNzLmFyY2hcbiAgICB9KWA7XG4gIH1cblxuICByZXR1cm4gXCI8ZW52aXJvbm1lbnQgdW5kZXRlY3RhYmxlPlwiO1xufVxuIiwgIi8vIHBrZy9kaXN0LXNyYy9kZWZhdWx0cy5qc1xuaW1wb3J0IHsgZ2V0VXNlckFnZW50IH0gZnJvbSBcInVuaXZlcnNhbC11c2VyLWFnZW50XCI7XG5cbi8vIHBrZy9kaXN0LXNyYy92ZXJzaW9uLmpzXG52YXIgVkVSU0lPTiA9IFwiMC4wLjAtZGV2ZWxvcG1lbnRcIjtcblxuLy8gcGtnL2Rpc3Qtc3JjL2RlZmF1bHRzLmpzXG52YXIgdXNlckFnZW50ID0gYG9jdG9raXQtZW5kcG9pbnQuanMvJHtWRVJTSU9OfSAke2dldFVzZXJBZ2VudCgpfWA7XG52YXIgREVGQVVMVFMgPSB7XG4gIG1ldGhvZDogXCJHRVRcIixcbiAgYmFzZVVybDogXCJodHRwczovL2FwaS5naXRodWIuY29tXCIsXG4gIGhlYWRlcnM6IHtcbiAgICBhY2NlcHQ6IFwiYXBwbGljYXRpb24vdm5kLmdpdGh1Yi52Mytqc29uXCIsXG4gICAgXCJ1c2VyLWFnZW50XCI6IHVzZXJBZ2VudFxuICB9LFxuICBtZWRpYVR5cGU6IHtcbiAgICBmb3JtYXQ6IFwiXCJcbiAgfVxufTtcblxuLy8gcGtnL2Rpc3Qtc3JjL3V0aWwvbG93ZXJjYXNlLWtleXMuanNcbmZ1bmN0aW9uIGxvd2VyY2FzZUtleXMob2JqZWN0KSB7XG4gIGlmICghb2JqZWN0KSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmplY3QpLnJlZHVjZSgobmV3T2JqLCBrZXkpID0+IHtcbiAgICBuZXdPYmpba2V5LnRvTG93ZXJDYXNlKCldID0gb2JqZWN0W2tleV07XG4gICAgcmV0dXJuIG5ld09iajtcbiAgfSwge30pO1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvdXRpbC9pcy1wbGFpbi1vYmplY3QuanNcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PT0gbnVsbClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICE9PSBcIltvYmplY3QgT2JqZWN0XVwiKVxuICAgIHJldHVybiBmYWxzZTtcbiAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpXG4gICAgcmV0dXJuIHRydWU7XG4gIGNvbnN0IEN0b3IgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvdG8sIFwiY29uc3RydWN0b3JcIikgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gXCJmdW5jdGlvblwiICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsKEN0b3IpID09PSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbCh2YWx1ZSk7XG59XG5cbi8vIHBrZy9kaXN0LXNyYy91dGlsL21lcmdlLWRlZXAuanNcbmZ1bmN0aW9uIG1lcmdlRGVlcChkZWZhdWx0cywgb3B0aW9ucykge1xuICBjb25zdCByZXN1bHQgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cyk7XG4gIE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGlmIChpc1BsYWluT2JqZWN0KG9wdGlvbnNba2V5XSkpIHtcbiAgICAgIGlmICghKGtleSBpbiBkZWZhdWx0cykpXG4gICAgICAgIE9iamVjdC5hc3NpZ24ocmVzdWx0LCB7IFtrZXldOiBvcHRpb25zW2tleV0gfSk7XG4gICAgICBlbHNlXG4gICAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2VEZWVwKGRlZmF1bHRzW2tleV0sIG9wdGlvbnNba2V5XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5hc3NpZ24ocmVzdWx0LCB7IFtrZXldOiBvcHRpb25zW2tleV0gfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gcGtnL2Rpc3Qtc3JjL3V0aWwvcmVtb3ZlLXVuZGVmaW5lZC1wcm9wZXJ0aWVzLmpzXG5mdW5jdGlvbiByZW1vdmVVbmRlZmluZWRQcm9wZXJ0aWVzKG9iaikge1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICBpZiAob2JqW2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvbWVyZ2UuanNcbmZ1bmN0aW9uIG1lcmdlKGRlZmF1bHRzLCByb3V0ZSwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHJvdXRlID09PSBcInN0cmluZ1wiKSB7XG4gICAgbGV0IFttZXRob2QsIHVybF0gPSByb3V0ZS5zcGxpdChcIiBcIik7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24odXJsID8geyBtZXRob2QsIHVybCB9IDogeyB1cmw6IG1ldGhvZCB9LCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgcm91dGUpO1xuICB9XG4gIG9wdGlvbnMuaGVhZGVycyA9IGxvd2VyY2FzZUtleXMob3B0aW9ucy5oZWFkZXJzKTtcbiAgcmVtb3ZlVW5kZWZpbmVkUHJvcGVydGllcyhvcHRpb25zKTtcbiAgcmVtb3ZlVW5kZWZpbmVkUHJvcGVydGllcyhvcHRpb25zLmhlYWRlcnMpO1xuICBjb25zdCBtZXJnZWRPcHRpb25zID0gbWVyZ2VEZWVwKGRlZmF1bHRzIHx8IHt9LCBvcHRpb25zKTtcbiAgaWYgKG9wdGlvbnMudXJsID09PSBcIi9ncmFwaHFsXCIpIHtcbiAgICBpZiAoZGVmYXVsdHMgJiYgZGVmYXVsdHMubWVkaWFUeXBlLnByZXZpZXdzPy5sZW5ndGgpIHtcbiAgICAgIG1lcmdlZE9wdGlvbnMubWVkaWFUeXBlLnByZXZpZXdzID0gZGVmYXVsdHMubWVkaWFUeXBlLnByZXZpZXdzLmZpbHRlcihcbiAgICAgICAgKHByZXZpZXcpID0+ICFtZXJnZWRPcHRpb25zLm1lZGlhVHlwZS5wcmV2aWV3cy5pbmNsdWRlcyhwcmV2aWV3KVxuICAgICAgKS5jb25jYXQobWVyZ2VkT3B0aW9ucy5tZWRpYVR5cGUucHJldmlld3MpO1xuICAgIH1cbiAgICBtZXJnZWRPcHRpb25zLm1lZGlhVHlwZS5wcmV2aWV3cyA9IChtZXJnZWRPcHRpb25zLm1lZGlhVHlwZS5wcmV2aWV3cyB8fCBbXSkubWFwKChwcmV2aWV3KSA9PiBwcmV2aWV3LnJlcGxhY2UoLy1wcmV2aWV3LywgXCJcIikpO1xuICB9XG4gIHJldHVybiBtZXJnZWRPcHRpb25zO1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvdXRpbC9hZGQtcXVlcnktcGFyYW1ldGVycy5qc1xuZnVuY3Rpb24gYWRkUXVlcnlQYXJhbWV0ZXJzKHVybCwgcGFyYW1ldGVycykge1xuICBjb25zdCBzZXBhcmF0b3IgPSAvXFw/Ly50ZXN0KHVybCkgPyBcIiZcIiA6IFwiP1wiO1xuICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKHBhcmFtZXRlcnMpO1xuICBpZiAobmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICByZXR1cm4gdXJsICsgc2VwYXJhdG9yICsgbmFtZXMubWFwKChuYW1lKSA9PiB7XG4gICAgaWYgKG5hbWUgPT09IFwicVwiKSB7XG4gICAgICByZXR1cm4gXCJxPVwiICsgcGFyYW1ldGVycy5xLnNwbGl0KFwiK1wiKS5tYXAoZW5jb2RlVVJJQ29tcG9uZW50KS5qb2luKFwiK1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIGAke25hbWV9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtZXRlcnNbbmFtZV0pfWA7XG4gIH0pLmpvaW4oXCImXCIpO1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvdXRpbC9leHRyYWN0LXVybC12YXJpYWJsZS1uYW1lcy5qc1xudmFyIHVybFZhcmlhYmxlUmVnZXggPSAvXFx7W159XStcXH0vZztcbmZ1bmN0aW9uIHJlbW92ZU5vbkNoYXJzKHZhcmlhYmxlTmFtZSkge1xuICByZXR1cm4gdmFyaWFibGVOYW1lLnJlcGxhY2UoL15cXFcrfFxcVyskL2csIFwiXCIpLnNwbGl0KC8sLyk7XG59XG5mdW5jdGlvbiBleHRyYWN0VXJsVmFyaWFibGVOYW1lcyh1cmwpIHtcbiAgY29uc3QgbWF0Y2hlcyA9IHVybC5tYXRjaCh1cmxWYXJpYWJsZVJlZ2V4KTtcbiAgaWYgKCFtYXRjaGVzKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBtYXRjaGVzLm1hcChyZW1vdmVOb25DaGFycykucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSwgW10pO1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvdXRpbC9vbWl0LmpzXG5mdW5jdGlvbiBvbWl0KG9iamVjdCwga2V5c1RvT21pdCkge1xuICBjb25zdCByZXN1bHQgPSB7IF9fcHJvdG9fXzogbnVsbCB9O1xuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvYmplY3QpKSB7XG4gICAgaWYgKGtleXNUb09taXQuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gcGtnL2Rpc3Qtc3JjL3V0aWwvdXJsLXRlbXBsYXRlLmpzXG5mdW5jdGlvbiBlbmNvZGVSZXNlcnZlZChzdHIpIHtcbiAgcmV0dXJuIHN0ci5zcGxpdCgvKCVbMC05QS1GYS1mXXsyfSkvZykubWFwKGZ1bmN0aW9uKHBhcnQpIHtcbiAgICBpZiAoIS8lWzAtOUEtRmEtZl0vLnRlc3QocGFydCkpIHtcbiAgICAgIHBhcnQgPSBlbmNvZGVVUkkocGFydCkucmVwbGFjZSgvJTVCL2csIFwiW1wiKS5yZXBsYWNlKC8lNUQvZywgXCJdXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcGFydDtcbiAgfSkuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIGVuY29kZVVucmVzZXJ2ZWQoc3RyKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKS5yZXBsYWNlKC9bIScoKSpdL2csIGZ1bmN0aW9uKGMpIHtcbiAgICByZXR1cm4gXCIlXCIgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZW5jb2RlVmFsdWUob3BlcmF0b3IsIHZhbHVlLCBrZXkpIHtcbiAgdmFsdWUgPSBvcGVyYXRvciA9PT0gXCIrXCIgfHwgb3BlcmF0b3IgPT09IFwiI1wiID8gZW5jb2RlUmVzZXJ2ZWQodmFsdWUpIDogZW5jb2RlVW5yZXNlcnZlZCh2YWx1ZSk7XG4gIGlmIChrZXkpIHtcbiAgICByZXR1cm4gZW5jb2RlVW5yZXNlcnZlZChrZXkpICsgXCI9XCIgKyB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzRGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZvaWQgMCAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzS2V5T3BlcmF0b3Iob3BlcmF0b3IpIHtcbiAgcmV0dXJuIG9wZXJhdG9yID09PSBcIjtcIiB8fCBvcGVyYXRvciA9PT0gXCImXCIgfHwgb3BlcmF0b3IgPT09IFwiP1wiO1xufVxuZnVuY3Rpb24gZ2V0VmFsdWVzKGNvbnRleHQsIG9wZXJhdG9yLCBrZXksIG1vZGlmaWVyKSB7XG4gIHZhciB2YWx1ZSA9IGNvbnRleHRba2V5XSwgcmVzdWx0ID0gW107XG4gIGlmIChpc0RlZmluZWQodmFsdWUpICYmIHZhbHVlICE9PSBcIlwiKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgaWYgKG1vZGlmaWVyICYmIG1vZGlmaWVyICE9PSBcIipcIikge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygwLCBwYXJzZUludChtb2RpZmllciwgMTApKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICBlbmNvZGVWYWx1ZShvcGVyYXRvciwgdmFsdWUsIGlzS2V5T3BlcmF0b3Iob3BlcmF0b3IpID8ga2V5IDogXCJcIilcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChtb2RpZmllciA9PT0gXCIqXCIpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUuZmlsdGVyKGlzRGVmaW5lZCkuZm9yRWFjaChmdW5jdGlvbih2YWx1ZTIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgICAgICBlbmNvZGVWYWx1ZShvcGVyYXRvciwgdmFsdWUyLCBpc0tleU9wZXJhdG9yKG9wZXJhdG9yKSA/IGtleSA6IFwiXCIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIE9iamVjdC5rZXlzKHZhbHVlKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICAgIGlmIChpc0RlZmluZWQodmFsdWVba10pKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGVuY29kZVZhbHVlKG9wZXJhdG9yLCB2YWx1ZVtrXSwgaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0bXAgPSBbXTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUuZmlsdGVyKGlzRGVmaW5lZCkuZm9yRWFjaChmdW5jdGlvbih2YWx1ZTIpIHtcbiAgICAgICAgICAgIHRtcC5wdXNoKGVuY29kZVZhbHVlKG9wZXJhdG9yLCB2YWx1ZTIpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWZpbmVkKHZhbHVlW2tdKSkge1xuICAgICAgICAgICAgICB0bXAucHVzaChlbmNvZGVVbnJlc2VydmVkKGspKTtcbiAgICAgICAgICAgICAgdG1wLnB1c2goZW5jb2RlVmFsdWUob3BlcmF0b3IsIHZhbHVlW2tdLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNLZXlPcGVyYXRvcihvcGVyYXRvcikpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGVVbnJlc2VydmVkKGtleSkgKyBcIj1cIiArIHRtcC5qb2luKFwiLFwiKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodG1wLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHRtcC5qb2luKFwiLFwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKG9wZXJhdG9yID09PSBcIjtcIikge1xuICAgICAgaWYgKGlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlVW5yZXNlcnZlZChrZXkpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBcIlwiICYmIChvcGVyYXRvciA9PT0gXCImXCIgfHwgb3BlcmF0b3IgPT09IFwiP1wiKSkge1xuICAgICAgcmVzdWx0LnB1c2goZW5jb2RlVW5yZXNlcnZlZChrZXkpICsgXCI9XCIpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IFwiXCIpIHtcbiAgICAgIHJlc3VsdC5wdXNoKFwiXCIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGFyc2VVcmwodGVtcGxhdGUpIHtcbiAgcmV0dXJuIHtcbiAgICBleHBhbmQ6IGV4cGFuZC5iaW5kKG51bGwsIHRlbXBsYXRlKVxuICB9O1xufVxuZnVuY3Rpb24gZXhwYW5kKHRlbXBsYXRlLCBjb250ZXh0KSB7XG4gIHZhciBvcGVyYXRvcnMgPSBbXCIrXCIsIFwiI1wiLCBcIi5cIiwgXCIvXCIsIFwiO1wiLCBcIj9cIiwgXCImXCJdO1xuICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLnJlcGxhY2UoXG4gICAgL1xceyhbXlxce1xcfV0rKVxcfXwoW15cXHtcXH1dKykvZyxcbiAgICBmdW5jdGlvbihfLCBleHByZXNzaW9uLCBsaXRlcmFsKSB7XG4gICAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICBsZXQgb3BlcmF0b3IgPSBcIlwiO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgaWYgKG9wZXJhdG9ycy5pbmRleE9mKGV4cHJlc3Npb24uY2hhckF0KDApKSAhPT0gLTEpIHtcbiAgICAgICAgICBvcGVyYXRvciA9IGV4cHJlc3Npb24uY2hhckF0KDApO1xuICAgICAgICAgIGV4cHJlc3Npb24gPSBleHByZXNzaW9uLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgICBleHByZXNzaW9uLnNwbGl0KC8sL2cpLmZvckVhY2goZnVuY3Rpb24odmFyaWFibGUpIHtcbiAgICAgICAgICB2YXIgdG1wID0gLyhbXjpcXCpdKikoPzo6KFxcZCspfChcXCopKT8vLmV4ZWModmFyaWFibGUpO1xuICAgICAgICAgIHZhbHVlcy5wdXNoKGdldFZhbHVlcyhjb250ZXh0LCBvcGVyYXRvciwgdG1wWzFdLCB0bXBbMl0gfHwgdG1wWzNdKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob3BlcmF0b3IgJiYgb3BlcmF0b3IgIT09IFwiK1wiKSB7XG4gICAgICAgICAgdmFyIHNlcGFyYXRvciA9IFwiLFwiO1xuICAgICAgICAgIGlmIChvcGVyYXRvciA9PT0gXCI/XCIpIHtcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IFwiJlwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAob3BlcmF0b3IgIT09IFwiI1wiKSB7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICh2YWx1ZXMubGVuZ3RoICE9PSAwID8gb3BlcmF0b3IgOiBcIlwiKSArIHZhbHVlcy5qb2luKHNlcGFyYXRvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlcy5qb2luKFwiLFwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVJlc2VydmVkKGxpdGVyYWwpO1xuICAgICAgfVxuICAgIH1cbiAgKTtcbiAgaWYgKHRlbXBsYXRlID09PSBcIi9cIikge1xuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGVtcGxhdGUucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuICB9XG59XG5cbi8vIHBrZy9kaXN0LXNyYy9wYXJzZS5qc1xuZnVuY3Rpb24gcGFyc2Uob3B0aW9ucykge1xuICBsZXQgbWV0aG9kID0gb3B0aW9ucy5tZXRob2QudG9VcHBlckNhc2UoKTtcbiAgbGV0IHVybCA9IChvcHRpb25zLnVybCB8fCBcIi9cIikucmVwbGFjZSgvOihbYS16XVxcdyspL2csIFwieyQxfVwiKTtcbiAgbGV0IGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLmhlYWRlcnMpO1xuICBsZXQgYm9keTtcbiAgbGV0IHBhcmFtZXRlcnMgPSBvbWl0KG9wdGlvbnMsIFtcbiAgICBcIm1ldGhvZFwiLFxuICAgIFwiYmFzZVVybFwiLFxuICAgIFwidXJsXCIsXG4gICAgXCJoZWFkZXJzXCIsXG4gICAgXCJyZXF1ZXN0XCIsXG4gICAgXCJtZWRpYVR5cGVcIlxuICBdKTtcbiAgY29uc3QgdXJsVmFyaWFibGVOYW1lcyA9IGV4dHJhY3RVcmxWYXJpYWJsZU5hbWVzKHVybCk7XG4gIHVybCA9IHBhcnNlVXJsKHVybCkuZXhwYW5kKHBhcmFtZXRlcnMpO1xuICBpZiAoIS9eaHR0cC8udGVzdCh1cmwpKSB7XG4gICAgdXJsID0gb3B0aW9ucy5iYXNlVXJsICsgdXJsO1xuICB9XG4gIGNvbnN0IG9taXR0ZWRQYXJhbWV0ZXJzID0gT2JqZWN0LmtleXMob3B0aW9ucykuZmlsdGVyKChvcHRpb24pID0+IHVybFZhcmlhYmxlTmFtZXMuaW5jbHVkZXMob3B0aW9uKSkuY29uY2F0KFwiYmFzZVVybFwiKTtcbiAgY29uc3QgcmVtYWluaW5nUGFyYW1ldGVycyA9IG9taXQocGFyYW1ldGVycywgb21pdHRlZFBhcmFtZXRlcnMpO1xuICBjb25zdCBpc0JpbmFyeVJlcXVlc3QgPSAvYXBwbGljYXRpb25cXC9vY3RldC1zdHJlYW0vaS50ZXN0KGhlYWRlcnMuYWNjZXB0KTtcbiAgaWYgKCFpc0JpbmFyeVJlcXVlc3QpIHtcbiAgICBpZiAob3B0aW9ucy5tZWRpYVR5cGUuZm9ybWF0KSB7XG4gICAgICBoZWFkZXJzLmFjY2VwdCA9IGhlYWRlcnMuYWNjZXB0LnNwbGl0KC8sLykubWFwKFxuICAgICAgICAoZm9ybWF0KSA9PiBmb3JtYXQucmVwbGFjZShcbiAgICAgICAgICAvYXBwbGljYXRpb25cXC92bmQoXFwuXFx3KykoXFwudjMpPyhcXC5cXHcrKT8oXFwranNvbik/JC8sXG4gICAgICAgICAgYGFwcGxpY2F0aW9uL3ZuZCQxJDIuJHtvcHRpb25zLm1lZGlhVHlwZS5mb3JtYXR9YFxuICAgICAgICApXG4gICAgICApLmpvaW4oXCIsXCIpO1xuICAgIH1cbiAgICBpZiAodXJsLmVuZHNXaXRoKFwiL2dyYXBocWxcIikpIHtcbiAgICAgIGlmIChvcHRpb25zLm1lZGlhVHlwZS5wcmV2aWV3cz8ubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHByZXZpZXdzRnJvbUFjY2VwdEhlYWRlciA9IGhlYWRlcnMuYWNjZXB0Lm1hdGNoKC9bXFx3LV0rKD89LXByZXZpZXcpL2cpIHx8IFtdO1xuICAgICAgICBoZWFkZXJzLmFjY2VwdCA9IHByZXZpZXdzRnJvbUFjY2VwdEhlYWRlci5jb25jYXQob3B0aW9ucy5tZWRpYVR5cGUucHJldmlld3MpLm1hcCgocHJldmlldykgPT4ge1xuICAgICAgICAgIGNvbnN0IGZvcm1hdCA9IG9wdGlvbnMubWVkaWFUeXBlLmZvcm1hdCA/IGAuJHtvcHRpb25zLm1lZGlhVHlwZS5mb3JtYXR9YCA6IFwiK2pzb25cIjtcbiAgICAgICAgICByZXR1cm4gYGFwcGxpY2F0aW9uL3ZuZC5naXRodWIuJHtwcmV2aWV3fS1wcmV2aWV3JHtmb3JtYXR9YDtcbiAgICAgICAgfSkuam9pbihcIixcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChbXCJHRVRcIiwgXCJIRUFEXCJdLmluY2x1ZGVzKG1ldGhvZCkpIHtcbiAgICB1cmwgPSBhZGRRdWVyeVBhcmFtZXRlcnModXJsLCByZW1haW5pbmdQYXJhbWV0ZXJzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoXCJkYXRhXCIgaW4gcmVtYWluaW5nUGFyYW1ldGVycykge1xuICAgICAgYm9keSA9IHJlbWFpbmluZ1BhcmFtZXRlcnMuZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHJlbWFpbmluZ1BhcmFtZXRlcnMpLmxlbmd0aCkge1xuICAgICAgICBib2R5ID0gcmVtYWluaW5nUGFyYW1ldGVycztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFoZWFkZXJzW1wiY29udGVudC10eXBlXCJdICYmIHR5cGVvZiBib2R5ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA9IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiO1xuICB9XG4gIGlmIChbXCJQQVRDSFwiLCBcIlBVVFwiXS5pbmNsdWRlcyhtZXRob2QpICYmIHR5cGVvZiBib2R5ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgYm9keSA9IFwiXCI7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgeyBtZXRob2QsIHVybCwgaGVhZGVycyB9LFxuICAgIHR5cGVvZiBib2R5ICE9PSBcInVuZGVmaW5lZFwiID8geyBib2R5IH0gOiBudWxsLFxuICAgIG9wdGlvbnMucmVxdWVzdCA/IHsgcmVxdWVzdDogb3B0aW9ucy5yZXF1ZXN0IH0gOiBudWxsXG4gICk7XG59XG5cbi8vIHBrZy9kaXN0LXNyYy9lbmRwb2ludC13aXRoLWRlZmF1bHRzLmpzXG5mdW5jdGlvbiBlbmRwb2ludFdpdGhEZWZhdWx0cyhkZWZhdWx0cywgcm91dGUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHBhcnNlKG1lcmdlKGRlZmF1bHRzLCByb3V0ZSwgb3B0aW9ucykpO1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvd2l0aC1kZWZhdWx0cy5qc1xuZnVuY3Rpb24gd2l0aERlZmF1bHRzKG9sZERlZmF1bHRzLCBuZXdEZWZhdWx0cykge1xuICBjb25zdCBERUZBVUxUUzIgPSBtZXJnZShvbGREZWZhdWx0cywgbmV3RGVmYXVsdHMpO1xuICBjb25zdCBlbmRwb2ludDIgPSBlbmRwb2ludFdpdGhEZWZhdWx0cy5iaW5kKG51bGwsIERFRkFVTFRTMik7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKGVuZHBvaW50Miwge1xuICAgIERFRkFVTFRTOiBERUZBVUxUUzIsXG4gICAgZGVmYXVsdHM6IHdpdGhEZWZhdWx0cy5iaW5kKG51bGwsIERFRkFVTFRTMiksXG4gICAgbWVyZ2U6IG1lcmdlLmJpbmQobnVsbCwgREVGQVVMVFMyKSxcbiAgICBwYXJzZVxuICB9KTtcbn1cblxuLy8gcGtnL2Rpc3Qtc3JjL2luZGV4LmpzXG52YXIgZW5kcG9pbnQgPSB3aXRoRGVmYXVsdHMobnVsbCwgREVGQVVMVFMpO1xuZXhwb3J0IHtcbiAgZW5kcG9pbnRcbn07XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGdldFVzZXJBZ2VudCgpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09IFwib2JqZWN0XCIgJiYgXCJ1c2VyQWdlbnRcIiBpbiBuYXZpZ2F0b3IpIHtcbiAgICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzLnZlcnNpb24gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBgTm9kZS5qcy8ke3Byb2Nlc3MudmVyc2lvbi5zdWJzdHIoMSl9ICgke3Byb2Nlc3MucGxhdGZvcm19OyAke1xuICAgICAgcHJvY2Vzcy5hcmNoXG4gICAgfSlgO1xuICB9XG5cbiAgcmV0dXJuIFwiPGVudmlyb25tZW50IHVuZGV0ZWN0YWJsZT5cIjtcbn1cbiIsICJjbGFzcyBSZXF1ZXN0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIG5hbWU7XG4gIC8qKlxuICAgKiBodHRwIHN0YXR1cyBjb2RlXG4gICAqL1xuICBzdGF0dXM7XG4gIC8qKlxuICAgKiBSZXF1ZXN0IG9wdGlvbnMgdGhhdCBsZWFkIHRvIHRoZSBlcnJvci5cbiAgICovXG4gIHJlcXVlc3Q7XG4gIC8qKlxuICAgKiBSZXNwb25zZSBvYmplY3QgaWYgYSByZXNwb25zZSB3YXMgcmVjZWl2ZWRcbiAgICovXG4gIHJlc3BvbnNlO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGF0dXNDb2RlLCBvcHRpb25zKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICB9XG4gICAgdGhpcy5uYW1lID0gXCJIdHRwRXJyb3JcIjtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1c0NvZGU7XG4gICAgaWYgKFwicmVzcG9uc2VcIiBpbiBvcHRpb25zKSB7XG4gICAgICB0aGlzLnJlc3BvbnNlID0gb3B0aW9ucy5yZXNwb25zZTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdENvcHkgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLnJlcXVlc3QpO1xuICAgIGlmIChvcHRpb25zLnJlcXVlc3QuaGVhZGVycy5hdXRob3JpemF0aW9uKSB7XG4gICAgICByZXF1ZXN0Q29weS5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5yZXF1ZXN0LmhlYWRlcnMsIHtcbiAgICAgICAgYXV0aG9yaXphdGlvbjogb3B0aW9ucy5yZXF1ZXN0LmhlYWRlcnMuYXV0aG9yaXphdGlvbi5yZXBsYWNlKFxuICAgICAgICAgIC8gLiokLyxcbiAgICAgICAgICBcIiBbUkVEQUNURURdXCJcbiAgICAgICAgKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJlcXVlc3RDb3B5LnVybCA9IHJlcXVlc3RDb3B5LnVybC5yZXBsYWNlKC9cXGJjbGllbnRfc2VjcmV0PVxcdysvZywgXCJjbGllbnRfc2VjcmV0PVtSRURBQ1RFRF1cIikucmVwbGFjZSgvXFxiYWNjZXNzX3Rva2VuPVxcdysvZywgXCJhY2Nlc3NfdG9rZW49W1JFREFDVEVEXVwiKTtcbiAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0Q29weTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgUmVxdWVzdEVycm9yXG59O1xuIiwgIi8vIHBrZy9kaXN0LXNyYy9pbmRleC5qc1xuaW1wb3J0IHsgZW5kcG9pbnQgfSBmcm9tIFwiQG9jdG9raXQvZW5kcG9pbnRcIjtcbmltcG9ydCB7IGdldFVzZXJBZ2VudCB9IGZyb20gXCJ1bml2ZXJzYWwtdXNlci1hZ2VudFwiO1xuXG4vLyBwa2cvZGlzdC1zcmMvdmVyc2lvbi5qc1xudmFyIFZFUlNJT04gPSBcIjAuMC4wLWRldmVsb3BtZW50XCI7XG5cbi8vIHBrZy9kaXN0LXNyYy9pcy1wbGFpbi1vYmplY3QuanNcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PT0gbnVsbClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICE9PSBcIltvYmplY3QgT2JqZWN0XVwiKVxuICAgIHJldHVybiBmYWxzZTtcbiAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpXG4gICAgcmV0dXJuIHRydWU7XG4gIGNvbnN0IEN0b3IgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvdG8sIFwiY29uc3RydWN0b3JcIikgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gXCJmdW5jdGlvblwiICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsKEN0b3IpID09PSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbCh2YWx1ZSk7XG59XG5cbi8vIHBrZy9kaXN0LXNyYy9mZXRjaC13cmFwcGVyLmpzXG5pbXBvcnQgeyBSZXF1ZXN0RXJyb3IgfSBmcm9tIFwiQG9jdG9raXQvcmVxdWVzdC1lcnJvclwiO1xuXG4vLyBwa2cvZGlzdC1zcmMvZ2V0LWJ1ZmZlci1yZXNwb25zZS5qc1xuZnVuY3Rpb24gZ2V0QnVmZmVyUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgcmV0dXJuIHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG59XG5cbi8vIHBrZy9kaXN0LXNyYy9mZXRjaC13cmFwcGVyLmpzXG5mdW5jdGlvbiBmZXRjaFdyYXBwZXIocmVxdWVzdE9wdGlvbnMpIHtcbiAgY29uc3QgbG9nID0gcmVxdWVzdE9wdGlvbnMucmVxdWVzdCAmJiByZXF1ZXN0T3B0aW9ucy5yZXF1ZXN0LmxvZyA/IHJlcXVlc3RPcHRpb25zLnJlcXVlc3QubG9nIDogY29uc29sZTtcbiAgY29uc3QgcGFyc2VTdWNjZXNzUmVzcG9uc2VCb2R5ID0gcmVxdWVzdE9wdGlvbnMucmVxdWVzdD8ucGFyc2VTdWNjZXNzUmVzcG9uc2VCb2R5ICE9PSBmYWxzZTtcbiAgaWYgKGlzUGxhaW5PYmplY3QocmVxdWVzdE9wdGlvbnMuYm9keSkgfHwgQXJyYXkuaXNBcnJheShyZXF1ZXN0T3B0aW9ucy5ib2R5KSkge1xuICAgIHJlcXVlc3RPcHRpb25zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShyZXF1ZXN0T3B0aW9ucy5ib2R5KTtcbiAgfVxuICBsZXQgaGVhZGVycyA9IHt9O1xuICBsZXQgc3RhdHVzO1xuICBsZXQgdXJsO1xuICBsZXQgeyBmZXRjaCB9ID0gZ2xvYmFsVGhpcztcbiAgaWYgKHJlcXVlc3RPcHRpb25zLnJlcXVlc3Q/LmZldGNoKSB7XG4gICAgZmV0Y2ggPSByZXF1ZXN0T3B0aW9ucy5yZXF1ZXN0LmZldGNoO1xuICB9XG4gIGlmICghZmV0Y2gpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcImZldGNoIGlzIG5vdCBzZXQuIFBsZWFzZSBwYXNzIGEgZmV0Y2ggaW1wbGVtZW50YXRpb24gYXMgbmV3IE9jdG9raXQoeyByZXF1ZXN0OiB7IGZldGNoIH19KS4gTGVhcm4gbW9yZSBhdCBodHRwczovL2dpdGh1Yi5jb20vb2N0b2tpdC9vY3Rva2l0LmpzLyNmZXRjaC1taXNzaW5nXCJcbiAgICApO1xuICB9XG4gIHJldHVybiBmZXRjaChyZXF1ZXN0T3B0aW9ucy51cmwsIHtcbiAgICBtZXRob2Q6IHJlcXVlc3RPcHRpb25zLm1ldGhvZCxcbiAgICBib2R5OiByZXF1ZXN0T3B0aW9ucy5ib2R5LFxuICAgIC8vIEhlYWRlciB2YWx1ZXMgbXVzdCBiZSBgc3RyaW5nYFxuICAgIGhlYWRlcnM6IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIE9iamVjdC5lbnRyaWVzKHJlcXVlc3RPcHRpb25zLmhlYWRlcnMpLm1hcCgoW25hbWUsIHZhbHVlXSkgPT4gW1xuICAgICAgICBuYW1lLFxuICAgICAgICBTdHJpbmcodmFsdWUpXG4gICAgICBdKVxuICAgICksXG4gICAgc2lnbmFsOiByZXF1ZXN0T3B0aW9ucy5yZXF1ZXN0Py5zaWduYWwsXG4gICAgLy8gZHVwbGV4IG11c3QgYmUgc2V0IGlmIHJlcXVlc3QuYm9keSBpcyBSZWFkYWJsZVN0cmVhbSBvciBBc3luYyBJdGVyYWJsZXMuXG4gICAgLy8gU2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tcmVxdWVzdGluaXQtZHVwbGV4LlxuICAgIC4uLnJlcXVlc3RPcHRpb25zLmJvZHkgJiYgeyBkdXBsZXg6IFwiaGFsZlwiIH1cbiAgfSkudGhlbihhc3luYyAocmVzcG9uc2UpID0+IHtcbiAgICB1cmwgPSByZXNwb25zZS51cmw7XG4gICAgc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzO1xuICAgIGZvciAoY29uc3Qga2V5QW5kVmFsdWUgb2YgcmVzcG9uc2UuaGVhZGVycykge1xuICAgICAgaGVhZGVyc1trZXlBbmRWYWx1ZVswXV0gPSBrZXlBbmRWYWx1ZVsxXTtcbiAgICB9XG4gICAgaWYgKFwiZGVwcmVjYXRpb25cIiBpbiBoZWFkZXJzKSB7XG4gICAgICBjb25zdCBtYXRjaGVzID0gaGVhZGVycy5saW5rICYmIGhlYWRlcnMubGluay5tYXRjaCgvPChbXj5dKyk+OyByZWw9XCJkZXByZWNhdGlvblwiLyk7XG4gICAgICBjb25zdCBkZXByZWNhdGlvbkxpbmsgPSBtYXRjaGVzICYmIG1hdGNoZXMucG9wKCk7XG4gICAgICBsb2cud2FybihcbiAgICAgICAgYFtAb2N0b2tpdC9yZXF1ZXN0XSBcIiR7cmVxdWVzdE9wdGlvbnMubWV0aG9kfSAke3JlcXVlc3RPcHRpb25zLnVybH1cIiBpcyBkZXByZWNhdGVkLiBJdCBpcyBzY2hlZHVsZWQgdG8gYmUgcmVtb3ZlZCBvbiAke2hlYWRlcnMuc3Vuc2V0fSR7ZGVwcmVjYXRpb25MaW5rID8gYC4gU2VlICR7ZGVwcmVjYXRpb25MaW5rfWAgOiBcIlwifWBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09IDIwNCB8fCBzdGF0dXMgPT09IDIwNSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocmVxdWVzdE9wdGlvbnMubWV0aG9kID09PSBcIkhFQURcIikge1xuICAgICAgaWYgKHN0YXR1cyA8IDQwMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgUmVxdWVzdEVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHN0YXR1cywge1xuICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgIHVybCxcbiAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBkYXRhOiB2b2lkIDBcbiAgICAgICAgfSxcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdE9wdGlvbnNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSAzMDQpIHtcbiAgICAgIHRocm93IG5ldyBSZXF1ZXN0RXJyb3IoXCJOb3QgbW9kaWZpZWRcIiwgc3RhdHVzLCB7XG4gICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIGRhdGE6IGF3YWl0IGdldFJlc3BvbnNlRGF0YShyZXNwb25zZSlcbiAgICAgICAgfSxcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdE9wdGlvbnNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID49IDQwMCkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGdldFJlc3BvbnNlRGF0YShyZXNwb25zZSk7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBSZXF1ZXN0RXJyb3IodG9FcnJvck1lc3NhZ2UoZGF0YSksIHN0YXR1cywge1xuICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgIHVybCxcbiAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBkYXRhXG4gICAgICAgIH0sXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RPcHRpb25zXG4gICAgICB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VTdWNjZXNzUmVzcG9uc2VCb2R5ID8gYXdhaXQgZ2V0UmVzcG9uc2VEYXRhKHJlc3BvbnNlKSA6IHJlc3BvbnNlLmJvZHk7XG4gIH0pLnRoZW4oKGRhdGEpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzLFxuICAgICAgdXJsLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGRhdGFcbiAgICB9O1xuICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBSZXF1ZXN0RXJyb3IpXG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICBlbHNlIGlmIChlcnJvci5uYW1lID09PSBcIkFib3J0RXJyb3JcIilcbiAgICAgIHRocm93IGVycm9yO1xuICAgIGxldCBtZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICBpZiAoZXJyb3IubmFtZSA9PT0gXCJUeXBlRXJyb3JcIiAmJiBcImNhdXNlXCIgaW4gZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5jYXVzZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBlcnJvci5jYXVzZS5tZXNzYWdlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZXJyb3IuY2F1c2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbWVzc2FnZSA9IGVycm9yLmNhdXNlO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgUmVxdWVzdEVycm9yKG1lc3NhZ2UsIDUwMCwge1xuICAgICAgcmVxdWVzdDogcmVxdWVzdE9wdGlvbnNcbiAgICB9KTtcbiAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRSZXNwb25zZURhdGEocmVzcG9uc2UpIHtcbiAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKTtcbiAgaWYgKC9hcHBsaWNhdGlvblxcL2pzb24vLnRlc3QoY29udGVudFR5cGUpKSB7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiByZXNwb25zZS50ZXh0KCkpLmNhdGNoKCgpID0+IFwiXCIpO1xuICB9XG4gIGlmICghY29udGVudFR5cGUgfHwgL150ZXh0XFwvfGNoYXJzZXQ9dXRmLTgkLy50ZXN0KGNvbnRlbnRUeXBlKSkge1xuICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gIH1cbiAgcmV0dXJuIGdldEJ1ZmZlclJlc3BvbnNlKHJlc3BvbnNlKTtcbn1cbmZ1bmN0aW9uIHRvRXJyb3JNZXNzYWdlKGRhdGEpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBkYXRhO1xuICBsZXQgc3VmZml4O1xuICBpZiAoXCJkb2N1bWVudGF0aW9uX3VybFwiIGluIGRhdGEpIHtcbiAgICBzdWZmaXggPSBgIC0gJHtkYXRhLmRvY3VtZW50YXRpb25fdXJsfWA7XG4gIH0gZWxzZSB7XG4gICAgc3VmZml4ID0gXCJcIjtcbiAgfVxuICBpZiAoXCJtZXNzYWdlXCIgaW4gZGF0YSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEuZXJyb3JzKSkge1xuICAgICAgcmV0dXJuIGAke2RhdGEubWVzc2FnZX06ICR7ZGF0YS5lcnJvcnMubWFwKEpTT04uc3RyaW5naWZ5KS5qb2luKFwiLCBcIil9JHtzdWZmaXh9YDtcbiAgICB9XG4gICAgcmV0dXJuIGAke2RhdGEubWVzc2FnZX0ke3N1ZmZpeH1gO1xuICB9XG4gIHJldHVybiBgVW5rbm93biBlcnJvcjogJHtKU09OLnN0cmluZ2lmeShkYXRhKX1gO1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvd2l0aC1kZWZhdWx0cy5qc1xuZnVuY3Rpb24gd2l0aERlZmF1bHRzKG9sZEVuZHBvaW50LCBuZXdEZWZhdWx0cykge1xuICBjb25zdCBlbmRwb2ludDIgPSBvbGRFbmRwb2ludC5kZWZhdWx0cyhuZXdEZWZhdWx0cyk7XG4gIGNvbnN0IG5ld0FwaSA9IGZ1bmN0aW9uKHJvdXRlLCBwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgZW5kcG9pbnRPcHRpb25zID0gZW5kcG9pbnQyLm1lcmdlKHJvdXRlLCBwYXJhbWV0ZXJzKTtcbiAgICBpZiAoIWVuZHBvaW50T3B0aW9ucy5yZXF1ZXN0IHx8ICFlbmRwb2ludE9wdGlvbnMucmVxdWVzdC5ob29rKSB7XG4gICAgICByZXR1cm4gZmV0Y2hXcmFwcGVyKGVuZHBvaW50Mi5wYXJzZShlbmRwb2ludE9wdGlvbnMpKTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdDIgPSAocm91dGUyLCBwYXJhbWV0ZXJzMikgPT4ge1xuICAgICAgcmV0dXJuIGZldGNoV3JhcHBlcihcbiAgICAgICAgZW5kcG9pbnQyLnBhcnNlKGVuZHBvaW50Mi5tZXJnZShyb3V0ZTIsIHBhcmFtZXRlcnMyKSlcbiAgICAgICk7XG4gICAgfTtcbiAgICBPYmplY3QuYXNzaWduKHJlcXVlc3QyLCB7XG4gICAgICBlbmRwb2ludDogZW5kcG9pbnQyLFxuICAgICAgZGVmYXVsdHM6IHdpdGhEZWZhdWx0cy5iaW5kKG51bGwsIGVuZHBvaW50MilcbiAgICB9KTtcbiAgICByZXR1cm4gZW5kcG9pbnRPcHRpb25zLnJlcXVlc3QuaG9vayhyZXF1ZXN0MiwgZW5kcG9pbnRPcHRpb25zKTtcbiAgfTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3QXBpLCB7XG4gICAgZW5kcG9pbnQ6IGVuZHBvaW50MixcbiAgICBkZWZhdWx0czogd2l0aERlZmF1bHRzLmJpbmQobnVsbCwgZW5kcG9pbnQyKVxuICB9KTtcbn1cblxuLy8gcGtnL2Rpc3Qtc3JjL2luZGV4LmpzXG52YXIgcmVxdWVzdCA9IHdpdGhEZWZhdWx0cyhlbmRwb2ludCwge1xuICBoZWFkZXJzOiB7XG4gICAgXCJ1c2VyLWFnZW50XCI6IGBvY3Rva2l0LXJlcXVlc3QuanMvJHtWRVJTSU9OfSAke2dldFVzZXJBZ2VudCgpfWBcbiAgfVxufSk7XG5leHBvcnQge1xuICByZXF1ZXN0XG59O1xuIiwgImV4cG9ydCBmdW5jdGlvbiBnZXRVc2VyQWdlbnQoKSB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSBcIm9iamVjdFwiICYmIFwidXNlckFnZW50XCIgaW4gbmF2aWdhdG9yKSB7XG4gICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gIH1cblxuICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2Vzcy52ZXJzaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gYE5vZGUuanMvJHtwcm9jZXNzLnZlcnNpb24uc3Vic3RyKDEpfSAoJHtwcm9jZXNzLnBsYXRmb3JtfTsgJHtcbiAgICAgIHByb2Nlc3MuYXJjaFxuICAgIH0pYDtcbiAgfVxuXG4gIHJldHVybiBcIjxlbnZpcm9ubWVudCB1bmRldGVjdGFibGU+XCI7XG59XG4iLCAiLy8gcGtnL2Rpc3Qtc3JjL2luZGV4LmpzXG5pbXBvcnQgeyByZXF1ZXN0IH0gZnJvbSBcIkBvY3Rva2l0L3JlcXVlc3RcIjtcbmltcG9ydCB7IGdldFVzZXJBZ2VudCB9IGZyb20gXCJ1bml2ZXJzYWwtdXNlci1hZ2VudFwiO1xuXG4vLyBwa2cvZGlzdC1zcmMvdmVyc2lvbi5qc1xudmFyIFZFUlNJT04gPSBcIjAuMC4wLWRldmVsb3BtZW50XCI7XG5cbi8vIHBrZy9kaXN0LXNyYy93aXRoLWRlZmF1bHRzLmpzXG5pbXBvcnQgeyByZXF1ZXN0IGFzIFJlcXVlc3QyIH0gZnJvbSBcIkBvY3Rva2l0L3JlcXVlc3RcIjtcblxuLy8gcGtnL2Rpc3Qtc3JjL2dyYXBocWwuanNcbmltcG9ydCB7IHJlcXVlc3QgYXMgUmVxdWVzdCB9IGZyb20gXCJAb2N0b2tpdC9yZXF1ZXN0XCI7XG5cbi8vIHBrZy9kaXN0LXNyYy9lcnJvci5qc1xuZnVuY3Rpb24gX2J1aWxkTWVzc2FnZUZvclJlc3BvbnNlRXJyb3JzKGRhdGEpIHtcbiAgcmV0dXJuIGBSZXF1ZXN0IGZhaWxlZCBkdWUgdG8gZm9sbG93aW5nIHJlc3BvbnNlIGVycm9yczpcbmAgKyBkYXRhLmVycm9ycy5tYXAoKGUpID0+IGAgLSAke2UubWVzc2FnZX1gKS5qb2luKFwiXFxuXCIpO1xufVxudmFyIEdyYXBocWxSZXNwb25zZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHJlcXVlc3QyLCBoZWFkZXJzLCByZXNwb25zZSkge1xuICAgIHN1cGVyKF9idWlsZE1lc3NhZ2VGb3JSZXNwb25zZUVycm9ycyhyZXNwb25zZSkpO1xuICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3QyO1xuICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIHRoaXMuZXJyb3JzID0gcmVzcG9uc2UuZXJyb3JzO1xuICAgIHRoaXMuZGF0YSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICB9XG4gIH1cbiAgbmFtZSA9IFwiR3JhcGhxbFJlc3BvbnNlRXJyb3JcIjtcbiAgZXJyb3JzO1xuICBkYXRhO1xufTtcblxuLy8gcGtnL2Rpc3Qtc3JjL2dyYXBocWwuanNcbnZhciBOT05fVkFSSUFCTEVfT1BUSU9OUyA9IFtcbiAgXCJtZXRob2RcIixcbiAgXCJiYXNlVXJsXCIsXG4gIFwidXJsXCIsXG4gIFwiaGVhZGVyc1wiLFxuICBcInJlcXVlc3RcIixcbiAgXCJxdWVyeVwiLFxuICBcIm1lZGlhVHlwZVwiXG5dO1xudmFyIEZPUkJJRERFTl9WQVJJQUJMRV9PUFRJT05TID0gW1wicXVlcnlcIiwgXCJtZXRob2RcIiwgXCJ1cmxcIl07XG52YXIgR0hFU19WM19TVUZGSVhfUkVHRVggPSAvXFwvYXBpXFwvdjNcXC8/JC87XG5mdW5jdGlvbiBncmFwaHFsKHJlcXVlc3QyLCBxdWVyeSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgcXVlcnkgPT09IFwic3RyaW5nXCIgJiYgXCJxdWVyeVwiIGluIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgICAgbmV3IEVycm9yKGBbQG9jdG9raXQvZ3JhcGhxbF0gXCJxdWVyeVwiIGNhbm5vdCBiZSB1c2VkIGFzIHZhcmlhYmxlIG5hbWVgKVxuICAgICAgKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKCFGT1JCSURERU5fVkFSSUFCTEVfT1BUSU9OUy5pbmNsdWRlcyhrZXkpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgIGBbQG9jdG9raXQvZ3JhcGhxbF0gXCIke2tleX1cIiBjYW5ub3QgYmUgdXNlZCBhcyB2YXJpYWJsZSBuYW1lYFxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBjb25zdCBwYXJzZWRPcHRpb25zID0gdHlwZW9mIHF1ZXJ5ID09PSBcInN0cmluZ1wiID8gT2JqZWN0LmFzc2lnbih7IHF1ZXJ5IH0sIG9wdGlvbnMpIDogcXVlcnk7XG4gIGNvbnN0IHJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmtleXMoXG4gICAgcGFyc2VkT3B0aW9uc1xuICApLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IHtcbiAgICBpZiAoTk9OX1ZBUklBQkxFX09QVElPTlMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBwYXJzZWRPcHRpb25zW2tleV07XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAoIXJlc3VsdC52YXJpYWJsZXMpIHtcbiAgICAgIHJlc3VsdC52YXJpYWJsZXMgPSB7fTtcbiAgICB9XG4gICAgcmVzdWx0LnZhcmlhYmxlc1trZXldID0gcGFyc2VkT3B0aW9uc1trZXldO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIHt9KTtcbiAgY29uc3QgYmFzZVVybCA9IHBhcnNlZE9wdGlvbnMuYmFzZVVybCB8fCByZXF1ZXN0Mi5lbmRwb2ludC5ERUZBVUxUUy5iYXNlVXJsO1xuICBpZiAoR0hFU19WM19TVUZGSVhfUkVHRVgudGVzdChiYXNlVXJsKSkge1xuICAgIHJlcXVlc3RPcHRpb25zLnVybCA9IGJhc2VVcmwucmVwbGFjZShHSEVTX1YzX1NVRkZJWF9SRUdFWCwgXCIvYXBpL2dyYXBocWxcIik7XG4gIH1cbiAgcmV0dXJuIHJlcXVlc3QyKHJlcXVlc3RPcHRpb25zKS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgIGlmIChyZXNwb25zZS5kYXRhLmVycm9ycykge1xuICAgICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocmVzcG9uc2UuaGVhZGVycykpIHtcbiAgICAgICAgaGVhZGVyc1trZXldID0gcmVzcG9uc2UuaGVhZGVyc1trZXldO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEdyYXBocWxSZXNwb25zZUVycm9yKFxuICAgICAgICByZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgcmVzcG9uc2UuZGF0YVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEuZGF0YTtcbiAgfSk7XG59XG5cbi8vIHBrZy9kaXN0LXNyYy93aXRoLWRlZmF1bHRzLmpzXG5mdW5jdGlvbiB3aXRoRGVmYXVsdHMocmVxdWVzdDIsIG5ld0RlZmF1bHRzKSB7XG4gIGNvbnN0IG5ld1JlcXVlc3QgPSByZXF1ZXN0Mi5kZWZhdWx0cyhuZXdEZWZhdWx0cyk7XG4gIGNvbnN0IG5ld0FwaSA9IChxdWVyeSwgb3B0aW9ucykgPT4ge1xuICAgIHJldHVybiBncmFwaHFsKG5ld1JlcXVlc3QsIHF1ZXJ5LCBvcHRpb25zKTtcbiAgfTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3QXBpLCB7XG4gICAgZGVmYXVsdHM6IHdpdGhEZWZhdWx0cy5iaW5kKG51bGwsIG5ld1JlcXVlc3QpLFxuICAgIGVuZHBvaW50OiBuZXdSZXF1ZXN0LmVuZHBvaW50XG4gIH0pO1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvaW5kZXguanNcbnZhciBncmFwaHFsMiA9IHdpdGhEZWZhdWx0cyhyZXF1ZXN0LCB7XG4gIGhlYWRlcnM6IHtcbiAgICBcInVzZXItYWdlbnRcIjogYG9jdG9raXQtZ3JhcGhxbC5qcy8ke1ZFUlNJT059ICR7Z2V0VXNlckFnZW50KCl9YFxuICB9LFxuICBtZXRob2Q6IFwiUE9TVFwiLFxuICB1cmw6IFwiL2dyYXBocWxcIlxufSk7XG5mdW5jdGlvbiB3aXRoQ3VzdG9tUmVxdWVzdChjdXN0b21SZXF1ZXN0KSB7XG4gIHJldHVybiB3aXRoRGVmYXVsdHMoY3VzdG9tUmVxdWVzdCwge1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgdXJsOiBcIi9ncmFwaHFsXCJcbiAgfSk7XG59XG5leHBvcnQge1xuICBHcmFwaHFsUmVzcG9uc2VFcnJvcixcbiAgZ3JhcGhxbDIgYXMgZ3JhcGhxbCxcbiAgd2l0aEN1c3RvbVJlcXVlc3Rcbn07XG4iLCAiLy8gcGtnL2Rpc3Qtc3JjL2F1dGguanNcbnZhciBSRUdFWF9JU19JTlNUQUxMQVRJT05fTEVHQUNZID0gL152MVxcLi87XG52YXIgUkVHRVhfSVNfSU5TVEFMTEFUSU9OID0gL15naHNfLztcbnZhciBSRUdFWF9JU19VU0VSX1RPX1NFUlZFUiA9IC9eZ2h1Xy87XG5hc3luYyBmdW5jdGlvbiBhdXRoKHRva2VuKSB7XG4gIGNvbnN0IGlzQXBwID0gdG9rZW4uc3BsaXQoL1xcLi8pLmxlbmd0aCA9PT0gMztcbiAgY29uc3QgaXNJbnN0YWxsYXRpb24gPSBSRUdFWF9JU19JTlNUQUxMQVRJT05fTEVHQUNZLnRlc3QodG9rZW4pIHx8IFJFR0VYX0lTX0lOU1RBTExBVElPTi50ZXN0KHRva2VuKTtcbiAgY29uc3QgaXNVc2VyVG9TZXJ2ZXIgPSBSRUdFWF9JU19VU0VSX1RPX1NFUlZFUi50ZXN0KHRva2VuKTtcbiAgY29uc3QgdG9rZW5UeXBlID0gaXNBcHAgPyBcImFwcFwiIDogaXNJbnN0YWxsYXRpb24gPyBcImluc3RhbGxhdGlvblwiIDogaXNVc2VyVG9TZXJ2ZXIgPyBcInVzZXItdG8tc2VydmVyXCIgOiBcIm9hdXRoXCI7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ0b2tlblwiLFxuICAgIHRva2VuLFxuICAgIHRva2VuVHlwZVxuICB9O1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvd2l0aC1hdXRob3JpemF0aW9uLXByZWZpeC5qc1xuZnVuY3Rpb24gd2l0aEF1dGhvcml6YXRpb25QcmVmaXgodG9rZW4pIHtcbiAgaWYgKHRva2VuLnNwbGl0KC9cXC4vKS5sZW5ndGggPT09IDMpIHtcbiAgICByZXR1cm4gYGJlYXJlciAke3Rva2VufWA7XG4gIH1cbiAgcmV0dXJuIGB0b2tlbiAke3Rva2VufWA7XG59XG5cbi8vIHBrZy9kaXN0LXNyYy9ob29rLmpzXG5hc3luYyBmdW5jdGlvbiBob29rKHRva2VuLCByZXF1ZXN0LCByb3V0ZSwgcGFyYW1ldGVycykge1xuICBjb25zdCBlbmRwb2ludCA9IHJlcXVlc3QuZW5kcG9pbnQubWVyZ2UoXG4gICAgcm91dGUsXG4gICAgcGFyYW1ldGVyc1xuICApO1xuICBlbmRwb2ludC5oZWFkZXJzLmF1dGhvcml6YXRpb24gPSB3aXRoQXV0aG9yaXphdGlvblByZWZpeCh0b2tlbik7XG4gIHJldHVybiByZXF1ZXN0KGVuZHBvaW50KTtcbn1cblxuLy8gcGtnL2Rpc3Qtc3JjL2luZGV4LmpzXG52YXIgY3JlYXRlVG9rZW5BdXRoID0gZnVuY3Rpb24gY3JlYXRlVG9rZW5BdXRoMih0b2tlbikge1xuICBpZiAoIXRva2VuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiW0BvY3Rva2l0L2F1dGgtdG9rZW5dIE5vIHRva2VuIHBhc3NlZCB0byBjcmVhdGVUb2tlbkF1dGhcIik7XG4gIH1cbiAgaWYgKHR5cGVvZiB0b2tlbiAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiW0BvY3Rva2l0L2F1dGgtdG9rZW5dIFRva2VuIHBhc3NlZCB0byBjcmVhdGVUb2tlbkF1dGggaXMgbm90IGEgc3RyaW5nXCJcbiAgICApO1xuICB9XG4gIHRva2VuID0gdG9rZW4ucmVwbGFjZSgvXih0b2tlbnxiZWFyZXIpICsvaSwgXCJcIik7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKGF1dGguYmluZChudWxsLCB0b2tlbiksIHtcbiAgICBob29rOiBob29rLmJpbmQobnVsbCwgdG9rZW4pXG4gIH0pO1xufTtcbmV4cG9ydCB7XG4gIGNyZWF0ZVRva2VuQXV0aFxufTtcbiIsICJjb25zdCBWRVJTSU9OID0gXCI2LjAuMVwiO1xuZXhwb3J0IHtcbiAgVkVSU0lPTlxufTtcbiIsICJpbXBvcnQgeyBnZXRVc2VyQWdlbnQgfSBmcm9tIFwidW5pdmVyc2FsLXVzZXItYWdlbnRcIjtcbmltcG9ydCBIb29rIGZyb20gXCJiZWZvcmUtYWZ0ZXItaG9va1wiO1xuaW1wb3J0IHsgcmVxdWVzdCB9IGZyb20gXCJAb2N0b2tpdC9yZXF1ZXN0XCI7XG5pbXBvcnQgeyBncmFwaHFsLCB3aXRoQ3VzdG9tUmVxdWVzdCB9IGZyb20gXCJAb2N0b2tpdC9ncmFwaHFsXCI7XG5pbXBvcnQgeyBjcmVhdGVUb2tlbkF1dGggfSBmcm9tIFwiQG9jdG9raXQvYXV0aC10b2tlblwiO1xuaW1wb3J0IHsgVkVSU0lPTiB9IGZyb20gXCIuL3ZlcnNpb24uanNcIjtcbmNvbnN0IG5vb3AgPSAoKSA9PiB7XG59O1xuY29uc3QgY29uc29sZVdhcm4gPSBjb25zb2xlLndhcm4uYmluZChjb25zb2xlKTtcbmNvbnN0IGNvbnNvbGVFcnJvciA9IGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKTtcbmNvbnN0IHVzZXJBZ2VudFRyYWlsID0gYG9jdG9raXQtY29yZS5qcy8ke1ZFUlNJT059ICR7Z2V0VXNlckFnZW50KCl9YDtcbmNsYXNzIE9jdG9raXQge1xuICBzdGF0aWMgVkVSU0lPTiA9IFZFUlNJT047XG4gIHN0YXRpYyBkZWZhdWx0cyhkZWZhdWx0cykge1xuICAgIGNvbnN0IE9jdG9raXRXaXRoRGVmYXVsdHMgPSBjbGFzcyBleHRlbmRzIHRoaXMge1xuICAgICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gYXJnc1swXSB8fCB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkZWZhdWx0cyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgc3VwZXIoZGVmYXVsdHMob3B0aW9ucykpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihcbiAgICAgICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICBkZWZhdWx0cyxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBvcHRpb25zLnVzZXJBZ2VudCAmJiBkZWZhdWx0cy51c2VyQWdlbnQgPyB7XG4gICAgICAgICAgICAgIHVzZXJBZ2VudDogYCR7b3B0aW9ucy51c2VyQWdlbnR9ICR7ZGVmYXVsdHMudXNlckFnZW50fWBcbiAgICAgICAgICAgIH0gOiBudWxsXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE9jdG9raXRXaXRoRGVmYXVsdHM7XG4gIH1cbiAgc3RhdGljIHBsdWdpbnMgPSBbXTtcbiAgLyoqXG4gICAqIEF0dGFjaCBhIHBsdWdpbiAob3IgbWFueSkgdG8geW91ciBPY3Rva2l0IGluc3RhbmNlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBBUEkgPSBPY3Rva2l0LnBsdWdpbihwbHVnaW4xLCBwbHVnaW4yLCBwbHVnaW4zLCAuLi4pXG4gICAqL1xuICBzdGF0aWMgcGx1Z2luKC4uLm5ld1BsdWdpbnMpIHtcbiAgICBjb25zdCBjdXJyZW50UGx1Z2lucyA9IHRoaXMucGx1Z2lucztcbiAgICBjb25zdCBOZXdPY3Rva2l0ID0gY2xhc3MgZXh0ZW5kcyB0aGlzIHtcbiAgICAgIHN0YXRpYyBwbHVnaW5zID0gY3VycmVudFBsdWdpbnMuY29uY2F0KFxuICAgICAgICBuZXdQbHVnaW5zLmZpbHRlcigocGx1Z2luKSA9PiAhY3VycmVudFBsdWdpbnMuaW5jbHVkZXMocGx1Z2luKSlcbiAgICAgICk7XG4gICAgfTtcbiAgICByZXR1cm4gTmV3T2N0b2tpdDtcbiAgfVxuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBob29rID0gbmV3IEhvb2suQ29sbGVjdGlvbigpO1xuICAgIGNvbnN0IHJlcXVlc3REZWZhdWx0cyA9IHtcbiAgICAgIGJhc2VVcmw6IHJlcXVlc3QuZW5kcG9pbnQuREVGQVVMVFMuYmFzZVVybCxcbiAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgcmVxdWVzdDogT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5yZXF1ZXN0LCB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmUgaW50ZXJuYWwgdXNhZ2Ugb25seSwgbm8gbmVlZCB0byB0eXBlXG4gICAgICAgIGhvb2s6IGhvb2suYmluZChudWxsLCBcInJlcXVlc3RcIilcbiAgICAgIH0pLFxuICAgICAgbWVkaWFUeXBlOiB7XG4gICAgICAgIHByZXZpZXdzOiBbXSxcbiAgICAgICAgZm9ybWF0OiBcIlwiXG4gICAgICB9XG4gICAgfTtcbiAgICByZXF1ZXN0RGVmYXVsdHMuaGVhZGVyc1tcInVzZXItYWdlbnRcIl0gPSBvcHRpb25zLnVzZXJBZ2VudCA/IGAke29wdGlvbnMudXNlckFnZW50fSAke3VzZXJBZ2VudFRyYWlsfWAgOiB1c2VyQWdlbnRUcmFpbDtcbiAgICBpZiAob3B0aW9ucy5iYXNlVXJsKSB7XG4gICAgICByZXF1ZXN0RGVmYXVsdHMuYmFzZVVybCA9IG9wdGlvbnMuYmFzZVVybDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucHJldmlld3MpIHtcbiAgICAgIHJlcXVlc3REZWZhdWx0cy5tZWRpYVR5cGUucHJldmlld3MgPSBvcHRpb25zLnByZXZpZXdzO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy50aW1lWm9uZSkge1xuICAgICAgcmVxdWVzdERlZmF1bHRzLmhlYWRlcnNbXCJ0aW1lLXpvbmVcIl0gPSBvcHRpb25zLnRpbWVab25lO1xuICAgIH1cbiAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0LmRlZmF1bHRzKHJlcXVlc3REZWZhdWx0cyk7XG4gICAgdGhpcy5ncmFwaHFsID0gd2l0aEN1c3RvbVJlcXVlc3QodGhpcy5yZXF1ZXN0KS5kZWZhdWx0cyhyZXF1ZXN0RGVmYXVsdHMpO1xuICAgIHRoaXMubG9nID0gT2JqZWN0LmFzc2lnbihcbiAgICAgIHtcbiAgICAgICAgZGVidWc6IG5vb3AsXG4gICAgICAgIGluZm86IG5vb3AsXG4gICAgICAgIHdhcm46IGNvbnNvbGVXYXJuLFxuICAgICAgICBlcnJvcjogY29uc29sZUVycm9yXG4gICAgICB9LFxuICAgICAgb3B0aW9ucy5sb2dcbiAgICApO1xuICAgIHRoaXMuaG9vayA9IGhvb2s7XG4gICAgaWYgKCFvcHRpb25zLmF1dGhTdHJhdGVneSkge1xuICAgICAgaWYgKCFvcHRpb25zLmF1dGgpIHtcbiAgICAgICAgdGhpcy5hdXRoID0gYXN5bmMgKCkgPT4gKHtcbiAgICAgICAgICB0eXBlOiBcInVuYXV0aGVudGljYXRlZFwiXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYXV0aCA9IGNyZWF0ZVRva2VuQXV0aChvcHRpb25zLmF1dGgpO1xuICAgICAgICBob29rLndyYXAoXCJyZXF1ZXN0XCIsIGF1dGguaG9vayk7XG4gICAgICAgIHRoaXMuYXV0aCA9IGF1dGg7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHsgYXV0aFN0cmF0ZWd5LCAuLi5vdGhlck9wdGlvbnMgfSA9IG9wdGlvbnM7XG4gICAgICBjb25zdCBhdXRoID0gYXV0aFN0cmF0ZWd5KFxuICAgICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJlcXVlc3Q6IHRoaXMucmVxdWVzdCxcbiAgICAgICAgICAgIGxvZzogdGhpcy5sb2csXG4gICAgICAgICAgICAvLyB3ZSBwYXNzIHRoZSBjdXJyZW50IG9jdG9raXQgaW5zdGFuY2UgYXMgd2VsbCBhcyBpdHMgY29uc3RydWN0b3Igb3B0aW9uc1xuICAgICAgICAgICAgLy8gdG8gYWxsb3cgZm9yIGF1dGhlbnRpY2F0aW9uIHN0cmF0ZWdpZXMgdGhhdCByZXR1cm4gYSBuZXcgb2N0b2tpdCBpbnN0YW5jZVxuICAgICAgICAgICAgLy8gdGhhdCBzaGFyZXMgdGhlIHNhbWUgaW50ZXJuYWwgc3RhdGUgYXMgdGhlIGN1cnJlbnQgb25lLiBUaGUgb3JpZ2luYWxcbiAgICAgICAgICAgIC8vIHJlcXVpcmVtZW50IGZvciB0aGlzIHdhcyB0aGUgXCJldmVudC1vY3Rva2l0XCIgYXV0aGVudGljYXRpb24gc3RyYXRlZ3lcbiAgICAgICAgICAgIC8vIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm9ib3Qvb2N0b2tpdC1hdXRoLXByb2JvdC5cbiAgICAgICAgICAgIG9jdG9raXQ6IHRoaXMsXG4gICAgICAgICAgICBvY3Rva2l0T3B0aW9uczogb3RoZXJPcHRpb25zXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvcHRpb25zLmF1dGhcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIGhvb2sud3JhcChcInJlcXVlc3RcIiwgYXV0aC5ob29rKTtcbiAgICAgIHRoaXMuYXV0aCA9IGF1dGg7XG4gICAgfVxuICAgIGNvbnN0IGNsYXNzQ29uc3RydWN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2xhc3NDb25zdHJ1Y3Rvci5wbHVnaW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNsYXNzQ29uc3RydWN0b3IucGx1Z2luc1tpXSh0aGlzLCBvcHRpb25zKSk7XG4gICAgfVxuICB9XG4gIC8vIGFzc2lnbmVkIGR1cmluZyBjb25zdHJ1Y3RvclxuICByZXF1ZXN0O1xuICBncmFwaHFsO1xuICBsb2c7XG4gIGhvb2s7XG4gIC8vIFRPRE86IHR5cGUgYG9jdG9raXQuYXV0aGAgYmFzZWQgb24gcGFzc2VkIG9wdGlvbnMuYXV0aFN0cmF0ZWd5XG4gIGF1dGg7XG59XG5leHBvcnQge1xuICBPY3Rva2l0XG59O1xuIiwgImltcG9ydCB7IE5vdGljZSB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgQ2xhc2hTdGF0dXMsIEZpbGVPcFJlY29yZCwgTG9jYWxGaWxlU3RhdHVzLCBSZW1vdGVDaGFuZ2VUeXBlIH0gZnJvbSBcIi4vZml0VHlwZXNcIjtcblxudHlwZSBTdGF0dXMgPSBSZW1vdGVDaGFuZ2VUeXBlIHwgTG9jYWxGaWxlU3RhdHVzXG5cbnR5cGUgRmlsZUxvY2F0aW9uID0gXCJyZW1vdGVcIiB8IFwibG9jYWxcIlxuXG50eXBlIENvbXBhcmlzb25SZXN1bHQ8RW52IGV4dGVuZHMgRmlsZUxvY2F0aW9uPiA9IHtcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgc3RhdHVzOiBFbnYgZXh0ZW5kcyBcImxvY2FsXCIgPyBMb2NhbEZpbGVTdGF0dXM6IFJlbW90ZUNoYW5nZVR5cGVcbiAgICBjdXJyZW50U2hhPzogc3RyaW5nXG4gICAgZXh0ZW5zaW9uPzogc3RyaW5nXG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlT3JOdWxsKG9iajogUmVjb3JkPHN0cmluZywgc3RyaW5nPiwga2V5OiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsIHtcbiAgICByZXR1cm4gb2JqLmhhc093blByb3BlcnR5KGtleSkgPyBvYmpba2V5XSA6IG51bGw7XG59XG5cblxuLy8gY29tcGFyZSBjdXJyZW50U2hhIHdpdGggc3RvcmVkU2hhIGFuZCBjaGVjayBmb3IgZGlmZmVyZW5jZXMsIGZpbGVzIG9ubHkgaW4gY3VycmVudFNoYVxuLy8gIGFyZSBjb25zaWRlcmQgYWRkZWQsIHdoaWxlIGZpbGVzIG9ubHkgaW4gc3RvcmVkU2hhIGFyZSBjb25zaWRlcmVkIHJlbW92ZWRcbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlU2hhPEVudiBleHRlbmRzIEZpbGVMb2NhdGlvbj4oXG4gICAgY3VycmVudFNoYU1hcDogUmVjb3JkPHN0cmluZywgc3RyaW5nPixcbiAgICBzdG9yZWRTaGFNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4sXG4gICAgZW52OiBFbnYpOiBDb21wYXJpc29uUmVzdWx0PEVudj5bXSB7XG4gICAgICAgIGNvbnN0IGRldGVybWluZVN0YXR1cyA9IChjdXJyZW50U2hhOiBzdHJpbmcgfCBudWxsLCBzdG9yZWRTaGE6IHN0cmluZyB8IG51bGwpOiBTdGF0dXMgfCBudWxsICA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFNoYSAmJiBzdG9yZWRTaGEgJiYgY3VycmVudFNoYSAhPT0gc3RvcmVkU2hhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudiA9PT0gXCJsb2NhbFwiID8gXCJjaGFuZ2VkXCIgOiBcIk1PRElGSUVEXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRTaGEgJiYgIXN0b3JlZFNoYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbnYgPT09IFwibG9jYWxcIiA/IFwiY3JlYXRlZFwiIDogXCJBRERFRFwiO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghY3VycmVudFNoYSAmJiBzdG9yZWRTaGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW52ID09PSBcImxvY2FsXCIgPyBcImRlbGV0ZWRcIiA6IFwiUkVNT1ZFRFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh7IC4uLmN1cnJlbnRTaGFNYXAsIC4uLnN0b3JlZFNoYU1hcCB9KS5mbGF0TWFwKChwYXRoKTogQ29tcGFyaXNvblJlc3VsdDxFbnY+W10gPT4ge1xuICAgICAgICAgICAgY29uc3QgW2N1cnJlbnRTaGEsIHN0b3JlZFNoYV0gPSBbZ2V0VmFsdWVPck51bGwoY3VycmVudFNoYU1hcCwgcGF0aCksIGdldFZhbHVlT3JOdWxsKHN0b3JlZFNoYU1hcCwgcGF0aCldO1xuICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gZGV0ZXJtaW5lU3RhdHVzKGN1cnJlbnRTaGEsIHN0b3JlZFNoYSk7XG4gICAgICAgICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogc3RhdHVzIGFzIEVudiBleHRlbmRzIFwibG9jYWxcIiA/IExvY2FsRmlsZVN0YXR1cyA6IFJlbW90ZUNoYW5nZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTaGE6IGN1cnJlbnRTaGEgPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBleHRlbnNpb246IGV4dHJhY3RFeHRlbnNpb24ocGF0aClcbiAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSk7XG59XG5cbmV4cG9ydCBjb25zdCBSRUNPR05JWkVEX0JJTkFSWV9FWFQgPSBbXCJwbmdcIiwgXCJqcGdcIiwgXCJqcGVnXCIsIFwicGRmXCJdXG5cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0RXh0ZW5zaW9uKHBhdGg6IHN0cmluZyk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHBhdGgubWF0Y2goL1teLl0rJC8pPy5bMF07XG59XG5cbi8vIFVzaW5nIGZpbGUgZXh0ZW5zaW9uIHRvIGRldGVybWluZSBlbmNvZGluZyBvZiBmaWxlcyAod29ya3MgaW4gbW9zdCBjYXNlcylcbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWxlRW5jb2RpbmcocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBleHRlbnNpb24gPSBwYXRoLm1hdGNoKC9bXi5dKyQvKT8uWzBdO1xuICAgIGNvbnN0IGlzQmluYXJ5ID0gZXh0ZW5zaW9uICYmIFJFQ09HTklaRURfQklOQVJZX0VYVC5pbmNsdWRlcyhleHRlbnNpb24pO1xuICAgIGlmIChpc0JpbmFyeSkge1xuICAgICAgICByZXR1cm4gXCJiYXNlNjRcIlxuICAgIH1cbiAgICByZXR1cm4gXCJ1dGYtOFwiXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRFcXVhbDxUPihhcnIxOiBBcnJheTxUPiwgYXJyMjogQXJyYXk8VD4pIHtcbiAgICBjb25zdCBzZXQxID0gbmV3IFNldChhcnIxKTtcbiAgICBjb25zdCBzZXQyID0gbmV3IFNldChhcnIyKTtcbiAgICBjb25zdCBpc0VxdWFsID0gc2V0MS5zaXplID09PSBzZXQyLnNpemUgJiYgWy4uLnNldDFdLmV2ZXJ5KHZhbHVlID0+IHNldDIuaGFzKHZhbHVlKSk7XG4gICAgcmV0dXJuIGlzRXF1YWxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUxpbmVFbmRpbmdzRnJvbUJhc2U2NFN0cmluZyhjb250ZW50OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBjb250ZW50LnJlcGxhY2UoL1xccj9cXG58XFxyfFxcbi9nLCAnJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG93RmlsZU9wc1JlY29yZChyZWNvcmRzOiBBcnJheTx7aGVhZGluZzogc3RyaW5nLCBvcHM6IEZpbGVPcFJlY29yZFtdfT4pOiB2b2lkIHtcbiAgICBpZiAocmVjb3Jkcy5sZW5ndGggPT09IDAgfHwgcmVjb3Jkcy5ldmVyeShyPT5yLm9wcy5sZW5ndGg9PT0wKSkge3JldHVybn1cbiAgICBjb25zdCBmaWxlT3BzTm90aWNlID0gbmV3IE5vdGljZShcIlwiLCAwKVxuICAgIHJlY29yZHMubWFwKHJlY29yZFNldCA9PiB7XG4gICAgICAgIGlmIChyZWNvcmRTZXQub3BzLmxlbmd0aCA9PT0gMCkge3JldHVybn1cbiAgICAgICAgY29uc3QgaGVhZGluZyA9IGZpbGVPcHNOb3RpY2Uubm90aWNlRWwuY3JlYXRlRWwoXCJzcGFuXCIsIHtcbiAgICAgICAgICAgIGNsczogXCJmaWxlLWNoYW5nZXMtaGVhZGluZ1wiXG4gICAgICAgIH0pXG4gICAgICAgIGhlYWRpbmcuc2V0VGV4dChgJHtyZWNvcmRTZXQuaGVhZGluZ31cXG5gKVxuICAgICAgICBjb25zdCBmaWxlQ2hhbmdlcyA9IHtcbiAgICAgICAgICAgIGNyZWF0ZWQ6IFtdIGFzIEFycmF5PHN0cmluZz4sXG4gICAgICAgICAgICBjaGFuZ2VkOiBbXSBhcyBBcnJheTxzdHJpbmc+LFxuICAgICAgICAgICAgZGVsZXRlZDogW10gYXMgQXJyYXk8c3RyaW5nPlxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qgb3Agb2YgcmVjb3JkU2V0Lm9wcykge1xuICAgICAgICAgICAgZmlsZUNoYW5nZXNbb3Auc3RhdHVzXS5wdXNoKG9wLnBhdGgpXG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbY2hhbmdlVHlwZSwgcGF0aHNdIG9mIE9iamVjdC5lbnRyaWVzKGZpbGVDaGFuZ2VzKSkge1xuICAgICAgICAgICAgaWYgKHBhdGhzLmxlbmd0aCA9PT0gMCkge2NvbnRpbnVlfVxuICAgICAgICAgICAgY29uc3QgaGVhZGluZyA9IGZpbGVPcHNOb3RpY2Uubm90aWNlRWwuY3JlYXRlRWwoXCJzcGFuXCIpXG4gICAgICAgICAgICBoZWFkaW5nLnNldFRleHQoYCR7Y2hhbmdlVHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGNoYW5nZVR5cGUuc2xpY2UoMSl9XFxuYClcbiAgICAgICAgICAgIGhlYWRpbmcuYWRkQ2xhc3MoYGZpbGUtY2hhbmdlcy1zdWJoZWFkaW5nYClcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpc3RJdGVtID0gZmlsZU9wc05vdGljZS5ub3RpY2VFbC5jcmVhdGVFbChcImxpXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgY2xzOiBcImZpbGUtdXBkYXRlLXJvd1wiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbGlzdEl0ZW0uc2V0VGV4dChgJHtwYXRofWApO1xuICAgICAgICAgICAgICAgIGxpc3RJdGVtLmFkZENsYXNzKGBmaWxlLSR7Y2hhbmdlVHlwZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG93VW5hcHBsaWVkQ29uZmxpY3RzKGNsYXNoZWRGaWxlczogQXJyYXk8Q2xhc2hTdGF0dXM+KTogdm9pZCB7XG4gICAgaWYgKGNsYXNoZWRGaWxlcy5sZW5ndGggPT09IDApIHtyZXR1cm59XG4gICAgY29uc3QgbG9jYWxTdGF0dXNNYXAgPSB7XG4gICAgICAgIGNyZWF0ZWQ6IFwiY3JlYXRlXCIsXG4gICAgICAgIGNoYW5nZWQ6IFwiY2hhbmdlXCIsXG4gICAgICAgIGRlbGV0ZWQ6IFwiZGVsZXRlXCJcbiAgICB9XG4gICAgY29uc3QgcmVtb3RlU3RhdHVzTWFwID0ge1xuICAgICAgICBBRERFRDogIFwiY3JlYXRlXCIsXG4gICAgICAgIE1PRElGSUVEOiBcImNoYW5nZVwiLFxuICAgICAgICBSRU1PVkVEOiBcImRlbGV0ZVwiXG4gICAgfVxuICAgIGNvbnN0IGNvbmZsaWN0Tm90aWNlID0gbmV3IE5vdGljZShcIlwiLCAwKVxuICAgIGNvbnN0IGhlYWRpbmcgPSBjb25mbGljdE5vdGljZS5ub3RpY2VFbC5jcmVhdGVFbChcInNwYW5cIilcbiAgICBoZWFkaW5nLnNldFRleHQoYENoYW5nZSBjb25mbGljdHM6XFxuYClcbiAgICBoZWFkaW5nLmFkZENsYXNzKGBmaWxlLWNoYW5nZXMtc3ViaGVhZGluZ2ApXG4gICAgY29uc3QgY29uZmxpY3RTdGF0dXMgPSBjb25mbGljdE5vdGljZS5ub3RpY2VFbC5jcmVhdGVEaXYoe1xuICAgICAgICBjbHM6IFwiZmlsZS1jb25mbGljdC1yb3dcIlxuICAgIH0pO1xuICAgIGNvbmZsaWN0U3RhdHVzLmNyZWF0ZURpdigpLnNldFRleHQoXCJMb2NhbFwiKVxuXHRjb25mbGljdFN0YXR1cy5jcmVhdGVEaXYoKS5zZXRUZXh0KFwiUmVtb3RlXCIpXG4gICAgZm9yIChjb25zdCBjbGFzaCBvZiBjbGFzaGVkRmlsZXMpIHtcbiAgICAgICAgY29uc3QgY29uZmxpY3RJdGVtID0gY29uZmxpY3ROb3RpY2Uubm90aWNlRWwuY3JlYXRlRGl2KHtcbiAgICAgICAgICAgIGNsczogXCJmaWxlLWNvbmZsaWN0LXJvd1wiXG4gICAgICAgIH0pO1xuICAgICAgICBjb25mbGljdEl0ZW0uY3JlYXRlRGl2KHtcbiAgICAgICAgICAgIGNsczogYGZpbGUtY29uZmxpY3QtJHtsb2NhbFN0YXR1c01hcFtjbGFzaC5sb2NhbFN0YXR1c119YFxuICAgICAgICB9KTtcbiAgICAgICAgY29uZmxpY3RJdGVtLmNyZWF0ZURpdihcImRpdlwiKVxuICAgICAgICAgICAgLnNldFRleHQoY2xhc2gucGF0aCk7XG4gICAgICAgIGNvbmZsaWN0SXRlbS5jcmVhdGVEaXYoe1xuICAgICAgICAgICAgY2xzOiBgZmlsZS1jb25mbGljdC0ke3JlbW90ZVN0YXR1c01hcFtjbGFzaC5yZW1vdGVTdGF0dXNdfWBcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGZvb3RlciA9IGNvbmZsaWN0Tm90aWNlLm5vdGljZUVsLmNyZWF0ZURpdih7XG4gICAgICAgIGNsczogXCJmaWxlLWNvbmZsaWN0LXJvd1wiXG4gICAgfSlcbiAgICBmb290ZXIuc2V0VGV4dChcIk5vdGU6XCIpXG4gICAgZm9vdGVyLnN0eWxlLmZvbnRXZWlnaHQgPSBcImJvbGRcIjtcbiAgICBjb25mbGljdE5vdGljZS5ub3RpY2VFbC5jcmVhdGVFbChcImxpXCIsIHtjbHM6IFwiZmlsZS1jb25mbGljdC1ub3RlXCJ9KVxuICAgICAgICAuc2V0VGV4dChcIlJlbW90ZSBjaGFuZ2VzIGluIF9maXRcIilcbiAgICBjb25mbGljdE5vdGljZS5ub3RpY2VFbC5jcmVhdGVFbChcImxpXCIsIHtjbHM6IFwiZmlsZS1jb25mbGljdC1ub3RlXCJ9KVxuICAgICAgICAuc2V0VGV4dChcIl9maXQgZm9sZGVyIGlzIG92ZXJ3cml0dGVuIG9uIGNvbmZsaWN0LCBjb3B5IG5lZWRlZCBjaGFuZ2VzIG91dHNpZGUgX2ZpdC5cIilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdGlvbihzZXRBOiBTZXQ8YW55Piwgc2V0QjogU2V0PGFueT4pIHtcbiAgICByZXR1cm4gbmV3IFNldChbLi4uc2V0QV0uZmlsdGVyKHggPT4gc2V0Qi5oYXMoeCkpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpZmZlcmVuY2Uoc2V0QTogU2V0PGFueT4sIHNldEI6IFNldDxhbnk+KSB7XG4gICAgcmV0dXJuIG5ldyBTZXQoWy4uLnNldEFdLmZpbHRlcih4ID0+ICFzZXRCLmhhcyh4KSkpO1xufVxuIiwgImltcG9ydCB7IExvY2FsU3RvcmVzLCBSZXBvc2l0b3J5LCBTeW5jU2V0dGluZyB9IGZyb20gXCJtYWluXCJcbmltcG9ydCB7IE9jdG9raXQgfSBmcm9tIFwiQG9jdG9raXQvY29yZVwiXG5pbXBvcnQgeyBSRUNPR05JWkVEX0JJTkFSWV9FWFQsIGNvbXBhcmVTaGEsIGV4dHJhY3RFeHRlbnNpb24gfSBmcm9tIFwiLi91dGlsc1wiXG5pbXBvcnQgeyBWYXVsdE9wZXJhdGlvbnMgfSBmcm9tIFwiLi92YXVsdE9wc1wiXG5pbXBvcnQgeyBMb2NhbENoYW5nZSwgTG9jYWxGaWxlU3RhdHVzLCBSZW1vdGVDaGFuZ2UsIFJlbW90ZUNoYW5nZVR5cGUgfSBmcm9tIFwiLi9maXRUeXBlc1wiXG5pbXBvcnQgeyBhcnJheUJ1ZmZlclRvQmFzZTY0IH0gZnJvbSBcIm9ic2lkaWFuXCJcblxuXG5cbmV4cG9ydCB0eXBlIFRyZWVOb2RlID0ge1xuICAgIHBhdGg6IHN0cmluZyxcbiAgICBtb2RlOiBcIjEwMDY0NFwiIHwgXCIxMDA3NTVcIiB8IFwiMDQwMDAwXCIgfCBcIjE2MDAwMFwiIHwgXCIxMjAwMDBcIiB8IHVuZGVmaW5lZCxcbiAgICB0eXBlOiBcImNvbW1pdFwiIHwgXCJibG9iXCIgfCBcInRyZWVcIiB8IHVuZGVmaW5lZCxcbiAgICBzaGE6IHN0cmluZyB8IG51bGx9XG5cbnR5cGUgT2N0b2tpdENhbGxNZXRob2RzID0ge1xuICAgIC8vIGdldFVzZXI6ICgpID0+IFByb21pc2U8e293bmVyOiBzdHJpbmcsIGF2YXRhclVybDogc3RyaW5nfT5cbiAgICBnZXRSZXBvczogKCkgPT4gUHJvbWlzZTxzdHJpbmdbXT5cbiAgICBnZXRSZWY6IChyZWY6IHN0cmluZykgPT4gUHJvbWlzZTxzdHJpbmc+XG4gICAgZ2V0VHJlZTogKHRyZWVfc2hhOiBzdHJpbmcpID0+IFByb21pc2U8VHJlZU5vZGVbXT5cbiAgICBnZXRDb21taXRUcmVlU2hhOiAocmVmOiBzdHJpbmcpID0+IFByb21pc2U8c3RyaW5nPlxuICAgIGdldFJlbW90ZVRyZWVTaGE6ICh0cmVlX3NoYTogc3RyaW5nKSA9PiBQcm9taXNlPHtbazpzdHJpbmddOiBzdHJpbmd9PlxuICAgIGNyZWF0ZUJsb2I6IChjb250ZW50OiBzdHJpbmcsIGVuY29kaW5nOiBzdHJpbmcpID0+UHJvbWlzZTxzdHJpbmc+XG4gICAgY3JlYXRlVHJlZU5vZGVGcm9tRmlsZTogKHtwYXRoLCBzdGF0dXMsIGV4dGVuc2lvbn06IExvY2FsQ2hhbmdlLCByZW1vdGVUcmVlOiBUcmVlTm9kZVtdKSA9PiBQcm9taXNlPFRyZWVOb2RlfG51bGw+XG4gICAgY3JlYXRlQ29tbWl0OiAodHJlZVNoYTogc3RyaW5nLCBwYXJlbnRTaGE6IHN0cmluZykgPT5Qcm9taXNlPHN0cmluZz5cbiAgICB1cGRhdGVSZWY6IChzaGE6IHN0cmluZywgcmVmOiBzdHJpbmcpID0+IFByb21pc2U8c3RyaW5nPlxuICAgIGdldEJsb2I6IChmaWxlX3NoYTpzdHJpbmcpID0+UHJvbWlzZTxzdHJpbmc+XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUZpdCBleHRlbmRzIE9jdG9raXRDYWxsTWV0aG9kc3tcbiAgICBvd25lcjogc3RyaW5nXG4gICAgcmVwbzogc3RyaW5nXG4gICAgYnJhbmNoOiBzdHJpbmdcbiAgICBoZWFkZXJzOiB7W2s6IHN0cmluZ106IHN0cmluZ31cbiAgICBkZXZpY2VOYW1lOiBzdHJpbmdcbiAgICBsb2NhbFNoYTogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuXHRsYXN0RmV0Y2hlZENvbW1pdFNoYTogc3RyaW5nIHwgbnVsbFxuXHRsYXN0RmV0Y2hlZFJlbW90ZVNoYTogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICAgIG9jdG9raXQ6IE9jdG9raXRcbiAgICB2YXVsdE9wczogVmF1bHRPcGVyYXRpb25zXG4gICAgZmlsZVNoYTE6IChwYXRoOiBzdHJpbmcpID0+IFByb21pc2U8c3RyaW5nPlxufVxuXG4vLyBEZWZpbmUgYSBjdXN0b20gSHR0cEVycm9yIGNsYXNzIHRoYXQgZXh0ZW5kcyBFcnJvclxuZXhwb3J0IGNsYXNzIE9jdG9raXRIdHRwRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgc3RhdHVzOiBudW1iZXI7XG4gICAgc291cmNlOiBrZXlvZiBPY3Rva2l0Q2FsbE1ldGhvZHNcblxuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgc3RhdHVzOiBudW1iZXIsIHNvdXJjZToga2V5b2YgT2N0b2tpdENhbGxNZXRob2RzKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnSHR0cEVycm9yJztcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlXG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgRml0IGltcGxlbWVudHMgSUZpdCB7XG4gICAgb3duZXI6IHN0cmluZ1xuICAgIHJlcG86IHN0cmluZ1xuICAgIGF1dGg6IHN0cmluZyB8IHVuZGVmaW5lZFxuICAgIGJyYW5jaDogc3RyaW5nXG4gICAgc3luY1BhdGg6IHN0cmluZ1xuICAgIGhlYWRlcnM6IHtbazogc3RyaW5nXTogc3RyaW5nfVxuICAgIGRldmljZU5hbWU6IHN0cmluZ1xuICAgIGxvY2FsU2hhOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG5cdGxhc3RGZXRjaGVkQ29tbWl0U2hhOiBzdHJpbmcgfCBudWxsXG5cdGxhc3RGZXRjaGVkUmVtb3RlU2hhOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gICAgb2N0b2tpdDogT2N0b2tpdFxuICAgIHZhdWx0T3BzOiBWYXVsdE9wZXJhdGlvbnNcbiAgICBleGNsdWRlczogc3RyaW5nW11cblxuXG4gICAgY29uc3RydWN0b3IocmVwbzogUmVwb3NpdG9yeSwgdmF1bHRPcHM6IFZhdWx0T3BlcmF0aW9ucykge1xuICAgICAgICB0aGlzLmxvYWRTZXR0aW5ncyhyZXBvKVxuICAgICAgICB0aGlzLnZhdWx0T3BzID0gdmF1bHRPcHNcbiAgICAgICAgdGhpcy5oZWFkZXJzID0ge1xuICAgICAgICAgICAgLy8gSGFjayB0byBkaXNhYmxlIGNhY2hpbmcgd2hpY2ggbGVhZHMgdG8gaW5jb25zaXN0ZW5jeSBmb3JcbiAgICAgICAgICAgIC8vIHJlYWQgYWZ0ZXIgd3JpdGUgaHR0cHM6Ly9naXRodWIuY29tL29jdG9raXQvb2N0b2tpdC5qcy9pc3N1ZXMvODkwXG4gICAgICAgICAgICBcIklmLU5vbmUtTWF0Y2hcIjogJycsXG4gICAgICAgICAgICAnWC1HaXRIdWItQXBpLVZlcnNpb24nOiAnMjAyMi0xMS0yOCdcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxvYWRTZXR0aW5ncyhyZXBvOiBSZXBvc2l0b3J5KSB7XG5cdFx0Y29uc3Qge3NldHRpbmdzLCBsb2NhbFN0b3JlfSA9IHJlcG9cbiAgICAgICAgdGhpcy5yZXBvID0gc2V0dGluZ3MucmVwb1xuICAgICAgICB0aGlzLm93bmVyID0gc2V0dGluZ3Mub3duZXJcbiAgICAgICAgdGhpcy5icmFuY2ggPSBzZXR0aW5ncy5icmFuY2hcbiAgICAgICAgdGhpcy5leGNsdWRlcyA9IHNldHRpbmdzLmV4Y2x1ZGVzXG4gICAgICAgIHRoaXMuc3luY1BhdGggPSBzZXR0aW5ncy5zeW5jUGF0aFxuICAgICAgICB0aGlzLmRldmljZU5hbWUgPSBzZXR0aW5ncy5kZXZpY2VOYW1lXG5cbiAgICAgICAgdGhpcy5vY3Rva2l0ID0gbmV3IE9jdG9raXQoe2F1dGg6IHNldHRpbmdzLnBhdH0pXG5cbiAgICAgICAgLy8gXHUwNDIyXHUwNDMwXHUwNDNBXHUwNDM2XHUwNDM1IFx1MDQzRFx1MDQ0M1x1MDQzNlx1MDQzRFx1MDQzRSBcdTA0NDFcdTA0M0VcdTA0NDVcdTA0NDBcdTA0MzBcdTA0M0RcdTA0MzhcdTA0NDJcdTA0NEMgXHUwNDM0XHUwNDQwXHUwNDQzXHUwNDMzXHUwNDM4XHUwNDM1IFx1MDQzRlx1MDQzRVx1MDQzQlx1MDQ0RiBcdTA0MzVcdTA0NDFcdTA0M0JcdTA0MzggXHUwNDNFXHUwNDNEXHUwNDM4IFx1MDQzOFx1MDQ0MVx1MDQzRlx1MDQzRVx1MDQzQlx1MDQ0Q1x1MDQzN1x1MDQ0M1x1MDQ0RVx1MDQ0Mlx1MDQ0MVx1MDQ0RiBcdTA0MzIgXHUwNDNBXHUwNDNCXHUwNDMwXHUwNDQxXHUwNDQxXHUwNDM1IEZpdFxuICAgICAgICAvLyB0aGlzLnBhdCA9IHNldHRpbmcucGF0O1xuICAgICAgICAvLyB0aGlzLmF2YXRhclVybCA9IHNldHRpbmcuYXZhdGFyVXJsO1xuICAgICAgICAvLyB0aGlzLnN5bmNQYXRoID0gc2V0dGluZy5zeW5jUGF0aDtcblxuICAgICAgICB0aGlzLmxvY2FsU2hhID0gbG9jYWxTdG9yZS5sb2NhbFNoYVxuICAgICAgICB0aGlzLmxhc3RGZXRjaGVkQ29tbWl0U2hhID0gbG9jYWxTdG9yZS5sYXN0RmV0Y2hlZENvbW1pdFNoYVxuICAgICAgICB0aGlzLmxhc3RGZXRjaGVkUmVtb3RlU2hhID0gbG9jYWxTdG9yZS5sYXN0RmV0Y2hlZFJlbW90ZVNoYVxuICAgIH1cblxuICAgIGFzeW5jIGZpbGVTaGExKGZpbGVDb250ZW50OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBjb25zdCBlbmMgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICAgICAgY29uc3QgaGFzaEJ1ZiA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KCdTSEEtMScsIGVuYy5lbmNvZGUoZmlsZUNvbnRlbnQpKVxuICAgICAgICBjb25zdCBoYXNoQXJyYXkgPSBBcnJheS5mcm9tKG5ldyBVaW50OEFycmF5KGhhc2hCdWYpKTtcbiAgICAgICAgY29uc3QgaGFzaEhleCA9IGhhc2hBcnJheS5tYXAoYiA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKS5qb2luKCcnKTtcbiAgICAgICAgcmV0dXJuIGhhc2hIZXg7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBjb21wdXRlRmlsZUxvY2FsU2hhKHBhdGg6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nfG51bGw+IHtcblx0XHRjb25zdCBmdWxsUGF0aCA9IHRoaXMuc3luY1BhdGggKyBwYXRoXG5cblx0XHQvLyBjb21wdXRlIHNoYTEgYmFzZWQgb24gcGF0aCBhbmQgZmlsZSBjb250ZW50XG5cdFx0bGV0IGNvbnRlbnQ6IHN0cmluZztcblxuXHRcdC8vIFRPRE8gcmVmYWN0b3JcbiAgICAgICAgLy8gTm90ZTogb25seSBzdXBwb3J0IFRGaWxlIG5vdywgaW52ZXN0aWdhdGUgbmVlZCBmb3Igc3VwcG9ydGluZyBURm9sZGVyIGxhdGVyIG9uXG4gICAgICAgIGNvbnN0IGZpbGUgPSBhd2FpdCB0aGlzLnZhdWx0T3BzLmdldFRGaWxlKGZ1bGxQYXRoKVxuXHRcdGlmIChmaWxlKSB7XG5cdFx0XHRpZiAoUkVDT0dOSVpFRF9CSU5BUllfRVhULmluY2x1ZGVzKGZpbGUuZXh0ZW5zaW9uKSkge1xuXHRcdFx0XHRjb250ZW50ID0gYXJyYXlCdWZmZXJUb0Jhc2U2NChhd2FpdCB0aGlzLnZhdWx0T3BzLnZhdWx0LnJlYWRCaW5hcnkoZmlsZSkpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb250ZW50ID0gYXdhaXQgdGhpcy52YXVsdE9wcy52YXVsdC5yZWFkKGZpbGUpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Y29uc3QgZXh0ZW5zaW9uID0gZXh0cmFjdEV4dGVuc2lvbihwYXRoKVxuXHRcdFx0aWYgKCFleHRlbnNpb24gfHwgUkVDT0dOSVpFRF9CSU5BUllfRVhULmluY2x1ZGVzKGV4dGVuc2lvbikpIHtcblx0XHRcdFx0Y29udGVudCA9IGFycmF5QnVmZmVyVG9CYXNlNjQoXG5cdFx0XHRcdFx0YXdhaXQgdGhpcy52YXVsdE9wcy52YXVsdC5hZGFwdGVyLnJlYWRCaW5hcnkoZnVsbFBhdGgpXG5cdFx0XHRcdClcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnRlbnQgPSBhd2FpdCB0aGlzLnZhdWx0T3BzLnZhdWx0LmFkYXB0ZXIucmVhZChmdWxsUGF0aClcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gYXdhaXQgdGhpcy5maWxlU2hhMShwYXRoICsgY29udGVudClcblx0fVxuXG5cdGFzeW5jIGNvbXB1dGVMb2NhbFNoYSgpOiBQcm9taXNlPHtbazpzdHJpbmddOnN0cmluZ30+IHtcblx0XHRjb25zdCBhbGxQYXRocyA9IGF3YWl0IHRoaXMudmF1bHRPcHMuZ2V0RmlsZXNJblZhdWx0KClcblx0XHRjb25zdCBwYXRocyA9IFtdXG5cdFx0Zm9yIChsZXQgcGF0aCBvZiBhbGxQYXRocykge1xuXHRcdFx0Ly8gVE9ETyBcdTA0M0RcdTA0NDNcdTA0MzZcdTA0M0RcdTA0NEIgXHUwNDNCXHUwNDM4IFx1MDQzQ1x1MDQzRFx1MDQzNSBcdTA0NERcdTA0NDJcdTA0MzggXHUwNDQ0XHUwNDMwXHUwNDM5XHUwNDNCXHUwNDRCIFx1MDQzMiBcdTA0MzFcdTA0NDNcdTA0MzRcdTA0NDNcdTA0NDlcdTA0MzVcdTA0M0M/XG5cdFx0XHRsZXQgaXNFeGNsdWRlZCA9IHBhdGguc3RhcnRzV2l0aChcIl9maXQvXCIpXG5cdFx0XHRcdHx8ICFwYXRoLnN0YXJ0c1dpdGgodGhpcy5zeW5jUGF0aClcblx0XHRcdFx0fHwgdGhpcy5leGNsdWRlcy5jb250YWlucyhwYXRoKVxuXG5cdFx0XHRcdC8vIFRPRE8gcmVmYWN0b3IgXHUwNDNDXHUwNDNFXHUwNDM2XHUwNDNEXHUwNDNFIFx1MDQzMiBcdTA0M0VcdTA0MzRcdTA0M0RcdTA0NDMgXHUwNDQxXHUwNDQyXHUwNDQwXHUwNDNFXHUwNDQ3XHUwNDNBXHUwNDQzIFx1MDQzRFx1MDQzMFx1MDQzRlx1MDQzOFx1MDQ0MVx1MDQzMFx1MDQ0Mlx1MDQ0QywgXHUwNDQxIFtdLnNvbWVcblx0XHRcdGZvciAobGV0IGV4Y2x1ZGUgb2YgdGhpcy5leGNsdWRlcykge1xuXHRcdFx0XHRpc0V4Y2x1ZGVkIHx8PSBwYXRoLnN0YXJ0c1dpdGgoZXhjbHVkZSlcblxuXHRcdFx0XHRpZiAoaXNFeGNsdWRlZClcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0fVxuXHRcdFx0Y29uc3QgcmVzdWx0ID0gcGF0aC5yZXBsYWNlKHRoaXMuc3luY1BhdGgsIFwiXCIpXG5cblx0XHRcdGlmICghaXNFeGNsdWRlZClcblx0XHRcdFx0cGF0aHMucHVzaChyZXN1bHQpXG5cdFx0fVxuXHRcdGNvbnN0IGFzeW5jQ29tcHV0ZSA9IHBhdGhzLm1hcChcblx0XHRcdGFzeW5jIChwYXRoKSA9PiB7XG5cdFx0XHRcdGNvbnN0IHNoYSA9IGF3YWl0IHRoaXMuY29tcHV0ZUZpbGVMb2NhbFNoYShwYXRoKVxuXHRcdFx0XHRyZXR1cm4gW3BhdGgsIHNoYV1cblx0XHRcdH1cblx0XHQpXG5cblx0XHRjb25zdCBjb21wdXRlZCA9IGF3YWl0IFByb21pc2UuYWxsKGFzeW5jQ29tcHV0ZSlcblx0XHRjb25zdCByZXN1bHQgPSBjb21wdXRlZC5maWx0ZXIoZWwgPT4gISFlbFsxXSlcblxuXHRcdHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMocmVzdWx0KVxuXHR9XG5cbiAgICBhc3luYyByZW1vdGVVcGRhdGVkKCk6IFByb21pc2U8e3JlbW90ZUNvbW1pdFNoYTogc3RyaW5nLCB1cGRhdGVkOiBib29sZWFufT4ge1xuICAgICAgICBjb25zdCByZW1vdGVDb21taXRTaGEgPSBhd2FpdCB0aGlzLmdldFJlZigpXG4gICAgICAgIHJldHVybiB7cmVtb3RlQ29tbWl0U2hhLCB1cGRhdGVkOiByZW1vdGVDb21taXRTaGEgIT09IHRoaXMubGFzdEZldGNoZWRDb21taXRTaGF9XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0TG9jYWxDaGFuZ2VzKGN1cnJlbnRMb2NhbFNoYT86IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pOiBQcm9taXNlPExvY2FsQ2hhbmdlW10+IHtcbiAgICAgICAgaWYgKCFjdXJyZW50TG9jYWxTaGEpIHtcbiAgICAgICAgICAgIGN1cnJlbnRMb2NhbFNoYSA9IGF3YWl0IHRoaXMuY29tcHV0ZUxvY2FsU2hhKClcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsb2NhbENoYW5nZXMgPSBjb21wYXJlU2hhKGN1cnJlbnRMb2NhbFNoYSwgdGhpcy5sb2NhbFNoYSwgXCJsb2NhbFwiKVxuICAgICAgICByZXR1cm4gbG9jYWxDaGFuZ2VzXG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0UmVtb3RlQ2hhbmdlcyhyZW1vdGVUcmVlU2hhOiB7W2s6IHN0cmluZ106IHN0cmluZ30pOiBQcm9taXNlPFJlbW90ZUNoYW5nZVtdPiB7XG4gICAgICAgIGNvbnN0IHJlbW90ZUNoYW5nZXMgPSBjb21wYXJlU2hhKHJlbW90ZVRyZWVTaGEsIHRoaXMubGFzdEZldGNoZWRSZW1vdGVTaGEsIFwicmVtb3RlXCIpXG4gICAgICAgIHJldHVybiByZW1vdGVDaGFuZ2VzXG4gICAgfVxuXG4gICAgZ2V0Q2xhc2hlZENoYW5nZXMobG9jYWxDaGFuZ2VzOiBMb2NhbENoYW5nZVtdLCByZW1vdGVDaGFuZ2VzOlJlbW90ZUNoYW5nZVtdKTpcblx0XHRBcnJheTx7cGF0aDogc3RyaW5nLCBsb2NhbFN0YXR1czogTG9jYWxGaWxlU3RhdHVzLCByZW1vdGVTdGF0dXM6IFJlbW90ZUNoYW5nZVR5cGV9PlxuXHR7XG4gICAgICAgIC8vIFRPRE8gZmZlenRfY2hlY2tpbmcgXHUwNDM3XHUwNDM0XHUwNDM1XHUwNDQxXHUwNDRDIFx1MDQzMlx1MDQ0MFx1MDQzRVx1MDQzNFx1MDQzNSBcdTA0M0RcdTA0MzVcdTA0NDFcdTA0M0VcdTA0MzJcdTA0M0NcdTA0MzVcdTA0NDFcdTA0NDJcdTA0MzhcdTA0M0NcdTA0NEJcdTA0MzUgXHUwNDM4XHUwNDM3XHUwNDNDXHUwNDM1XHUwNDNEXHUwNDM1XHUwNDNEXHUwNDM4XHUwNDRGIFx1MDQzRlx1MDQzRVx1MDQ0Rlx1MDQzMlx1MDQzQlx1MDQ0Rlx1MDQ0RVx1MDQ0Mlx1MDQ0MVx1MDQ0RlxuXG4gICAgICAgIGNvbnN0IGxvY2FsQ2hhbmdlUGF0aHMgPSBsb2NhbENoYW5nZXMubWFwKFxuICAgICAgICAgICAgYyA9PiBjLnBhdGgucmVwbGFjZSh0aGlzLnN5bmNQYXRoLCAnJylcbiAgICAgICAgKVxuICAgICAgICBjb25zdCByZW1vdGVDaGFuZ2VQYXRocyA9IHJlbW90ZUNoYW5nZXMubWFwKGM9PmMucGF0aClcblxuICAgICAgICBjb25zdCBjbGFzaGVkRmlsZXMgPSBsb2NhbENoYW5nZVBhdGhzLm1hcChcbiAgICAgICAgICAgIChwYXRoLCBsb2NhbEluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVtb3RlSW5kZXggPSByZW1vdGVDaGFuZ2VQYXRocy5pbmRleE9mKHBhdGgpXG4gICAgICAgICAgICAgICAgaWYgKHJlbW90ZUluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge3BhdGgsIGxvY2FsSW5kZXgsIHJlbW90ZUluZGV4fVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICApLmZpbHRlcihCb29sZWFuKSBhcyBBcnJheTx7cGF0aDogc3RyaW5nLCBsb2NhbEluZGV4OiBudW1iZXIsIHJlbW90ZUluZGV4Om51bWJlcn0+XG5cbiAgICAgICAgcmV0dXJuIGNsYXNoZWRGaWxlcy5tYXAoXG4gICAgICAgICAgICAoe3BhdGgsIGxvY2FsSW5kZXgsIHJlbW90ZUluZGV4fSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU3RhdHVzOiBsb2NhbENoYW5nZXNbbG9jYWxJbmRleF0uc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICByZW1vdGVTdGF0dXM6IHJlbW90ZUNoYW5nZXNbcmVtb3RlSW5kZXhdLnN0YXR1c1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0UmVwb3MoKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgICAgICBjb25zdCBhbGxSZXBvczogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgbGV0IHBhZ2UgPSAxO1xuICAgICAgICBjb25zdCBwZXJQYWdlID0gMTAwOyAvLyBTZXQgdG8gdGhlIG1heGltdW0gdmFsdWUgb2YgMTAwXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBoYXNNb3JlUGFnZXMgPSB0cnVlO1xuICAgICAgICAgICAgd2hpbGUgKGhhc01vcmVQYWdlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogcmVzcG9uc2UgfSA9IGF3YWl0IHRoaXMub2N0b2tpdC5yZXF1ZXN0KFxuICAgICAgICAgICAgICAgICAgICBgR0VUIC91c2VyL3JlcG9zYCwge1xuICAgICAgICAgICAgICAgICAgICBhZmZpbGlhdGlvbjogXCJvd25lclwiLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIHBlcl9wYWdlOiBwZXJQYWdlLCAvLyBOdW1iZXIgb2YgcmVwb3NpdG9yaWVzIHRvIGltcG9ydCBwZXIgcGFnZSAodXAgdG8gMTAwKVxuICAgICAgICAgICAgICAgICAgICBwYWdlOiBwYWdlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYWxsUmVwb3MucHVzaCguLi5yZXNwb25zZS5tYXAociA9PiByLm5hbWUpKTtcblxuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB5b3UgaGF2ZSB0aGUgZm9sbG93aW5nIHBhZ2VzXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmxlbmd0aCA8IHBlclBhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzTW9yZVBhZ2VzID0gZmFsc2U7IC8vIEV4aXQgd2hlbiB0aGVyZSBhcmUgbm8gbW9yZSByZXBvc2l0b3JpZXNcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwYWdlKys7IC8vIEdvIHRvIHRoZSBuZXh0IHBhZ2VcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFsbFJlcG9zO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9jdG9raXRIdHRwRXJyb3IoZXJyb3IubWVzc2FnZSwgZXJyb3Iuc3RhdHVzLCBcImdldFJlcG9zXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0QnJhbmNoZXMoKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qge2RhdGE6IHJlc3BvbnNlfSA9IGF3YWl0IHRoaXMub2N0b2tpdC5yZXF1ZXN0KFxuICAgICAgICAgICAgICAgIGBHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2JyYW5jaGVzYCxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG93bmVyOiB0aGlzLm93bmVyLFxuICAgICAgICAgICAgICAgICAgICByZXBvOiB0aGlzLnJlcG8sXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVyc1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5tYXAociA9PiByLm5hbWUpXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT2N0b2tpdEh0dHBFcnJvcihlcnJvci5tZXNzYWdlLCBlcnJvci5zdGF0dXMsIFwiZ2V0UmVwb3NcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHZXQgdGhlIHNoYSBvZiB0aGUgbGF0ZXN0IGNvbW1pdCBpbiB0aGUgZGVmYXVsdCBicmFuY2ggKHNldCBieSB1c2VyIGluIHNldHRpbmcpXG4gICAgYXN5bmMgZ2V0UmVmKHJlZjogc3RyaW5nID0gYGhlYWRzLyR7dGhpcy5icmFuY2h9YCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7ZGF0YTogcmVzcG9uc2V9ID0gYXdhaXQgdGhpcy5vY3Rva2l0LnJlcXVlc3QoXG4gICAgICAgICAgICAgICAgYEdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vZ2l0L3JlZi97cmVmfWAsIHtcbiAgICAgICAgICAgICAgICAgICAgb3duZXI6IHRoaXMub3duZXIsXG4gICAgICAgICAgICAgICAgICAgIHJlcG86IHRoaXMucmVwbyxcbiAgICAgICAgICAgICAgICAgICAgcmVmOiByZWYsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVyc1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5vYmplY3Quc2hhXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT2N0b2tpdEh0dHBFcnJvcihlcnJvci5tZXNzYWdlLCBlcnJvci5zdGF0dXMsIFwiZ2V0UmVmXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVmIENhbiBiZSBhIGNvbW1pdCBTSEEsIGJyYW5jaCBuYW1lIChoZWFkcy9CUkFOQ0hfTkFNRSksIG9yIHRhZyBuYW1lICh0YWdzL1RBR19OQU1FKSxcbiAgICAvLyByZWZlcnMgdG8gaHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL2VuL3YyL0dpdC1JbnRlcm5hbHMtR2l0LVJlZmVyZW5jZXNcbiAgICBhc3luYyBnZXRDb21taXRUcmVlU2hhKHJlZjogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3Qge2RhdGE6IGNvbW1pdH0gPSAgYXdhaXQgdGhpcy5vY3Rva2l0LnJlcXVlc3QoXG4gICAgICAgICAgICBgR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9jb21taXRzL3tyZWZ9YCwge1xuICAgICAgICAgICAgb3duZXI6IHRoaXMub3duZXIsXG4gICAgICAgICAgICByZXBvOiB0aGlzLnJlcG8sXG4gICAgICAgICAgICByZWYsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnNcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIGNvbW1pdC5jb21taXQudHJlZS5zaGFcbiAgICB9XG5cbiAgICBhc3luYyBnZXRUcmVlKHRyZWVfc2hhOiBzdHJpbmcpOiBQcm9taXNlPFRyZWVOb2RlW10+IHtcbiAgICAgICAgY29uc3QgeyBkYXRhOiB0cmVlIH0gPSAgYXdhaXQgdGhpcy5vY3Rva2l0LnJlcXVlc3QoXG4gICAgICAgICAgICBgR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9naXQvdHJlZXMve3RyZWVfc2hhfWAsIHtcbiAgICAgICAgICAgIG93bmVyOiB0aGlzLm93bmVyLFxuICAgICAgICAgICAgcmVwbzogdGhpcy5yZXBvLFxuICAgICAgICAgICAgdHJlZV9zaGEsXG4gICAgICAgICAgICByZWN1cnNpdmU6ICd0cnVlJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVyc1xuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gdHJlZS50cmVlIGFzIFRyZWVOb2RlW11cbiAgICB9XG5cbiAgICAvLyBnZXQgdGhlIHJlbW90ZSB0cmVlIHNoYSBpbiB0aGUgZm9ybWF0IGNvbXBhdGlibGUgd2l0aCBsb2NhbCBzdG9yZVxuICAgIGFzeW5jIGdldFJlbW90ZVRyZWVTaGEodHJlZV9zaGE6IHN0cmluZyk6IFByb21pc2U8e1trOnN0cmluZ106IHN0cmluZ30+IHtcbiAgICAgICAgY29uc3QgcmVtb3RlVHJlZSA9IGF3YWl0IHRoaXMuZ2V0VHJlZSh0cmVlX3NoYSlcbiAgICAgICAgY29uc3QgcmVtb3RlU2hhID0gT2JqZWN0LmZyb21FbnRyaWVzKHJlbW90ZVRyZWUubWFwKChub2RlOiBUcmVlTm9kZSkgOiBbc3RyaW5nLCBzdHJpbmddIHwgbnVsbD0+e1xuICAgICAgICAgICAgLy8gY3VycmVudGx5IGlnbm9yaW5nIGRpcmVjdG9yeSBjaGFuZ2VzLCBpZiB5b3UnZCBsaWtlIHRvIHVwbG9hZCBhIG5ldyBkaXJlY3RvcnksXG4gICAgICAgICAgICAvLyBhIHF1aWNrIGhhY2sgd291bGQgYmUgY3JlYXRpbmcgYW4gZW1wdHkgZmlsZSBpbnNpZGVcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGU9PVwiYmxvYlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlLnBhdGggfHwgIW5vZGUuc2hhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhdGggb3Igc2hhIG5vdCBmb3VuZCBmb3IgYmxvYiBub2RlIGluIHJlbW90ZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWdub3JlIGNoYW5nZXMgaW4gdGhlIF9maXQvIGRpcmVjdG9yeVxuICAgICAgICAgICAgICAgIGlmIChub2RlLnBhdGguc3RhcnRzV2l0aChcIl9maXQvXCIpKSB7cmV0dXJuIG51bGx9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtub2RlLnBhdGgsIG5vZGUuc2hhXVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfSkuZmlsdGVyKEJvb2xlYW4pIGFzIFtzdHJpbmcsIHN0cmluZ11bXSlcbiAgICAgICAgcmV0dXJuIHJlbW90ZVNoYVxuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZUJsb2IoY29udGVudDogc3RyaW5nLCBlbmNvZGluZzogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3Qge2RhdGE6IGJsb2J9ID0gYXdhaXQgdGhpcy5vY3Rva2l0LnJlcXVlc3QoXG4gICAgICAgICAgICBgUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vZ2l0L2Jsb2JzYCwge1xuICAgICAgICAgICAgb3duZXI6IHRoaXMub3duZXIsXG4gICAgICAgICAgICByZXBvOiB0aGlzLnJlcG8sXG4gICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgZW5jb2RpbmcsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnNcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIGJsb2Iuc2hhXG4gICAgfVxuXG5cbiAgICBhc3luYyBjcmVhdGVUcmVlTm9kZUZyb21GaWxlKHtwYXRoLCBzdGF0dXMsIGV4dGVuc2lvbn06IExvY2FsQ2hhbmdlLCByZW1vdGVUcmVlOiBBcnJheTxUcmVlTm9kZT4pOiBQcm9taXNlPFRyZWVOb2RlfG51bGw+IHtcblx0XHRpZiAoc3RhdHVzID09PSBcImRlbGV0ZWRcIikge1xuICAgICAgICAgICAgLy8gc2tpcCBjcmVhdGluZyBkZWxldGlvbiBub2RlIGlmIGZpbGUgbm90IGZvdW5kIG9uIHJlbW90ZVxuICAgICAgICAgICAgaWYgKHJlbW90ZVRyZWUuZXZlcnkobm9kZSA9PiBub2RlLnBhdGggIT09IHBhdGgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgIH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHBhdGgsXG5cdFx0XHRcdG1vZGU6ICcxMDA2NDQnLFxuXHRcdFx0XHR0eXBlOiAnYmxvYicsXG5cdFx0XHRcdHNoYTogbnVsbFxuXHRcdFx0fVxuXHRcdH1cblx0XHRjb25zdCBmdWxsUGF0aCA9IHRoaXMuc3luY1BhdGggKyBwYXRoXG4gICAgICAgIC8vIGNvbnN0IGZpbGUgPSBhd2FpdCB0aGlzLnZhdWx0T3BzLmdldFRGaWxlKHRoaXMuc3luY1BhdGggKyBwYXRoKVxuXHRcdC8vIGlmICghZmlsZSlcblx0XHQvLyBcdHJldHVybiBudWxsXG5cblx0XHRsZXQgZW5jb2Rpbmc6IHN0cmluZztcblx0XHRsZXQgY29udGVudDogc3RyaW5nXG4gICAgICAgIC8vIFRPRE8gY2hlY2sgd2hldGhlciBldmVyeSBmaWxlcyBpbmNsdWRpbmcgbWQgY2FuIGJlIHJlYWQgdXNpbmcgcmVhZEJpbmFyeSB0byByZWR1Y2UgY29kZSBjb21wbGV4aXR5XG5cdFx0aWYgKGV4dGVuc2lvbiAmJiBSRUNPR05JWkVEX0JJTkFSWV9FWFQuaW5jbHVkZXMoZXh0ZW5zaW9uKSkge1xuXHRcdFx0ZW5jb2RpbmcgPSBcImJhc2U2NFwiXG5cblx0XHRcdGNvbnN0IGZpbGVBcnJheUJ1ZiA9IGF3YWl0IHRoaXMudmF1bHRPcHMudmF1bHQuYWRhcHRlci5yZWFkQmluYXJ5KGZ1bGxQYXRoKVxuXHRcdFx0Ly8gY29uc3QgZmlsZUFycmF5QnVmID0gYXdhaXQgdGhpcy52YXVsdE9wcy52YXVsdC5yZWFkQmluYXJ5KGZpbGUpXG5cdFx0XHRjb25zdCB1aW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZmlsZUFycmF5QnVmKTtcblx0XHRcdGxldCBiaW5hcnlTdHJpbmcgPSAnJztcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdWludDhBcnJheS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRiaW5hcnlTdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1aW50OEFycmF5W2ldKTtcblx0XHRcdH1cblx0XHRcdGNvbnRlbnQgPSBidG9hKGJpbmFyeVN0cmluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVuY29kaW5nID0gJ3V0Zi04J1xuXHRcdFx0Ly8gY29udGVudCA9IGF3YWl0IHRoaXMudmF1bHRPcHMudmF1bHQucmVhZChmaWxlKVxuXHRcdFx0Y29udGVudCA9IGF3YWl0IHRoaXMudmF1bHRPcHMudmF1bHQuYWRhcHRlci5yZWFkKGZ1bGxQYXRoKVxuXHRcdH1cblx0XHRjb25zdCBibG9iU2hhID0gYXdhaXQgdGhpcy5jcmVhdGVCbG9iKGNvbnRlbnQsIGVuY29kaW5nKVxuICAgICAgICAvLyBza2lwIGNyZWF0aW5nIG5vZGUgaWYgZmlsZSBmb3VuZCBvbiByZW1vdGUgaXMgdGhlIHNhbWUgYXMgdGhlIGNyZWF0ZWQgYmxvYlxuICAgICAgICBpZiAocmVtb3RlVHJlZS5zb21lKG5vZGUgPT4gbm9kZS5wYXRoID09PSBwYXRoICYmIG5vZGUuc2hhID09PSBibG9iU2hhKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXHRcdHJldHVybiB7XG5cdFx0XHRwYXRoOiBwYXRoLFxuXHRcdFx0bW9kZTogJzEwMDY0NCcsXG5cdFx0XHR0eXBlOiAnYmxvYicsXG5cdFx0XHRzaGE6IGJsb2JTaGEsXG5cdFx0fVxuXHR9XG5cbiAgICBhc3luYyBjcmVhdGVUcmVlKFxuICAgICAgICB0cmVlTm9kZXM6IEFycmF5PFRyZWVOb2RlPixcbiAgICAgICAgYmFzZV90cmVlX3NoYTogc3RyaW5nKTpcbiAgICAgICAgUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgICAgIGNvbnN0IHtkYXRhOiBuZXdUcmVlfSA9IGF3YWl0IHRoaXMub2N0b2tpdC5yZXF1ZXN0KFxuICAgICAgICAgICAgICAgIGBQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9naXQvdHJlZXNgLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgb3duZXI6IHRoaXMub3duZXIsXG4gICAgICAgICAgICAgICAgICAgIHJlcG86IHRoaXMucmVwbyxcbiAgICAgICAgICAgICAgICAgICAgdHJlZTogdHJlZU5vZGVzLFxuICAgICAgICAgICAgICAgICAgICBiYXNlX3RyZWU6IGJhc2VfdHJlZV9zaGEsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVyc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiBuZXdUcmVlLnNoYVxuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZUNvbW1pdCh0cmVlU2hhOiBzdHJpbmcsIHBhcmVudFNoYTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBDb21taXQgZnJvbSAke3RoaXMuZGV2aWNlTmFtZX0gb24gJHtuZXcgRGF0ZSgpLnRvTG9jYWxlU3RyaW5nKCl9YFxuICAgICAgICBjb25zdCB7IGRhdGE6IGNyZWF0ZWRDb21taXQgfSA9IGF3YWl0IHRoaXMub2N0b2tpdC5yZXF1ZXN0KFxuICAgICAgICAgICAgYFBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2dpdC9jb21taXRzYCAsIHtcbiAgICAgICAgICAgIG93bmVyOiB0aGlzLm93bmVyLFxuICAgICAgICAgICAgcmVwbzogdGhpcy5yZXBvLFxuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgIHRyZWU6IHRyZWVTaGEsXG4gICAgICAgICAgICBwYXJlbnRzOiBbcGFyZW50U2hhXSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVyc1xuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gY3JlYXRlZENvbW1pdC5zaGFcbiAgICB9XG5cbiAgICBhc3luYyB1cGRhdGVSZWYoc2hhOiBzdHJpbmcsIHJlZiA9IGBoZWFkcy8ke3RoaXMuYnJhbmNofWApOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBjb25zdCB7IGRhdGE6dXBkYXRlZFJlZiB9ID0gYXdhaXQgdGhpcy5vY3Rva2l0LnJlcXVlc3QoXG4gICAgICAgICAgICBgUEFUQ0ggL3JlcG9zL3tvd25lcn0ve3JlcG99L2dpdC9yZWZzL3tyZWZ9YCwge1xuICAgICAgICAgICAgb3duZXI6IHRoaXMub3duZXIsXG4gICAgICAgICAgICByZXBvOiB0aGlzLnJlcG8sXG4gICAgICAgICAgICByZWYsXG4gICAgICAgICAgICBzaGEsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnNcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIHVwZGF0ZWRSZWYub2JqZWN0LnNoYVxuICAgIH1cblxuICAgIGFzeW5jIGdldEJsb2IoZmlsZV9zaGE6c3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3QgeyBkYXRhOiBibG9iIH0gPSBhd2FpdCB0aGlzLm9jdG9raXQucmVxdWVzdChcbiAgICAgICAgICAgIGBHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2dpdC9ibG9icy97ZmlsZV9zaGF9YCwge1xuICAgICAgICAgICAgb3duZXI6IHRoaXMub3duZXIsXG4gICAgICAgICAgICByZXBvOiB0aGlzLnJlcG8sXG4gICAgICAgICAgICBmaWxlX3NoYSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVyc1xuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gYmxvYi5jb250ZW50XG4gICAgfVxufVxuIiwgImltcG9ydCB7IE5vdGljZSB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgRml0IH0gZnJvbSBcIi4vZml0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpdE5vdGljZSB7XG4gICAgZml0OiBGaXRcbiAgICBtdXRlZDogYm9vbGVhblxuICAgIG5vdGljZTogbnVsbCB8IE5vdGljZVxuICAgIGNsYXNzZXM6IEFycmF5PHN0cmluZz5cblxuXHRjb25zdHJ1Y3RvcihhZGRDbGFzc2VzOiBBcnJheTxzdHJpbmc+ID0gW10sIGluaXRpYWxNZXNzYWdlPzogc3RyaW5nLCBkdXJhdGlvbiA9IDAsIG11dGVkID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5tdXRlZCA9IG11dGVkXG4gICAgICAgIHRoaXMuY2xhc3NlcyA9IFsnZml0LW5vdGljZSddXG4gICAgICAgIGlmIChpbml0aWFsTWVzc2FnZSAmJiAhdGhpcy5tdXRlZCkge1xuICAgICAgICAgICAgdGhpcy5zaG93KGluaXRpYWxNZXNzYWdlLCBhZGRDbGFzc2VzLCBkdXJhdGlvbilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NlcyA9IFsuLi50aGlzLmNsYXNzZXMsIC4uLmFkZENsYXNzZXNdXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtdXRlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLm11dGVkID0gdHJ1ZVxuICAgICAgICBpZiAodGhpcy5ub3RpY2UpIHtcbiAgICAgICAgICAgIHRoaXMubm90aWNlLmhpZGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdW5tdXRlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLm11dGVkID0gZmFsc2VcbiAgICB9XG5cbiAgICBzaG93KGluaXRpYWxNZXNzYWdlPzogc3RyaW5nLCBhZGRDbGFzc2VzOiBBcnJheTxzdHJpbmc+ID0gW10sIGR1cmF0aW9uID0gMCk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMubm90aWNlICYmICF0aGlzLm11dGVkKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gKGluaXRpYWxNZXNzYWdlICYmIGluaXRpYWxNZXNzYWdlLmxlbmd0aCA+IDApPyBpbml0aWFsTWVzc2FnZSA6IFwiIFwiXG4gICAgICAgICAgICB0aGlzLm5vdGljZSA9IG5ldyBOb3RpY2UobWVzc2FnZSwgZHVyYXRpb24pXG4gICAgICAgICAgICB0aGlzLm5vdGljZS5ub3RpY2VFbC5hZGRDbGFzc2VzKFsuLi50aGlzLmNsYXNzZXMsIC4uLmFkZENsYXNzZXNdKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlQ2xhc3NlcyhhZGRDbGFzc2VzOiBBcnJheTxzdHJpbmc+ID0gW10sIHJlbW92ZUNsYXNzZXM6IEFycmF5PHN0cmluZz4gPSBbXSk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5tdXRlZCkge3JldHVybn1cbiAgICAgICAgdGhpcy5jbGFzc2VzID0gdGhpcy5jbGFzc2VzLmZpbHRlcihjID0+ICFyZW1vdmVDbGFzc2VzLmluY2x1ZGVzKGMpKVxuICAgICAgICBpZiAodGhpcy5ub3RpY2UpIHtcbiAgICAgICAgICAgIHRoaXMubm90aWNlLm5vdGljZUVsLnJlbW92ZUNsYXNzZXMocmVtb3ZlQ2xhc3NlcylcbiAgICAgICAgICAgIHRoaXMubm90aWNlLm5vdGljZUVsLmFkZENsYXNzZXMoYWRkQ2xhc3NlcylcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsYXNzZXMgPSBbLi4udGhpcy5jbGFzc2VzLCAuLi5hZGRDbGFzc2VzXVxuICAgIH1cblxuICAgIC8vIGFsbG93cyBlcnJvciBkaXNwbGF5IHRvIG92ZXJyaWRlIG11dGVkXG4gICAgc2V0TWVzc2FnZShtZXNzYWdlOiBzdHJpbmcsIGlzRXJyb3I/OiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIGlmIChpc0Vycm9yKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMubm90aWNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpY2UgPSBuZXcgTm90aWNlKG1lc3NhZ2UsIDApXG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpY2Uubm90aWNlRWwuYWRkQ2xhc3NlcyhbJ2ZpdC1ub3RpY2UnLCAnZXJyb3InXSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpY2Uuc2V0TWVzc2FnZShtZXNzYWdlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMubm90aWNlICYmICF0aGlzLm11dGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpY2Uuc2V0TWVzc2FnZShtZXNzYWdlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVtb3ZlKGZpbmFsQ2xhc3M/OiBzdHJpbmcsIGR1cmF0aW9uID0gNTAwMCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5tdXRlZCkge3JldHVybn1cblx0XHR0aGlzLm5vdGljZT8ubm90aWNlRWwucmVtb3ZlQ2xhc3Nlcyh0aGlzLmNsYXNzZXMuZmlsdGVyKGMgPT4gYyAhPT0gXCJmaXQtbm90aWNlXCIpKVxuICAgICAgICBpZiAoZmluYWxDbGFzcykge1xuICAgICAgICAgICAgdGhpcy5ub3RpY2U/Lm5vdGljZUVsLmFkZENsYXNzKGZpbmFsQ2xhc3MpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5vdGljZT8ubm90aWNlRWwuYWRkQ2xhc3MoXCJkb25lXCIpXG4gICAgICAgIH1cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLm5vdGljZT8uaGlkZSgpLCBkdXJhdGlvbilcbiAgICB9XG5cbn1cbiIsICJpbXBvcnQgRml0UGx1Z2luLCB7IERFRkFVTFRfUkVQT1NJVE9SWSwgU3luY1NldHRpbmcsIERFRkFVTFRfTE9DQUxfU1RPUkUgfSBmcm9tIFwibWFpblwiO1xuaW1wb3J0IHsgQXBwLCBQbHVnaW5TZXR0aW5nVGFiLCBTZXR0aW5nLCBOb3RpY2UgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IGRpZmZlcmVuY2UsIGludGVyc2VjdGlvbiwgc2V0RXF1YWwgfSBmcm9tIFwiLi91dGlsc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaXRTZXR0aW5nVGFiIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XG5cdHBsdWdpbjogRml0UGx1Z2luO1xuXHQvLyBhdXRoZW50aWNhdGluZzogYm9vbGVhbjtcblx0YXV0aFVzZXJBdmF0YXI6IEhUTUxEaXZFbGVtZW50O1xuXHRhdXRoVXNlckhhbmRsZTogSFRNTFNwYW5FbGVtZW50O1xuXHQvLyBwYXRTZXR0aW5nOiBTZXR0aW5nO1xuXHQvLyBvd25lclNldHRpbmc6IFNldHRpbmc7XG5cdC8vIHJlcG9TZXR0aW5nOiBTZXR0aW5nO1xuXHQvLyBicmFuY2hTZXR0aW5nOiBTZXR0aW5nO1xuXHQvLyBzeW5jUGF0aFNldHRpbmc6IFNldHRpbmc7XG5cdC8vIGV4aXN0aW5nUmVwb3M6IEFycmF5PHN0cmluZz47XG5cdC8vIGV4aXN0aW5nQnJhbmNoZXM6IEFycmF5PHN0cmluZz47XG5cdC8vIHJlcG9MaW5rOiBzdHJpbmc7XG5cdC8vIHN5bmNQYXRoOiBzdHJpbmc7XG5cdGN1cnJlbnRTeW5jSW5kZXg6IG51bWJlciA9IDA7XG5cblx0Y29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogRml0UGx1Z2luKSB7XG5cdFx0c3VwZXIoYXBwLCBwbHVnaW4pO1xuXHRcdHRoaXMucGx1Z2luID0gcGx1Z2luO1xuXHRcdC8vIHRoaXMuY3VycmVudFN5bmNJbmRleCA9IHBsdWdpbi5zZXR0aW5ncy5jdXJyZW50U3luY0luZGV4IHx8IDA7XG5cdFx0Ly8gdGhpcy5yZXBvTGluayA9IHRoaXMuZ2V0TGF0ZXN0TGluaygpO1xuXHRcdC8vIHRoaXMuYXV0aGVudGljYXRpbmcgPSBmYWxzZTtcblx0XHQvLyB0aGlzLmV4aXN0aW5nUmVwb3MgPSBbXTtcblx0XHQvLyB0aGlzLmV4aXN0aW5nQnJhbmNoZXMgPSBbXTtcblx0fVxuXG5cdGdldEN1cnJlbnRTeW5jU2V0dGluZygpOiBTeW5jU2V0dGluZyB7XG5cdFx0cmV0dXJuIHRoaXMucGx1Z2luLnN0b3JhZ2UucmVwb1t0aGlzLmN1cnJlbnRTeW5jSW5kZXhdLnNldHRpbmdzO1xuXHR9XG5cblx0Z2V0TGF0ZXN0TGluayA9ICgpOiBzdHJpbmcgPT4ge1xuXHRcdGNvbnN0IGN1cnJlbnRTZXR0aW5nID0gdGhpcy5nZXRDdXJyZW50U3luY1NldHRpbmcoKTtcblx0XHRjb25zdCB7b3duZXIsIHJlcG8sIGJyYW5jaH0gPSBjdXJyZW50U2V0dGluZztcblx0XHRpZiAob3duZXIubGVuZ3RoID4gMCAmJiByZXBvLmxlbmd0aCA+IDAgJiYgYnJhbmNoLmxlbmd0aCA+IDApIHtcblx0XHRcdHJldHVybiBgaHR0cHM6Ly9naXRodWIuY29tLyR7b3duZXJ9LyR7cmVwb30vdHJlZS8ke2JyYW5jaH1gO1xuXHRcdH1cblx0XHRyZXR1cm4gXCJcIjtcblx0fVxuXG5cdGFzeW5jIGdpdGh1YlVzZXJJbmZvQmxvY2soKSB7XG5cdFx0Y29uc3Qge2NvbnRhaW5lckVsfSA9IHRoaXM7XG5cdFx0Y29uc3QgY3VycmVudFNldHRpbmcgPSB0aGlzLmdldEN1cnJlbnRTeW5jU2V0dGluZygpO1xuXG5cdFx0Y29uc3Qge2ZvbGRlcnMsIGZpbGVzfSA9IGF3YWl0IHRoaXMucGx1Z2luLnZhdWx0T3BzLmdldEFsbEluVmF1bHQoKVxuXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpLnNldEhlYWRpbmcoKVxuXHRcdFx0LnNldE5hbWUoYEdpdEh1YiB1c2VyIGluZm8gKFJlcG9zaXRvcnkgJHt0aGlzLmN1cnJlbnRTeW5jSW5kZXggKyAxfSlgKVxuXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZSgnR2l0aHViIHVzZXJuYW1lJylcblx0XHRcdC5zZXREZXNjKCdFbnRlciB5b3VyIG5hbWUgb24gR2l0aHViJylcblx0XHRcdC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuXHRcdFx0XHQuc2V0UGxhY2Vob2xkZXIoJ0dpdEh1YiB1c2VybmFtZScpXG5cdFx0XHRcdC5zZXRWYWx1ZShjdXJyZW50U2V0dGluZy5vd25lcilcblx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdGN1cnJlbnRTZXR0aW5nLm93bmVyID0gdmFsdWU7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdH0pKVxuXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZSgnR2l0aHViIHBlcnNvbmFsIGFjY2VzcyB0b2tlbicpXG5cdFx0XHQuc2V0RGVzYygnUmVtZW1iZXIgdG8gZ2l2ZSBpdCBhY2Nlc3MgZm9yIHJlYWRpbmcgYW5kIHdyaXRpbmcgdG8gdGhlIHN0b3JhZ2UgcmVwby4nKVxuXHRcdFx0LmFkZFRleHQodGV4dCA9PiB0ZXh0XG5cdFx0XHRcdC5zZXRQbGFjZWhvbGRlcignR2l0SHViIHBlcnNvbmFsIGFjY2VzcyB0b2tlbicpXG5cdFx0XHRcdC5zZXRWYWx1ZShjdXJyZW50U2V0dGluZy5wYXQpXG5cdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHRjdXJyZW50U2V0dGluZy5wYXQgPSB2YWx1ZTtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0fSkpXG5cdFx0XHQuYWRkRXh0cmFCdXR0b24oYnV0dG9uPT5idXR0b25cblx0XHRcdFx0LnNldEljb24oJ2V4dGVybmFsLWxpbmsnKVxuXHRcdFx0XHQuc2V0VG9vbHRpcChcIkNyZWF0ZSBhIHRva2VuXCIpXG5cdFx0XHRcdC5vbkNsaWNrKGFzeW5jICgpPT57XG5cdFx0XHRcdFx0d2luZG93Lm9wZW4oXCJodHRwczovL2dpdGh1Yi5jb20vc2V0dGluZ3MvdG9rZW5zL25ld1wiLCAnX2JsYW5rJyk7XG5cdFx0XHRcdH0pKTtcblxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoJ0RldmljZSBuYW1lJylcblx0XHRcdC5zZXREZXNjKCdTaWduIGNvbW1pdCBtZXNzYWdlIHdpdGggdGhpcyBkZXZpY2UgbmFtZS4nKVxuXHRcdFx0LmFkZFRleHQodGV4dCA9PiB0ZXh0XG5cdFx0XHRcdC5zZXRQbGFjZWhvbGRlcignRGV2aWNlIG5hbWUnKVxuXHRcdFx0XHQuc2V0VmFsdWUoY3VycmVudFNldHRpbmcuZGV2aWNlTmFtZSlcblx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdGN1cnJlbnRTZXR0aW5nLmRldmljZU5hbWUgPSB2YWx1ZTtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0fSkpO1xuXG4vLyBleHBvcnQgaW50ZXJmYWNlIFN5bmNTZXR0aW5nIHtcbi8vIFx0cGF0OiBzdHJpbmc7ICtcbi8vIFx0b3duZXI6IHN0cmluZzsgK1xuLy8gXHRhdmF0YXJVcmw6IHN0cmluZztcbi8vIFx0cmVwbzogc3RyaW5nOyArXG4vLyBcdGJyYW5jaDogc3RyaW5nOyArXG4vLyBcdHN5bmNQYXRoOiBzdHJpbmc7ICtcbi8vIFx0ZGV2aWNlTmFtZTogc3RyaW5nOyArXG4vLyBcdGV4Y2x1ZGVzOiBzdHJpbmdbXVxuLy8gfVxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoJ1JlcG9zaXRvcnkgbmFtZScpXG5cdFx0XHQuc2V0RGVzYygnU2VsZWN0IGEgcmVwby4nKVxuXHRcdFx0LmFkZFRleHQodGV4dCA9PiB0ZXh0XG5cdFx0XHRcdC5zZXRQbGFjZWhvbGRlcignUmVwb3NpdG9yeScpXG5cdFx0XHRcdC5zZXRWYWx1ZShjdXJyZW50U2V0dGluZy5yZXBvKVxuXHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0Y3VycmVudFNldHRpbmcucmVwbyA9IHZhbHVlO1xuXHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHR9KSk7XG5cblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKCdCcmFuY2ggbmFtZScpXG5cdFx0XHQuc2V0RGVzYygnU2VsZWN0IGEgYnJhbmNoLicpXG5cdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHRleHRcblx0XHRcdFx0LnNldFBsYWNlaG9sZGVyKCdCcmFuY2gnKVxuXHRcdFx0XHQuc2V0VmFsdWUoY3VycmVudFNldHRpbmcuYnJhbmNoKVxuXHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0Y3VycmVudFNldHRpbmcuYnJhbmNoID0gdmFsdWU7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdH0pKTtcblxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoJ1N5bmMgcGF0aCcpXG5cdFx0XHQuc2V0RGVzYygnU2VsZWN0IGEgbG9jYWwgcGF0aCB0byBzeW5jIHdpdGggdGhlIHJlcG8uIElmIHRoZSBmaWVsZCBpcyBlbXB0eSwgdGhlIGVudGlyZSB2YXVsdCB3aWxsIGJlIHN5bmNlZC4nKVxuXHRcdFx0LmFkZFRleHQoYXN5bmMgKHRleHQpID0+IHtcblx0XHRcdFx0dGV4dC5zZXRQbGFjZWhvbGRlcignRW50ZXIgZm9sZGVyIHBhdGgnKVxuXHRcdFx0XHRcdC5zZXRWYWx1ZShjdXJyZW50U2V0dGluZy5zeW5jUGF0aCB8fCAnJylcblx0XHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0XHRpZiAoIWZvbGRlcnMuY29udGFpbnModmFsdWUpKVxuXHRcdFx0XHRcdFx0XHRyZXR1cm5cblxuXHRcdFx0XHRcdFx0Y3VycmVudFNldHRpbmcuc3luY1BhdGggPSB2YWx1ZTtcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGNvbnN0IGRhdGFMaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGF0YWxpc3QnKTtcblx0XHRcdFx0ZGF0YUxpc3QuaWQgPSBgZm9sZGVyLXN1Z2dlc3Rpb25zYDtcblxuXHRcdFx0XHRjb25zdCBvdGhlclN5bmNQYXRoID0gbmV3IFNldCgpXG5cdFx0XHRcdHRoaXMucGx1Z2luLnN0b3JhZ2UucmVwby5mb3JFYWNoKFxuXHRcdFx0XHRcdChlbCwgaSkgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKGkgPT0gdGhpcy5jdXJyZW50U3luY0luZGV4KVxuXHRcdFx0XHRcdFx0XHRyZXR1cm5cblxuXHRcdFx0XHRcdFx0b3RoZXJTeW5jUGF0aC5hZGQoXG5cdFx0XHRcdFx0XHRcdGVsLnNldHRpbmdzLnN5bmNQYXRoXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpXG5cblx0XHRcdFx0Y29uc3QgYWxsRm9sZGVycyA9IG5ldyBTZXQoXG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4udmF1bHRPcHMuZ2V0Rm9sZGVyc0luVmF1bHQoKVxuXHRcdFx0XHQpXG5cblx0XHRcdFx0Y29uc3QgZm9sZGVycyA9IEFycmF5LmZyb20oXG5cdFx0XHRcdFx0ZGlmZmVyZW5jZShhbGxGb2xkZXJzLCBvdGhlclN5bmNQYXRoKVxuXHRcdFx0XHQpXG5cdFx0XHRcdGZvciAobGV0IGkgaW4gZm9sZGVycykge1xuXHRcdFx0XHRcdGNvbnN0IGZvbGRlciA9IGZvbGRlcnNbaV1cblxuXHRcdFx0XHRcdGNvbnN0IG9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuXHRcdFx0XHRcdG9wdGlvbi52YWx1ZSA9IGZvbGRlcjtcblx0XHRcdFx0XHRkYXRhTGlzdC5hcHBlbmRDaGlsZChvcHRpb24pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGV4dC5pbnB1dEVsLnNldEF0dHJpYnV0ZSgnbGlzdCcsIGBmb2xkZXItc3VnZ2VzdGlvbnNgKTtcblx0XHRcdFx0dGV4dC5pbnB1dEVsLnBhcmVudEVsZW1lbnQ/LmFwcGVuZENoaWxkKGRhdGFMaXN0KTtcblx0XHRcdH0pO1xuXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZShcIlZpZXcgeW91ciB2YXVsdCBvbiBHaXRIdWJcIilcblx0XHRcdC5hZGRFeHRyYUJ1dHRvbihidXR0b24gPT4gYnV0dG9uXG5cdFx0XHRcdC5zZXRUb29sdGlwKFwiT3BlbiBvbiBHaXRIdWJcIilcblx0XHRcdFx0LnNldEljb24oJ2V4dGVybmFsLWxpbmsnKVxuXHRcdFx0XHQub25DbGljaygoKSA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgbGluayA9IHRoaXMuZ2V0TGF0ZXN0TGluaygpO1xuXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coYG9wZW5pbmcgJHtsaW5rfWApO1xuXHRcdFx0XHRcdHdpbmRvdy5vcGVuKGxpbmspO1xuXHRcdFx0XHR9KVxuXHRcdFx0KVxuXHRcdFx0LmRlc2NFbC5hZGRDbGFzcyhcImxpbmstZGVzY1wiKTtcblxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoJ0V4Y2x1ZGVkIGZpbGVzL2ZvbGRlcnMnKVxuXHRcdFx0LnNldERlc2MoJ0ZpbGVzIG9yIGZvbGRlcnMgd2l0aGluIHN5bmMgcGF0aCB0aGF0IHdpbGwgbm90IGJlIHN5bmNlZCcpXG5cdFx0XHQuYWRkQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cblx0XHRcdFx0LnNldEJ1dHRvblRleHQoJ0FkZCBleGNsdXNpb24nKVxuXHRcdFx0XHQuc2V0Q3RhKClcblx0XHRcdFx0Lm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRcdGlmICghY3VycmVudFNldHRpbmcuZXhjbHVkZXMpIHtcblx0XHRcdFx0XHRcdGN1cnJlbnRTZXR0aW5nLmV4Y2x1ZGVzID0gW107XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGN1cnJlbnRTZXR0aW5nLmV4Y2x1ZGVzLnB1c2goJycpO1xuXHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdHRoaXMuZGlzcGxheSgpO1xuXHRcdFx0XHR9KSk7XG5cblx0XHRjb25zdCBhbGxJdGVtcyA9IGF3YWl0IHRoaXMucGx1Z2luLnZhdWx0T3BzLmdldEFsbEluVmF1bHQoKTtcblx0XHRjb25zdCBhbGxQYXRocyA9IFsuLi5hbGxJdGVtcy5mb2xkZXJzLCAuLi5hbGxJdGVtcy5maWxlc107XG5cblx0XHRpZiAoY3VycmVudFNldHRpbmcuZXhjbHVkZXM/Lmxlbmd0aCA+IDApIHtcblx0XHRcdGN1cnJlbnRTZXR0aW5nLmV4Y2x1ZGVzLmZvckVhY2goKGV4Y2x1ZGUsIGluZGV4KSA9PiB7XG5cdFx0XHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0XHRcdC5zZXROYW1lKGBFeGNsdXNpb24gJHtpbmRleCArIDF9YClcblx0XHRcdFx0XHQvLyAuc2V0RGVzYygnUGF0aCByZWxhdGl2ZSB0byBzeW5jIHBhdGgnKVxuXHRcdFx0XHRcdC5hZGRUZXh0KHRleHQgPT4ge1xuXHRcdFx0XHRcdFx0dGV4dC5zZXRQbGFjZWhvbGRlcigncGF0aC90by9leGNsdWRlJylcblx0XHRcdFx0XHRcdFx0LnNldFZhbHVlKGV4Y2x1ZGUpXG5cdFx0XHRcdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIWZvbGRlcnMuY29udGFpbnModmFsdWUpICYmICFmaWxlcy5jb250YWlucyh2YWx1ZSkpXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5cblxuXHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRTZXR0aW5nLmV4Y2x1ZGVzW2luZGV4XSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHRcdC8vIFRPRE8gXHUwNDM4IFx1MDQzOFx1MDQ0MVx1MDQzQVx1MDQzQlx1MDQ0RVx1MDQ0N1x1MDQzNVx1MDQzRFx1MDQzOFx1MDQ0RiBcdTA0M0RcdTA0MzUgXHUwNDM0XHUwNDNFXHUwNDNCXHUwNDM2XHUwNDNEXHUwNDRCIFx1MDQzRlx1MDQzRVx1MDQzMlx1MDQ0Mlx1MDQzRVx1MDQ0MFx1MDQ0Rlx1MDQ0Mlx1MDQ0Q1x1MDQ0MVx1MDQ0RiwgXHUwNDNEXHUwNDNFIFx1MDQ0RFx1MDQ0Mlx1MDQzRSBcdTA0M0ZcdTA0M0VcdTA0NDRcdTA0MzhcdTA0MzNcblx0XHRcdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdC8vIFx1MDQxNFx1MDQzRVx1MDQzMVx1MDQzMFx1MDQzMlx1MDQzQlx1MDQ0Rlx1MDQzNVx1MDQzQyBkYXRhbGlzdCBcdTA0MzRcdTA0M0JcdTA0NEYgXHUwNDMwXHUwNDMyXHUwNDQyXHUwNDNFXHUwNDM0XHUwNDNFXHUwNDNGXHUwNDNFXHUwNDNCXHUwNDNEXHUwNDM1XHUwNDNEXHUwNDM4XHUwNDRGXG5cdFx0XHRcdFx0XHRjb25zdCBkYXRhTGlzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RhdGFsaXN0Jyk7XG5cdFx0XHRcdFx0XHRkYXRhTGlzdC5pZCA9IGBleGNsdWRlLXN1Z2dlc3Rpb25zLSR7aW5kZXh9YDtcblxuXHRcdFx0XHRcdFx0Ly8gXHUwNDI0XHUwNDM4XHUwNDNCXHUwNDRDXHUwNDQyXHUwNDQwXHUwNDQzXHUwNDM1XHUwNDNDIFx1MDQzRlx1MDQ0M1x1MDQ0Mlx1MDQzODogXHUwNDQyXHUwNDNFXHUwNDNCXHUwNDRDXHUwNDNBXHUwNDNFIFx1MDQ0Mlx1MDQzNSwgXHUwNDNBXHUwNDNFXHUwNDQyXHUwNDNFXHUwNDQwXHUwNDRCXHUwNDM1IFx1MDQzRFx1MDQzMFx1MDQ0NVx1MDQzRVx1MDQzNFx1MDQ0Rlx1MDQ0Mlx1MDQ0MVx1MDQ0RiBcdTA0MzJcdTA0M0RcdTA0NDNcdTA0NDJcdTA0NDBcdTA0Mzggc3luY1BhdGggKFx1MDQzNVx1MDQ0MVx1MDQzQlx1MDQzOCBcdTA0M0VcdTA0M0QgXHUwNDM3XHUwNDMwXHUwNDM0XHUwNDMwXHUwNDNEKVxuXHRcdFx0XHRcdFx0bGV0IGZpbHRlcmVkUGF0aHMgPSBhbGxQYXRocztcblx0XHRcdFx0XHRcdGlmIChjdXJyZW50U2V0dGluZy5zeW5jUGF0aCkge1xuXHRcdFx0XHRcdFx0XHRmaWx0ZXJlZFBhdGhzID0gYWxsUGF0aHMuZmlsdGVyKHBhdGggPT5cblx0XHRcdFx0XHRcdFx0XHRwYXRoLnN0YXJ0c1dpdGgoY3VycmVudFNldHRpbmcuc3luY1BhdGggKyAnLycpIHx8XG5cdFx0XHRcdFx0XHRcdFx0cGF0aCA9PT0gY3VycmVudFNldHRpbmcuc3luY1BhdGhcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0ZmlsdGVyZWRQYXRocy5mb3JFYWNoKHBhdGggPT4ge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcblx0XHRcdFx0XHRcdFx0b3B0aW9uLnZhbHVlID0gcGF0aDtcblx0XHRcdFx0XHRcdFx0ZGF0YUxpc3QuYXBwZW5kQ2hpbGQob3B0aW9uKTtcblx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHR0ZXh0LmlucHV0RWwuc2V0QXR0cmlidXRlKCdsaXN0JywgYGV4Y2x1ZGUtc3VnZ2VzdGlvbnMtJHtpbmRleH1gKTtcblx0XHRcdFx0XHRcdHRleHQuaW5wdXRFbC5wYXJlbnRFbGVtZW50Py5hcHBlbmRDaGlsZChkYXRhTGlzdCk7XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHQuYWRkQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cblx0XHRcdFx0XHRcdC5zZXRJY29uKCd0cmFzaCcpXG5cdFx0XHRcdFx0XHQuc2V0VG9vbHRpcCgnUmVtb3ZlIHRoaXMgZXhjbHVzaW9uJylcblx0XHRcdFx0XHRcdC5vbkNsaWNrKGFzeW5jICgpID0+IHtcblx0XHRcdFx0XHRcdFx0Y3VycmVudFNldHRpbmcuZXhjbHVkZXMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdFx0XHRcdHRoaXMuZGlzcGxheSgpOyAvLyBcdTA0MUZcdTA0MzVcdTA0NDBcdTA0MzVcdTA0NDBcdTA0MzhcdTA0NDFcdTA0M0VcdTA0MzJcdTA0NEJcdTA0MzJcdTA0MzBcdTA0MzVcdTA0M0MgXHUwNDNGXHUwNDNFXHUwNDQxXHUwNDNCXHUwNDM1IFx1MDQ0M1x1MDQzNFx1MDQzMFx1MDQzQlx1MDQzNVx1MDQzRFx1MDQzOFx1MDQ0RlxuXHRcdFx0XHRcdFx0fSkpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdH1cblxuXHRhc3luYyBnZXRJdGVtc0luU3luY1BhdGgoKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuXHRcdGNvbnN0IGN1cnJlbnRTZXR0aW5nID0gdGhpcy5nZXRDdXJyZW50U3luY1NldHRpbmcoKTtcblx0XHRpZiAoIWN1cnJlbnRTZXR0aW5nLnN5bmNQYXRoKSByZXR1cm4gW107XG5cblx0XHR0cnkge1xuXHRcdFx0Y29uc3Qgc3luY1BhdGggPSBjdXJyZW50U2V0dGluZy5zeW5jUGF0aDtcblx0XHRcdGNvbnN0IGFsbEl0ZW1zOiBzdHJpbmdbXSA9IFtdO1xuXG5cdFx0XHRjb25zdCBhbGwgPSBhd2FpdCB0aGlzLnBsdWdpbi52YXVsdE9wcy5nZXRBbGxJblZhdWx0KClcblx0XHRcdGZvciAoY29uc3QgZmlsZSBpbiBhbGwpIHtcblx0XHRcdFx0aWYgKHN5bmNQYXRoID09IFwiXCJcblx0XHRcdFx0XHR8fCBmaWxlLnN0YXJ0c1dpdGgoc3luY1BhdGggKyAnLycpXG5cdFx0XHRcdFx0fHwgZmlsZSA9PT0gc3luY1BhdGgpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRhbGxJdGVtcy5wdXNoKGZpbGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBhbGxJdGVtcy5zb3J0KCk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoXCJFcnJvciBnZXR0aW5nIGl0ZW1zIGluIHN5bmMgcGF0aDpcIiwgZXJyb3IpO1xuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH1cblx0fVxuXG5cdGxvY2FsQ29uZmlnQmxvY2sgPSAoKSA9PiB7XG5cdFx0Y29uc3Qge2NvbnRhaW5lckVsfSA9IHRoaXM7XG5cdFx0Ly8gY29uc3QgY3VycmVudFNldHRpbmcgPSB0aGlzLmdldEN1cnJlbnRTeW5jU2V0dGluZygpO1xuXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpLnNldEhlYWRpbmcoKS5zZXROYW1lKFwiTG9jYWwgY29uZmlndXJhdGlvbnNcIik7XG5cblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKFwiQXV0byBzeW5jXCIpXG5cdFx0XHQuc2V0RGVzYyhgQXV0b21hdGljYWxseSBzeW5jIHlvdXIgdmF1bHQgd2hlbiByZW1vdGUgaGFzIHVwZGF0ZXMuIChNdXRlZDogc3luYyBpbiB0aGUgYmFja2dyb3VuZCB3aXRob3V0IGRpc3BsYXlpbmcgbm90aWNlcywgZXhjZXB0IGZvciBmaWxlIGNoYW5nZXMgYW5kIGNvbmZsaWN0cyBub3RpY2UpYClcblx0XHRcdC5hZGREcm9wZG93bihkcm9wZG93biA9PiB7XG5cdFx0XHRcdGRyb3Bkb3duXG5cdFx0XHRcdC5hZGRPcHRpb24oJ29mZicsICdPZmYnKVxuXHRcdFx0XHQuYWRkT3B0aW9uKCdtdXRlZCcsICdNdXRlZCcpXG5cdFx0XHRcdC5hZGRPcHRpb24oJ3JlbWluZCcsICdSZW1pbmQgb25seScpXG5cdFx0XHRcdC5hZGRPcHRpb24oJ29uJywgJ09uJylcblx0XHRcdFx0LnNldFZhbHVlKHRoaXMucGx1Z2luLnN0b3JhZ2UuYXV0b1N5bmMgPyB0aGlzLnBsdWdpbi5zdG9yYWdlLmF1dG9TeW5jIDogJ29mZicpXG5cdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zdG9yYWdlLmF1dG9TeW5jID0gdmFsdWUgYXMgXCJvZmZcIiB8IFwibXV0ZWRcIiB8IFwicmVtaW5kXCIgfCBcIm9uXCI7XG5cdFx0XHRcdFx0Y2hlY2tJbnRlcnZhbFNsaWRlci5zZXR0aW5nRWwuYWRkQ2xhc3ModmFsdWUgPT09IFwib2ZmXCIgPyBcImNsZWFyXCIgOiBcInJlc3RvcmVcIik7XG5cdFx0XHRcdFx0Y2hlY2tJbnRlcnZhbFNsaWRlci5zZXR0aW5nRWwucmVtb3ZlQ2xhc3ModmFsdWUgPT09IFwib2ZmXCIgPyBcInJlc3RvcmVcIiA6IFwiY2xlYXJcIik7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdH0pXG5cdFx0XHR9KVxuXG5cdFx0Y29uc3QgY2hlY2tJbnRlcnZhbFNsaWRlciA9IG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoJ0F1dG8gY2hlY2sgaW50ZXJ2YWwnKVxuXHRcdFx0LnNldERlc2MoYEF1dG9tYXRpY2FsbHkgY2hlY2sgZm9yIHJlbW90ZSBjaGFuZ2VzIGluIHRoZSBiYWNrZ3JvdW5kIGV2ZXJ5ICR7dGhpcy5wbHVnaW4uc3RvcmFnZS5jaGVja0V2ZXJ5WE1pbnV0ZXN9IG1pbnV0ZXMuYClcblx0XHRcdC5hZGRTbGlkZXIoc2xpZGVyID0+IHNsaWRlclxuXHRcdFx0XHQuc2V0TGltaXRzKDEsIDYwLCAxKVxuXHRcdFx0XHQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc3RvcmFnZS5jaGVja0V2ZXJ5WE1pbnV0ZXMpXG5cdFx0XHRcdC5zZXREeW5hbWljVG9vbHRpcCgpXG5cdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zdG9yYWdlLmNoZWNrRXZlcnlYTWludXRlcyA9IHZhbHVlO1xuXHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdGNoZWNrSW50ZXJ2YWxTbGlkZXIuc2V0RGVzYyhgQXV0b21hdGljYWxseSBjaGVjayBmb3IgcmVtb3RlIGNoYW5nZXMgaW4gdGhlIGJhY2tncm91bmQgZXZlcnkgJHt2YWx1ZX0gbWludXRlcy5gKVxuXHRcdFx0XHR9KVxuXHRcdFx0KVxuXG5cdFx0aWYgKHRoaXMucGx1Z2luLnN0b3JhZ2UuYXV0b1N5bmMgPT09IFwib2ZmXCIpIHtcblx0XHRcdGNoZWNrSW50ZXJ2YWxTbGlkZXIuc2V0dGluZ0VsLmFkZENsYXNzKFwiY2xlYXJcIilcblx0XHR9XG5cdH1cblxuXHRub3RpY2VDb25maWdCbG9jayA9ICgpID0+IHtcblx0XHRjb25zdCB7Y29udGFpbmVyRWx9ID0gdGhpcztcblx0XHRjb25zdCBzZWxlY3RlZENvbCA9IFwidmFyKC0taW50ZXJhY3RpdmUtYWNjZW50KVwiO1xuXHRcdGNvbnN0IHNlbGVjdGVkVHh0Q29sID0gXCJ2YXIoLS10ZXh0LW9uLWFjY2VudClcIjtcblx0XHRjb25zdCB1bnNlbGVjdGVkQ29sb3IgPSBcInZhcigtLWludGVyYWN0aXZlLW5vcm1hbClcIjtcblx0XHRjb25zdCB1bnNlbGVjdGVkVHh0Q29sID0gXCJ2YXIoLS10ZXh0LW5vcm1hbClcIjtcblx0XHRjb25zdCBzdGF0ZVRleHRNYXAgPSAobm90aWZ5Q29uZmxpY3RzOiBib29sZWFuLCBub3RpZnlDaGFuZ2VzOiBib29sZWFuKSA9PiB7XG5cdFx0XHRpZiAobm90aWZ5Q29uZmxpY3RzICYmIG5vdGlmeUNoYW5nZXMpIHtcblx0XHRcdFx0cmV0dXJuIFwiRGlzcGxheWluZyBmaWxlIGNoYW5nZXMgYW5kIGNvbmZsaWN0cyBcIjtcblx0XHRcdH0gZWxzZSBpZiAoIW5vdGlmeUNvbmZsaWN0cyAmJiBub3RpZnlDaGFuZ2VzKSB7XG5cdFx0XHRcdHJldHVybiBcIkRpc3BsYXlpbmcgZmlsZSBjaGFuZ2VzIFwiO1xuXHRcdFx0fSBlbHNlIGlmIChub3RpZnlDb25mbGljdHMgJiYgIW5vdGlmeUNoYW5nZXMpIHtcblx0XHRcdFx0cmV0dXJuIFwiRGlzcGxheWluZyBjaGFuZ2UgY29uZmxpY3RzIFwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIFwiTm8gbm90aWNlIGRpc3BsYXllZCBcIjtcblx0XHRcdH1cblx0XHR9O1xuXHRcdGNvbnN0IG5vdGljZURpc3BsYXkgPSBuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKFwiTm90aWNlIGRpc3BsYXlcIilcblx0XHRcdC5zZXREZXNjKGAke3N0YXRlVGV4dE1hcCh0aGlzLnBsdWdpbi5zdG9yYWdlLm5vdGlmeUNvbmZsaWN0cywgdGhpcy5wbHVnaW4uc3RvcmFnZS5ub3RpZnlDaGFuZ2VzKX0gYWZ0ZXIgc3luYy5gKVxuXHRcdFx0LmFkZEJ1dHRvbihidXR0b24gPT4ge1xuXHRcdFx0XHRidXR0b24uc2V0QnV0dG9uVGV4dChcIkNoYW5nZSBjb25mbGljdHNcIik7XG5cdFx0XHRcdGJ1dHRvbi5vbkNsaWNrKGFzeW5jICgpID0+IHtcblx0XHRcdFx0XHRjb25zdCBub3RpZnlDb25mbGljdHMgPSAhdGhpcy5wbHVnaW4uc3RvcmFnZS5ub3RpZnlDb25mbGljdHM7XG5cdFx0XHRcdFx0dGhpcy5wbHVnaW4uc3RvcmFnZS5ub3RpZnlDb25mbGljdHMgPSBub3RpZnlDb25mbGljdHM7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdFx0YnV0dG9uLmJ1dHRvbkVsLnNldENzc1N0eWxlcyh7XG5cdFx0XHRcdFx0XHRcImJhY2tncm91bmRcIjogbm90aWZ5Q29uZmxpY3RzID8gc2VsZWN0ZWRDb2wgOiB1bnNlbGVjdGVkQ29sb3IsXG5cdFx0XHRcdFx0XHRcImNvbG9yXCI6IG5vdGlmeUNvbmZsaWN0cyA/IHNlbGVjdGVkVHh0Q29sIDogdW5zZWxlY3RlZFR4dENvbCxcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRub3RpY2VEaXNwbGF5LnNldERlc2MoYCR7c3RhdGVUZXh0TWFwKG5vdGlmeUNvbmZsaWN0cywgdGhpcy5wbHVnaW4uc3RvcmFnZS5ub3RpZnlDaGFuZ2VzKX0gYWZ0ZXIgc3luYy5gKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGJ1dHRvbi5idXR0b25FbC5zZXRDc3NTdHlsZXMoe1xuXHRcdFx0XHRcdFwiYmFja2dyb3VuZFwiOiB0aGlzLnBsdWdpbi5zdG9yYWdlLm5vdGlmeUNvbmZsaWN0cyA/IHNlbGVjdGVkQ29sIDogdW5zZWxlY3RlZENvbG9yLFxuXHRcdFx0XHRcdFwiY29sb3JcIjogdGhpcy5wbHVnaW4uc3RvcmFnZS5ub3RpZnlDb25mbGljdHMgPyBzZWxlY3RlZFR4dENvbCA6IHVuc2VsZWN0ZWRUeHRDb2wsXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSlcblx0XHRcdC5hZGRCdXR0b24oYnV0dG9uID0+IHtcblx0XHRcdFx0YnV0dG9uLnNldEJ1dHRvblRleHQoXCJGaWxlIGNoYW5nZXNcIik7XG5cdFx0XHRcdGJ1dHRvbi5vbkNsaWNrKGFzeW5jICgpID0+IHtcblx0XHRcdFx0XHRjb25zdCBub3RpZnlDaGFuZ2VzID0gIXRoaXMucGx1Z2luLnN0b3JhZ2Uubm90aWZ5Q2hhbmdlcztcblx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zdG9yYWdlLm5vdGlmeUNoYW5nZXMgPSBub3RpZnlDaGFuZ2VzO1xuXHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdGJ1dHRvbi5idXR0b25FbC5zZXRDc3NTdHlsZXMoe1xuXHRcdFx0XHRcdFx0XCJiYWNrZ3JvdW5kXCI6IG5vdGlmeUNoYW5nZXMgPyBzZWxlY3RlZENvbCA6IHVuc2VsZWN0ZWRDb2xvcixcblx0XHRcdFx0XHRcdFwiY29sb3JcIjogbm90aWZ5Q2hhbmdlcyA/IHNlbGVjdGVkVHh0Q29sIDogdW5zZWxlY3RlZFR4dENvbCxcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRub3RpY2VEaXNwbGF5LnNldERlc2MoYCR7c3RhdGVUZXh0TWFwKHRoaXMucGx1Z2luLnN0b3JhZ2Uubm90aWZ5Q29uZmxpY3RzLCBub3RpZnlDaGFuZ2VzKX0gYWZ0ZXIgc3luYy5gKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGJ1dHRvbi5idXR0b25FbC5zZXRDc3NTdHlsZXMoe1xuXHRcdFx0XHRcdFwiYmFja2dyb3VuZFwiOiB0aGlzLnBsdWdpbi5zdG9yYWdlLm5vdGlmeUNoYW5nZXMgPyBzZWxlY3RlZENvbCA6IHVuc2VsZWN0ZWRDb2xvcixcblx0XHRcdFx0XHRcImNvbG9yXCI6IHRoaXMucGx1Z2luLnN0b3JhZ2Uubm90aWZ5Q2hhbmdlcyA/IHNlbGVjdGVkVHh0Q29sIDogdW5zZWxlY3RlZFR4dENvbCxcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0fVxuXG5cdGNvdW50ZXJSZXBvQmxvY2sgPSAoKSA9PiB7XG5cdFx0Y29uc3Qge2NvbnRhaW5lckVsfSA9IHRoaXM7XG5cblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKCdNYW5hZ2UgcmVwb3NpdG9yaWVzJylcblx0XHRcdC5zZXREZXNjKCdBZGQgb3IgcmVtb3ZlIHJlcG9zaXRvcnkgY29uZmlndXJhdGlvbnMnKVxuXHRcdFx0LmFkZEJ1dHRvbihidXR0b24gPT4gYnV0dG9uXG5cdFx0XHRcdC5zZXRCdXR0b25UZXh0KCdBZGQgUmVwb3NpdG9yeScpXG5cdFx0XHRcdC5zZXRDdGEoKVxuXHRcdFx0XHQub25DbGljayhhc3luYyAoKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy5wbHVnaW4uc3RvcmFnZS5yZXBvLnB1c2goREVGQVVMVF9SRVBPU0lUT1JZKTtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHR0aGlzLmRpc3BsYXkoKTtcblx0XHRcdFx0fSkpXG5cdFx0XHQuYWRkQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cblx0XHRcdFx0LnNldEJ1dHRvblRleHQoJ1JlbW92ZSBSZXBvc2l0b3J5Jylcblx0XHRcdFx0LnNldFdhcm5pbmcoKVxuXHRcdFx0XHQuc2V0RGlzYWJsZWQodGhpcy5wbHVnaW4uc3RvcmFnZS5yZXBvLmxlbmd0aCA8PSAxKVxuXHRcdFx0XHQub25DbGljayhhc3luYyAoKSA9PiB7XG5cdFx0XHRcdFx0aWYgKHRoaXMucGx1Z2luLnN0b3JhZ2UucmVwby5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zdG9yYWdlLnJlcG8uc3BsaWNlKHRoaXMuY3VycmVudFN5bmNJbmRleCwgMSk7XG5cdFx0XHRcdFx0XHRpZiAodGhpcy5jdXJyZW50U3luY0luZGV4ID49IHRoaXMucGx1Z2luLnN0b3JhZ2UucmVwby5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5jdXJyZW50U3luY0luZGV4ID0gdGhpcy5wbHVnaW4uc3RvcmFnZS5yZXBvLmxlbmd0aCAtIDE7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHRcdHRoaXMuZGlzcGxheSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkpO1xuXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZSgnQ3VycmVudCByZXBvc2l0b3J5Jylcblx0XHRcdC5zZXREZXNjKCdTZWxlY3Qgd2hpY2ggcmVwb3NpdG9yeSBjb25maWd1cmF0aW9uIHRvIGVkaXQnKVxuXHRcdFx0LmFkZERyb3Bkb3duKGRyb3Bkb3duID0+IHtcblx0XHRcdFx0dGhpcy5wbHVnaW4uc3RvcmFnZS5yZXBvLmZvckVhY2goKF8sIGluZGV4KSA9PiB7XG5cdFx0XHRcdFx0ZHJvcGRvd24uYWRkT3B0aW9uKGluZGV4LnRvU3RyaW5nKCksIGBSZXBvc2l0b3J5ICR7aW5kZXggKyAxfWApO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0ZHJvcGRvd24uc2V0VmFsdWUodGhpcy5jdXJyZW50U3luY0luZGV4LnRvU3RyaW5nKCkpO1xuXHRcdFx0XHRkcm9wZG93bi5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHR0aGlzLmN1cnJlbnRTeW5jSW5kZXggPSBwYXJzZUludCh2YWx1ZSk7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdFx0dGhpcy5kaXNwbGF5KCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdH1cblxuXHRyZXNldEJsb2NrID0gKCkgPT4ge1xuXHRcdGNvbnN0IHtjb250YWluZXJFbH0gPSB0aGlzO1xuXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZSgnUmVzZXQgc2V0dGluZ3MnKVxuXHRcdFx0LnNldERlc2MoJ1JlbW92ZSBTeW5jIHN0b3JhZ2Ugb3IgU2V0dGluZ3MnKVxuXHRcdFx0LmFkZEJ1dHRvbihidXR0b24gPT4gYnV0dG9uXG5cdFx0XHRcdC5zZXRCdXR0b25UZXh0KCdSZXNldCBzdG9yYWdlJylcblx0XHRcdFx0LnNldFdhcm5pbmcoKVxuXHRcdFx0XHQub25DbGljayhhc3luYyAoKSA9PiB7XG5cdFx0XHRcdFx0Zm9yIChsZXQgc3RvcmFnZSBvZiB0aGlzLnBsdWdpbi5zdG9yYWdlLnJlcG8pIHtcblx0XHRcdFx0XHRcdHN0b3JhZ2UubG9jYWxTdG9yZSA9IERFRkFVTFRfTE9DQUxfU1RPUkVcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gVE9ETyBhZGQgbm90aWNlKFwiRG9uZVwiKVxuXHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdHRoaXMuZGlzcGxheSgpO1xuXHRcdFx0XHR9KSlcblx0XHRcdC5hZGRCdXR0b24oYnV0dG9uID0+IGJ1dHRvblxuXHRcdFx0XHQuc2V0QnV0dG9uVGV4dCgnUmVzZXQgU2V0dGluZ3MnKVxuXHRcdFx0XHQuc2V0V2FybmluZygpXG5cdFx0XHRcdC5vbkNsaWNrKGFzeW5jICgpID0+IHtcblx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zdG9yYWdlLnJlcG8gPSBbREVGQVVMVF9SRVBPU0lUT1JZXTtcblx0XHRcdFx0XHQvLyBUT0RPIGFkZCBub3RpY2UoXCJEb25lXCIpXG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdFx0dGhpcy5kaXNwbGF5KCk7XG5cdFx0XHRcdH0pKVxuXG5cdH1cblxuXHRpbXBvcnRFeHBvcnQoKSB7XG5cdFx0Y29uc3Qge2NvbnRhaW5lckVsfSA9IHRoaXM7XG5cblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKCdJbXBvcnQvRXhwb3J0IHNldHRpbmdzJylcblx0XHRcdC5zZXREZXNjKCdCYWNrdXAgb3IgcmVzdG9yZSB5b3VyIHBsdWdpbiBjb25maWd1cmF0aW9uJylcblx0XHRcdC5zZXRIZWFkaW5nKCk7XG5cblx0XHQvLyBcdTA0MjJcdTA0MzVcdTA0M0FcdTA0NDFcdTA0NDJcdTA0M0VcdTA0MzJcdTA0M0VcdTA0MzUgXHUwNDNGXHUwNDNFXHUwNDNCXHUwNDM1IFx1MDQzNFx1MDQzQlx1MDQ0RiBcdTA0M0VcdTA0NDJcdTA0M0VcdTA0MzFcdTA0NDBcdTA0MzBcdTA0MzZcdTA0MzVcdTA0M0RcdTA0MzhcdTA0NEYvXHUwNDMyXHUwNDMyXHUwNDNFXHUwNDM0XHUwNDMwIFx1MDQzQVx1MDQzRVx1MDQzRFx1MDQ0NFx1MDQzOFx1MDQzM1x1MDQ0M1x1MDQ0MFx1MDQzMFx1MDQ0Nlx1MDQzOFx1MDQzOFxuXHRcdGNvbnN0IHRleHRBcmVhQ29udGFpbmVyID0gY29udGFpbmVyRWwuY3JlYXRlRGl2KCdpbXBvcnQtZXhwb3J0LWNvbnRhaW5lcicpO1xuXHRcdGNvbnN0IHRleHRBcmVhID0gdGV4dEFyZWFDb250YWluZXIuY3JlYXRlRWwoJ3RleHRhcmVhJywge1xuXHRcdFx0YXR0cjoge1xuXHRcdFx0XHRwbGFjZWhvbGRlcjogJ0NvbmZpZ3VyYXRpb24gSlNPTiB3aWxsIGFwcGVhciBoZXJlLi4uJyxcblx0XHRcdFx0cm93czogJzEwJyxcblx0XHRcdFx0c3R5bGU6ICd3aWR0aDogMTAwJTsgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTsnXG5cdFx0XHR9LFxuXHRcdFx0Y2xzOiAnaW1wb3J0LWV4cG9ydC10ZXh0YXJlYSdcblx0XHR9KTtcblxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LmFkZEJ1dHRvbihidXR0b24gPT4gYnV0dG9uXG5cdFx0XHRcdC5zZXRCdXR0b25UZXh0KCdFeHBvcnQgdG8gVGV4dCBGaWVsZCcpXG5cdFx0XHRcdC5zZXRDdGEoKVxuXHRcdFx0XHQub25DbGljayhhc3luYyAoKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy5leHBvcnRUb1RleHRGaWVsZCh0ZXh0QXJlYSk7XG5cdFx0XHRcdH0pKVxuXHRcdFx0LmFkZEJ1dHRvbihidXR0b24gPT4gYnV0dG9uXG5cdFx0XHRcdC5zZXRCdXR0b25UZXh0KCdJbXBvcnQgZnJvbSBUZXh0IEZpZWxkJylcblx0XHRcdFx0LnNldFdhcm5pbmcoKVxuXHRcdFx0XHQub25DbGljayhhc3luYyAoKSA9PiB7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5pbXBvcnRGcm9tVGV4dEZpZWxkKHRleHRBcmVhKTtcblx0XHRcdFx0fSkpXG5cdFx0XHQuYWRkQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cblx0XHRcdFx0LnNldEJ1dHRvblRleHQoJ0NsZWFyIEZpZWxkJylcblx0XHRcdFx0LnNldEljb24oJ3RyYXNoJylcblx0XHRcdFx0Lm9uQ2xpY2soKCkgPT4ge1xuXHRcdFx0XHRcdHRleHRBcmVhLnZhbHVlID0gJyc7XG5cdFx0XHRcdH0pKTtcblx0fVxuXG5cdHByaXZhdGUgZXhwb3J0VG9UZXh0RmllbGQodGV4dEFyZWE6IEhUTUxUZXh0QXJlYUVsZW1lbnQpIHtcblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgcmVzdWx0OiBhbnkgPSBzdHJ1Y3R1cmVkQ2xvbmUodGhpcy5wbHVnaW4uc3RvcmFnZSlcblx0XHRcdGZvcihsZXQgaSBpbiByZXN1bHQucmVwbykge1xuXHRcdFx0XHRkZWxldGUgcmVzdWx0LnJlcG9baV0ubG9jYWxTdG9yZVxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzZXR0aW5nc0pzb24gPSBKU09OLnN0cmluZ2lmeShyZXN1bHQsIG51bGwsIDQpO1xuXG5cdFx0XHR0ZXh0QXJlYS52YWx1ZSA9IHNldHRpbmdzSnNvbjtcblx0XHRcdHRleHRBcmVhLmZvY3VzKCk7XG5cdFx0XHR0ZXh0QXJlYS5zZWxlY3QoKTtcblxuXHRcdH1cblx0XHRjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGV4cG9ydGluZyBzZXR0aW5nczonLCBlcnJvcik7XG5cdFx0XHRuZXcgTm90aWNlKCdFcnJvciBleHBvcnRpbmcgY29uZmlndXJhdGlvbicsIDMwMDApO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgaW1wb3J0RnJvbVRleHRGaWVsZCh0ZXh0QXJlYTogSFRNTFRleHRBcmVhRWxlbWVudCkge1xuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCBqc29uQ29udGVudCA9IHRleHRBcmVhLnZhbHVlLnRyaW0oKTtcblxuXHRcdFx0aWYgKCFqc29uQ29udGVudCkge1xuXHRcdFx0XHRuZXcgTm90aWNlKCdUZXh0IGZpZWxkIGlzIGVtcHR5JywgMzAwMCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgaW1wb3J0ZWRTZXR0aW5ncyA9IEpTT04ucGFyc2UoanNvbkNvbnRlbnQpO1xuXG5cdFx0XHQvLyBcdTA0MTJcdTA0MzBcdTA0M0JcdTA0MzhcdTA0MzRcdTA0MzBcdTA0NDZcdTA0MzhcdTA0NEYgXHUwNDM4XHUwNDNDXHUwNDNGXHUwNDNFXHUwNDQwXHUwNDQyXHUwNDM4XHUwNDQwXHUwNDNFXHUwNDMyXHUwNDMwXHUwNDNEXHUwNDNEXHUwNDRCXHUwNDQ1IFx1MDQzRFx1MDQzMFx1MDQ0MVx1MDQ0Mlx1MDQ0MFx1MDQzRVx1MDQzNVx1MDQzQVxuXHRcdFx0aWYgKHRoaXMudmFsaWRhdGVJbXBvcnRlZFNldHRpbmdzKGltcG9ydGVkU2V0dGluZ3MpKSB7XG5cdFx0XHRcdGZvciAobGV0IHJlcG8gb2YgaW1wb3J0ZWRTZXR0aW5ncy5yZXBvKSB7XG5cdFx0XHRcdFx0cmVwby5sb2NhbFN0b3JlID0gREVGQVVMVF9MT0NBTF9TVE9SRVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5wbHVnaW4uc3RvcmFnZSA9IGltcG9ydGVkU2V0dGluZ3Ncblx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cblx0XHRcdFx0bmV3IE5vdGljZSgnU2V0dGluZ3MgaW1wb3J0ZWQgc3VjY2Vzc2Z1bGx5IScsIDMwMDApO1xuXG5cdFx0XHRcdGF3YWl0IHRoaXMuZGlzcGxheSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bmV3IE5vdGljZSgnSW52YWxpZCBzZXR0aW5ncyBmb3JtYXQgaW4gdGV4dCBmaWVsZCcsIDQwMDApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGltcG9ydGluZyBzZXR0aW5ncyBmcm9tIHRleHQgZmllbGQ6JywgZXJyb3IpO1xuXHRcdFx0bmV3IE5vdGljZSgnRXJyb3IgcGFyc2luZyBKU09OIGNvbmZpZ3VyYXRpb24nLCA0MDAwKTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIHZhbGlkYXRlSW1wb3J0ZWRTZXR0aW5ncyhzZXR0aW5nczogYW55KTogYm9vbGVhbiB7XG5cdFx0Ly8gQmFzaWMgdmFsaWRhdGlvblxuXHRcdHJldHVybiBzZXR0aW5ncyAmJlxuXHRcdFx0dHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0JyAmJlxuXHRcdFx0QXJyYXkuaXNBcnJheShzZXR0aW5ncy5yZXBvKSAmJlxuXHRcdFx0c2V0dGluZ3MucmVwby5sZW5ndGggPiAwICYmXG5cdFx0XHRzZXR0aW5ncy5yZXBvWzBdLnNldHRpbmdzICYmXG5cdFx0XHR0eXBlb2Ygc2V0dGluZ3MucmVwb1swXS5zZXR0aW5ncyA9PT0gJ29iamVjdCcgJiZcblx0XHRcdCdzeW5jUGF0aCcgaW4gc2V0dGluZ3MucmVwb1swXS5zZXR0aW5ncztcblx0fVxuXG5cdGFzeW5jIGRpc3BsYXkoKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0Y29uc3Qge2NvbnRhaW5lckVsfSA9IHRoaXM7XG5cblx0XHRjb250YWluZXJFbC5lbXB0eSgpO1xuXG5cblx0XHR0aGlzLmxvY2FsQ29uZmlnQmxvY2soKTtcblx0XHR0aGlzLm5vdGljZUNvbmZpZ0Jsb2NrKCk7XG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ2hyJyk7XG5cblx0XHR0aGlzLmNvdW50ZXJSZXBvQmxvY2soKTtcblx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgnaHInKTtcblxuXHRcdC8vIFRPRE8gXHUwNDNEXHUwNDMwXHUwNDNGXHUwNDM4XHUwNDQxXHUwNDMwXHUwNDQyXHUwNDRDLCBcdTA0NDdcdTA0NDJcdTA0M0UgXHUwNDQyXHUwNDQzXHUwNDQyIFx1MDQzNFx1MDQzQlx1MDQ0RiBhbGxTZXR0aW5ncywgXHUwNDMwIFx1MDQzRFx1MDQzNSBcdTA0M0VcdTA0NDJcdTA0MzRcdTA0MzVcdTA0M0JcdTA0NENcdTA0M0RcdTA0NEJcdTA0MzkgXHUwNDQwXHUwNDM1XHUwNDNGXHUwNDNFXHUwNDM3XHUwNDM4XHUwNDQyXHUwNDNFXHUwNDQwXHUwNDM4XHUwNDM5XG5cdFx0Ly8gVE9ETyBhZGQgcHJ1bmUgc2V0dGluZ3MgZXhhY3RseSBmb3Igb25lIHJlcG9cblx0XHR0aGlzLnJlc2V0QmxvY2soKVxuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdocicpO1xuXG5cdFx0YXdhaXQgdGhpcy5naXRodWJVc2VySW5mb0Jsb2NrKCk7XG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ2hyJyk7XG5cblx0XHR0aGlzLmltcG9ydEV4cG9ydCgpXG5cblx0fVxufVxuXG4vLyBjbGFzcyBGb2xkZXJTdWdnZXN0TW9kYWwgZXh0ZW5kcyBTdWdnZXN0TW9kYWw8c3RyaW5nPiB7XG4vLyAgICAgY29uc3RydWN0b3IoYXBwOiBBcHAsIHByaXZhdGUgZm9sZGVyczogc3RyaW5nW10sIHByaXZhdGUgY2FsbGJhY2s6IChmb2xkZXI6IHN0cmluZykgPT4gdm9pZCkge1xuLy8gICAgICAgICBzdXBlcihhcHApO1xuLy8gICAgIH1cblxuLy8gICAgIGdldFN1Z2dlc3Rpb25zKHF1ZXJ5OiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4vLyAgICAgICAgIHJldHVybiB0aGlzLmZvbGRlcnMuZmlsdGVyKGZvbGRlciA9PlxuLy8gICAgICAgICAgICAgZm9sZGVyLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMocXVlcnkudG9Mb3dlckNhc2UoKSlcbi8vICAgICAgICAgKTtcbi8vICAgICB9XG5cbi8vICAgICByZW5kZXJTdWdnZXN0aW9uKGZvbGRlcjogc3RyaW5nLCBlbDogSFRNTEVsZW1lbnQpIHtcbi8vICAgICAgICAgZWwuY3JlYXRlRWwoJ2RpdicsIHsgdGV4dDogZm9sZGVyIH0pO1xuLy8gICAgIH1cblxuLy8gICAgIG9uQ2hvb3NlU3VnZ2VzdGlvbihmb2xkZXI6IHN0cmluZywgZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCkge1xuLy8gICAgICAgICB0aGlzLmNhbGxiYWNrKGZvbGRlcik7XG4vLyAgICAgfVxuLy8gfVxuIiwgImltcG9ydCB7IGFycmF5QnVmZmVyVG9CYXNlNjQgfSBmcm9tIFwib2JzaWRpYW5cIlxuaW1wb3J0IHsgRml0IH0gZnJvbSBcIi4vZml0XCJcbmltcG9ydCB7IENsYXNoU3RhdHVzLCBDb25mbGljdFJlcG9ydCwgQ29uZmxpY3RSZXNvbHV0aW9uUmVzdWx0LCBGaWxlT3BSZWNvcmQsIExvY2FsQ2hhbmdlLCBMb2NhbFVwZGF0ZSwgUmVtb3RlQ2hhbmdlLCBSZW1vdGVVcGRhdGUgfSBmcm9tIFwiLi9maXRUeXBlc1wiXG5pbXBvcnQgeyBSRUNPR05JWkVEX0JJTkFSWV9FWFQsIGV4dHJhY3RFeHRlbnNpb24sIHJlbW92ZUxpbmVFbmRpbmdzRnJvbUJhc2U2NFN0cmluZyB9IGZyb20gXCIuL3V0aWxzXCJcbmltcG9ydCB7IEZpdFB1bGwgfSBmcm9tIFwiLi9maXRQdWxsXCJcbmltcG9ydCB7IEZpdFB1c2ggfSBmcm9tIFwiLi9maXRQdXNoXCJcbmltcG9ydCB7IFZhdWx0T3BlcmF0aW9ucyB9IGZyb20gXCIuL3ZhdWx0T3BzXCJcbmltcG9ydCB7IExvY2FsU3RvcmVzIH0gZnJvbSBcIm1haW5cIlxuaW1wb3J0IEZpdE5vdGljZSBmcm9tIFwiLi9maXROb3RpY2VcIlxuaW1wb3J0IHBhdGggZnJvbSBcInBhdGhcIlxuXG5leHBvcnQgaW50ZXJmYWNlIElGaXRTeW5jIHtcbiAgICBmaXQ6IEZpdFxufVxuXG50eXBlIFByZVN5bmNDaGVja1Jlc3VsdCA9ICB7XG4gICAgc3RhdHVzOiBcImluU3luY1wiXG59IHwge1xuICAgIHN0YXR1czogRXhjbHVkZTxQcmVTeW5jQ2hlY2tSZXN1bHRUeXBlLCBcImluU3luY1wiPlxuICAgIHJlbW90ZVVwZGF0ZTogUmVtb3RlVXBkYXRlXG4gICAgbG9jYWxDaGFuZ2VzOiBMb2NhbENoYW5nZVtdXG4gICAgbG9jYWxUcmVlU2hhOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG59XG5cbnR5cGUgUHJlU3luY0NoZWNrUmVzdWx0VHlwZSA9IChcbiAgICBcImluU3luY1wiIHxcbiAgICBcIm9ubHlMb2NhbENoYW5nZWRcIiB8XG4gICAgXCJvbmx5UmVtb3RlQ2hhbmdlZFwiIHxcbiAgICBcIm9ubHlSZW1vdGVDb21taXRTaGFDaGFuZ2VkXCIgfFxuICAgIFwibG9jYWxBbmRSZW1vdGVDaGFuZ2VzQ29tcGF0aWJsZVwiIHxcbiAgICBcImxvY2FsQW5kUmVtb3RlQ2hhbmdlc0NsYXNoZWRcIlxuKVxuXG5leHBvcnQgY2xhc3MgRml0U3luYyBpbXBsZW1lbnRzIElGaXRTeW5jIHtcbiAgICBmaXQ6IEZpdFxuICAgIGZpdFB1bGw6IEZpdFB1bGxcbiAgICBmaXRQdXNoOiBGaXRQdXNoXG4gICAgdmF1bHRPcHM6IFZhdWx0T3BlcmF0aW9uc1xuICAgIHNhdmVMb2NhbFN0b3JlQ2FsbGJhY2s6IChwYXRoOiBzdHJpbmcsIGxvY2FsU3RvcmU6IFBhcnRpYWw8TG9jYWxTdG9yZXM+KSA9PiBQcm9taXNlPHZvaWQ+XG5cblxuICAgIGNvbnN0cnVjdG9yKGZpdDogRml0LFxuICAgICAgICB2YXVsdE9wczogVmF1bHRPcGVyYXRpb25zLFxuICAgICAgICBzYXZlTG9jYWxTdG9yZUNhbGxiYWNrOiAocGF0aDogc3RyaW5nLCBsb2NhbFN0b3JlOiBQYXJ0aWFsPExvY2FsU3RvcmVzPilcbiAgICAgICAgICAgID0+IFByb21pc2U8dm9pZD4pXG4gICAge1xuICAgICAgICB0aGlzLmZpdCA9IGZpdFxuICAgICAgICB0aGlzLmZpdFB1bGwgPSBuZXcgRml0UHVsbChmaXQpXG4gICAgICAgIHRoaXMuZml0UHVzaCA9IG5ldyBGaXRQdXNoKGZpdClcbiAgICAgICAgdGhpcy52YXVsdE9wcyA9IHZhdWx0T3BzXG4gICAgICAgIHRoaXMuc2F2ZUxvY2FsU3RvcmVDYWxsYmFjayA9IHNhdmVMb2NhbFN0b3JlQ2FsbGJhY2tcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIHBlcmZvcm1QcmVTeW5jQ2hlY2tzKCk6IFByb21pc2U8UHJlU3luY0NoZWNrUmVzdWx0PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRMb2NhbFNoYSA9IGF3YWl0IHRoaXMuZml0LmNvbXB1dGVMb2NhbFNoYSgpXG4gICAgICAgIGNvbnN0IGxvY2FsQ2hhbmdlcyA9IGF3YWl0IHRoaXMuZml0LmdldExvY2FsQ2hhbmdlcyhjdXJyZW50TG9jYWxTaGEpXG4gICAgICAgIGNvbnN0IHtyZW1vdGVDb21taXRTaGEsIHVwZGF0ZWQ6IHJlbW90ZVVwZGF0ZWR9ID0gYXdhaXQgdGhpcy5maXQucmVtb3RlVXBkYXRlZCgpO1xuICAgICAgICBpZiAobG9jYWxDaGFuZ2VzLmxlbmd0aCA9PT0gMCAmJiAhcmVtb3RlVXBkYXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtzdGF0dXM6IFwiaW5TeW5jXCJ9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZW1vdGVUcmVlU2hhID0gYXdhaXQgdGhpcy5maXQuZ2V0UmVtb3RlVHJlZVNoYShyZW1vdGVDb21taXRTaGEpXG4gICAgICAgIGNvbnN0IHJlbW90ZUNoYW5nZXMgPSBhd2FpdCB0aGlzLmZpdC5nZXRSZW1vdGVDaGFuZ2VzKHJlbW90ZVRyZWVTaGEpXG4gICAgICAgIGxldCBjbGFzaGVzOiBDbGFzaFN0YXR1c1tdID0gW107XG4gICAgICAgIGxldCBzdGF0dXM6IFByZVN5bmNDaGVja1Jlc3VsdFR5cGVcblxuICAgICAgICBpZiAobG9jYWxDaGFuZ2VzLmxlbmd0aCA+IDAgJiYgIXJlbW90ZVVwZGF0ZWQpIHtcbiAgICAgICAgICAgIHN0YXR1cyA9IFwib25seUxvY2FsQ2hhbmdlZFwiXG4gICAgICAgIH0gZWxzZSBpZiAocmVtb3RlVXBkYXRlZCAmJiBsb2NhbENoYW5nZXMubGVuZ3RoID09PSAwICYmIHJlbW90ZUNoYW5nZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBzdGF0dXMgPSBcIm9ubHlSZW1vdGVDb21taXRTaGFDaGFuZ2VkXCJcbiAgICAgICAgfSBlbHNlIGlmIChsb2NhbENoYW5nZXMubGVuZ3RoID09PSAwICYmIHJlbW90ZVVwZGF0ZWQpIHtcbiAgICAgICAgICAgIHN0YXR1cyA9IFwib25seVJlbW90ZUNoYW5nZWRcIlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xhc2hlcyA9IHRoaXMuZml0LmdldENsYXNoZWRDaGFuZ2VzKGxvY2FsQ2hhbmdlcywgcmVtb3RlQ2hhbmdlcylcbiAgICAgICAgICAgIGlmIChjbGFzaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN0YXR1cyA9IFwibG9jYWxBbmRSZW1vdGVDaGFuZ2VzQ29tcGF0aWJsZVwiXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXR1cyA9ICBcImxvY2FsQW5kUmVtb3RlQ2hhbmdlc0NsYXNoZWRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgICByZW1vdGVVcGRhdGU6IHtcbiAgICAgICAgICAgICAgICByZW1vdGVDaGFuZ2VzLFxuICAgICAgICAgICAgICAgIHJlbW90ZVRyZWVTaGEsXG4gICAgICAgICAgICAgICAgbGF0ZXN0UmVtb3RlQ29tbWl0U2hhOiByZW1vdGVDb21taXRTaGEsXG4gICAgICAgICAgICAgICAgY2xhc2hlZEZpbGVzOiBjbGFzaGVzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbG9jYWxDaGFuZ2VzLFxuICAgICAgICAgICAgbG9jYWxUcmVlU2hhOiBjdXJyZW50TG9jYWxTaGFcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgZ2VuZXJhdGVDb25mbGljdFJlcG9ydChwYXRoOiBzdHJpbmcsIGxvY2FsQ29udGVudDogc3RyaW5nLCByZW1vdGVDb250ZW50OiBzdHJpbmcpOiBDb25mbGljdFJlcG9ydCB7XG4gICAgICAgIGNvbnN0IGRldGVjdGVkRXh0ZW5zaW9uID0gZXh0cmFjdEV4dGVuc2lvbihwYXRoKVxuICAgICAgICBpZiAoZGV0ZWN0ZWRFeHRlbnNpb24gJiYgUkVDT0dOSVpFRF9CSU5BUllfRVhULmluY2x1ZGVzKGRldGVjdGVkRXh0ZW5zaW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgIHJlc29sdXRpb25TdHJhdGVneTogXCJiaW5hcnlcIixcbiAgICAgICAgICAgICAgICByZW1vdGVDb250ZW50XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXNzdW1lIGZpbGUgZW5jb2RpbmcgaXMgdXRmOCBpZiBleHRlbnNpb24gaXMgbm90IGtub3duXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgcmVzb2x1dGlvblN0cmF0ZWd5OiBcInV0Zi04XCIsXG4gICAgICAgICAgICBsb2NhbENvbnRlbnQsXG4gICAgICAgICAgICByZW1vdGVDb250ZW50LFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBoYW5kbGVCaW5hcnlDb25mbGljdChwYXRoOiBzdHJpbmcsIHJlbW90ZUNvbnRlbnQ6IHN0cmluZyk6IFByb21pc2U8RmlsZU9wUmVjb3JkfG51bGw+IHtcbiAgICAgICAgY29uc3QgY29uZmxpY3RSZXNvbHV0aW9uRm9sZGVyID0gXCJfZml0XCJcbiAgICAgICAgY29uc3QgY29uZmxpY3RSZXNvbHV0aW9uUGF0aCA9IGAke2NvbmZsaWN0UmVzb2x1dGlvbkZvbGRlcn0vJHt0aGlzLmZpdC5zeW5jUGF0aCtwYXRofWBcblxuICAgICAgICBjb25zdCBleGNsdWRlcyA9IHRoaXMuZml0LmV4Y2x1ZGVzXG5cbiAgICAgICAgbGV0IGlzRXhjbHVkZWQgPSBmYWxzZVxuICAgICAgICBpZiAoZXhjbHVkZXMubGVuZ3RoKSB7XG4gICAgICAgICAgaXNFeGNsdWRlZCA9IGV4Y2x1ZGVzLnNvbWUoZWwgPT4gY29uZmxpY3RSZXNvbHV0aW9uUGF0aC5zdGFydHNXaXRoKGVsKSlcbiAgICAgICAgfVxuXG5cdFx0aWYgKGlzRXhjbHVkZWQpXG5cdFx0XHRyZXR1cm4gbnVsbFxuXG4gICAgICAgIGF3YWl0IHRoaXMuZml0LnZhdWx0T3BzLmVuc3VyZUZvbGRlckV4aXN0cyhjb25mbGljdFJlc29sdXRpb25QYXRoKVxuICAgICAgICBhd2FpdCB0aGlzLmZpdC52YXVsdE9wcy53cml0ZVRvTG9jYWwoY29uZmxpY3RSZXNvbHV0aW9uUGF0aCwgcmVtb3RlQ29udGVudClcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhdGg6IGNvbmZsaWN0UmVzb2x1dGlvblBhdGgsXG4gICAgICAgICAgICBzdGF0dXM6IFwiY3JlYXRlZFwiXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgaGFuZGxlVVRGOENvbmZsaWN0KHBhdGg6IHN0cmluZywgbG9jYWxDb250ZW50OiBzdHJpbmcsIHJlbW90ZUNvbmVudDogc3RyaW5nKTogUHJvbWlzZTxGaWxlT3BSZWNvcmR8bnVsbD4ge1xuICAgICAgICBjb25zdCBjb25mbGljdFJlc29sdXRpb25Gb2xkZXIgPSBcIl9maXRcIlxuICAgICAgICBjb25zdCBjb25mbGljdFJlc29sdXRpb25QYXRoID0gYCR7Y29uZmxpY3RSZXNvbHV0aW9uRm9sZGVyfS8ke3RoaXMuZml0LnN5bmNQYXRoK3BhdGh9YFxuXG4gICAgICAgIGNvbnN0IGV4Y2x1ZGVzID0gdGhpcy5maXQuZXhjbHVkZXNcblxuICAgICAgICBsZXQgaXNFeGNsdWRlZCA9IGZhbHNlXG4gICAgICAgIGlmIChleGNsdWRlcy5sZW5ndGgpIHtcbiAgICAgICAgICBpc0V4Y2x1ZGVkID0gZXhjbHVkZXMuc29tZShlbCA9PiBjb25mbGljdFJlc29sdXRpb25QYXRoLnN0YXJ0c1dpdGgoZWwpKVxuICAgICAgICB9XG5cblx0XHRpZiAoaXNFeGNsdWRlZClcblx0XHRcdHJldHVybiBudWxsXG5cbiAgICAgICAgYXdhaXQgdGhpcy5maXQudmF1bHRPcHMuZW5zdXJlRm9sZGVyRXhpc3RzKGNvbmZsaWN0UmVzb2x1dGlvblBhdGgpXG4gICAgICAgIHRoaXMuZml0LnZhdWx0T3BzLndyaXRlVG9Mb2NhbChjb25mbGljdFJlc29sdXRpb25QYXRoLCByZW1vdGVDb25lbnQpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXRoOiBjb25mbGljdFJlc29sdXRpb25QYXRoLFxuICAgICAgICAgICAgc3RhdHVzOiBcImNyZWF0ZWRcIlxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBoYW5kbGVMb2NhbERlbGV0aW9uQ29uZmxpY3QocGF0aDogc3RyaW5nLCByZW1vdGVDb250ZW50OiBzdHJpbmcpOiBQcm9taXNlPEZpbGVPcFJlY29yZHxudWxsPiB7XG4gICAgICAgIGNvbnN0IGNvbmZsaWN0UmVzb2x1dGlvbkZvbGRlciA9IFwiX2ZpdFwiXG4gICAgICAgIGNvbnN0IGNvbmZsaWN0UmVzb2x1dGlvblBhdGggPSBgJHtjb25mbGljdFJlc29sdXRpb25Gb2xkZXJ9LyR7dGhpcy5maXQuc3luY1BhdGgrcGF0aH1gXG5cbiAgICAgICAgY29uc3QgZXhjbHVkZXMgPSB0aGlzLmZpdC5leGNsdWRlc1xuXG4gICAgICAgIGxldCBpc0V4Y2x1ZGVkID0gZmFsc2VcbiAgICAgICAgaWYgKGV4Y2x1ZGVzLmxlbmd0aCkge1xuICAgICAgICAgIGlzRXhjbHVkZWQgPSBleGNsdWRlcy5zb21lKGVsID0+IGNvbmZsaWN0UmVzb2x1dGlvblBhdGguc3RhcnRzV2l0aChlbCkpXG4gICAgICAgIH1cblxuXHRcdGlmIChpc0V4Y2x1ZGVkKVxuXHRcdFx0cmV0dXJuIG51bGxcblxuICAgICAgICBhd2FpdCB0aGlzLmZpdC52YXVsdE9wcy5lbnN1cmVGb2xkZXJFeGlzdHMoY29uZmxpY3RSZXNvbHV0aW9uRm9sZGVyKVxuICAgICAgICB0aGlzLmZpdC52YXVsdE9wcy53cml0ZVRvTG9jYWwoY29uZmxpY3RSZXNvbHV0aW9uUGF0aCwgcmVtb3RlQ29udGVudClcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhdGg6IGNvbmZsaWN0UmVzb2x1dGlvblBhdGgsXG4gICAgICAgICAgICBzdGF0dXM6IFwiY3JlYXRlZFwiXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIHJlc29sdmVGaWxlQ29uZmxpY3QoY2xhc2g6IENsYXNoU3RhdHVzLCBsYXRlc3RSZW1vdGVGaWxlU2hhOiBzdHJpbmcpOiBQcm9taXNlPENvbmZsaWN0UmVzb2x1dGlvblJlc3VsdCB8IG51bGw+IHtcbiAgICAgICAgaWYgKGNsYXNoLmxvY2FsU3RhdHVzID09PSBcImRlbGV0ZWRcIiAmJiBjbGFzaC5yZW1vdGVTdGF0dXMgPT09IFwiUkVNT1ZFRFwiKSB7XG4gICAgICAgICAgICByZXR1cm4ge3BhdGg6IGNsYXNoLnBhdGgsIG5vRGlmZjogdHJ1ZX1cbiAgICAgICAgfSBlbHNlIGlmIChjbGFzaC5sb2NhbFN0YXR1cyA9PT0gXCJkZWxldGVkXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbW90ZUNvbnRlbnQgPSBhd2FpdCB0aGlzLmZpdC5nZXRCbG9iKGxhdGVzdFJlbW90ZUZpbGVTaGEpXG4gICAgICAgICAgICBjb25zdCBmaWxlT3AgPSBhd2FpdCB0aGlzLmhhbmRsZUxvY2FsRGVsZXRpb25Db25mbGljdChjbGFzaC5wYXRoLCByZW1vdGVDb250ZW50KVxuXHRcdFx0Ly8gTk9URSBkaWRuJ3QgZGVsZXRlIHNpbmNlIGl0J3MgaW4gZXhjbHVkZVxuXHRcdFx0aWYgKCFmaWxlT3ApXG5cdFx0XHRcdHJldHVybiBudWxsXG5cbiAgICAgICAgICAgIHJldHVybiB7cGF0aDogY2xhc2gucGF0aCwgbm9EaWZmOiBmYWxzZSwgZmlsZU9wOiBmaWxlT3B9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwYXRoID0gdGhpcy5maXQuc3luY1BhdGggKyBjbGFzaC5wYXRoXG4gICAgICAgIC8vIGNvbnN0IGxvY2FsRmlsZSA9IGF3YWl0IHRoaXMuZml0LnZhdWx0T3BzLmdldFRGaWxlKHBhdGgpXG5cdFx0Ly8gaWYgKCFsb2NhbEZpbGUpXG5cdFx0Ly8gXHRyZXR1cm4gbnVsbFxuXG5cdFx0Ly8gTk9URSB1c2UgYWRhcHRlciBmb3IgZmlsZXMgaW4gdGhlIC5vYnNpZGlhbi8uLi5cbiAgICAgICAgY29uc3QgbG9jYWxGaWxlQ29udGVudCA9IGFycmF5QnVmZmVyVG9CYXNlNjQoYXdhaXQgdGhpcy5maXQudmF1bHRPcHMudmF1bHQuYWRhcHRlci5yZWFkQmluYXJ5KHBhdGgpKVxuXG4gICAgICAgIGlmIChsYXRlc3RSZW1vdGVGaWxlU2hhKSB7XG4gICAgICAgICAgICBjb25zdCByZW1vdGVDb250ZW50ID0gYXdhaXQgdGhpcy5maXQuZ2V0QmxvYihsYXRlc3RSZW1vdGVGaWxlU2hhKVxuICAgICAgICAgICAgaWYgKHJlbW92ZUxpbmVFbmRpbmdzRnJvbUJhc2U2NFN0cmluZyhyZW1vdGVDb250ZW50KSAhPT0gcmVtb3ZlTGluZUVuZGluZ3NGcm9tQmFzZTY0U3RyaW5nKGxvY2FsRmlsZUNvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVwb3J0ID0gdGhpcy5nZW5lcmF0ZUNvbmZsaWN0UmVwb3J0KGNsYXNoLnBhdGgsIGxvY2FsRmlsZUNvbnRlbnQsIHJlbW90ZUNvbnRlbnQpXG4gICAgICAgICAgICAgICAgbGV0IGZpbGVPcDogRmlsZU9wUmVjb3JkIHwgbnVsbFxuICAgICAgICAgICAgICAgIGlmIChyZXBvcnQucmVzb2x1dGlvblN0cmF0ZWd5ID09PSBcImJpbmFyeVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVPcCA9IGF3YWl0IHRoaXMuaGFuZGxlQmluYXJ5Q29uZmxpY3QoY2xhc2gucGF0aCwgcmVwb3J0LnJlbW90ZUNvbnRlbnQpXG5cblx0XHRcdFx0XHQvLyBOT1RFIGRpZG4ndCBkZWxldGUgc2luY2UgaXQncyBpbiBleGNsdWRlXG5cdFx0XHRcdFx0aWYgKCFmaWxlT3ApXG5cdFx0XHRcdFx0XHRyZXR1cm4gbnVsbFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVPcCA9IGF3YWl0IHRoaXMuaGFuZGxlVVRGOENvbmZsaWN0KGNsYXNoLnBhdGgsIHJlcG9ydC5sb2NhbENvbnRlbnQsIHJlcG9ydC5yZW1vdGVDb250ZW50KVxuXG5cdFx0XHRcdFx0Ly8gTk9URSBkaWRuJ3QgZGVsZXRlIHNpbmNlIGl0J3MgaW4gZXhjbHVkZVxuXHRcdFx0XHRcdGlmICghZmlsZU9wKVxuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtwYXRoOiBjbGFzaC5wYXRoLCBub0RpZmY6IGZhbHNlLCBmaWxlT3A6IGZpbGVPcH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHBhdGg6IGNsYXNoLnBhdGgsIG5vRGlmZjogdHJ1ZSB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBhc3N1bWVzIHJlbW90ZSBmaWxlIGlzIGRlbGV0ZWQgaWYgc2hhIG5vdCBmb3VuZCBpbiBsYXRlc3RSZW1vdGVUcmVlU2hhLlxuICAgICAgICAgICAgcmV0dXJuIHsgcGF0aDogY2xhc2gucGF0aCwgbm9EaWZmOiBmYWxzZSB9XG4gICAgICAgIH1cblx0fVxuXG4gICAgYXN5bmMgcmVzb2x2ZUNvbmZsaWN0cyhcbiAgICAgICAgY2xhc2hlZEZpbGVzOiBBcnJheTxDbGFzaFN0YXR1cz4sIGxhdGVzdFJlbW90ZVRyZWVTaGE6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pXG4gICAgICAgIDogUHJvbWlzZTx7bm9Db25mbGljdDogYm9vbGVhbiwgdW5yZXNvbHZlZEZpbGVzOiBDbGFzaFN0YXR1c1tdLCBmaWxlT3BzUmVjb3JkOiBGaWxlT3BSZWNvcmRbXX0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVSZXNvbHV0aW9ucyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgICAgICAgIGNsYXNoZWRGaWxlcy5tYXAoXG4gICAgICAgICAgICAgICAgICAgIGFzeW5jIChjbGFzaCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucmVzb2x2ZUZpbGVDb25mbGljdChjbGFzaCwgbGF0ZXN0UmVtb3RlVHJlZVNoYVtjbGFzaC5wYXRoXSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgY29uc3QgdW5yZXNvbHZlZEZpbGVzID0gZmlsZVJlc29sdXRpb25zLm1hcCgocmVzLCBpKT0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlcz8ubm9EaWZmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbGFzaGVkRmlsZXNbaV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgIH0pLmZpbHRlcihCb29sZWFuKSBhcyBBcnJheTxDbGFzaFN0YXR1cz5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbm9Db25mbGljdDogZmlsZVJlc29sdXRpb25zLmV2ZXJ5KHJlcz0+cmVzPy5ub0RpZmYpLFxuICAgICAgICAgICAgICAgIHVucmVzb2x2ZWRGaWxlcyxcbiAgICAgICAgICAgICAgICBmaWxlT3BzUmVjb3JkOiBmaWxlUmVzb2x1dGlvbnMubWFwKHIgPT4gcj8uZmlsZU9wKS5maWx0ZXIoQm9vbGVhbikgYXMgRmlsZU9wUmVjb3JkW11cbiAgICAgICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBzeW5jQ29tcGF0aWJsZUNoYW5nZXMoXG4gICAgICAgIGxvY2FsVXBkYXRlOiBMb2NhbFVwZGF0ZSxcbiAgICAgICAgcmVtb3RlVXBkYXRlOiBSZW1vdGVVcGRhdGUsXG4gICAgICAgIHN5bmNOb3RpY2U6IEZpdE5vdGljZSk6IFByb21pc2U8e2xvY2FsT3BzOiBMb2NhbENoYW5nZVtdLCByZW1vdGVPcHM6IEZpbGVPcFJlY29yZFtdfT4ge1xuXHRcdFx0bGV0IHthZGRUb0xvY2FsLCBkZWxldGVGcm9tTG9jYWx9ID0gYXdhaXQgdGhpcy5maXRQdWxsLnByZXBhcmVDaGFuZ2VzVG9FeGVjdXRlKFxuXHRcdFx0XHRyZW1vdGVVcGRhdGUucmVtb3RlQ2hhbmdlcylcblx0XHRcdHN5bmNOb3RpY2Uuc2V0TWVzc2FnZShcIlVwbG9hZGluZyBsb2NhbCBjaGFuZ2VzXCIpXG5cdFx0XHRjb25zdCByZW1vdGVUcmVlID0gYXdhaXQgdGhpcy5maXQuZ2V0VHJlZShsb2NhbFVwZGF0ZS5wYXJlbnRDb21taXRTaGEpXG5cdFx0XHRjb25zdCBjcmVhdGVDb21taXRSZXN1bHQgPSBhd2FpdCB0aGlzLmZpdFB1c2guY3JlYXRlQ29tbWl0RnJvbUxvY2FsVXBkYXRlKGxvY2FsVXBkYXRlLCByZW1vdGVUcmVlKVxuXHRcdFx0bGV0IGxhdGVzdFJlbW90ZVRyZWVTaGE6IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG5cdFx0XHRsZXQgbGF0ZXN0Q29tbWl0U2hhOiBzdHJpbmc7XG5cdFx0XHRsZXQgcHVzaGVkQ2hhbmdlczogQXJyYXk8TG9jYWxDaGFuZ2U+O1xuXHRcdFx0aWYgKGNyZWF0ZUNvbW1pdFJlc3VsdCkge1xuXHRcdFx0XHRjb25zdCB7Y3JlYXRlZENvbW1pdFNoYX0gPSBjcmVhdGVDb21taXRSZXN1bHRcblx0XHRcdFx0Y29uc3QgbGF0ZXN0UmVmU2hhID0gYXdhaXQgdGhpcy5maXQudXBkYXRlUmVmKGNyZWF0ZWRDb21taXRTaGEpXG5cdFx0XHRcdGxhdGVzdFJlbW90ZVRyZWVTaGEgPSBhd2FpdCB0aGlzLmZpdC5nZXRSZW1vdGVUcmVlU2hhKGxhdGVzdFJlZlNoYSlcblx0XHRcdFx0bGF0ZXN0Q29tbWl0U2hhID0gY3JlYXRlZENvbW1pdFNoYVxuXHRcdFx0XHRwdXNoZWRDaGFuZ2VzID0gY3JlYXRlQ29tbWl0UmVzdWx0LnB1c2hlZENoYW5nZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxhdGVzdFJlbW90ZVRyZWVTaGEgPSByZW1vdGVVcGRhdGUucmVtb3RlVHJlZVNoYVxuXHRcdFx0XHRsYXRlc3RDb21taXRTaGEgPSByZW1vdGVVcGRhdGUubGF0ZXN0UmVtb3RlQ29tbWl0U2hhXG5cdFx0XHRcdHB1c2hlZENoYW5nZXMgPSBbXVxuXHRcdFx0fVxuXG5cdFx0XHRzeW5jTm90aWNlLnNldE1lc3NhZ2UoXCJXcml0aW5nIHJlbW90ZSBjaGFuZ2VzIHRvIGxvY2FsXCIpXG5cblx0XHRcdGNvbnN0IGJhc2VwYXRoID0gdGhpcy5maXQuc3luY1BhdGhcblx0XHRcdGFkZFRvTG9jYWwgPSBhZGRUb0xvY2FsXG5cdFx0XHRcdC5tYXAoXG5cdFx0XHRcdFx0KHtwYXRoLCBjb250ZW50fSkgPT4ge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0cGF0aDogYmFzZXBhdGggKyBwYXRoLFxuXHRcdFx0XHRcdFx0XHRjb250ZW50XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpXG5cdFx0XHRcdC5maWx0ZXIoXG5cdFx0XHRcdFx0ZmlsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleGNsdWRlcyA9IHRoaXMuZml0LmV4Y2x1ZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV4Y2x1ZGVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhjbHVkZXMuc29tZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhjbHVkZSA9PiAhZmlsZS5wYXRoLnN0YXJ0c1dpdGgoZXhjbHVkZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgfVxuXHRcdFx0XHQpXG5cblx0XHRcdGRlbGV0ZUZyb21Mb2NhbCA9IGRlbGV0ZUZyb21Mb2NhbFxuXHRcdFx0XHQubWFwKHBhdGggPT4gYmFzZXBhdGggKyBwYXRoKVxuXHRcdFx0XHQuZmlsdGVyKFxuXHRcdFx0XHRcdHBhdGggPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhjbHVkZXMgPSB0aGlzLmZpdC5leGNsdWRlc1xuICAgICAgICAgICAgaWYgKCFleGNsdWRlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcblxuICAgICAgICAgICAgcmV0dXJuIGV4Y2x1ZGVzLnNvbWUoXG4gICAgICAgICAgICAgIGV4Y2x1ZGUgPT4gIXBhdGguc3RhcnRzV2l0aChleGNsdWRlKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblx0XHRcdFx0KVxuXG5cblx0XHRcdGNvbnN0IGxvY2FsRmlsZU9wc1JlY29yZCA9IGF3YWl0IHRoaXMudmF1bHRPcHMudXBkYXRlTG9jYWxGaWxlcyhhZGRUb0xvY2FsLCBkZWxldGVGcm9tTG9jYWwpXG5cdFx0XHRhd2FpdCB0aGlzLnNhdmVMb2NhbFN0b3JlQ2FsbGJhY2soXG4gICAgICAgICAgICAgICAgYmFzZXBhdGgsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBsYXN0RmV0Y2hlZFJlbW90ZVNoYTogbGF0ZXN0UmVtb3RlVHJlZVNoYSxcbiAgICAgICAgICAgICAgICAgICAgbGFzdEZldGNoZWRDb21taXRTaGE6IGxhdGVzdENvbW1pdFNoYSxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTaGE6IGF3YWl0IHRoaXMuZml0LmNvbXB1dGVMb2NhbFNoYSgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuXHRcdFx0c3luY05vdGljZS5zZXRNZXNzYWdlKFwiU3luYyBzdWNjZXNzZnVsXCIpXG4gICAgICAgICAgICByZXR1cm4ge2xvY2FsT3BzOiBsb2NhbEZpbGVPcHNSZWNvcmQsIHJlbW90ZU9wczogcHVzaGVkQ2hhbmdlc31cbiAgICB9XG5cblxuICAgIGFzeW5jIHN5bmNXaXRoQ29uZmxpY3RzKFxuICAgICAgICBsb2NhbENoYW5nZXM6IExvY2FsQ2hhbmdlW10sXG4gICAgICAgIHJlbW90ZVVwZGF0ZTogUmVtb3RlVXBkYXRlLFxuICAgICAgICBzeW5jTm90aWNlOiBGaXROb3RpY2UpIDogUHJvbWlzZTx7dW5yZXNvbHZlZEZpbGVzOiBDbGFzaFN0YXR1c1tdLCBsb2NhbE9wczogTG9jYWxDaGFuZ2VbXSwgcmVtb3RlT3BzOiBMb2NhbENoYW5nZVtdfSB8IG51bGw+XG5cdHtcbiAgICAgICAgY29uc3Qge2xhdGVzdFJlbW90ZUNvbW1pdFNoYSwgY2xhc2hlZEZpbGVzLCByZW1vdGVUcmVlU2hhOiBsYXRlc3RSZW1vdGVUcmVlU2hhfSA9IHJlbW90ZVVwZGF0ZVxuXHRcdGNvbnN0IHtub0NvbmZsaWN0LCB1bnJlc29sdmVkRmlsZXMsIGZpbGVPcHNSZWNvcmR9ID0gYXdhaXQgdGhpcy5yZXNvbHZlQ29uZmxpY3RzKGNsYXNoZWRGaWxlcywgbGF0ZXN0UmVtb3RlVHJlZVNoYSlcblx0XHRsZXQgbG9jYWxDaGFuZ2VzVG9QdXNoOiBBcnJheTxMb2NhbENoYW5nZT47XG5cdFx0bGV0IHJlbW90ZUNoYW5nZXNUb1dyaXRlOiBBcnJheTxSZW1vdGVDaGFuZ2U+XG5cdFx0aWYgKG5vQ29uZmxpY3QpIHtcblx0XHRcdC8vIG5vIGNvbmZsaWN0IGRldGVjdGVkIGFtb25nIGNsYXNoZWQgZmlsZXMsIGp1c3QgcHVsbCBjaGFuZ2VzIG9ubHkgbWFkZSBvbiByZW1vdGUgYW5kIHB1c2ggY2hhbmdlcyBvbmx5IG1hZGUgb24gbG9jYWxcblx0XHRcdHJlbW90ZUNoYW5nZXNUb1dyaXRlID0gcmVtb3RlVXBkYXRlLnJlbW90ZUNoYW5nZXMuZmlsdGVyKGMgPT4gIWxvY2FsQ2hhbmdlcy5zb21lKGwgPT4gbC5wYXRoID09PSBjLnBhdGgpKVxuXHRcdFx0bG9jYWxDaGFuZ2VzVG9QdXNoID0gbG9jYWxDaGFuZ2VzLmZpbHRlcihjID0+ICFyZW1vdGVVcGRhdGUucmVtb3RlQ2hhbmdlcy5zb21lKHIgPT4gci5wYXRoID09PSBjLnBhdGgpKVxuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHN5bmNOb3RpY2Uuc2V0TWVzc2FnZShgQ2hhbmdlIGNvbmZsaWN0cyBkZXRlY3RlZGApXG5cdFx0XHQvLyBkbyBub3QgbW9kaWZ5IHVucmVzb2x2ZWQgZmlsZXMgbG9jYWxseVxuXHRcdFx0cmVtb3RlQ2hhbmdlc1RvV3JpdGUgPSByZW1vdGVVcGRhdGUucmVtb3RlQ2hhbmdlcy5maWx0ZXIoYyA9PiAhdW5yZXNvbHZlZEZpbGVzLnNvbWUobCA9PiBsLnBhdGggPT09IGMucGF0aCkpXG5cdFx0XHQvLyBwdXNoIGNoYW5nZSBldmVuIGlmIHRoZXkgYXJlIGluIHVucmVzb2x2ZWQgZmlsZXMsIHNvIHJlbW90ZSBoYXMgYSByZWNvcmQgb2YgdGhlbSxcblx0XHRcdC8vIHNvIHVzZXIgY2FuIHJlc29sdmUgbGF0ZXIgYnkgbW9kaWZ5aW5nIGxvY2FsIGFuZCBwdXNoIGFnYWluXG5cdFx0XHRsb2NhbENoYW5nZXNUb1B1c2ggPSBsb2NhbENoYW5nZXNcblx0XHR9XG5cdFx0bGV0IHthZGRUb0xvY2FsLCBkZWxldGVGcm9tTG9jYWx9ID0gYXdhaXQgdGhpcy5maXRQdWxsLnByZXBhcmVDaGFuZ2VzVG9FeGVjdXRlKHJlbW90ZUNoYW5nZXNUb1dyaXRlKVxuXHRcdGNvbnN0IHN5bmNMb2NhbFVwZGF0ZSA9IHtcblx0XHRcdGxvY2FsQ2hhbmdlczogbG9jYWxDaGFuZ2VzVG9QdXNoLFxuXHRcdFx0cGFyZW50Q29tbWl0U2hhOiBsYXRlc3RSZW1vdGVDb21taXRTaGFcblx0XHR9XG5cdFx0Y29uc3QgcHVzaFJlc3VsdCA9IGF3YWl0IHRoaXMuZml0UHVzaC5wdXNoQ2hhbmdlZEZpbGVzVG9SZW1vdGUoc3luY0xvY2FsVXBkYXRlKVxuXHRcdGxldCBwdXNoZWRDaGFuZ2VzOiBMb2NhbENoYW5nZVtdO1xuXHRcdGxldCBsYXN0RmV0Y2hlZENvbW1pdFNoYTogc3RyaW5nO1xuXHRcdGxldCBsYXN0RmV0Y2hlZFJlbW90ZVNoYTogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcblx0XHRpZiAocHVzaFJlc3VsdCkge1xuXHRcdFx0cHVzaGVkQ2hhbmdlcyA9IHB1c2hSZXN1bHQucHVzaGVkQ2hhbmdlc1xuXHRcdFx0bGFzdEZldGNoZWRDb21taXRTaGEgPSBwdXNoUmVzdWx0Lmxhc3RGZXRjaGVkQ29tbWl0U2hhXG5cdFx0XHRsYXN0RmV0Y2hlZFJlbW90ZVNoYSA9IHB1c2hSZXN1bHQubGFzdEZldGNoZWRSZW1vdGVTaGFcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gZGlkIG5vdCBwdXNoIGFueSBjaGFuZ2VzXG5cdFx0XHRwdXNoZWRDaGFuZ2VzID0gW11cblx0XHRcdGxhc3RGZXRjaGVkQ29tbWl0U2hhID0gcmVtb3RlVXBkYXRlLmxhdGVzdFJlbW90ZUNvbW1pdFNoYVxuXHRcdFx0bGFzdEZldGNoZWRSZW1vdGVTaGEgPSByZW1vdGVVcGRhdGUucmVtb3RlVHJlZVNoYVxuXHRcdH1cblxuXHRcdGNvbnN0IGJhc2VwYXRoID0gdGhpcy5maXQuc3luY1BhdGhcblx0XHRhZGRUb0xvY2FsID0gYWRkVG9Mb2NhbFxuXHRcdFx0Lm1hcChcblx0XHRcdFx0KHtwYXRoLCBjb250ZW50fSkgPT4ge1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRwYXRoOiBiYXNlcGF0aCArIHBhdGgsXG5cdFx0XHRcdFx0XHRjb250ZW50XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHQpXG4gICAgICAuZmlsdGVyKFxuICAgICAgICBmaWxlID0+IHtcbiAgICAgICAgICBjb25zdCBleGNsdWRlcyA9IHRoaXMuZml0LmV4Y2x1ZGVzXG4gICAgICAgICAgaWYgKCFleGNsdWRlcy5sZW5ndGgpXG4gICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgcmV0dXJuIGV4Y2x1ZGVzLnNvbWUoXG4gICAgICAgICAgICBleGNsdWRlID0+ICFmaWxlLnBhdGguc3RhcnRzV2l0aChleGNsdWRlKVxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgKVxuXG5cdFx0ZGVsZXRlRnJvbUxvY2FsID0gZGVsZXRlRnJvbUxvY2FsXG5cdFx0XHQubWFwKHBhdGggPT4gYmFzZXBhdGggKyBwYXRoKVxuXHRcdFx0XHQuZmlsdGVyKFxuXHRcdFx0XHRcdHBhdGggPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhjbHVkZXMgPSB0aGlzLmZpdC5leGNsdWRlc1xuICAgICAgICAgICAgaWYgKCFleGNsdWRlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcblxuICAgICAgICAgICAgcmV0dXJuIGV4Y2x1ZGVzLnNvbWUoXG4gICAgICAgICAgICAgIGV4Y2x1ZGUgPT4gIXBhdGguc3RhcnRzV2l0aChleGNsdWRlKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgKVxuXG5cdFx0Y29uc3QgbG9jYWxGaWxlT3BzUmVjb3JkID0gYXdhaXQgdGhpcy52YXVsdE9wcy51cGRhdGVMb2NhbEZpbGVzKFxuXHRcdFx0YWRkVG9Mb2NhbCxcblx0XHRcdGRlbGV0ZUZyb21Mb2NhbFxuXHRcdClcblxuXHRcdGF3YWl0IHRoaXMuc2F2ZUxvY2FsU3RvcmVDYWxsYmFjayhcblx0XHRcdGJhc2VwYXRoLFxuXHRcdHtcblx0XHRcdGxhc3RGZXRjaGVkUmVtb3RlU2hhLFxuXHRcdFx0bGFzdEZldGNoZWRDb21taXRTaGEsXG5cdFx0XHRsb2NhbFNoYTogYXdhaXQgdGhpcy5maXQuY29tcHV0ZUxvY2FsU2hhKClcblx0XHR9KVxuXHRcdGNvbnN0IG9wcyA9IGxvY2FsRmlsZU9wc1JlY29yZC5jb25jYXQoZmlsZU9wc1JlY29yZClcblx0XHRpZiAodW5yZXNvbHZlZEZpbGVzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0c3luY05vdGljZS5zZXRNZXNzYWdlKGBTeW5jIHN1Y2Nlc3NmdWxgKVxuXHRcdH0gZWxzZSBpZiAodW5yZXNvbHZlZEZpbGVzLnNvbWUoZiA9PiBmLnJlbW90ZVN0YXR1cyAhPT0gXCJSRU1PVkVEXCIpKSB7XG5cdFx0XHQvLyBsZXQgdXNlciBrbm93cyByZW1vdGUgZmlsZSBjaGFuZ2VzIGhhdmUgYmVlbiB3cml0dGVuIHRvIF9maXQgaWYgbm9uLWRlbGV0aW9uIGNoYW5nZSBvbiByZW1vdGUgY2xhc2hlZCB3aXRoIGxvY2FsIGNoYW5nZXNcblx0XHRcdHN5bmNOb3RpY2Uuc2V0TWVzc2FnZShgU3luY2VkIHdpdGggcmVtb3RlLCB1bnJlc29sdmVkIGNvbmZsaWN0cyB3cml0dGVuIHRvIF9maXRgKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzeW5jTm90aWNlLnNldE1lc3NhZ2UoYFN5bmNlZCB3aXRoIHJlbW90ZSwgaWdub3JlZCByZW1vdGUgZGVsZXRpb24gb2YgbG9jYWxseSBjaGFuZ2VkIGZpbGVzYClcblx0XHR9XG5cdFx0cmV0dXJuIHt1bnJlc29sdmVkRmlsZXMsIGxvY2FsT3BzOiBvcHMsIHJlbW90ZU9wczogcHVzaGVkQ2hhbmdlc31cbiAgICB9XG5cbiAgICBhc3luYyBzeW5jKHN5bmNOb3RpY2U6IEZpdE5vdGljZSk6XG5cdFx0XHRQcm9taXNlPHtcblx0XHRcdFx0XHRvcHM6IEFycmF5PHtoZWFkaW5nOiBzdHJpbmcsIG9wczogRmlsZU9wUmVjb3JkW119Pixcblx0XHRcdFx0XHRjbGFzaDogQ2xhc2hTdGF0dXNbXSxcblx0XHRcdFx0XHQvLyBiYXNlcGF0aDogc3RyaW5nXG5cdFx0XHRcdH0gfCB2b2lkXG5cdFx0XHQ+XG5cdHtcbiAgICAgICAgc3luY05vdGljZS5zZXRNZXNzYWdlKFwiUGVyZm9ybWluZyBwcmUgc3luYyBjaGVja3MuXCIpXG5cdFx0Y29uc3QgcHJlU3luY0NoZWNrUmVzdWx0ID0gYXdhaXQgdGhpcy5wZXJmb3JtUHJlU3luY0NoZWNrcygpO1xuXG4gICAgICAgIC8vIGNvbnZlcnQgdG8gc3dpdGNoIHN0YXRlbWVudCBsYXRlciBvbiBmb3IgYmV0dGVyIG1haW50YWluYWJpbGl0eVxuXHRcdGlmIChwcmVTeW5jQ2hlY2tSZXN1bHQuc3RhdHVzID09PSBcImluU3luY1wiKSB7XG5cdFx0XHRzeW5jTm90aWNlLnNldE1lc3NhZ2UoXCJTeW5jIHN1Y2Nlc3NmdWxcIilcblx0XHRcdHJldHVyblxuXHRcdH1cblxuXHRcdGlmIChwcmVTeW5jQ2hlY2tSZXN1bHQuc3RhdHVzID09PSBcIm9ubHlSZW1vdGVDb21taXRTaGFDaGFuZ2VkXCIpIHtcblx0XHRcdGNvbnN0IHsgbGF0ZXN0UmVtb3RlQ29tbWl0U2hhIH0gPSBwcmVTeW5jQ2hlY2tSZXN1bHQucmVtb3RlVXBkYXRlXG5cdFx0XHRhd2FpdCB0aGlzLnNhdmVMb2NhbFN0b3JlQ2FsbGJhY2soXG4gICAgICAgICAgICAgICAgdGhpcy5maXQuc3luY1BhdGgsXG4gICAgICAgICAgICAgICAge2xhc3RGZXRjaGVkQ29tbWl0U2hhOiBsYXRlc3RSZW1vdGVDb21taXRTaGF9XG4gICAgICAgICAgICApXG5cblx0XHRcdHN5bmNOb3RpY2Uuc2V0TWVzc2FnZShcIlN5bmMgc3VjY2Vzc2Z1bFwiKVxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0Y29uc3QgcmVtb3RlVXBkYXRlID0gcHJlU3luY0NoZWNrUmVzdWx0LnJlbW90ZVVwZGF0ZVxuXHRcdGlmIChwcmVTeW5jQ2hlY2tSZXN1bHQuc3RhdHVzID09PSBcIm9ubHlSZW1vdGVDaGFuZ2VkXCIpIHtcblx0XHRcdGNvbnN0IGZpbGVPcHNSZWNvcmQgPSBhd2FpdCB0aGlzLmZpdFB1bGwucHVsbFJlbW90ZVRvTG9jYWwoXG4gICAgICAgICAgICAgICAgcmVtb3RlVXBkYXRlLFxuICAgICAgICAgICAgICAgIHRoaXMuc2F2ZUxvY2FsU3RvcmVDYWxsYmFja1xuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICBzeW5jTm90aWNlLnNldE1lc3NhZ2UoXCJTeW5jIHN1Y2Nlc3NmdWxcIilcblxuICAgICAgICAgICAgcmV0dXJuIHtcblx0XHRcdFx0b3BzOiBbe2hlYWRpbmc6IFwiTG9jYWwgZmlsZSB1cGRhdGVzOlwiLCBvcHM6IGZpbGVPcHNSZWNvcmR9XSxcblx0XHRcdFx0Y2xhc2g6IFtdLFxuXHRcdFx0XHQvLyBiYXNlcGF0aDogdGhpcy5maXQuc3luY1BhdGhcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjb25zdCB7bG9jYWxDaGFuZ2VzLCBsb2NhbFRyZWVTaGF9ID0gcHJlU3luY0NoZWNrUmVzdWx0XG5cdFx0Y29uc3QgbG9jYWxVcGRhdGUgPSB7XG5cdFx0XHRsb2NhbENoYW5nZXMsXG5cdFx0XHRwYXJlbnRDb21taXRTaGE6IHJlbW90ZVVwZGF0ZS5sYXRlc3RSZW1vdGVDb21taXRTaGFcblx0XHR9XG5cdFx0aWYgKHByZVN5bmNDaGVja1Jlc3VsdC5zdGF0dXMgPT09IFwib25seUxvY2FsQ2hhbmdlZFwiKSB7XG5cdFx0XHRzeW5jTm90aWNlLnNldE1lc3NhZ2UoXCJVcGxvYWRpbmcgbG9jYWwgY2hhbmdlc1wiKVxuXHRcdFx0Y29uc3QgcHVzaFJlc3VsdCA9IGF3YWl0IHRoaXMuZml0UHVzaC5wdXNoQ2hhbmdlZEZpbGVzVG9SZW1vdGUobG9jYWxVcGRhdGUpXG4gICAgICAgICAgICBzeW5jTm90aWNlLnNldE1lc3NhZ2UoXCJTeW5jIHN1Y2Nlc3NmdWxcIilcbiAgICAgICAgICAgIGlmIChwdXNoUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zYXZlTG9jYWxTdG9yZUNhbGxiYWNrKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpdC5zeW5jUGF0aCxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTaGE6IGxvY2FsVHJlZVNoYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RGZXRjaGVkUmVtb3RlU2hhOiBwdXNoUmVzdWx0Lmxhc3RGZXRjaGVkUmVtb3RlU2hhLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEZldGNoZWRDb21taXRTaGE6IHB1c2hSZXN1bHQubGFzdEZldGNoZWRDb21taXRTaGFcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHRcdFx0XHRcdG9wczogW3toZWFkaW5nOiBcIkxvY2FsIGZpbGUgdXBkYXRlczpcIiwgb3BzOiBwdXNoUmVzdWx0LnB1c2hlZENoYW5nZXN9XSxcblx0XHRcdFx0XHRjbGFzaDogW10sXG5cdFx0XHRcdFx0Ly8gYmFzZXBhdGg6IHRoaXMuZml0LnN5bmNQYXRoXG5cdFx0XHRcdH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVyblxuXHRcdH1cblxuXHRcdC8vIGRvIGJvdGggcHVsbCBhbmQgcHVzaCAob3JkZXJzIG9mIGV4ZWN1dGlvbiBkaWZmZXJlbnQgZnJvbSBwdWxsUmVtb3RlVG9Mb2NhbCBhbmRcblx0XHQvLyBwdXNoQ2hhbmdlZEZpbGVzVG9SZW1vdGUgdG8gbWFrZSB0aGlzIG1vcmUgdHJhbnNhY3Rpb24gbGlrZSwgaS5lLiBtYWludGFpbiBvcmlnaW5hbFxuXHRcdC8vIHN0YXRlIGlmIHRoZSB0cmFuc2FjdGlvbiBmYWlsZWQpIElmIHlvdSBoYXZlIGlkZWFzIG9uIGhvdyB0byBtYWtlIHRoaXMgbW9yZSB0cmFuc2FjdGlvbi1saWtlLFxuXHRcdC8vICBwbGVhc2Ugb3BlbiBhbiBpc3N1ZSBvbiB0aGUgZml0IHJlcG9cblx0XHRpZiAocHJlU3luY0NoZWNrUmVzdWx0LnN0YXR1cyA9PT0gXCJsb2NhbEFuZFJlbW90ZUNoYW5nZXNDb21wYXRpYmxlXCIpIHtcblx0XHRcdGNvbnN0IHtsb2NhbE9wcywgcmVtb3RlT3BzfSA9IGF3YWl0IHRoaXMuc3luY0NvbXBhdGlibGVDaGFuZ2VzKFxuXHRcdFx0XHRsb2NhbFVwZGF0ZSwgcmVtb3RlVXBkYXRlLCBzeW5jTm90aWNlKVxuICAgICAgICAgICAgICAgIHJldHVybiAoe1xuICAgICAgICAgICAgICAgICAgICBvcHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtoZWFkaW5nOiBcIkxvY2FsIGZpbGUgdXBkYXRlczpcIiwgb3BzOiBsb2NhbE9wc30sXG4gICAgICAgICAgICAgICAgICAgICAgICB7aGVhZGluZzogXCJSZW1vdGUgZmlsZSB1cGRhdGVzOlwiLCBvcHM6IHJlbW90ZU9wc30sXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIGNsYXNoOiBbXSxcblx0XHRcdFx0XHQvLyBiYXNlcGF0aDogdGhpcy5maXQuc3luY1BhdGhcbiAgICAgICAgICAgICAgICB9KVxuXHRcdH1cblxuXHRcdGlmIChwcmVTeW5jQ2hlY2tSZXN1bHQuc3RhdHVzID09PSBcImxvY2FsQW5kUmVtb3RlQ2hhbmdlc0NsYXNoZWRcIikge1xuXHRcdFx0Y29uc3QgY29uZmxpY3RSZXNvbHV0aW9uUmVzdWx0ID0gYXdhaXQgdGhpcy5zeW5jV2l0aENvbmZsaWN0cyhcblx0XHRcdFx0bG9jYWxVcGRhdGUubG9jYWxDaGFuZ2VzLCByZW1vdGVVcGRhdGUsIHN5bmNOb3RpY2UpXG5cdFx0XHRpZiAoY29uZmxpY3RSZXNvbHV0aW9uUmVzdWx0KSB7XG5cdFx0XHRcdGNvbnN0IHt1bnJlc29sdmVkRmlsZXMsIGxvY2FsT3BzLCByZW1vdGVPcHN9ID0gY29uZmxpY3RSZXNvbHV0aW9uUmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoe1xuXHRcdFx0XHRcdFx0b3BzOltcblx0XHRcdFx0XHRcdFx0e2hlYWRpbmc6IFwiTG9jYWwgZmlsZSB1cGRhdGVzOlwiLCBvcHM6IGxvY2FsT3BzfSxcblx0XHRcdFx0XHRcdFx0e2hlYWRpbmc6IFwiUmVtb3RlIGZpbGUgdXBkYXRlczpcIiwgb3BzOiByZW1vdGVPcHN9LFxuXHRcdFx0XHRcdFx0XSxcblx0XHRcdFx0XHRcdGNsYXNoOiB1bnJlc29sdmVkRmlsZXMsXG5cdFx0XHRcdFx0XHQvLyBiYXNlcGF0aDogdGhpcy5maXQuc3luY1BhdGhcbiAgICAgICAgICAgICAgICAgICAgfSlcblx0XHRcdH1cblx0XHR9XG4gICAgfVxufVxuIiwgImltcG9ydCB7IEZpdCB9IGZyb20gXCIuL2ZpdFwiO1xuaW1wb3J0IHsgTG9jYWxTdG9yZXMgfSBmcm9tIFwibWFpblwiO1xuaW1wb3J0IHsgRmlsZU9wUmVjb3JkLCBMb2NhbENoYW5nZSwgUmVtb3RlQ2hhbmdlLCBSZW1vdGVVcGRhdGUgfSBmcm9tIFwiLi9maXRUeXBlc1wiO1xuXG50eXBlIFByZVB1bGxDaGVja1Jlc3VsdFR5cGUgPSAoXG4gICAgXCJsb2NhbENvcHlVcFRvRGF0ZVwiIHxcbiAgICBcImxvY2FsQ2hhbmdlc0NsYXNoV2l0aFJlbW90ZUNoYW5nZXNcIiB8XG4gICAgXCJyZW1vdGVDaGFuZ2VzQ2FuQmVNZXJnZWRcIiB8XG4gICAgXCJub1JlbW90ZUNoYW5nZXNEZXRlY3RlZFwiXG4pXG5cbnR5cGUgUHJlUHVsbENoZWNrUmVzdWx0ID0gKFxuICAgIHsgc3RhdHVzOiBcImxvY2FsQ29weVVwVG9EYXRlXCIsIHJlbW90ZVVwZGF0ZTogbnVsbCB9IHxcbiAgICB7IHN0YXR1czogRXhjbHVkZTxQcmVQdWxsQ2hlY2tSZXN1bHRUeXBlLCBcImxvY2FsQ29weVVwVG9EYXRlXCI+LCByZW1vdGVVcGRhdGU6IFJlbW90ZVVwZGF0ZSB9XG4pO1xuXG50eXBlIFNhdmVDYWxsYmFjayA9IChwYXRoOiBzdHJpbmcsIGxvY2FsU3RvcmU6IFBhcnRpYWw8TG9jYWxTdG9yZXM+KSA9PiBQcm9taXNlPHZvaWQ+XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUZpdFB1bGwge1xuICAgIGZpdDogRml0XG59XG5cbmV4cG9ydCBjbGFzcyBGaXRQdWxsIGltcGxlbWVudHMgSUZpdFB1bGwge1xuICAgIGZpdDogRml0XG5cblxuICAgIGNvbnN0cnVjdG9yKGZpdDogRml0KSB7XG4gICAgICAgIHRoaXMuZml0ID0gZml0XG4gICAgfVxuXG4gICAgYXN5bmMgcGVyZm9ybVByZVB1bGxDaGVja3MobG9jYWxDaGFuZ2VzPzogTG9jYWxDaGFuZ2VbXSk6IFByb21pc2U8UHJlUHVsbENoZWNrUmVzdWx0PiB7XG4gICAgICAgIGNvbnN0IHtyZW1vdGVDb21taXRTaGEsIHVwZGF0ZWR9ID0gYXdhaXQgdGhpcy5maXQucmVtb3RlVXBkYXRlZCgpXG4gICAgICAgIGlmICghdXBkYXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtzdGF0dXM6IFwibG9jYWxDb3B5VXBUb0RhdGVcIiwgcmVtb3RlVXBkYXRlOiBudWxsfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbG9jYWxDaGFuZ2VzKSB7XG4gICAgICAgICAgICBsb2NhbENoYW5nZXMgPSBhd2FpdCB0aGlzLmZpdC5nZXRMb2NhbENoYW5nZXMoKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlbW90ZVRyZWVTaGEgPSBhd2FpdCB0aGlzLmZpdC5nZXRSZW1vdGVUcmVlU2hhKHJlbW90ZUNvbW1pdFNoYSlcbiAgICAgICAgY29uc3QgcmVtb3RlQ2hhbmdlcyA9IGF3YWl0IHRoaXMuZml0LmdldFJlbW90ZUNoYW5nZXMocmVtb3RlVHJlZVNoYSlcbiAgICAgICAgY29uc3QgY2xhc2hlZEZpbGVzID0gdGhpcy5maXQuZ2V0Q2xhc2hlZENoYW5nZXMobG9jYWxDaGFuZ2VzLCByZW1vdGVDaGFuZ2VzKVxuICAgICAgICAvLyBUT0RPIGhhbmRsZSBjbGFzaGVzIHdpdGhvdXQgY29tcGxldGVseSBibG9ja2luZyBwdWxsXG4gICAgICAgIGNvbnN0IHByZVB1bGxDaGVja1N0YXR1cyA9IChcbiAgICAgICAgICAgIChyZW1vdGVDaGFuZ2VzLmxlbmd0aCA+IDApID8gKFxuICAgICAgICAgICAgICAgIChjbGFzaGVkRmlsZXMubGVuZ3RoID4gMCkgPyBcImxvY2FsQ2hhbmdlc0NsYXNoV2l0aFJlbW90ZUNoYW5nZXNcIiA6IFwicmVtb3RlQ2hhbmdlc0NhbkJlTWVyZ2VkXCIpOlxuICAgICAgICAgICAgICAgIFwibm9SZW1vdGVDaGFuZ2VzRGV0ZWN0ZWRcIilcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdHVzOiBwcmVQdWxsQ2hlY2tTdGF0dXMsXG4gICAgICAgICAgICByZW1vdGVVcGRhdGU6IHtcbiAgICAgICAgICAgICAgICByZW1vdGVDaGFuZ2VzLCByZW1vdGVUcmVlU2hhLCBsYXRlc3RSZW1vdGVDb21taXRTaGE6IHJlbW90ZUNvbW1pdFNoYSwgY2xhc2hlZEZpbGVzXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHZXQgY2hhbmdlcyBmcm9tIHJlbW90ZSwgcGF0aFNoYU1hcCBpcyBjb3VwbGVkIHRvIHRoZSBGaXQgcGx1Z2luIGRlc2lnblxuICAgIGFzeW5jIGdldFJlbW90ZU5vbkRlbGV0aW9uQ2hhbmdlc0NvbnRlbnQocGF0aFNoYU1hcDogUmVjb3JkPHN0cmluZywgc3RyaW5nPikge1xuICAgICAgICBjb25zdCByZW1vdGVDaGFuZ2VzID0gT2JqZWN0LmVudHJpZXMocGF0aFNoYU1hcCkubWFwKGFzeW5jIChbcGF0aCwgZmlsZV9zaGFdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy5maXQuZ2V0QmxvYihmaWxlX3NoYSk7XG4gICAgICAgICAgICByZXR1cm4ge3BhdGgsIGNvbnRlbnR9O1xuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwocmVtb3RlQ2hhbmdlcylcbiAgICB9XG5cbiAgICBhc3luYyBwcmVwYXJlQ2hhbmdlc1RvRXhlY3V0ZShyZW1vdGVDaGFuZ2VzOiBSZW1vdGVDaGFuZ2VbXSkge1xuICAgICAgICBjb25zdCBkZWxldGVGcm9tTG9jYWwgPSByZW1vdGVDaGFuZ2VzLmZpbHRlcihjPT5jLnN0YXR1cz09XCJSRU1PVkVEXCIpLm1hcChjPT5jLnBhdGgpXG4gICAgICAgIGNvbnN0IGNoYW5nZXNUb1Byb2Nlc3MgPSByZW1vdGVDaGFuZ2VzLmZpbHRlcihjPT5jLnN0YXR1cyE9XCJSRU1PVkVEXCIpLnJlZHVjZShcbiAgICAgICAgICAgIChhY2MsIGNoYW5nZSkgPT4ge1xuICAgICAgICAgICAgICAgIGFjY1tjaGFuZ2UucGF0aF0gPSBjaGFuZ2UuY3VycmVudFNoYSBhcyBzdHJpbmc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH0sIHt9IGFzIFJlY29yZDxzdHJpbmcsIHN0cmluZz4pO1xuXG4gICAgICAgICAgICBjb25zdCBhZGRUb0xvY2FsID0gYXdhaXQgdGhpcy5nZXRSZW1vdGVOb25EZWxldGlvbkNoYW5nZXNDb250ZW50KGNoYW5nZXNUb1Byb2Nlc3MpXG4gICAgICAgIHJldHVybiB7YWRkVG9Mb2NhbCwgZGVsZXRlRnJvbUxvY2FsfVxuICAgIH1cblxuICAgIGFzeW5jIHB1bGxSZW1vdGVUb0xvY2FsKFxuICAgICAgICByZW1vdGVVcGRhdGU6IFJlbW90ZVVwZGF0ZSxcbiAgICAgICAgc2F2ZUxvY2FsU3RvcmVDYWxsYmFjazogU2F2ZUNhbGxiYWNrXG4gICAgKSA6IFByb21pc2U8RmlsZU9wUmVjb3JkW10+XG4gICAge1xuICAgICAgICAgICAgY29uc3Qge3JlbW90ZUNoYW5nZXMsIHJlbW90ZVRyZWVTaGEsIGxhdGVzdFJlbW90ZUNvbW1pdFNoYX0gPSByZW1vdGVVcGRhdGVcbiAgICAgICAgICAgIGxldCB7YWRkVG9Mb2NhbCwgZGVsZXRlRnJvbUxvY2FsfSA9IGF3YWl0IHRoaXMucHJlcGFyZUNoYW5nZXNUb0V4ZWN1dGUocmVtb3RlQ2hhbmdlcylcblxuICAgICAgICAgICAgY29uc3QgYmFzZXBhdGggPSB0aGlzLmZpdC5zeW5jUGF0aFxuXHRcdFx0YWRkVG9Mb2NhbCA9IGFkZFRvTG9jYWxcblx0XHRcdFx0Lm1hcChcblx0XHRcdFx0XHQoe3BhdGgsIGNvbnRlbnR9KSA9PiB7XG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRwYXRoOiBiYXNlcGF0aCtwYXRoLFxuXHRcdFx0XHRcdFx0XHRjb250ZW50XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpXG5cdFx0XHRcdC5maWx0ZXIoXG5cdFx0XHRcdFx0ZmlsZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBleGNsdWRlcyA9IHRoaXMuZml0LmV4Y2x1ZGVzXG4gICAgICAgICAgICBpZiAoIWV4Y2x1ZGVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgcmV0dXJuIGV4Y2x1ZGVzLnNvbWUoXG4gICAgICAgICAgICAgIGV4Y2x1ZGUgPT4gIWZpbGUucGF0aC5zdGFydHNXaXRoKGV4Y2x1ZGUpXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuXHRcdFx0XHQpXG5cblx0XHRcdGRlbGV0ZUZyb21Mb2NhbCA9IGRlbGV0ZUZyb21Mb2NhbFxuXHRcdFx0XHQubWFwKFxuXHRcdFx0XHRcdHBhdGggPT4gYmFzZXBhdGggKyBwYXRoXG5cdFx0XHRcdClcblx0XHRcdFx0LmZpbHRlcihcblx0XHRcdFx0XHRwYXRoID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4Y2x1ZGVzID0gdGhpcy5maXQuZXhjbHVkZXNcbiAgICAgICAgICAgIGlmICghZXhjbHVkZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG5cbiAgICAgICAgICAgIHJldHVybiBleGNsdWRlcy5zb21lKFxuICAgICAgICAgICAgICBleGNsdWRlID0+ICFwYXRoLnN0YXJ0c1dpdGgoZXhjbHVkZSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIClcblxuXHRcdFx0Y29uc3QgZmlsZU9wc1JlY29yZCA9IGF3YWl0IHRoaXMuZml0LnZhdWx0T3BzLnVwZGF0ZUxvY2FsRmlsZXMoXG4gICAgICAgICAgICAgICAgYWRkVG9Mb2NhbCxcbiAgICAgICAgICAgICAgICBkZWxldGVGcm9tTG9jYWxcbiAgICAgICAgICAgICk7XG5cblx0XHRcdGF3YWl0IHNhdmVMb2NhbFN0b3JlQ2FsbGJhY2soXG4gICAgICAgICAgICAgICAgYmFzZXBhdGgsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBsYXN0RmV0Y2hlZFJlbW90ZVNoYTogcmVtb3RlVHJlZVNoYSxcbiAgICAgICAgICAgICAgICAgICAgbGFzdEZldGNoZWRDb21taXRTaGE6IGxhdGVzdFJlbW90ZUNvbW1pdFNoYSxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTaGE6IGF3YWl0IHRoaXMuZml0LmNvbXB1dGVMb2NhbFNoYSgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuIGZpbGVPcHNSZWNvcmRcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgRml0LCBUcmVlTm9kZSB9IGZyb20gXCIuL2ZpdFwiO1xuaW1wb3J0IHsgTG9jYWxDaGFuZ2UsIExvY2FsVXBkYXRlIH0gZnJvbSBcIi4vZml0VHlwZXNcIjtcblxuXG5leHBvcnQgaW50ZXJmYWNlIElGaXRQdXNoIHtcbiAgICBsb2NhbFNoYTogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICAgIGZpdDogRml0XG59XG5cbmV4cG9ydCBjbGFzcyBGaXRQdXNoIGltcGxlbWVudHMgSUZpdFB1c2gge1xuICAgIGxvY2FsU2hhOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICAgIGZpdDogRml0XG5cblxuICAgIGNvbnN0cnVjdG9yKGZpdDogRml0KSB7XG4gICAgICAgIHRoaXMuZml0ID0gZml0XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlQ29tbWl0RnJvbUxvY2FsVXBkYXRlKGxvY2FsVXBkYXRlOiBMb2NhbFVwZGF0ZSwgcmVtb3RlVHJlZTogQXJyYXk8VHJlZU5vZGU+KTogUHJvbWlzZTx7Y3JlYXRlZENvbW1pdFNoYTogc3RyaW5nLCBwdXNoZWRDaGFuZ2VzOiBMb2NhbENoYW5nZVtdfSB8IG51bGw+IHtcbiAgICAgICAgY29uc3Qge2xvY2FsQ2hhbmdlcywgcGFyZW50Q29tbWl0U2hhfSA9IGxvY2FsVXBkYXRlXG4gICAgICAgIGNvbnN0IHB1c2hlZENoYW5nZXM6IExvY2FsQ2hhbmdlW10gPSBbXTtcbiAgICAgICAgY29uc3QgdHJlZU5vZGVzID0gKGF3YWl0IFByb21pc2UuYWxsKGxvY2FsQ2hhbmdlcy5tYXAoYXN5bmMgKGYsIGkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSAgYXdhaXQgdGhpcy5maXQuY3JlYXRlVHJlZU5vZGVGcm9tRmlsZShmLCByZW1vdGVUcmVlKVxuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBwdXNoZWRDaGFuZ2VzLnB1c2gobG9jYWxDaGFuZ2VzW2ldKVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKSkuZmlsdGVyKEJvb2xlYW4pIGFzIEFycmF5PFRyZWVOb2RlPlxuICAgICAgICBjb25zb2xlLmxvZyh0cmVlTm9kZXMpXG4gICAgICAgIGlmICh0cmVlTm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhdGVzdFJlbW90ZUNvbW1pdFRyZWVTaGEgPSBhd2FpdCB0aGlzLmZpdC5nZXRDb21taXRUcmVlU2hhKHBhcmVudENvbW1pdFNoYSlcbiAgICAgICAgY29uc3QgY3JlYXRlZFRyZWVTaGEgPSBhd2FpdCB0aGlzLmZpdC5jcmVhdGVUcmVlKHRyZWVOb2RlcywgbGF0ZXN0UmVtb3RlQ29tbWl0VHJlZVNoYSlcbiAgICAgICAgY29uc3QgY3JlYXRlZENvbW1pdFNoYSA9IGF3YWl0IHRoaXMuZml0LmNyZWF0ZUNvbW1pdChjcmVhdGVkVHJlZVNoYSwgcGFyZW50Q29tbWl0U2hhKVxuICAgICAgICByZXR1cm4ge2NyZWF0ZWRDb21taXRTaGEsIHB1c2hlZENoYW5nZXN9XG4gICAgfVxuXG5cblxuICAgIGFzeW5jIHB1c2hDaGFuZ2VkRmlsZXNUb1JlbW90ZShcbiAgICAgICAgbG9jYWxVcGRhdGU6IExvY2FsVXBkYXRlLFxuICAgICAgICApOiBQcm9taXNlPHtwdXNoZWRDaGFuZ2VzOiBMb2NhbENoYW5nZVtdLCBsYXN0RmV0Y2hlZFJlbW90ZVNoYTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiwgbGFzdEZldGNoZWRDb21taXRTaGE6IHN0cmluZ318bnVsbD4ge1xuICAgICAgICAgICAgaWYgKGxvY2FsVXBkYXRlLmxvY2FsQ2hhbmdlcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGRpZCBub3QgdXBkYXRlIHJlZlxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb25zdCB7bG9jYWxUcmVlU2hhfSA9IGxvY2FsVXBkYXRlO1xuICAgICAgICAgICAgY29uc3QgcmVtb3RlVHJlZSA9IGF3YWl0IHRoaXMuZml0LmdldFRyZWUobG9jYWxVcGRhdGUucGFyZW50Q29tbWl0U2hhKVxuICAgICAgICAgICAgY29uc3QgY3JlYXRlQ29tbWl0UmVzdWx0ID0gYXdhaXQgdGhpcy5jcmVhdGVDb21taXRGcm9tTG9jYWxVcGRhdGUobG9jYWxVcGRhdGUsIHJlbW90ZVRyZWUpXG4gICAgICAgICAgICBpZiAoIWNyZWF0ZUNvbW1pdFJlc3VsdCkge1xuICAgICAgICAgICAgICAgIC8vIGRpZCBub3QgdXBkYXRlIHJlZlxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7Y3JlYXRlZENvbW1pdFNoYSwgcHVzaGVkQ2hhbmdlc30gPSBjcmVhdGVDb21taXRSZXN1bHRcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRSZWZTaGEgPSBhd2FpdCB0aGlzLmZpdC51cGRhdGVSZWYoY3JlYXRlZENvbW1pdFNoYSlcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRSZW1vdGVUcmVlU2hhID0gYXdhaXQgdGhpcy5maXQuZ2V0UmVtb3RlVHJlZVNoYSh1cGRhdGVkUmVmU2hhKVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwdXNoZWRDaGFuZ2VzLFxuICAgICAgICAgICAgICAgIGxhc3RGZXRjaGVkUmVtb3RlU2hhOiB1cGRhdGVkUmVtb3RlVHJlZVNoYSxcbiAgICAgICAgICAgICAgICBsYXN0RmV0Y2hlZENvbW1pdFNoYTogY3JlYXRlZENvbW1pdFNoYSxcbiAgICAgICAgICAgIH1cbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgTGlzdGVkRmlsZXMsIFRGaWxlLCBURm9sZGVyLCBWYXVsdCwgYmFzZTY0VG9BcnJheUJ1ZmZlciB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgRmlsZU9wUmVjb3JkIH0gZnJvbSBcIi4vZml0VHlwZXNcIjtcblxudHlwZSBGaWxlc0ZvbGRlcnMgPSB7XG4gICAgZm9sZGVyczogc3RyaW5nW11cbiAgICBmaWxlczogc3RyaW5nW11cbn1cblxuZXhwb3J0IGludGVyZmFjZSBJVmF1bHRPcGVyYXRpb25zIHtcbiAgICB2YXVsdDogVmF1bHRcbiAgICBkZWxldGVGcm9tTG9jYWw6IChwYXRoOiBzdHJpbmcpID0+IFByb21pc2U8RmlsZU9wUmVjb3JkIHwgbnVsbD5cbiAgICB3cml0ZVRvTG9jYWw6IChwYXRoOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZykgPT4gUHJvbWlzZTxGaWxlT3BSZWNvcmQ+XG4gICAgdXBkYXRlTG9jYWxGaWxlczogKFxuICAgICAgICBhZGRUb0xvY2FsOiB7cGF0aDogc3RyaW5nLCBjb250ZW50OiBzdHJpbmd9W10sXG4gICAgICAgIGRlbGV0ZUZyb21Mb2NhbDogQXJyYXk8c3RyaW5nPlxuICAgICkgPT4gUHJvbWlzZTxGaWxlT3BSZWNvcmRbXT5cblxuICAgIGNyZWF0ZUNvcHlJbkRpcjogKHBhdGg6IHN0cmluZywgY29weURpcjogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+XG59XG5cbmV4cG9ydCBjbGFzcyBWYXVsdE9wZXJhdGlvbnMgaW1wbGVtZW50cyBJVmF1bHRPcGVyYXRpb25zIHtcbiAgICB2YXVsdDogVmF1bHRcblxuICAgIGNvbnN0cnVjdG9yKHZhdWx0OiBWYXVsdCkge1xuICAgICAgICB0aGlzLnZhdWx0ID0gdmF1bHRcbiAgICB9XG5cbiAgICBhc3luYyBnZXRURmlsZShwYXRoOiBzdHJpbmcpOiBQcm9taXNlPFRGaWxlIHwgbnVsbD4ge1xuICAgICAgICBjb25zdCBmaWxlID0gdGhpcy52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocGF0aClcbiAgICAgICAgaWYgKGZpbGUgJiYgZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY29uc29sZS5lcnJvcihgQXR0ZW1wdGluZyB0byByZWFkICR7cGF0aH0gZnJvbSBsb2NhbCBkcml2ZSBhcyBURmlsZSBidXQgbm90IHN1Y2Nlc3NmdWwsXG4gICAgICAgICAgICAvLyBmaWxlIGlzIG9mIHR5cGUgJHt0eXBlb2YgZmlsZX0uYClcblxuXHRcdFx0cmV0dXJuIG51bGxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGRlbGV0ZUZyb21Mb2NhbChwYXRoOiBzdHJpbmcpOiBQcm9taXNlPEZpbGVPcFJlY29yZCB8IG51bGw+IHtcbiAgICAgICAgLy8gYWRvcHRlZCBnZXRBYnN0cmFjdEZpbGVCeVBhdGggZm9yIG1vYmlsZSBjb21wYXRpYWJpbGl0eVxuXHRcdC8vIHVzZSBhZGFwdGVyIGZvciBmaWxlcyBpbiB0aGUgLm9ic2lkaWFuXG4gICAgICAgIC8vIGNvbnN0IGZpbGUgPSB0aGlzLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwYXRoKVxuXHRcdGNvbnN0IGlzRXhpc3RzID0gYXdhaXQgdGhpcy52YXVsdC5hZGFwdGVyLmV4aXN0cyhwYXRoKVxuICAgICAgICBpZiAoIWlzRXhpc3RzKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKGBBdHRlbXB0aW5nIHRvIHJlYWQgJHtwYXRofSBmcm9tIGxvY2FsIGRyaXZlIGJ1dCBub3Qgc3VjY2Vzc2Z1bDpcblx0XHRcdFx0dGhlIGZpbGUgZG9lc24ndCBleGlzdHNgKVxuXG5cdFx0XHRyZXR1cm4gbnVsbFxuXHRcdH1cblxuXHRcdGF3YWl0IHRoaXMudmF1bHQuYWRhcHRlci5yZW1vdmUocGF0aCk7XG5cdFx0cmV0dXJuIHtwYXRoLCBzdGF0dXM6IFwiZGVsZXRlZFwifVxuICAgIH1cblxuICAgIC8vIGlmIGNoZWNraW5nIGEgZm9sZGVyLCByZXF1aXJlIGluY2x1ZGluZyB0aGUgbGFzdCAvIGluIHRoZSBwYXRoIHBhcmFtXG4gICAgYXN5bmMgZW5zdXJlRm9sZGVyRXhpc3RzKHBhdGg6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICAvLyBleHRyYWN0IGZvbGRlciBwYXRoLCByZXR1cm4gZW1wdHkgc3RyaW5nIGlzIG5vIGZvbGRlciBwYXRoIGlzIG1hdGNoZWQgKGV4Y2x1ZGUgdGhlIGxhc3QgLylcbiAgICAgICAgY29uc3QgZm9sZGVyUGF0aCA9IHBhdGgubWF0Y2goL14oLiopXFwvLyk/LlsxXSB8fCAnJztcbiAgICAgICAgaWYgKGZvbGRlclBhdGggPT0gXCJcIikge1xuXHRcdFx0cmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAvLyBjb25zdCBmb2xkZXIgPSB0aGlzLnZhdWx0LmFkYXB0ZXIuZXhpc3RzKGZvbGRlclBhdGgpXG4gICAgICAgICAgICAvLyBpZiAoIWZvbGRlcikge1xuXHRcdFx0Ly8gXHQvLyBUT0RPIFx1MDQ0N1x1MDQ0Mlx1MDQzRSBcdTA0MzVcdTA0NDFcdTA0M0JcdTA0MzggXHUwNDNEXHUwNDM1XHUwNDQxXHUwNDNBXHUwNDNFXHUwNDNCXHUwNDRDXHUwNDNBXHUwNDNFIFx1MDQzMlx1MDQzQlx1MDQzRVx1MDQzNlx1MDQzNVx1MDQzRFx1MDQzRFx1MDQ0Qlx1MDQ0NSBcdTA0M0ZcdTA0MzBcdTA0M0ZcdTA0M0VcdTA0M0EgKG1rZGlyIC1wIC4uLi4pXG4gICAgICAgICAgICAvLyAgICAgYXdhaXQgdGhpcy52YXVsdC5hZGFwdGVyLm1rZGlyKGZvbGRlclBhdGgpXG4gICAgICAgICAgICAvLyB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFydHMgPSBmb2xkZXJQYXRoLnNwbGl0KCcvJyk7XG4gICAgICAgIGxldCBjdXJyZW50UGF0aCA9ICcnO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICAgICAgICAgIGN1cnJlbnRQYXRoICs9IHBhcnQgKyAnLyc7XG4gICAgICAgICAgICB0cnkge1xuXHRcdFx0XHRjb25zdCBpc0V4aXN0cyA9IGF3YWl0IHRoaXMudmF1bHQuYWRhcHRlci5leGlzdHMoY3VycmVudFBhdGgsIHRydWUpXG5cbiAgICAgICAgICAgICAgICBpZiAoaXNFeGlzdHMpXG5cdFx0XHRcdFx0Y29udGludWVcblxuXHRcdFx0XHRhd2FpdCB0aGlzLnZhdWx0LmFkYXB0ZXIubWtkaXIoY3VycmVudFBhdGgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXHRcdHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgYXN5bmMgd3JpdGVUb0xvY2FsKHBhdGg6IHN0cmluZywgY29udGVudDogc3RyaW5nKTogUHJvbWlzZTxGaWxlT3BSZWNvcmQ+IHtcbiAgICAgICAgLy8gVE9ETzogYWRkIGNhcGFiaWxpdHkgZm9yIGNyZWF0aW5nIGZvbGRlciBmcm9tIHJlbW90ZVxuICAgICAgICBjb25zdCBmaWxlID0gYXdhaXQgdGhpcy52YXVsdC5hZGFwdGVyLmV4aXN0cyhwYXRoKVxuXG5cdFx0Ly8gVE9ETyByZWZhY3RvciBpZiBlbHNlXG4gICAgICAgIGlmIChmaWxlKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnZhdWx0LmFkYXB0ZXIud3JpdGVCaW5hcnkocGF0aCwgYmFzZTY0VG9BcnJheUJ1ZmZlcihjb250ZW50KSlcbiAgICAgICAgICAgIHJldHVybiB7cGF0aCwgc3RhdHVzOiBcImNoYW5nZWRcIn1cbiAgICAgICAgfVxuXHRcdGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5lbnN1cmVGb2xkZXJFeGlzdHMocGF0aClcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudmF1bHQuYWRhcHRlci53cml0ZUJpbmFyeShwYXRoLCBiYXNlNjRUb0FycmF5QnVmZmVyKGNvbnRlbnQpKVxuICAgICAgICAgICAgcmV0dXJuIHtwYXRoLCBzdGF0dXM6IFwiY3JlYXRlZFwifVxuICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoYCR7cGF0aH06IHdyaXRlVG9Mb2NhbCBvcGVyYXRpb24gdW5zdWNjZXNzZnVsYCk7XG4gICAgfVxuXG4gICAgYXN5bmMgdXBkYXRlTG9jYWxGaWxlcyhcbiAgICAgICAgYWRkVG9Mb2NhbDoge3BhdGg6IHN0cmluZywgY29udGVudDogc3RyaW5nfVtdLFxuICAgICAgICBkZWxldGVGcm9tTG9jYWw6IEFycmF5PHN0cmluZz4pOiBQcm9taXNlPEZpbGVPcFJlY29yZFtdPlxuICAgIHtcbiAgICAgICAgLy8gUHJvY2VzcyBmaWxlIGFkZGl0aW9ucyBvciB1cGRhdGVzXG4gICAgICAgIGNvbnN0IHdyaXRlT3BlcmF0aW9ucyA9IGFkZFRvTG9jYWwubWFwKGFzeW5jICh7cGF0aCwgY29udGVudH0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLndyaXRlVG9Mb2NhbChwYXRoLCBjb250ZW50KVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBQcm9jZXNzIGZpbGUgZGVsZXRpb25zXG4gICAgICAgIGNvbnN0IGRlbGV0aW9uT3BlcmF0aW9ucyA9IGRlbGV0ZUZyb21Mb2NhbC5tYXAoYXN5bmMgKHBhdGgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmRlbGV0ZUZyb21Mb2NhbChwYXRoKVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZmlsZU9wcyA9IGF3YWl0IFByb21pc2UuYWxsKFsuLi53cml0ZU9wZXJhdGlvbnMsIC4uLmRlbGV0aW9uT3BlcmF0aW9uc10pO1xuXG4gICAgICAgIHJldHVybiBmaWxlT3BzIGFzIEZpbGVPcFJlY29yZFtdXG4gICAgfVxuXG5cdC8vIFRPRE8gXHUwNDQ1XHUwNDNFXHUwNDQyXHUwNDRGIFx1MDQzRFx1MDQzOFx1MDQzM1x1MDQzNFx1MDQzNSBcdTA0M0RcdTA0MzUgXHUwNDM4XHUwNDQxXHUwNDNGXHUwNDNFXHUwNDNCXHUwNDRDXHUwNDM3XHUwNDQzXHUwNDM1XHUwNDQyXHUwNDQxXHUwNDRGLCBcdTA0M0NcdTA0MzEgXHUwNDQzXHUwNDM0XHUwNDMwXHUwNDNCXHUwNDM4XHUwNDQyXHUwNDRDIFx1MDQzRFx1MDQzMFx1MDQzNFx1MDQzRVxuICAgIGFzeW5jIGNyZWF0ZUNvcHlJbkRpcihwYXRoOiBzdHJpbmcsIGNvcHlEaXIgPSBcIl9maXRcIik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBmaWxlID0gYXdhaXQgdGhpcy52YXVsdC5hZGFwdGVyLmV4aXN0cyhwYXRoKVxuICAgICAgICBpZiAoZmlsZSkge1xuICAgICAgICAgICAgY29uc3QgY29weVBhdGggPSBgJHtjb3B5RGlyfS8ke3BhdGh9YFxuXG4gICAgICAgICAgICBjb25zdCBjb3B5ID0gYXdhaXQgdGhpcy52YXVsdC5hZGFwdGVyLnJlYWRCaW5hcnkocGF0aClcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlRm9sZGVyRXhpc3RzKGNvcHlQYXRoKVxuXG5cdFx0XHQvLyBUT0RPIFx1MDQzN1x1MDQzNFx1MDQzNVx1MDQ0MVx1MDQ0QyBcdTA0MzdcdTA0MzBcdTA0M0ZcdTA0MzhcdTA0NDFcdTA0NEJcdTA0MzJcdTA0MzBcdTA0MzVcdTA0NDJcdTA0NDFcdTA0NEYgXHUwNDMyIF9maXRcbiAgICAgICAgICAgIGNvbnN0IGNvcHlGaWxlID0gYXdhaXQgdGhpcy52YXVsdC5hZGFwdGVyLmV4aXN0cyhwYXRoKVxuICAgICAgICAgICAgLy8gaWYgKGNvcHlGaWxlKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy52YXVsdC5hZGFwdGVyLndyaXRlQmluYXJ5KGNvcHlQYXRoLCBjb3B5KVxuICAgICAgICAgICAgLy8gfSBlbHNlIGlmICghY29weUZpbGUpIHtcbiAgICAgICAgICAgIC8vICAgICBhd2FpdCB0aGlzLnZhdWx0LmNyZWF0ZUJpbmFyeShjb3B5UGF0aCwgY29weSlcblx0XHRcdC8vIH1cbiAgICAgICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyAgICAgdGhpcy52YXVsdC5hZGFwdGVyLnJlbW92ZShjb3B5RmlsZSkgLy8gVE9ETyBhZGQgd2FybmluZyB0byBsZXQgdXNlciBrbm93IGZpbGVzIGluIF9maXQgd2lsbCBiZSBvdmVyd3JpdHRlblxuICAgICAgICAgICAgLy8gICAgIGF3YWl0IHRoaXMudmF1bHQuY3JlYXRlQmluYXJ5KGNvcHlQYXRoLCBjb3B5KVxuICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnZhdWx0LmFkYXB0ZXIud3JpdGVCaW5hcnkoY29weVBhdGgsIGNvcHkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEF0dGVtcHRpbmcgdG8gY3JlYXRlIGNvcHkgb2YgJHtwYXRofSBmcm9tIGxvY2FsIGRyaXZlIGFzIFRGaWxlIGJ1dCBub3Qgc3VjY2Vzc2Z1bCxcbiAgICAgICAgICAgIGZpbGUgaXMgb2YgdHlwZSAke3R5cGVvZiBmaWxlfS5gKVxuICAgICAgICB9XG4gICAgfVxuXG5cdGFzeW5jIGdldEFsbEluT2JzaWRpYW4oKTogUHJvbWlzZTxGaWxlc0ZvbGRlcnM+IHtcblx0XHRjb25zdCByb290UGF0aCA9IHRoaXMudmF1bHQuY29uZmlnRGlyO1xuXG5cdFx0Y29uc3QgZm9sZGVyczogc3RyaW5nW10gPSBbcm9vdFBhdGggKyBcIi9cIl07XG5cdFx0Y29uc3QgZmlsZXM6IHN0cmluZ1tdID0gW107XG5cblx0XHRjb25zdCB0cmF2ZXJzZURpcmVjdG9yeSA9IGFzeW5jIChwYXRoOiBzdHJpbmcpID0+IHtcblx0XHRcdGxldCBpdGVtczogTGlzdGVkRmlsZXNcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGl0ZW1zID0gYXdhaXQgdGhpcy52YXVsdC5hZGFwdGVyLmxpc3QocGF0aCk7XG5cdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHQvLyBjb25zb2xlLmVycm9yKGBFcnJvciB0cmF2ZXJzaW5nIGRpcmVjdG9yeSAke3BhdGh9OmAsIGVycm9yKTtcblx0XHRcdFx0cmV0dXJuIG51bGxcblx0XHRcdH1cblxuXHRcdFx0Zm9yIChjb25zdCBmb2xkZXIgb2YgaXRlbXMuZm9sZGVycykge1xuXHRcdFx0XHRhd2FpdCB0cmF2ZXJzZURpcmVjdG9yeShmb2xkZXIpO1xuXG5cdFx0XHRcdGxldCBmb2xkZXJQYXRoID0gZm9sZGVyLnN0YXJ0c1dpdGgoJy8nKSA/IGZvbGRlci5zbGljZSgxKSA6IGZvbGRlcjtcblx0XHRcdFx0Zm9sZGVyUGF0aCA9IGZvbGRlclBhdGggPT09IFwiXCIgPyBcIlwiIDogYCR7Zm9sZGVyUGF0aH0vYDtcblxuXHRcdFx0XHRmb2xkZXJzLnB1c2goZm9sZGVyUGF0aCk7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoY29uc3QgZmlsZSBvZiBpdGVtcy5maWxlcykge1xuXHRcdFx0XHRsZXQgZmlsZVBhdGggPSBmaWxlLnN0YXJ0c1dpdGgoJy8nKSA/IGZpbGUuc2xpY2UoMSkgOiBmaWxlO1xuXG5cdFx0XHRcdGZpbGVzLnB1c2goZmlsZVBhdGgpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRhd2FpdCB0cmF2ZXJzZURpcmVjdG9yeShyb290UGF0aCk7XG5cblx0XHRyZXR1cm4ge2ZvbGRlcnMsIGZpbGVzfVxuXHR9XG5cblx0YXN5bmMgZ2V0QWxsSW5WYXVsdCgpOiBQcm9taXNlPEZpbGVzRm9sZGVycz4ge1xuXHRcdGNvbnN0IGFsbCA9IHRoaXMudmF1bHQuZ2V0QWxsTG9hZGVkRmlsZXMoKTtcblxuXHRcdGNvbnN0IGZvbGRlcnM6IHN0cmluZ1tdID0gW107XG5cdFx0Y29uc3QgZmlsZXM6IHN0cmluZ1tdID0gW107XG5cblx0XHRmb3IgKGxldCBmaWxlIG9mIGFsbCkge1xuXHRcdFx0aWYgKGZpbGUgaW5zdGFuY2VvZiBURm9sZGVyKSB7XG5cdFx0XHRcdGxldCBwYXRoID0gZmlsZS5wYXRoLnN0YXJ0c1dpdGgoJy8nKSA/IGZpbGUucGF0aC5zbGljZSgxKSA6IGZpbGUucGF0aDtcbiAgICAgICAgICAgICAgICBwYXRoID0gcGF0aCA9PSBcIlwiID8gXCJcIiA6IGAke3BhdGh9L2Bcblx0XHRcdFx0Zm9sZGVycy5wdXNoKHBhdGgpO1xuXHRcdFx0fVxuICAgICAgICAgICAgZWxzZSBpZiAoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XG5cdFx0XHRcdGNvbnN0IHBhdGggPSBmaWxlLnBhdGguc3RhcnRzV2l0aCgnLycpID8gZmlsZS5wYXRoLnNsaWNlKDEpIDogZmlsZS5wYXRoO1xuXHRcdFx0XHRmaWxlcy5wdXNoKHBhdGgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIC5vYnNpZGlhbiBmb2xkZXJcblx0XHRjb25zdCBvYnNpZGlhbkl0ZW1zID0gYXdhaXQgdGhpcy5nZXRBbGxJbk9ic2lkaWFuKClcblx0XHRjb25zdCBbb2JzaWRpYW5GaWxlcywgb2JzaWRpYW5Gb2xkZXJzXSA9IFtvYnNpZGlhbkl0ZW1zLmZpbGVzLCBvYnNpZGlhbkl0ZW1zLmZvbGRlcnNdXG5cblx0XHRmb2xkZXJzLnB1c2goLi4ub2JzaWRpYW5Gb2xkZXJzKVxuXHRcdGZpbGVzLnB1c2goLi4ub2JzaWRpYW5GaWxlcylcblxuXHRcdHJldHVybiB7Zm9sZGVycywgZmlsZXN9O1xuICAgIH1cblxuXHRhc3luYyBnZXRGb2xkZXJzSW5WYXVsdCgpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgICAgIGNvbnN0IHtmb2xkZXJzfSA9IGF3YWl0IHRoaXMuZ2V0QWxsSW5WYXVsdCgpXG5cblx0XHRyZXR1cm4gZm9sZGVycztcblx0fVxuXG5cdGFzeW5jIGdldEZpbGVzSW5WYXVsdCgpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgICAgIGNvbnN0IHtmaWxlc30gPSBhd2FpdCB0aGlzLmdldEFsbEluVmF1bHQoKVxuXG5cdFx0cmV0dXJuIGZpbGVzO1xuXHR9XG59XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLG1CQUFtQzs7O0FDQTVCLFNBQVMsZUFBZTtBQUM3QixNQUFJLE9BQU8sY0FBYyxZQUFZLGVBQWUsV0FBVztBQUM3RCxXQUFPLFVBQVU7QUFBQSxFQUNuQjtBQUVBLE1BQUksT0FBTyxZQUFZLFlBQVksUUFBUSxZQUFZLFFBQVc7QUFDaEUsV0FBTyxXQUFXLFFBQVEsUUFBUSxPQUFPLENBQUMsTUFBTSxRQUFRLGFBQ3RELFFBQVE7QUFBQSxFQUVaO0FBRUEsU0FBTztBQUNUOzs7QUNWTyxTQUFTLFNBQVMsT0FBTyxNQUFNLFFBQVEsU0FBUztBQUNyRCxNQUFJLE9BQU8sV0FBVyxZQUFZO0FBQ2hDLFVBQU0sSUFBSSxNQUFNLDJDQUEyQztBQUFBLEVBQzdEO0FBRUEsTUFBSSxDQUFDLFNBQVM7QUFDWixjQUFVLENBQUM7QUFBQSxFQUNiO0FBRUEsTUFBSSxNQUFNLFFBQVEsSUFBSSxHQUFHO0FBQ3ZCLFdBQU8sS0FBSyxRQUFRLEVBQUUsT0FBTyxDQUFDLFVBQVVDLFVBQVM7QUFDL0MsYUFBTyxTQUFTLEtBQUssTUFBTSxPQUFPQSxPQUFNLFVBQVUsT0FBTztBQUFBLElBQzNELEdBQUcsTUFBTSxFQUFFO0FBQUEsRUFDYjtBQUVBLFNBQU8sUUFBUSxRQUFRLEVBQUUsS0FBSyxNQUFNO0FBQ2xDLFFBQUksQ0FBQyxNQUFNLFNBQVMsSUFBSSxHQUFHO0FBQ3pCLGFBQU8sT0FBTyxPQUFPO0FBQUEsSUFDdkI7QUFFQSxXQUFPLE1BQU0sU0FBUyxJQUFJLEVBQUUsT0FBTyxDQUFDQyxTQUFRLGVBQWU7QUFDekQsYUFBTyxXQUFXLEtBQUssS0FBSyxN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aEMsZ0JBQUksR0FBRyxJQUFJLE9BQU8sU0FBUyxHQUFHLENBQUM7QUFBQSxVQUNoQyxXQUNTLFFBQVEsbUJBQW1CLFFBQVEsbUJBQW1CO0FBQzlELGdCQUFJLEdBQUcsSUFBSSxRQUFRLFNBQVMsR0FBRyxDQUFDO0FBQUEsVUFDakMsT0FDSztBQUNKLGdCQUFJLEdBQUcsSUFBSSxTQUFTLEdBQUc7QUFBQSxVQUN4QjtBQUFBLFFBQ0Q7QUFDQSxlQUFPO0FBQUEsTUFDUjtBQUFBLE1BQUcsQ0FBQztBQUFBLElBQWU7QUFDcEIsU0FBSyxVQUFVO0FBQUEsRUFDaEI7QUFBQTtBQUFBLEVBR0EsTUFBTSxlQUFlO0FBQ3BCLFVBQU0sT0FBTyxPQUFPLE9BQU8sQ0FBQyxHQUFHLGtCQUFrQixNQUFNLEtBQUssU0FBUyxDQUFDO0FBRXRFLFVBQU0sU0FBcUIsRUFBRSxHQUFHLE1BQU0sR0FBRyxLQUFLLFFBQVE7QUFFdEQsVUFBTSxLQUFLLFNBQVMsTUFBTTtBQUUxQixVQUFNLFdBQVcsS0FBSyxZQUFZO0FBR2xDLGFBQVMsS0FBSyxLQUFLLE1BQU07QUFDeEIsVUFBSSxPQUFPLGdCQUFnQixLQUFLLFFBQVEsS0FBSyxDQUFDLENBQUM7QUFFL0MsZUFBUyxXQUFXLFVBQVU7QUFDN0IsWUFBSSxZQUFZLEtBQUssU0FBUztBQUM3QjtBQUVELGFBQUssU0FBUyxTQUFTLEtBQUssT0FBTztBQUFBLE1BQ3BDO0FBRUEsV0FBSyxLQUFLLENBQUMsRUFBRSxhQUFhLElBQUk7QUFBQSxJQUMvQjtBQUdBLFNBQUssOEJBQThCO0FBQUEsRUFDcEM7QUFBQSxFQUVBLGNBQXdCO0FBQ3ZCLFVBQU0sV0FBVyxDQUFDO0FBQ2xCLGFBQVMsUUFBUSxLQUFLLFFBQVEsTUFBTTtBQUNuQyxZQUFNLE9BQU8sS0FBSyxTQUFTO0FBQzNCLFVBQUk7QUFDSCxpQkFBUyxLQUFLLElBQUk7QUFBQSxJQUNwQjtBQUVBLFdBQU87QUFBQSxFQUNSO0FBRUQ7IiwKICAibmFtZXMiOiBbIkZpdFBsdWdpbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAibmFtZSIsICJtZXRob2QiLCAiaG9vayIsICJob29rIiwgImdldFVzZXJBZ2VudCIsICJnZXRVc2VyQWdlbnQiLCAiZ2V0VXNlckFnZW50IiwgIlZFUlNJT04iLCAiaXNQbGFpbk9iamVjdCIsICJ3aXRoRGVmYXVsdHMiLCAiZ2V0VXNlckFnZW50IiwgImdldFVzZXJBZ2VudCIsICJWRVJTSU9OIiwgIndpdGhEZWZhdWx0cyIsICJnZXRVc2VyQWdlbnQiLCAicmVxdWVzdCIsICJlbmRwb2ludCIsICJWRVJTSU9OIiwgIlZFUlNJT04iLCAiaG9vayIsICJhdXRoIiwgImhlYWRpbmciLCAiaW1wb3J0X29ic2lkaWFuIiwgInJlc3VsdCIsICJpbXBvcnRfb2JzaWRpYW4iLCAiX2EiLCAiaW1wb3J0X29ic2lkaWFuIiwgIl9hIiwgImZvbGRlcnMiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJGaXRQbHVnaW4iXQp9Cg==
