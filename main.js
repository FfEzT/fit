/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// main.ts
var main_exports = {};
__export(main_exports, {
  DEFAULT_LOCAL_STORE: () => DEFAULT_LOCAL_STORE,
  DEFAULT_REPOSITORY: () => DEFAULT_REPOSITORY,
  default: () => FitPlugin2
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// src/const.ts
var rootFitFolder = "_fit";
var conflictResolutionFolder = rootFitFolder + "/conflict";
var VIEW_TYPE = "fit-view";

// node_modules/@octokit/core/node_modules/universal-user-agent/index.js
function getUserAgent() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && process.version !== void 0) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}

// node_modules/before-after-hook/lib/register.js
function register(state, name, method, options) {
  if (typeof method !== "function") {
    throw new Error("method for before hook must be a function");
  }
  if (!options) {
    options = {};
  }
  if (Array.isArray(name)) {
    return name.reverse().reduce((callback, name2) => {
      return register.bind(null, state, name2, callback, options);
    }, method)();
  }
  return Promise.resolve().then(() => {
    if (!state.registry[name]) {
      return method(options);
    }
    return state.registry[name].reduce((method2, registered) => {
      return registered.hook.bind(null, method2, options);
    }, method)();
  });
}

// node_modules/before-after-hook/lib/add.js
function addHook(state, kind, name, hook2) {
  const orig = hook2;
  if (!state.registry[name]) {
    state.registry[name] = [];
  }
  if (kind === "before") {
    hook2 = (method, options) => {
      return Promise.resolve().then(orig.bind(null, options)).then(method.bind(null, options));
    };
  }
  if (kind === "after") {
    hook2 = (method, options) => {
      let result;
      return Promise.resolve().then(method.bind(null, options)).then((result_) => {
        result = result_;
        return orig(result, options);
      }).then(() => {
        return result;
      });
    };
  }
  if (kind === "error") {
    hook2 = (method, options) => {
      return Promise.resolve().then(method.bind(null, options)).catch((error) => {
        return orig(error, options);
      });
    };
  }
  state.registry[name].push({
    hook: hook2,
    orig
  });
}

// node_modules/before-after-hook/lib/remove.js
function removeHook(state, name, method) {
  if (!state.registry[name]) {
    return;
  }
  const index = state.registry[name].map((registered) => {
    return registered.orig;
  }).indexOf(method);
  if (index === -1) {
    return;
  }
  state.registry[name].splice(index, 1);
}

// node_modules/before-after-hook/index.js
var bind = Function.bind;
var bindable = bind.bind(bind);
function bindApi(hook2, state, name) {
  const removeHookRef = bindable(removeHook, null).apply(
    null,
    name ? [state, name] : [state]
  );
  hook2.api = { remove: removeHookRef };
  hook2.remove = removeHookRef;
  ["before", "error", "after", "wrap"].forEach((kind) => {
    const args = name ? [state, kind, name] : [state, kind];
    hook2[kind] = hook2.api[kind] = bindable(addHook, null).apply(null, args);
  });
}
function Singular() {
  const singularHookName = Symbol("Singular");
  const singularHookState = {
    registry: {}
  };
  const singularHook = register.bind(null, singularHookState, singularHookName);
  bindApi(singularHook, singularHookState, singularHookName);
  return singularHook;
}
function Collection() {
  const state = {
    registry: {}
  };
  const hook2 = register.bind(null, state);
  bindApi(hook2, state);
  return hook2;
}
var before_after_hook_default = { Singular, Collection };

// node_modules/@octokit/endpoint/node_modules/universal-user-agent/index.js
function getUserAgent2() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && process.version !== void 0) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}

// node_modules/@octokit/endpoint/dist-bundle/index.js
var VERSION = "0.0.0-development";
var userAgent = `octokit-endpoint.js/${VERSION} ${getUserAgent2()}`;
var DEFAULTS = {
  method: "GET",
  baseUrl: "https://api.github.com",
  headers: {
    accept: "application/vnd.github.v3+json",
    "user-agent": userAgent
  },
  mediaType: {
    format: ""
  }
};
function lowercaseKeys(object) {
  if (!object) {
    return {};
  }
  return Object.keys(object).reduce((newObj, key) => {
    newObj[key.toLowerCase()] = object[key];
    return newObj;
  }, {});
}
function isPlainObject(value) {
  if (typeof value !== "object" || value === null)
    return false;
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
function mergeDeep(defaults, options) {
  const result = Object.assign({}, defaults);
  Object.keys(options).forEach((key) => {
    if (isPlainObject(options[key])) {
      if (!(key in defaults))
        Object.assign(result, { [key]: options[key] });
      else
        result[key] = mergeDeep(defaults[key], options[key]);
    } else {
      Object.assign(result, { [key]: options[key] });
    }
  });
  return result;
}
function removeUndefinedProperties(obj) {
  for (const key in obj) {
    if (obj[key] === void 0) {
      delete obj[key];
    }
  }
  return obj;
}
function merge(defaults, route, options) {
  var _a;
  if (typeof route === "string") {
    let [method, url] = route.split(" ");
    options = Object.assign(url ? { method, url } : { url: method }, options);
  } else {
    options = Object.assign({}, route);
  }
  options.headers = lowercaseKeys(options.headers);
  removeUndefinedProperties(options);
  removeUndefinedProperties(options.headers);
  const mergedOptions = mergeDeep(defaults || {}, options);
  if (options.url === "/graphql") {
    if (defaults && ((_a = defaults.mediaType.previews) == null ? void 0 : _a.length)) {
      mergedOptions.mediaType.previews = defaults.mediaType.previews.filter(
        (preview) => !mergedOptions.mediaType.previews.includes(preview)
      ).concat(mergedOptions.mediaType.previews);
    }
    mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview) => preview.replace(/-preview/, ""));
  }
  return mergedOptions;
}
function addQueryParameters(url, parameters) {
  const separator = /\?/.test(url) ? "&" : "?";
  const names = Object.keys(parameters);
  if (names.length === 0) {
    return url;
  }
  return url + separator + names.map((name) => {
    if (name === "q") {
      return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
    }
    return `${name}=${encodeURIComponent(parameters[name])}`;
  }).join("&");
}
var urlVariableRegex = /\{[^}]+\}/g;
function removeNonChars(variableName) {
  return variableName.replace(/^\W+|\W+$/g, "").split(/,/);
}
function extractUrlVariableNames(url) {
  const matches = url.match(urlVariableRegex);
  if (!matches) {
    return [];
  }
  return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
}
function omit(object, keysToOmit) {
  const result = { __proto__: null };
  for (const key of Object.keys(object)) {
    if (keysToOmit.indexOf(key) === -1) {
      result[key] = object[key];
    }
  }
  return result;
}
function encodeReserved(str) {
  return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
    if (!/%[0-9A-Fa-f]/.test(part)) {
      part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
    }
    return part;
  }).join("");
}
function encodeUnreserved(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
    return "%" + c.charCodeAt(0).toString(16).toUpperCase();
  });
}
function encodeValue(operator, value, key) {
  value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);
  if (key) {
    return encodeUnreserved(key) + "=" + value;
  } else {
    return value;
  }
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isKeyOperator(operator) {
  return operator === ";" || operator === "&" || operator === "?";
}
function getValues(context, operator, key, modifier) {
  var value = context[key], result = [];
  if (isDefined(value) && value !== "") {
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      value = value.toString();
      if (modifier && modifier !== "*") {
        value = value.substring(0, parseInt(modifier, 10));
      }
      result.push(
        encodeValue(operator, value, isKeyOperator(operator) ? key : "")
      );
    } else {
      if (modifier === "*") {
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            result.push(
              encodeValue(operator, value2, isKeyOperator(operator) ? key : "")
            );
          });
        } else {
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k])) {
              result.push(encodeValue(operator, value[k], k));
            }
          });
        }
      } else {
        const tmp = [];
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            tmp.push(encodeValue(operator, value2));
          });
        } else {
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k])) {
              tmp.push(encodeUnreserved(k));
              tmp.push(encodeValue(operator, value[k].toString()));
            }
          });
        }
        if (isKeyOperator(operator)) {
          result.push(encodeUnreserved(key) + "=" + tmp.join(","));
        } else if (tmp.length !== 0) {
          result.push(tmp.join(","));
        }
      }
    }
  } else {
    if (operator === ";") {
      if (isDefined(value)) {
        result.push(encodeUnreserved(key));
      }
    } else if (value === "" && (operator === "&" || operator === "?")) {
      result.push(encodeUnreserved(key) + "=");
    } else if (value === "") {
      result.push("");
    }
  }
  return result;
}
function parseUrl(template) {
  return {
    expand: expand.bind(null, template)
  };
}
function expand(template, context) {
  var operators = ["+", "#", ".", "/", ";", "?", "&"];
  template = template.replace(
    /\{([^\{\}]+)\}|([^\{\}]+)/g,
    function(_, expression, literal) {
      if (expression) {
        let operator = "";
        const values = [];
        if (operators.indexOf(expression.charAt(0)) !== -1) {
          operator = expression.charAt(0);
          expression = expression.substr(1);
        }
        expression.split(/,/g).forEach(function(variable) {
          var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
          values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
        });
        if (operator && operator !== "+") {
          var separator = ",";
          if (operator === "?") {
            separator = "&";
          } else if (operator !== "#") {
            separator = operator;
          }
          return (values.length !== 0 ? operator : "") + values.join(separator);
        } else {
          return values.join(",");
        }
      } else {
        return encodeReserved(literal);
      }
    }
  );
  if (template === "/") {
    return template;
  } else {
    return template.replace(/\/$/, "");
  }
}
function parse(options) {
  var _a;
  let method = options.method.toUpperCase();
  let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
  let headers = Object.assign({}, options.headers);
  let body;
  let parameters = omit(options, [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "mediaType"
  ]);
  const urlVariableNames = extractUrlVariableNames(url);
  url = parseUrl(url).expand(parameters);
  if (!/^http/.test(url)) {
    url = options.baseUrl + url;
  }
  const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
  const remainingParameters = omit(parameters, omittedParameters);
  const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
  if (!isBinaryRequest) {
    if (options.mediaType.format) {
      headers.accept = headers.accept.split(/,/).map(
        (format) => format.replace(
          /application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/,
          `application/vnd$1$2.${options.mediaType.format}`
        )
      ).join(",");
    }
    if (url.endsWith("/graphql")) {
      if ((_a = options.mediaType.previews) == null ? void 0 : _a.length) {
        const previewsFromAcceptHeader = headers.accept.match(/[\w-]+(?=-preview)/g) || [];
        headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
          const format = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
          return `application/vnd.github.${preview}-preview${format}`;
        }).join(",");
      }
    }
  }
  if (["GET", "HEAD"].includes(method)) {
    url = addQueryParameters(url, remainingParameters);
  } else {
    if ("data" in remainingParameters) {
      body = remainingParameters.data;
    } else {
      if (Object.keys(remainingParameters).length) {
        body = remainingParameters;
      }
    }
  }
  if (!headers["content-type"] && typeof body !== "undefined") {
    headers["content-type"] = "application/json; charset=utf-8";
  }
  if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
    body = "";
  }
  return Object.assign(
    { method, url, headers },
    typeof body !== "undefined" ? { body } : null,
    options.request ? { request: options.request } : null
  );
}
function endpointWithDefaults(defaults, route, options) {
  return parse(merge(defaults, route, options));
}
function withDefaults(oldDefaults, newDefaults) {
  const DEFAULTS2 = merge(oldDefaults, newDefaults);
  const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
  return Object.assign(endpoint2, {
    DEFAULTS: DEFAULTS2,
    defaults: withDefaults.bind(null, DEFAULTS2),
    merge: merge.bind(null, DEFAULTS2),
    parse
  });
}
var endpoint = withDefaults(null, DEFAULTS);

// node_modules/@octokit/request/node_modules/universal-user-agent/index.js
function getUserAgent3() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && process.version !== void 0) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}

// node_modules/@octokit/request/node_modules/@octokit/request-error/dist-src/index.js
var RequestError = class extends Error {
  constructor(message, statusCode, options) {
    super(message);
    __publicField(this, "name");
    /**
     * http status code
     */
    __publicField(this, "status");
    /**
     * Request options that lead to the error.
     */
    __publicField(this, "request");
    /**
     * Response object if a response was received
     */
    __publicField(this, "response");
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = "HttpError";
    this.status = statusCode;
    if ("response" in options) {
      this.response = options.response;
    }
    const requestCopy = Object.assign({}, options.request);
    if (options.request.headers.authorization) {
      requestCopy.headers = Object.assign({}, options.request.headers, {
        authorization: options.request.headers.authorization.replace(
          / .*$/,
          " [REDACTED]"
        )
      });
    }
    requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
    this.request = requestCopy;
  }
};

// node_modules/@octokit/request/dist-bundle/index.js
var VERSION2 = "0.0.0-development";
function isPlainObject2(value) {
  if (typeof value !== "object" || value === null)
    return false;
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
function getBufferResponse(response) {
  return response.arrayBuffer();
}
function fetchWrapper(requestOptions) {
  var _a, _b, _c;
  const log = requestOptions.request && requestOptions.request.log ? requestOptions.request.log : console;
  const parseSuccessResponseBody = ((_a = requestOptions.request) == null ? void 0 : _a.parseSuccessResponseBody) !== false;
  if (isPlainObject2(requestOptions.body) || Array.isArray(requestOptions.body)) {
    requestOptions.body = JSON.stringify(requestOptions.body);
  }
  let headers = {};
  let status;
  let url;
  let { fetch } = globalThis;
  if ((_b = requestOptions.request) == null ? void 0 : _b.fetch) {
    fetch = requestOptions.request.fetch;
  }
  if (!fetch) {
    throw new Error(
      "fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing"
    );
  }
  return fetch(requestOptions.url, {
    method: requestOptions.method,
    body: requestOptions.body,
    // Header values must be `string`
    headers: Object.fromEntries(
      Object.entries(requestOptions.headers).map(([name, value]) => [
        name,
        String(value)
      ])
    ),
    signal: (_c = requestOptions.request) == null ? void 0 : _c.signal,
    // duplex must be set if request.body is ReadableStream or Async Iterables.
    // See https://fetch.spec.whatwg.org/#dom-requestinit-duplex.
    ...requestOptions.body && { duplex: "half" }
  }).then(async (response) => {
    url = response.url;
    status = response.status;
    for (const keyAndValue of response.headers) {
      headers[keyAndValue[0]] = keyAndValue[1];
    }
    if ("deprecation" in headers) {
      const matches = headers.link && headers.link.match(/<([^>]+)>; rel="deprecation"/);
      const deprecationLink = matches && matches.pop();
      log.warn(
        `[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`
      );
    }
    if (status === 204 || status === 205) {
      return;
    }
    if (requestOptions.method === "HEAD") {
      if (status < 400) {
        return;
      }
      throw new RequestError(response.statusText, status, {
        response: {
          url,
          status,
          headers,
          data: void 0
        },
        request: requestOptions
      });
    }
    if (status === 304) {
      throw new RequestError("Not modified", status, {
        response: {
          url,
          status,
          headers,
          data: await getResponseData(response)
        },
        request: requestOptions
      });
    }
    if (status >= 400) {
      const data = await getResponseData(response);
      const error = new RequestError(toErrorMessage(data), status, {
        response: {
          url,
          status,
          headers,
          data
        },
        request: requestOptions
      });
      throw error;
    }
    return parseSuccessResponseBody ? await getResponseData(response) : response.body;
  }).then((data) => {
    return {
      status,
      url,
      headers,
      data
    };
  }).catch((error) => {
    if (error instanceof RequestError)
      throw error;
    else if (error.name === "AbortError")
      throw error;
    let message = error.message;
    if (error.name === "TypeError" && "cause" in error) {
      if (error.cause instanceof Error) {
        message = error.cause.message;
      } else if (typeof error.cause === "string") {
        message = error.cause;
      }
    }
    throw new RequestError(message, 500, {
      request: requestOptions
    });
  });
}
async function getResponseData(response) {
  const contentType = response.headers.get("content-type");
  if (/application\/json/.test(contentType)) {
    return response.json().catch(() => response.text()).catch(() => "");
  }
  if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) {
    return response.text();
  }
  return getBufferResponse(response);
}
function toErrorMessage(data) {
  if (typeof data === "string")
    return data;
  let suffix;
  if ("documentation_url" in data) {
    suffix = ` - ${data.documentation_url}`;
  } else {
    suffix = "";
  }
  if ("message" in data) {
    if (Array.isArray(data.errors)) {
      return `${data.message}: ${data.errors.map(JSON.stringify).join(", ")}${suffix}`;
    }
    return `${data.message}${suffix}`;
  }
  return `Unknown error: ${JSON.stringify(data)}`;
}
function withDefaults2(oldEndpoint, newDefaults) {
  const endpoint2 = oldEndpoint.defaults(newDefaults);
  const newApi = function(route, parameters) {
    const endpointOptions = endpoint2.merge(route, parameters);
    if (!endpointOptions.request || !endpointOptions.request.hook) {
      return fetchWrapper(endpoint2.parse(endpointOptions));
    }
    const request2 = (route2, parameters2) => {
      return fetchWrapper(
        endpoint2.parse(endpoint2.merge(route2, parameters2))
      );
    };
    Object.assign(request2, {
      endpoint: endpoint2,
      defaults: withDefaults2.bind(null, endpoint2)
    });
    return endpointOptions.request.hook(request2, endpointOptions);
  };
  return Object.assign(newApi, {
    endpoint: endpoint2,
    defaults: withDefaults2.bind(null, endpoint2)
  });
}
var request = withDefaults2(endpoint, {
  headers: {
    "user-agent": `octokit-request.js/${VERSION2} ${getUserAgent3()}`
  }
});

// node_modules/@octokit/graphql/node_modules/universal-user-agent/index.js
function getUserAgent4() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && process.version !== void 0) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}

// node_modules/@octokit/graphql/dist-bundle/index.js
var VERSION3 = "0.0.0-development";
function _buildMessageForResponseErrors(data) {
  return `Request failed due to following response errors:
` + data.errors.map((e) => ` - ${e.message}`).join("\n");
}
var GraphqlResponseError = class extends Error {
  constructor(request2, headers, response) {
    super(_buildMessageForResponseErrors(response));
    __publicField(this, "name", "GraphqlResponseError");
    __publicField(this, "errors");
    __publicField(this, "data");
    this.request = request2;
    this.headers = headers;
    this.response = response;
    this.errors = response.errors;
    this.data = response.data;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
};
var NON_VARIABLE_OPTIONS = [
  "method",
  "baseUrl",
  "url",
  "headers",
  "request",
  "query",
  "mediaType"
];
var FORBIDDEN_VARIABLE_OPTIONS = ["query", "method", "url"];
var GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
function graphql(request2, query, options) {
  if (options) {
    if (typeof query === "string" && "query" in options) {
      return Promise.reject(
        new Error(`[@octokit/graphql] "query" cannot be used as variable name`)
      );
    }
    for (const key in options) {
      if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key))
        continue;
      return Promise.reject(
        new Error(
          `[@octokit/graphql] "${key}" cannot be used as variable name`
        )
      );
    }
  }
  const parsedOptions = typeof query === "string" ? Object.assign({ query }, options) : query;
  const requestOptions = Object.keys(
    parsedOptions
  ).reduce((result, key) => {
    if (NON_VARIABLE_OPTIONS.includes(key)) {
      result[key] = parsedOptions[key];
      return result;
    }
    if (!result.variables) {
      result.variables = {};
    }
    result.variables[key] = parsedOptions[key];
    return result;
  }, {});
  const baseUrl = parsedOptions.baseUrl || request2.endpoint.DEFAULTS.baseUrl;
  if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
    requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
  }
  return request2(requestOptions).then((response) => {
    if (response.data.errors) {
      const headers = {};
      for (const key of Object.keys(response.headers)) {
        headers[key] = response.headers[key];
      }
      throw new GraphqlResponseError(
        requestOptions,
        headers,
        response.data
      );
    }
    return response.data.data;
  });
}
function withDefaults3(request2, newDefaults) {
  const newRequest = request2.defaults(newDefaults);
  const newApi = (query, options) => {
    return graphql(newRequest, query, options);
  };
  return Object.assign(newApi, {
    defaults: withDefaults3.bind(null, newRequest),
    endpoint: newRequest.endpoint
  });
}
var graphql2 = withDefaults3(request, {
  headers: {
    "user-agent": `octokit-graphql.js/${VERSION3} ${getUserAgent4()}`
  },
  method: "POST",
  url: "/graphql"
});
function withCustomRequest(customRequest) {
  return withDefaults3(customRequest, {
    method: "POST",
    url: "/graphql"
  });
}

// node_modules/@octokit/auth-token/dist-bundle/index.js
var REGEX_IS_INSTALLATION_LEGACY = /^v1\./;
var REGEX_IS_INSTALLATION = /^ghs_/;
var REGEX_IS_USER_TO_SERVER = /^ghu_/;
async function auth(token) {
  const isApp = token.split(/\./).length === 3;
  const isInstallation = REGEX_IS_INSTALLATION_LEGACY.test(token) || REGEX_IS_INSTALLATION.test(token);
  const isUserToServer = REGEX_IS_USER_TO_SERVER.test(token);
  const tokenType = isApp ? "app" : isInstallation ? "installation" : isUserToServer ? "user-to-server" : "oauth";
  return {
    type: "token",
    token,
    tokenType
  };
}
function withAuthorizationPrefix(token) {
  if (token.split(/\./).length === 3) {
    return `bearer ${token}`;
  }
  return `token ${token}`;
}
async function hook(token, request2, route, parameters) {
  const endpoint2 = request2.endpoint.merge(
    route,
    parameters
  );
  endpoint2.headers.authorization = withAuthorizationPrefix(token);
  return request2(endpoint2);
}
var createTokenAuth = function createTokenAuth2(token) {
  if (!token) {
    throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
  }
  if (typeof token !== "string") {
    throw new Error(
      "[@octokit/auth-token] Token passed to createTokenAuth is not a string"
    );
  }
  token = token.replace(/^(token|bearer) +/i, "");
  return Object.assign(auth.bind(null, token), {
    hook: hook.bind(null, token)
  });
};

// node_modules/@octokit/core/dist-src/version.js
var VERSION4 = "6.0.1";

// node_modules/@octokit/core/dist-src/index.js
var noop = () => {
};
var consoleWarn = console.warn.bind(console);
var consoleError = console.error.bind(console);
var userAgentTrail = `octokit-core.js/${VERSION4} ${getUserAgent()}`;
var Octokit = class {
  constructor(options = {}) {
    // assigned during constructor
    __publicField(this, "request");
    __publicField(this, "graphql");
    __publicField(this, "log");
    __publicField(this, "hook");
    // TODO: type `octokit.auth` based on passed options.authStrategy
    __publicField(this, "auth");
    const hook2 = new before_after_hook_default.Collection();
    const requestDefaults = {
      baseUrl: request.endpoint.DEFAULTS.baseUrl,
      headers: {},
      request: Object.assign({}, options.request, {
        // @ts-ignore internal usage only, no need to type
        hook: hook2.bind(null, "request")
      }),
      mediaType: {
        previews: [],
        format: ""
      }
    };
    requestDefaults.headers["user-agent"] = options.userAgent ? `${options.userAgent} ${userAgentTrail}` : userAgentTrail;
    if (options.baseUrl) {
      requestDefaults.baseUrl = options.baseUrl;
    }
    if (options.previews) {
      requestDefaults.mediaType.previews = options.previews;
    }
    if (options.timeZone) {
      requestDefaults.headers["time-zone"] = options.timeZone;
    }
    this.request = request.defaults(requestDefaults);
    this.graphql = withCustomRequest(this.request).defaults(requestDefaults);
    this.log = Object.assign(
      {
        debug: noop,
        info: noop,
        warn: consoleWarn,
        error: consoleError
      },
      options.log
    );
    this.hook = hook2;
    if (!options.authStrategy) {
      if (!options.auth) {
        this.auth = async () => ({
          type: "unauthenticated"
        });
      } else {
        const auth2 = createTokenAuth(options.auth);
        hook2.wrap("request", auth2.hook);
        this.auth = auth2;
      }
    } else {
      const { authStrategy, ...otherOptions } = options;
      const auth2 = authStrategy(
        Object.assign(
          {
            request: this.request,
            log: this.log,
            // we pass the current octokit instance as well as its constructor options
            // to allow for authentication strategies that return a new octokit instance
            // that shares the same internal state as the current one. The original
            // requirement for this was the "event-octokit" authentication strategy
            // of https://github.com/probot/octokit-auth-probot.
            octokit: this,
            octokitOptions: otherOptions
          },
          options.auth
        )
      );
      hook2.wrap("request", auth2.hook);
      this.auth = auth2;
    }
    const classConstructor = this.constructor;
    for (let i = 0; i < classConstructor.plugins.length; ++i) {
      Object.assign(this, classConstructor.plugins[i](this, options));
    }
  }
  static defaults(defaults) {
    const OctokitWithDefaults = class extends this {
      constructor(...args) {
        const options = args[0] || {};
        if (typeof defaults === "function") {
          super(defaults(options));
          return;
        }
        super(
          Object.assign(
            {},
            defaults,
            options,
            options.userAgent && defaults.userAgent ? {
              userAgent: `${options.userAgent} ${defaults.userAgent}`
            } : null
          )
        );
      }
    };
    return OctokitWithDefaults;
  }
  /**
   * Attach a plugin (or many) to your Octokit instance.
   *
   * @example
   * const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
   */
  static plugin(...newPlugins) {
    var _a;
    const currentPlugins = this.plugins;
    const NewOctokit = (_a = class extends this {
    }, __publicField(_a, "plugins", currentPlugins.concat(
      newPlugins.filter((plugin) => !currentPlugins.includes(plugin))
    )), _a);
    return NewOctokit;
  }
};
__publicField(Octokit, "VERSION", VERSION4);
__publicField(Octokit, "plugins", []);

// src/utils.ts
var import_obsidian = require("obsidian");
function getValueOrNull(obj, key) {
  return obj.hasOwnProperty(key) ? obj[key] : null;
}
function compareSha(currentShaMap, storedShaMap, env) {
  const determineStatus = (currentSha, storedSha) => {
    if (currentSha && storedSha && currentSha !== storedSha) {
      return env === "local" ? "changed" : "MODIFIED";
    } else if (currentSha && !storedSha) {
      return env === "local" ? "created" : "ADDED";
    } else if (!currentSha && storedSha) {
      return env === "local" ? "deleted" : "REMOVED";
    }
    return null;
  };
  return Object.keys({ ...currentShaMap, ...storedShaMap }).flatMap((path) => {
    const [currentSha, storedSha] = [getValueOrNull(currentShaMap, path), getValueOrNull(storedShaMap, path)];
    const status = determineStatus(currentSha, storedSha);
    if (status) {
      return [{
        path,
        status,
        currentSha: currentSha != null ? currentSha : void 0,
        extension: extractExtension(path)
      }];
    }
    return [];
  });
}
var RECOGNIZED_TXT_EXT = ["txt", "md"];
function extractExtension(path) {
  var _a;
  return (_a = path.match(/[^.]+$/)) == null ? void 0 : _a[0];
}
function removeLineEndingsFromBase64String(content) {
  return content.replace(/\r?\n|\r|\n/g, "");
}
function showFileOpsRecord(records) {
  if (records.length === 0 || records.every((r) => r.ops.length === 0)) {
    return;
  }
  const fileOpsNotice = new import_obsidian.Notice("", 0);
  records.map((recordSet) => {
    if (recordSet.ops.length === 0) {
      return;
    }
    const heading = fileOpsNotice.noticeEl.createEl("span", {
      cls: "file-changes-heading"
    });
    heading.setText(`${recordSet.heading}
`);
    const fileChanges = {
      created: [],
      changed: [],
      deleted: []
    };
    for (const op of recordSet.ops) {
      fileChanges[op.status].push(op.path);
    }
    for (const [changeType, paths] of Object.entries(fileChanges)) {
      if (paths.length === 0) {
        continue;
      }
      const heading2 = fileOpsNotice.noticeEl.createEl("span");
      heading2.setText(`${changeType.charAt(0).toUpperCase() + changeType.slice(1)}
`);
      heading2.addClass(`file-changes-subheading`);
      for (const path of paths) {
        const listItem = fileOpsNotice.noticeEl.createEl("li", {
          cls: "file-update-row"
        });
        listItem.setText(`${path}`);
        listItem.addClass(`file-${changeType}`);
      }
    }
  });
}
function showUnappliedConflicts(clashedFiles) {
  if (clashedFiles.length === 0) {
    return;
  }
  const localStatusMap = {
    created: "create",
    changed: "change",
    deleted: "delete"
  };
  const remoteStatusMap = {
    ADDED: "create",
    MODIFIED: "change",
    REMOVED: "delete"
  };
  const conflictNotice = new import_obsidian.Notice("", 0);
  const heading = conflictNotice.noticeEl.createEl("span");
  heading.setText(`Change conflicts:
`);
  heading.addClass(`file-changes-subheading`);
  const conflictStatus = conflictNotice.noticeEl.createDiv({
    cls: "file-conflict-row"
  });
  conflictStatus.createDiv().setText("Local");
  conflictStatus.createDiv().setText("Remote");
  for (const clash of clashedFiles) {
    const conflictItem = conflictNotice.noticeEl.createDiv({
      cls: "file-conflict-row"
    });
    conflictItem.createDiv({
      cls: `file-conflict-${localStatusMap[clash.localStatus]}`
    });
    conflictItem.createDiv("div").setText(clash.path);
    conflictItem.createDiv({
      cls: `file-conflict-${remoteStatusMap[clash.remoteStatus]}`
    });
  }
  const footer = conflictNotice.noticeEl.createDiv({
    cls: "file-conflict-row"
  });
  footer.setText("Note:");
  footer.style.fontWeight = "bold";
  conflictNotice.noticeEl.createEl("li", { cls: "file-conflict-note" }).setText(`Remote changes in ${conflictResolutionFolder}`);
  conflictNotice.noticeEl.createEl("li", { cls: "file-conflict-note" }).setText(`${conflictResolutionFolder} folder is overwritten on conflict, copy needed changes outside ${conflictResolutionFolder}.`);
}
function difference(setA, setB) {
  return new Set([...setA].filter((x) => !setB.has(x)));
}

// src/fit.ts
var import_obsidian2 = require("obsidian");
var OctokitHttpError = class extends Error {
  constructor(message, status, source) {
    super(message);
    this.name = "HttpError";
    this.status = status;
    this.source = source;
  }
};
var Fit = class {
  constructor(repo, vaultOps) {
    this.loadSettings(repo);
    this.vaultOps = vaultOps;
    this.headers = {
      // Hack to disable caching which leads to inconsistency for
      // read after write https://github.com/octokit/octokit.js/issues/890
      "If-None-Match": "",
      "X-GitHub-Api-Version": "2022-11-28"
    };
  }
  loadSettings(repo) {
    const { settings, localStore } = repo;
    this.repo = settings.repo;
    this.owner = settings.owner;
    this.branch = settings.branch;
    this.excludes = settings.excludes;
    this.syncPath = settings.syncPath;
    this.deviceName = settings.deviceName;
    this.octokit = new Octokit({ auth: settings.pat });
    this.localSha = localStore.localSha;
    this.lastFetchedCommitSha = localStore.lastFetchedCommitSha;
    this.lastFetchedRemoteSha = localStore.lastFetchedRemoteSha;
  }
  async fileSha1(fileContent) {
    const enc = new TextEncoder();
    const hashBuf = await crypto.subtle.digest("SHA-1", enc.encode(fileContent));
    const hashArray = Array.from(new Uint8Array(hashBuf));
    const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
    return hashHex;
  }
  async computeFileLocalSha(path) {
    const fullPath = this.syncPath + path;
    let content;
    const file = await this.vaultOps.getTFile(fullPath);
    if (file) {
      if (RECOGNIZED_TXT_EXT.includes(file.extension)) {
        content = await this.vaultOps.vault.read(file);
      } else {
        content = (0, import_obsidian2.arrayBufferToBase64)(await this.vaultOps.vault.readBinary(file));
      }
    } else {
      const extension = extractExtension(path);
      if (!extension || !RECOGNIZED_TXT_EXT.includes(extension)) {
        content = (0, import_obsidian2.arrayBufferToBase64)(
          await this.vaultOps.vault.adapter.readBinary(fullPath)
        );
      } else {
        content = await this.vaultOps.vault.adapter.read(fullPath);
      }
    }
    return await this.fileSha1(path + content);
  }
  async computeLocalSha() {
    const allPaths = await this.vaultOps.getFilesInVault();
    const paths = [];
    for (let path of allPaths) {
      let isExcluded = path.startsWith(conflictResolutionFolder) || !path.startsWith(this.syncPath) || this.excludes.contains(path) || this.excludes.some(
        (exclude) => path.startsWith(exclude) && !this.syncPath.startsWith(exclude)
        // NOTE if one syncPath nested in another syncPath
      );
      const result2 = path.replace(this.syncPath, "");
      if (!isExcluded)
        paths.push(result2);
    }
    const asyncCompute = paths.map(
      async (path) => {
        const sha = await this.computeFileLocalSha(path);
        return [path, sha];
      }
    );
    const computed = await Promise.all(asyncCompute);
    const result = computed.filter((el) => !!el[1]);
    return Object.fromEntries(result);
  }
  async remoteUpdated() {
    const remoteCommitSha = await this.getRef();
    return { remoteCommitSha, updated: remoteCommitSha !== this.lastFetchedCommitSha };
  }
  async getLocalChanges(currentLocalSha) {
    if (!currentLocalSha) {
      currentLocalSha = await this.computeLocalSha();
    }
    const localChanges = compareSha(currentLocalSha, this.localSha, "local");
    return localChanges;
  }
  async getRemoteChanges(remoteTreeSha) {
    const remoteChanges = compareSha(remoteTreeSha, this.lastFetchedRemoteSha, "remote");
    return remoteChanges;
  }
  getClashedChanges(localChanges, remoteChanges) {
    const localChangePaths = localChanges.map(
      (c) => c.path.replace(this.syncPath, "")
    );
    const remoteChangePaths = remoteChanges.map((c) => c.path);
    const clashedFiles = localChangePaths.map(
      (path, localIndex) => {
        const remoteIndex = remoteChangePaths.indexOf(path);
        if (remoteIndex !== -1) {
          return { path, localIndex, remoteIndex };
        }
        return null;
      }
    ).filter(Boolean);
    return clashedFiles.map(
      ({ path, localIndex, remoteIndex }) => {
        return {
          path,
          localStatus: localChanges[localIndex].status,
          remoteStatus: remoteChanges[remoteIndex].status
        };
      }
    );
  }
  async getRepos() {
    const allRepos = [];
    let page = 1;
    const perPage = 100;
    try {
      let hasMorePages = true;
      while (hasMorePages) {
        const { data: response } = await this.octokit.request(
          `GET /user/repos`,
          {
            affiliation: "owner",
            headers: this.headers,
            per_page: perPage,
            // Number of repositories to import per page (up to 100)
            page
          }
        );
        allRepos.push(...response.map((r) => r.name));
        if (response.length < perPage) {
          hasMorePages = false;
        }
        page++;
      }
      return allRepos;
    } catch (error) {
      throw new OctokitHttpError(error.message, error.status, "getRepos");
    }
  }
  async getBranches() {
    try {
      const { data: response } = await this.octokit.request(
        `GET /repos/{owner}/{repo}/branches`,
        {
          owner: this.owner,
          repo: this.repo,
          headers: this.headers
        }
      );
      return response.map((r) => r.name);
    } catch (error) {
      throw new OctokitHttpError(error.message, error.status, "getRepos");
    }
  }
  // Get the sha of the latest commit in the default branch (set by user in setting)
  async getRef(ref = `heads/${this.branch}`) {
    try {
      const { data: response } = await this.octokit.request(
        `GET /repos/{owner}/{repo}/git/ref/{ref}`,
        {
          owner: this.owner,
          repo: this.repo,
          ref,
          headers: this.headers
        }
      );
      return response.object.sha;
    } catch (error) {
      throw new OctokitHttpError(error.message, error.status, "getRef");
    }
  }
  // ref Can be a commit SHA, branch name (heads/BRANCH_NAME), or tag name (tags/TAG_NAME),
  // refers to https://git-scm.com/book/en/v2/Git-Internals-Git-References
  async getCommitTreeSha(ref) {
    const { data: commit } = await this.octokit.request(
      `GET /repos/{owner}/{repo}/commits/{ref}`,
      {
        owner: this.owner,
        repo: this.repo,
        ref,
        headers: this.headers
      }
    );
    return commit.commit.tree.sha;
  }
  async getTree(tree_sha) {
    const { data: tree } = await this.octokit.request(
      `GET /repos/{owner}/{repo}/git/trees/{tree_sha}`,
      {
        owner: this.owner,
        repo: this.repo,
        tree_sha,
        recursive: "true",
        headers: this.headers
      }
    );
    return tree.tree;
  }
  // get the remote tree sha in the format compatible with local store
  async getRemoteTreeSha(tree_sha) {
    const remoteTree = await this.getTree(tree_sha);
    const remoteSha = Object.fromEntries(remoteTree.map((node) => {
      if (node.type == "blob") {
        if (!node.path || !node.sha) {
          throw new Error("Path or sha not found for blob node in remote");
        }
        if (node.path.startsWith(conflictResolutionFolder)) {
          return null;
        }
        return [node.path, node.sha];
      }
      return null;
    }).filter(Boolean));
    return remoteSha;
  }
  async createBlob(content, encoding) {
    const { data: blob } = await this.octokit.request(
      `POST /repos/{owner}/{repo}/git/blobs`,
      {
        owner: this.owner,
        repo: this.repo,
        content,
        encoding,
        headers: this.headers
      }
    );
    return blob.sha;
  }
  async createTreeNodeFromFile({ path, status, extension }, remoteTree) {
    if (status === "deleted") {
      if (remoteTree.every((node) => node.path !== path)) {
        return null;
      }
      return {
        path,
        mode: "100644",
        type: "blob",
        sha: null
      };
    }
    const fullPath = this.syncPath + path;
    let encoding;
    let content;
    if (extension && !RECOGNIZED_TXT_EXT.includes(extension)) {
      encoding = "base64";
      const fileArrayBuf = await this.vaultOps.vault.adapter.readBinary(fullPath);
      const uint8Array = new Uint8Array(fileArrayBuf);
      let binaryString = "";
      for (let i = 0; i < uint8Array.length; i++) {
        binaryString += String.fromCharCode(uint8Array[i]);
      }
      content = btoa(binaryString);
    } else {
      encoding = "utf-8";
      content = await this.vaultOps.vault.adapter.read(fullPath);
    }
    const blobSha = await this.createBlob(content, encoding);
    if (remoteTree.some((node) => node.path === path && node.sha === blobSha)) {
      return null;
    }
    return {
      path,
      mode: "100644",
      type: "blob",
      sha: blobSha
    };
  }
  async createTree(treeNodes, base_tree_sha) {
    const { data: newTree } = await this.octokit.request(
      `POST /repos/{owner}/{repo}/git/trees`,
      {
        owner: this.owner,
        repo: this.repo,
        tree: treeNodes,
        base_tree: base_tree_sha,
        headers: this.headers
      }
    );
    return newTree.sha;
  }
  async createCommit(treeSha, parentSha) {
    const message = `Commit from ${this.deviceName} on ${new Date().toLocaleString()}`;
    const { data: createdCommit } = await this.octokit.request(
      `POST /repos/{owner}/{repo}/git/commits`,
      {
        owner: this.owner,
        repo: this.repo,
        message,
        tree: treeSha,
        parents: [parentSha],
        headers: this.headers
      }
    );
    return createdCommit.sha;
  }
  async updateRef(sha, ref = `heads/${this.branch}`) {
    const { data: updatedRef } = await this.octokit.request(
      `PATCH /repos/{owner}/{repo}/git/refs/{ref}`,
      {
        owner: this.owner,
        repo: this.repo,
        ref,
        sha,
        headers: this.headers
      }
    );
    return updatedRef.object.sha;
  }
  async getBlob(file_sha) {
    const { data: blob } = await this.octokit.request(
      `GET /repos/{owner}/{repo}/git/blobs/{file_sha}`,
      {
        owner: this.owner,
        repo: this.repo,
        file_sha,
        headers: this.headers
      }
    );
    return blob.content;
  }
  getAddToLocal(addToLocal_) {
    const basepath = this.syncPath;
    const addToLocal = structuredClone(addToLocal_);
    return addToLocal.map(
      ({ path, content }) => {
        return {
          path: basepath + path,
          content
        };
      }
    ).filter(
      (file) => {
        const excludes = this.excludes;
        if (!excludes.length)
          return true;
        return excludes.some(
          (exclude) => !file.path.startsWith(exclude) || this.syncPath.startsWith(exclude)
          // NOTE if one syncPath nested in another syncPath
        );
      }
    );
  }
  getDeleteFromLocal(deleteFromLocal_) {
    const basepath = this.syncPath;
    const deleteFromLocal = structuredClone(deleteFromLocal_);
    return deleteFromLocal.map(
      (path) => basepath + path
    ).filter(
      (path) => {
        const excludes = this.excludes;
        if (!excludes.length)
          return true;
        return excludes.some(
          (exclude) => !path.startsWith(exclude) || this.syncPath.startsWith(exclude)
          // NOTE if one syncPath nested in another syncPath
        );
      }
    );
  }
};

// src/fitNotice.ts
var import_obsidian3 = require("obsidian");
var FitNotice = class {
  constructor(addClasses = [], initialMessage, duration = 0, muted = false) {
    this.muted = muted;
    this.classes = ["fit-notice"];
    if (initialMessage && !this.muted) {
      this.show(initialMessage, addClasses, duration);
    } else {
      this.classes = [...this.classes, ...addClasses];
    }
  }
  mute() {
    this.muted = true;
    if (this.notice) {
      this.notice.hide();
    }
  }
  unmute() {
    this.muted = false;
  }
  show(initialMessage, addClasses = [], duration = 0) {
    if (!this.notice && !this.muted) {
      const message = initialMessage && initialMessage.length > 0 ? initialMessage : " ";
      this.notice = new import_obsidian3.Notice(message, duration);
      this.notice.noticeEl.addClasses([...this.classes, ...addClasses]);
    }
  }
  updateClasses(addClasses = [], removeClasses = []) {
    if (this.muted) {
      return;
    }
    this.classes = this.classes.filter((c) => !removeClasses.includes(c));
    if (this.notice) {
      this.notice.noticeEl.removeClasses(removeClasses);
      this.notice.noticeEl.addClasses(addClasses);
    }
    this.classes = [...this.classes, ...addClasses];
  }
  // allows error display to override muted
  setMessage(message, isError) {
    if (isError) {
      if (!this.notice) {
        this.notice = new import_obsidian3.Notice(message, 0);
        this.notice.noticeEl.addClasses(["fit-notice", "error"]);
      } else {
        this.notice.setMessage(message);
      }
    } else {
      if (this.notice && !this.muted) {
        this.notice.setMessage(message);
      }
    }
  }
  remove(finalClass, duration = 5e3) {
    var _a, _b, _c;
    if (this.muted) {
      return;
    }
    (_a = this.notice) == null ? void 0 : _a.noticeEl.removeClasses(this.classes.filter((c) => c !== "fit-notice"));
    if (finalClass) {
      (_b = this.notice) == null ? void 0 : _b.noticeEl.addClass(finalClass);
    } else {
      (_c = this.notice) == null ? void 0 : _c.noticeEl.addClass("done");
    }
    setTimeout(() => {
      var _a2;
      return (_a2 = this.notice) == null ? void 0 : _a2.hide();
    }, duration);
  }
};

// src/fitSetting.ts
var import_obsidian4 = require("obsidian");
var FitSettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    // patSetting: Setting;
    // ownerSetting: Setting;
    // repoSetting: Setting;
    // branchSetting: Setting;
    // syncPathSetting: Setting;
    // existingRepos: Array<string>;
    // existingBranches: Array<string>;
    // repoLink: string;
    // syncPath: string;
    this.currentSyncIndex = 0;
    this.getLatestLink = () => {
      const currentSetting = this.getCurrentSyncSetting();
      const { owner, repo, branch } = currentSetting;
      if (owner.length > 0 && repo.length > 0 && branch.length > 0) {
        return `https://github.com/${owner}/${repo}/tree/${branch}`;
      }
      return "";
    };
    this.localConfigBlock = () => {
      const { containerEl } = this;
      new import_obsidian4.Setting(containerEl).setHeading().setName("Local configurations");
      new import_obsidian4.Setting(containerEl).setName("Auto sync").setDesc(`Automatically sync your vault when remote has updates. (Muted: sync in the background without displaying notices, except for file changes and conflicts notice)`).addDropdown((dropdown) => {
        dropdown.addOption("off", "Off").addOption("muted", "Muted").addOption("remind", "Remind only").addOption("on", "On").setValue(this.plugin.storage.autoSync ? this.plugin.storage.autoSync : "off").onChange(async (value) => {
          this.plugin.storage.autoSync = value;
          checkIntervalSlider.settingEl.addClass(value === "off" ? "clear" : "restore");
          checkIntervalSlider.settingEl.removeClass(value === "off" ? "restore" : "clear");
          await this.plugin.saveSettings();
        });
      });
      const checkIntervalSlider = new import_obsidian4.Setting(containerEl).setName("Auto check interval").setDesc(`Automatically check for remote changes in the background every ${this.plugin.storage.checkEveryXMinutes} minutes.`).addSlider(
        (slider) => slider.setLimits(1, 60, 1).setValue(this.plugin.storage.checkEveryXMinutes).setDynamicTooltip().onChange(async (value) => {
          this.plugin.storage.checkEveryXMinutes = value;
          await this.plugin.saveSettings();
          checkIntervalSlider.setDesc(`Automatically check for remote changes in the background every ${value} minutes.`);
        })
      );
      if (this.plugin.storage.autoSync === "off") {
        checkIntervalSlider.settingEl.addClass("clear");
      }
    };
    this.noticeConfigBlock = () => {
      const { containerEl } = this;
      const selectedCol = "var(--interactive-accent)";
      const selectedTxtCol = "var(--text-on-accent)";
      const unselectedColor = "var(--interactive-normal)";
      const unselectedTxtCol = "var(--text-normal)";
      const stateTextMap = (notifyConflicts, notifyChanges) => {
        if (notifyConflicts && notifyChanges) {
          return "Displaying file changes and conflicts ";
        } else if (!notifyConflicts && notifyChanges) {
          return "Displaying file changes ";
        } else if (notifyConflicts && !notifyChanges) {
          return "Displaying change conflicts ";
        } else {
          return "No notice displayed ";
        }
      };
      const noticeDisplay = new import_obsidian4.Setting(containerEl).setName("Notice display").setDesc(`${stateTextMap(this.plugin.storage.notifyConflicts, this.plugin.storage.notifyChanges)} after sync.`).addButton((button) => {
        button.setButtonText("Change conflicts");
        button.onClick(async () => {
          const notifyConflicts = !this.plugin.storage.notifyConflicts;
          this.plugin.storage.notifyConflicts = notifyConflicts;
          await this.plugin.saveSettings();
          button.buttonEl.setCssStyles({
            "background": notifyConflicts ? selectedCol : unselectedColor,
            "color": notifyConflicts ? selectedTxtCol : unselectedTxtCol
          });
          noticeDisplay.setDesc(`${stateTextMap(notifyConflicts, this.plugin.storage.notifyChanges)} after sync.`);
        });
        button.buttonEl.setCssStyles({
          "background": this.plugin.storage.notifyConflicts ? selectedCol : unselectedColor,
          "color": this.plugin.storage.notifyConflicts ? selectedTxtCol : unselectedTxtCol
        });
      }).addButton((button) => {
        button.setButtonText("File changes");
        button.onClick(async () => {
          const notifyChanges = !this.plugin.storage.notifyChanges;
          this.plugin.storage.notifyChanges = notifyChanges;
          await this.plugin.saveSettings();
          button.buttonEl.setCssStyles({
            "background": notifyChanges ? selectedCol : unselectedColor,
            "color": notifyChanges ? selectedTxtCol : unselectedTxtCol
          });
          noticeDisplay.setDesc(`${stateTextMap(this.plugin.storage.notifyConflicts, notifyChanges)} after sync.`);
        });
        button.buttonEl.setCssStyles({
          "background": this.plugin.storage.notifyChanges ? selectedCol : unselectedColor,
          "color": this.plugin.storage.notifyChanges ? selectedTxtCol : unselectedTxtCol
        });
      });
    };
    this.counterRepoBlock = () => {
      const { containerEl } = this;
      new import_obsidian4.Setting(containerEl).setName("Manage repositories").setDesc("Add or remove repository configurations").addButton((button) => button.setButtonText("Add Repository").setCta().onClick(async () => {
        this.plugin.storage.repo.push(DEFAULT_REPOSITORY);
        await this.plugin.saveSettings();
        await this.display();
      })).addButton((button) => button.setButtonText("Remove Repository").setWarning().setDisabled(this.plugin.storage.repo.length <= 1).onClick(async () => {
        if (this.plugin.storage.repo.length > 1) {
          this.plugin.storage.repo.splice(this.currentSyncIndex, 1);
          if (this.currentSyncIndex >= this.plugin.storage.repo.length) {
            this.currentSyncIndex = this.plugin.storage.repo.length - 1;
          }
          await this.plugin.saveSettings();
          await this.display();
        }
      }));
      new import_obsidian4.Setting(containerEl).setName("Current repository").setDesc("Select which repository configuration to edit").addDropdown((dropdown) => {
        this.plugin.storage.repo.forEach((_, index) => {
          dropdown.addOption(index.toString(), `Repository ${index + 1}`);
        });
        dropdown.setValue(this.currentSyncIndex.toString());
        dropdown.onChange(async (value) => {
          this.currentSyncIndex = parseInt(value);
          await this.plugin.saveSettings();
          await this.display();
        });
      });
    };
    this.resetBlock = () => {
      const { containerEl } = this;
      new import_obsidian4.Setting(containerEl).setName("Reset settings").setDesc("Remove Sync storage or Settings").addButton((button) => button.setButtonText("Reset storage").setWarning().onClick(async () => {
        for (let storage of this.plugin.storage.repo) {
          storage.localStore = DEFAULT_LOCAL_STORE;
        }
        await this.plugin.saveSettings();
        await this.display();
      })).addButton((button) => button.setButtonText("Reset Settings").setWarning().onClick(async () => {
        this.plugin.storage.repo = [DEFAULT_REPOSITORY];
        await this.plugin.saveSettings();
        await this.display();
      }));
    };
    this.plugin = plugin;
  }
  getCurrentSyncSetting() {
    return this.plugin.storage.repo[this.currentSyncIndex].settings;
  }
  async githubUserInfoBlock() {
    const { containerEl } = this;
    const currentSetting = this.getCurrentSyncSetting();
    const allItems = await this.plugin.vaultOps.getAllInVault();
    const allPaths = [...allItems.folders, ...allItems.files];
    const { folders, files } = allItems;
    new import_obsidian4.Setting(containerEl).setHeading().setName(`GitHub user info (Repository ${this.currentSyncIndex + 1})`);
    new import_obsidian4.Setting(containerEl).setName("Github username").setDesc("Enter your name on Github").addText((text) => text.setPlaceholder("GitHub username").setValue(currentSetting.owner).onChange(async (value) => {
      currentSetting.owner = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Github personal access token").setDesc("Remember to give it access for reading and writing to the storage repo.").addText((text) => text.setPlaceholder("GitHub personal access token").setValue(currentSetting.pat).onChange(async (value) => {
      currentSetting.pat = value;
      await this.plugin.saveSettings();
    })).addExtraButton((button) => button.setIcon("external-link").setTooltip("Create a token").onClick(async () => {
      window.open("https://github.com/settings/tokens/new", "_blank");
    }));
    new import_obsidian4.Setting(containerEl).setName("Device name").setDesc("Sign commit message with this device name.").addText((text) => text.setPlaceholder("Device name").setValue(currentSetting.deviceName).onChange(async (value) => {
      currentSetting.deviceName = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Repository name").setDesc("Select a repo.").addText((text) => text.setPlaceholder("Repository").setValue(currentSetting.repo).onChange(async (value) => {
      currentSetting.repo = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Branch name").setDesc("Select a branch.").addText((text) => text.setPlaceholder("Branch").setValue(currentSetting.branch).onChange(async (value) => {
      currentSetting.branch = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Sync path").setDesc("Select a local path to sync with the repo. If the field is empty, the entire vault will be synced.").addText(async (text) => {
      var _a;
      text.setPlaceholder("Enter folder path").setValue(currentSetting.syncPath || "").onChange(async (value) => {
        if (!folders2.contains(value))
          return;
        currentSetting.syncPath = value;
        await this.plugin.saveSettings();
      });
      const dataList = document.createElement("datalist");
      dataList.id = `folder-suggestions`;
      const otherSyncPath = /* @__PURE__ */ new Set();
      this.plugin.storage.repo.forEach(
        (el, i) => {
          if (i == this.currentSyncIndex)
            return;
          otherSyncPath.add(
            el.settings.syncPath
          );
        }
      );
      const allFolders = new Set(
        await this.plugin.vaultOps.getFoldersInVault()
      );
      const folders2 = Array.from(
        difference(allFolders, otherSyncPath)
      );
      for (let i in folders2) {
        const folder = folders2[i];
        const option = document.createElement("option");
        option.value = folder;
        dataList.appendChild(option);
      }
      text.inputEl.setAttribute("list", `folder-suggestions`);
      (_a = text.inputEl.parentElement) == null ? void 0 : _a.appendChild(dataList);
    });
    new import_obsidian4.Setting(containerEl).setName("View your vault on GitHub").addExtraButton(
      (button) => button.setTooltip("Open on GitHub").setIcon("external-link").onClick(() => {
        const link = this.getLatestLink();
        console.log(`opening ${link}`);
        window.open(link);
      })
    ).descEl.addClass("link-desc");
    new import_obsidian4.Setting(containerEl).setName("Excluded files/folders").setDesc("Files or folders within sync path that will not be synced").addButton((button) => button.setButtonText("Add exclusion").setCta().onClick(async () => {
      if (!currentSetting.excludes) {
        currentSetting.excludes = [];
      }
      currentSetting.excludes.push("");
      await this.plugin.saveSettings();
      await this.display();
    }));
    for (let index_ in currentSetting.excludes) {
      const index = Number(index_);
      const exclude = currentSetting.excludes[index];
      new import_obsidian4.Setting(containerEl).setName(`Exclusion ${index + 1}`).addText((text) => {
        var _a;
        text.setPlaceholder("path/to/exclude").setValue(exclude).onChange(async (value) => {
          if (!folders.contains(value) && !files.contains(value))
            return;
          currentSetting.excludes[index] = value;
          await this.plugin.saveSettings();
        });
        const dataList = document.createElement("datalist");
        dataList.id = `exclude-suggestions-${index}`;
        let filteredPaths = allPaths;
        if (currentSetting.syncPath) {
          filteredPaths = allPaths.filter(
            (path) => path.startsWith(currentSetting.syncPath + "/") || path === currentSetting.syncPath
          );
        }
        filteredPaths.forEach((path) => {
          const option = document.createElement("option");
          option.value = path;
          dataList.appendChild(option);
        });
        text.inputEl.setAttribute("list", `exclude-suggestions-${index}`);
        (_a = text.inputEl.parentElement) == null ? void 0 : _a.appendChild(dataList);
      }).addButton((button) => button.setIcon("trash").setTooltip("Remove this exclusion").onClick(async () => {
        currentSetting.excludes.splice(index, 1);
        await this.plugin.saveSettings();
        await this.display();
      }));
    }
  }
  async getItemsInSyncPath() {
    const currentSetting = this.getCurrentSyncSetting();
    if (!currentSetting.syncPath)
      return [];
    try {
      const syncPath = currentSetting.syncPath;
      const allItems = [];
      const all = await this.plugin.vaultOps.getAllInVault();
      for (const file in all) {
        if (syncPath == "" || file.startsWith(syncPath + "/") || file === syncPath) {
          allItems.push(file);
        }
      }
      return allItems.sort();
    } catch (error) {
      console.error("Error getting items in sync path:", error);
      return [];
    }
  }
  importExport() {
    const { containerEl } = this;
    new import_obsidian4.Setting(containerEl).setName("Import/Export settings").setDesc("Backup or restore your plugin configuration").setHeading();
    const textAreaContainer = containerEl.createDiv("import-export-container");
    const textArea = textAreaContainer.createEl("textarea", {
      attr: {
        placeholder: "Configuration JSON will appear here...",
        rows: "10",
        style: "width: 100%; font-family: monospace;"
      },
      cls: "import-export-textarea"
    });
    new import_obsidian4.Setting(containerEl).addButton((button) => button.setButtonText("Export to Text Field").setCta().onClick(async () => {
      this.exportToTextField(textArea);
    })).addButton((button) => button.setButtonText("Import from Text Field").setWarning().onClick(async () => {
      await this.importFromTextField(textArea);
    })).addButton((button) => button.setButtonText("Clear Field").setIcon("trash").onClick(() => {
      textArea.value = "";
    }));
  }
  exportToTextField(textArea) {
    try {
      const result = structuredClone(this.plugin.storage);
      for (let i in result.repo) {
        delete result.repo[i].localStore;
      }
      const settingsJson = JSON.stringify(result, null, 4);
      textArea.value = settingsJson;
      textArea.focus();
      textArea.select();
    } catch (error) {
      console.error("Error exporting settings:", error);
      new import_obsidian4.Notice("Error exporting configuration", 3e3);
    }
  }
  async importFromTextField(textArea) {
    try {
      const jsonContent = textArea.value.trim();
      if (!jsonContent) {
        new import_obsidian4.Notice("Text field is empty", 3e3);
        return;
      }
      const importedSettings = JSON.parse(jsonContent);
      if (this.validateImportedSettings(importedSettings)) {
        for (let repo of importedSettings.repo) {
          repo.localStore = DEFAULT_LOCAL_STORE;
        }
        this.plugin.storage = importedSettings;
        await this.plugin.saveSettings();
        new import_obsidian4.Notice("Settings imported successfully!", 3e3);
        await this.display();
      } else {
        new import_obsidian4.Notice("Invalid settings format in text field", 4e3);
      }
    } catch (error) {
      console.error("Error importing settings from text field:", error);
      new import_obsidian4.Notice("Error parsing JSON configuration", 4e3);
    }
  }
  validateImportedSettings(settings) {
    return settings && typeof settings === "object" && Array.isArray(settings.repo) && settings.repo.length > 0 && settings.repo[0].settings && typeof settings.repo[0].settings === "object" && "syncPath" in settings.repo[0].settings;
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    this.localConfigBlock();
    this.noticeConfigBlock();
    containerEl.createEl("hr");
    await this.importExport();
    containerEl.createEl("hr");
    this.counterRepoBlock();
    containerEl.createEl("hr");
    this.resetBlock();
    containerEl.createEl("hr");
    await this.githubUserInfoBlock();
  }
};

// src/fitSync.ts
var import_obsidian5 = require("obsidian");

// src/fitPull.ts
var FitPull = class {
  constructor(fit) {
    this.fit = fit;
  }
  async performPrePullChecks(localChanges) {
    const { remoteCommitSha, updated } = await this.fit.remoteUpdated();
    if (!updated) {
      return { status: "localCopyUpToDate", remoteUpdate: null };
    }
    if (!localChanges) {
      localChanges = await this.fit.getLocalChanges();
    }
    const remoteTreeSha = await this.fit.getRemoteTreeSha(remoteCommitSha);
    const remoteChanges = await this.fit.getRemoteChanges(remoteTreeSha);
    const clashedFiles = this.fit.getClashedChanges(localChanges, remoteChanges);
    const prePullCheckStatus = remoteChanges.length > 0 ? clashedFiles.length > 0 ? "localChangesClashWithRemoteChanges" : "remoteChangesCanBeMerged" : "noRemoteChangesDetected";
    return {
      status: prePullCheckStatus,
      remoteUpdate: {
        remoteChanges,
        remoteTreeSha,
        latestRemoteCommitSha: remoteCommitSha,
        clashedFiles
      }
    };
  }
  // Get changes from remote, pathShaMap is coupled to the Fit plugin design
  async getRemoteNonDeletionChangesContent(pathShaMap) {
    const remoteChanges = Object.entries(pathShaMap).map(async ([path, file_sha]) => {
      const content = await this.fit.getBlob(file_sha);
      return { path, content };
    });
    return await Promise.all(remoteChanges);
  }
  async prepareChangesToExecute(remoteChanges) {
    const deleteFromLocal = remoteChanges.filter((c) => c.status == "REMOVED").map((c) => c.path);
    const changesToProcess = remoteChanges.filter((c) => c.status != "REMOVED").reduce(
      (acc, change) => {
        acc[change.path] = change.currentSha;
        return acc;
      },
      {}
    );
    const addToLocal = await this.getRemoteNonDeletionChangesContent(changesToProcess);
    return { addToLocal, deleteFromLocal };
  }
  async pullRemoteToLocal(remoteUpdate, saveLocalStoreCallback) {
    const { remoteChanges, remoteTreeSha, latestRemoteCommitSha } = remoteUpdate;
    let { addToLocal, deleteFromLocal } = await this.prepareChangesToExecute(remoteChanges);
    const basepath = this.fit.syncPath;
    addToLocal = this.fit.getAddToLocal(addToLocal);
    deleteFromLocal = this.fit.getDeleteFromLocal(deleteFromLocal);
    const fileOpsRecord = await this.fit.vaultOps.updateLocalFiles(
      addToLocal,
      deleteFromLocal
    );
    await saveLocalStoreCallback(
      basepath,
      {
        lastFetchedRemoteSha: remoteTreeSha,
        lastFetchedCommitSha: latestRemoteCommitSha,
        localSha: await this.fit.computeLocalSha()
      }
    );
    return fileOpsRecord;
  }
};

// src/fitPush.ts
var FitPush = class {
  constructor(fit) {
    this.fit = fit;
  }
  async createCommitFromLocalUpdate(localUpdate, remoteTree) {
    const { localChanges, parentCommitSha } = localUpdate;
    const pushedChanges = [];
    const treeNodes = (await Promise.all(localChanges.map(async (f, i) => {
      const node = await this.fit.createTreeNodeFromFile(f, remoteTree);
      if (node) {
        pushedChanges.push(localChanges[i]);
        return node;
      }
    }))).filter(Boolean);
    console.log(treeNodes);
    if (treeNodes.length === 0) {
      return null;
    }
    const latestRemoteCommitTreeSha = await this.fit.getCommitTreeSha(parentCommitSha);
    const createdTreeSha = await this.fit.createTree(treeNodes, latestRemoteCommitTreeSha);
    const createdCommitSha = await this.fit.createCommit(createdTreeSha, parentCommitSha);
    return { createdCommitSha, pushedChanges };
  }
  async pushChangedFilesToRemote(localUpdate) {
    if (localUpdate.localChanges.length == 0) {
      return null;
    }
    const remoteTree = await this.fit.getTree(localUpdate.parentCommitSha);
    const createCommitResult = await this.createCommitFromLocalUpdate(localUpdate, remoteTree);
    if (!createCommitResult) {
      return null;
    }
    const { createdCommitSha, pushedChanges } = createCommitResult;
    const updatedRefSha = await this.fit.updateRef(createdCommitSha);
    const updatedRemoteTreeSha = await this.fit.getRemoteTreeSha(updatedRefSha);
    return {
      pushedChanges,
      lastFetchedRemoteSha: updatedRemoteTreeSha,
      lastFetchedCommitSha: createdCommitSha
    };
  }
};

// src/fitSync.ts
var FitSync = class {
  constructor(fit, vaultOps, saveLocalStoreCallback) {
    this.fit = fit;
    this.fitPull = new FitPull(fit);
    this.fitPush = new FitPush(fit);
    this.vaultOps = vaultOps;
    this.saveLocalStoreCallback = saveLocalStoreCallback;
  }
  async performPreSyncChecks() {
    const currentLocalSha = await this.fit.computeLocalSha();
    const localChanges = await this.fit.getLocalChanges(currentLocalSha);
    const { remoteCommitSha, updated: remoteUpdated } = await this.fit.remoteUpdated();
    if (localChanges.length === 0 && !remoteUpdated) {
      return { status: "inSync" };
    }
    const remoteTreeSha = await this.fit.getRemoteTreeSha(remoteCommitSha);
    const remoteChanges = await this.fit.getRemoteChanges(remoteTreeSha);
    let clashes = [];
    let status;
    if (localChanges.length > 0 && !remoteUpdated) {
      status = "onlyLocalChanged";
    } else if (remoteUpdated && localChanges.length === 0 && remoteChanges.length === 0) {
      status = "onlyRemoteCommitShaChanged";
    } else if (localChanges.length === 0 && remoteUpdated) {
      status = "onlyRemoteChanged";
    } else {
      clashes = this.fit.getClashedChanges(localChanges, remoteChanges);
      if (clashes.length === 0) {
        status = "localAndRemoteChangesCompatible";
      } else {
        status = "localAndRemoteChangesClashed";
      }
    }
    return {
      status,
      remoteUpdate: {
        remoteChanges,
        remoteTreeSha,
        latestRemoteCommitSha: remoteCommitSha,
        clashedFiles: clashes
      },
      localChanges,
      localTreeSha: currentLocalSha
    };
  }
  generateConflictReport(path, localContent, remoteContent) {
    const detectedExtension = extractExtension(path);
    let resolutionStrategy = "utf-8";
    if (detectedExtension && !RECOGNIZED_TXT_EXT.includes(detectedExtension))
      resolutionStrategy = "binary";
    return {
      path,
      resolutionStrategy,
      localContent,
      remoteContent
    };
  }
  async handleBinaryConflict(path, localContent, remoteContent) {
    const conflictPath = this.fit.syncPath + path;
    const conflictResolutionPath = conflictResolutionFolder + conflictPath;
    const excludes = this.fit.excludes;
    let isExcluded = false;
    if (excludes.length) {
      isExcluded = excludes.some((el) => conflictResolutionPath.startsWith(el));
    }
    if (isExcluded)
      return null;
    await Promise.all([
      this.fit.vaultOps.writeToLocal(conflictPath, remoteContent),
      this.fit.vaultOps.writeToLocal(conflictResolutionPath, localContent)
    ]);
    return {
      path: conflictResolutionPath,
      status: "created"
    };
  }
  async handleUTF8Conflict(path, localContent, remoteContent) {
    const conflictPath = this.fit.syncPath + path;
    const conflictResolutionPath = conflictResolutionFolder + conflictPath;
    const excludes = this.fit.excludes;
    let isExcluded = false;
    if (excludes.length) {
      isExcluded = excludes.some((el) => conflictResolutionPath.startsWith(el));
    }
    if (isExcluded)
      return null;
    await Promise.all([
      this.fit.vaultOps.writeToLocal(conflictPath, remoteContent),
      this.fit.vaultOps.writeToLocal(conflictResolutionPath, localContent)
    ]);
    return {
      path: conflictResolutionPath,
      status: "created"
    };
  }
  async handleLocalDeletionConflict(path, remoteContent) {
    const conflictResolutionPath = this.fit.syncPath + path;
    const excludes = this.fit.excludes;
    let isExcluded = false;
    if (excludes.length) {
      isExcluded = excludes.some((el) => conflictResolutionPath.startsWith(el));
    }
    if (isExcluded)
      return null;
    await this.fit.vaultOps.writeToLocal(conflictResolutionPath, remoteContent);
    return {
      path: conflictResolutionPath,
      status: "created"
    };
  }
  async resolveFileConflict(clash, latestRemoteFileSha) {
    if (clash.localStatus === "deleted" && clash.remoteStatus === "REMOVED") {
      return { path: clash.path, noDiff: true };
    } else if (clash.localStatus === "deleted") {
      const remoteContent2 = await this.fit.getBlob(latestRemoteFileSha);
      const fileOp = await this.handleLocalDeletionConflict(clash.path, remoteContent2);
      if (!fileOp)
        return null;
      return { path: clash.path, noDiff: false, fileOp };
    }
    const path = this.fit.syncPath + clash.path;
    const localFileContent = (0, import_obsidian5.arrayBufferToBase64)(
      await this.fit.vaultOps.vault.adapter.readBinary(path)
    );
    if (!latestRemoteFileSha)
      return { path: clash.path, noDiff: false };
    const remoteContent = await this.fit.getBlob(latestRemoteFileSha);
    if (removeLineEndingsFromBase64String(remoteContent) !== removeLineEndingsFromBase64String(localFileContent)) {
      const report = this.generateConflictReport(clash.path, localFileContent, remoteContent);
      let fileOp;
      if (report.resolutionStrategy === "binary") {
        fileOp = await this.handleBinaryConflict(clash.path, report.localContent, report.remoteContent);
      } else {
        fileOp = await this.handleUTF8Conflict(clash.path, report.localContent, report.remoteContent);
      }
      if (!fileOp)
        return null;
      return { path: clash.path, noDiff: false, fileOp };
    }
    return { path: clash.path, noDiff: true };
  }
  async resolveConflicts(clashedFiles, latestRemoteTreeSha) {
    const fileResolutions = await Promise.all(
      clashedFiles.map(
        async (clash) => {
          return await this.resolveFileConflict(clash, latestRemoteTreeSha[clash.path]);
        }
      )
    );
    const unresolvedFiles = fileResolutions.map((res, i) => {
      if (!(res == null ? void 0 : res.noDiff)) {
        return clashedFiles[i];
      }
      return null;
    }).filter(Boolean);
    return {
      noConflict: fileResolutions.every((res) => res == null ? void 0 : res.noDiff),
      unresolvedFiles,
      fileOpsRecord: fileResolutions.map((r) => r == null ? void 0 : r.fileOp).filter(Boolean)
    };
  }
  async syncCompatibleChanges(localUpdate, remoteUpdate, syncNotice) {
    let { addToLocal, deleteFromLocal } = await this.fitPull.prepareChangesToExecute(
      remoteUpdate.remoteChanges
    );
    syncNotice.setMessage("Uploading local changes");
    const remoteTree = await this.fit.getTree(localUpdate.parentCommitSha);
    const createCommitResult = await this.fitPush.createCommitFromLocalUpdate(localUpdate, remoteTree);
    let latestRemoteTreeSha;
    let latestCommitSha;
    let pushedChanges;
    if (createCommitResult) {
      const { createdCommitSha } = createCommitResult;
      const latestRefSha = await this.fit.updateRef(createdCommitSha);
      latestRemoteTreeSha = await this.fit.getRemoteTreeSha(latestRefSha);
      latestCommitSha = createdCommitSha;
      pushedChanges = createCommitResult.pushedChanges;
    } else {
      latestRemoteTreeSha = remoteUpdate.remoteTreeSha;
      latestCommitSha = remoteUpdate.latestRemoteCommitSha;
      pushedChanges = [];
    }
    syncNotice.setMessage("Writing remote changes to local");
    const basepath = this.fit.syncPath;
    addToLocal = this.fit.getAddToLocal(addToLocal);
    deleteFromLocal = this.fit.getDeleteFromLocal(deleteFromLocal);
    const localFileOpsRecord = await this.vaultOps.updateLocalFiles(addToLocal, deleteFromLocal);
    await this.saveLocalStoreCallback(
      basepath,
      {
        lastFetchedRemoteSha: latestRemoteTreeSha,
        lastFetchedCommitSha: latestCommitSha,
        localSha: await this.fit.computeLocalSha()
      }
    );
    syncNotice.setMessage("Sync successful");
    return { localOps: localFileOpsRecord, remoteOps: pushedChanges };
  }
  async syncWithConflicts(localChanges, remoteUpdate, syncNotice) {
    const { latestRemoteCommitSha, clashedFiles, remoteTreeSha: latestRemoteTreeSha } = remoteUpdate;
    const { noConflict, unresolvedFiles, fileOpsRecord } = await this.resolveConflicts(clashedFiles, latestRemoteTreeSha);
    let localChangesToPush;
    let remoteChangesToWrite;
    if (noConflict) {
      remoteChangesToWrite = remoteUpdate.remoteChanges.filter((c) => !localChanges.some((l) => l.path === c.path));
      localChangesToPush = localChanges.filter((c) => !remoteUpdate.remoteChanges.some((r) => r.path === c.path));
    } else {
      syncNotice.setMessage(`Change conflicts detected`);
      remoteChangesToWrite = remoteUpdate.remoteChanges.filter((c) => !unresolvedFiles.some((l) => l.path === c.path));
      localChangesToPush = localChanges;
    }
    let { addToLocal, deleteFromLocal } = await this.fitPull.prepareChangesToExecute(remoteChangesToWrite);
    const syncLocalUpdate = {
      localChanges: localChangesToPush,
      parentCommitSha: latestRemoteCommitSha
    };
    const pushResult = await this.fitPush.pushChangedFilesToRemote(syncLocalUpdate);
    let pushedChanges;
    let lastFetchedCommitSha;
    let lastFetchedRemoteSha;
    if (pushResult) {
      pushedChanges = pushResult.pushedChanges;
      lastFetchedCommitSha = pushResult.lastFetchedCommitSha;
      lastFetchedRemoteSha = pushResult.lastFetchedRemoteSha;
    } else {
      pushedChanges = [];
      lastFetchedCommitSha = remoteUpdate.latestRemoteCommitSha;
      lastFetchedRemoteSha = remoteUpdate.remoteTreeSha;
    }
    const basepath = this.fit.syncPath;
    addToLocal = this.fit.getAddToLocal(addToLocal);
    deleteFromLocal = this.fit.getDeleteFromLocal(deleteFromLocal);
    const localFileOpsRecord = await this.vaultOps.updateLocalFiles(
      addToLocal,
      deleteFromLocal
    );
    await this.saveLocalStoreCallback(
      basepath,
      {
        lastFetchedRemoteSha,
        lastFetchedCommitSha,
        localSha: await this.fit.computeLocalSha()
      }
    );
    const ops = localFileOpsRecord.concat(fileOpsRecord);
    if (unresolvedFiles.length === 0) {
      syncNotice.setMessage(`Sync successful`);
    } else if (unresolvedFiles.some((f) => f.remoteStatus !== "REMOVED")) {
      syncNotice.setMessage(`Synced with remote, unresolved conflicts written to ${conflictResolutionFolder}`);
    } else {
      syncNotice.setMessage(`Synced with remote, ignored remote deletion of locally changed files`);
    }
    return { unresolvedFiles, localOps: ops, remoteOps: pushedChanges };
  }
  async unresolvedChangesConflicts() {
    return await this.vaultOps.vault.adapter.exists(conflictResolutionFolder);
  }
  async sync(syncNotice) {
    syncNotice.setMessage("Performing pre sync checks.");
    if (await this.unresolvedChangesConflicts()) {
      syncNotice.setMessage(`There are unresolved files: pls, resolve files in: ${conflictResolutionFolder}.`);
      return;
    }
    const preSyncCheckResult = await this.performPreSyncChecks();
    if (preSyncCheckResult.status === "inSync") {
      syncNotice.setMessage("Sync successful");
      return;
    }
    if (preSyncCheckResult.status === "onlyRemoteCommitShaChanged") {
      const { latestRemoteCommitSha } = preSyncCheckResult.remoteUpdate;
      await this.saveLocalStoreCallback(
        this.fit.syncPath,
        { lastFetchedCommitSha: latestRemoteCommitSha }
      );
      syncNotice.setMessage("Sync successful");
      return;
    }
    const remoteUpdate = preSyncCheckResult.remoteUpdate;
    if (preSyncCheckResult.status === "onlyRemoteChanged") {
      const fileOpsRecord = await this.fitPull.pullRemoteToLocal(
        remoteUpdate,
        this.saveLocalStoreCallback
      );
      syncNotice.setMessage("Sync successful");
      return {
        ops: [{ heading: "Local file updates:", ops: fileOpsRecord }],
        clash: []
        // basepath: this.fit.syncPath
      };
    }
    const { localChanges, localTreeSha } = preSyncCheckResult;
    const localUpdate = {
      localChanges,
      parentCommitSha: remoteUpdate.latestRemoteCommitSha
    };
    if (preSyncCheckResult.status === "onlyLocalChanged") {
      syncNotice.setMessage("Uploading local changes");
      const pushResult = await this.fitPush.pushChangedFilesToRemote(localUpdate);
      syncNotice.setMessage("Sync successful");
      if (pushResult) {
        await this.saveLocalStoreCallback(
          this.fit.syncPath,
          {
            localSha: localTreeSha,
            lastFetchedRemoteSha: pushResult.lastFetchedRemoteSha,
            lastFetchedCommitSha: pushResult.lastFetchedCommitSha
          }
        );
        return {
          ops: [{ heading: "Local file updates:", ops: pushResult.pushedChanges }],
          clash: []
          // basepath: this.fit.syncPath
        };
      }
      return;
    }
    if (preSyncCheckResult.status === "localAndRemoteChangesCompatible") {
      const { localOps, remoteOps } = await this.syncCompatibleChanges(
        localUpdate,
        remoteUpdate,
        syncNotice
      );
      return {
        ops: [
          { heading: "Local file updates:", ops: localOps },
          { heading: "Remote file updates:", ops: remoteOps }
        ],
        clash: []
        // basepath: this.fit.syncPath
      };
    }
    if (preSyncCheckResult.status === "localAndRemoteChangesClashed") {
      const conflictResolutionResult = await this.syncWithConflicts(
        localUpdate.localChanges,
        remoteUpdate,
        syncNotice
      );
      if (conflictResolutionResult) {
        const { unresolvedFiles, localOps, remoteOps } = conflictResolutionResult;
        return {
          ops: [
            { heading: "Local file updates:", ops: localOps },
            { heading: "Remote file updates:", ops: remoteOps }
          ],
          clash: unresolvedFiles
          // basepath: this.fit.syncPath
        };
      }
    }
  }
};

// src/vaultOps.ts
var import_obsidian6 = require("obsidian");
var VaultOperations = class {
  constructor(vault) {
    this.vault = vault;
  }
  async getTFile(path) {
    const file = this.vault.getAbstractFileByPath(path);
    if (file && file instanceof import_obsidian6.TFile) {
      return file;
    } else {
      return null;
    }
  }
  async deleteFromLocal(path) {
    const isExists = await this.vault.adapter.exists(path);
    if (!isExists) {
      console.error(`Attempting to read ${path} from local drive but not successful:
                the file doesn't exists`);
      return null;
    }
    await this.vault.adapter.remove(path);
    return { path, status: "deleted" };
  }
  // if checking a folder, require including the last / in the path param
  async ensureFolderExists(path) {
    var _a;
    const folderPath = ((_a = path.match(/^(.*)\//)) == null ? void 0 : _a[1]) || "";
    if (folderPath == "") {
      return false;
    }
    const parts = folderPath.split("/");
    let currentPath = "";
    for (const part of parts) {
      currentPath += part + "/";
      try {
        const isExists = await this.vault.adapter.exists(currentPath, true);
        if (isExists)
          continue;
        await this.vault.adapter.mkdir(currentPath);
      } catch (e) {
        return false;
      }
    }
    return true;
  }
  async writeToLocal(path, content) {
    const file = await this.vault.adapter.exists(path);
    if (file) {
      await this.vault.adapter.writeBinary(path, (0, import_obsidian6.base64ToArrayBuffer)(content));
      return { path, status: "changed" };
    } else {
      await this.ensureFolderExists(path);
      await this.vault.adapter.writeBinary(path, (0, import_obsidian6.base64ToArrayBuffer)(content));
      return { path, status: "created" };
    }
  }
  async updateLocalFiles(addToLocal, deleteFromLocal) {
    const writeOperations = addToLocal.map(async ({ path, content }) => {
      return await this.writeToLocal(path, content);
    });
    const deletionOperations = deleteFromLocal.map(async (path) => {
      return await this.deleteFromLocal(path);
    });
    const fileOps = await Promise.all([...writeOperations, ...deletionOperations]);
    return fileOps;
  }
  // TODO хотя нигде не используется, мб удалить надо
  async createCopyInDir(path, copyDir = conflictResolutionFolder) {
    const file = await this.vault.adapter.exists(path);
    if (file) {
      const copyPath = copyDir + path;
      const copy = await this.vault.adapter.readBinary(path);
      await this.ensureFolderExists(copyPath);
      await this.vault.adapter.writeBinary(copyPath, copy);
      await this.vault.adapter.writeBinary(copyPath, copy);
    } else {
      throw new Error(`Attempting to create copy of ${path} from local drive as TFile but not successful,
            file is of type ${typeof file}.`);
    }
  }
  async getAllInObsidian() {
    const rootPath = this.vault.configDir;
    const folders = [rootPath + "/"];
    const files = [];
    const traverseDirectory = async (path) => {
      let items;
      try {
        items = await this.vault.adapter.list(path);
      } catch (error) {
        return null;
      }
      for (const folder of items.folders) {
        await traverseDirectory(folder);
        let folderPath = folder.startsWith("/") ? folder.slice(1) : folder;
        folderPath = folderPath === "" ? "" : `${folderPath}/`;
        folders.push(folderPath);
      }
      for (const file of items.files) {
        let filePath = file.startsWith("/") ? file.slice(1) : file;
        files.push(filePath);
      }
    };
    await traverseDirectory(rootPath);
    return { folders, files };
  }
  async getAllInVault() {
    const all = this.vault.getAllLoadedFiles();
    const folders = [];
    const files = [];
    for (let file of all) {
      if (file instanceof import_obsidian6.TFolder) {
        let path = file.path.startsWith("/") ? file.path.slice(1) : file.path;
        path = path == "" ? "" : `${path}/`;
        folders.push(path);
      } else if (file instanceof import_obsidian6.TFile) {
        const path = file.path.startsWith("/") ? file.path.slice(1) : file.path;
        files.push(path);
      }
    }
    const obsidianItems = await this.getAllInObsidian();
    const [obsidianFiles, obsidianFolders] = [obsidianItems.files, obsidianItems.folders];
    folders.push(...obsidianFolders);
    files.push(...obsidianFiles);
    return { folders, files };
  }
  async getFoldersInVault() {
    const { folders } = await this.getAllInVault();
    return folders;
  }
  async getFilesInVault() {
    const { files } = await this.getAllInVault();
    return files;
  }
};

// main.ts
var DEFAULT_LOCAL_STORE = {
  localSha: {},
  lastFetchedCommitSha: null,
  lastFetchedRemoteSha: {}
};
var DEFAULT_REPOSITORY = {
  settings: {
    pat: "",
    owner: "",
    avatarUrl: "",
    repo: "",
    branch: "",
    syncPath: "",
    deviceName: "",
    excludes: []
  },
  localStore: { ...DEFAULT_LOCAL_STORE }
};
var DEFAULT_SETTINGS = {
  repo: [DEFAULT_REPOSITORY],
  checkEveryXMinutes: 5,
  autoSync: "off",
  notifyChanges: true,
  notifyConflicts: true
};
var FitPlugin2 = class extends import_obsidian7.Plugin {
  constructor() {
    super(...arguments);
    // localStore: LocalStores
    this.fits = [];
    this.fitSync = [];
    // use of arrow functions to ensure this refers to the FitPlugin class
    this.saveLocalStoreCallback = async (path, localStore) => {
      const i = this.storage.repo.findIndex(
        (storage, _) => storage.settings.syncPath === path
      );
      if (i < 0) {
        return;
      }
      await this.loadSettings();
      this.storage.repo[i].localStore = {
        ...this.storage.repo[i].localStore,
        ...localStore
      };
      await this.saveSettings();
    };
    this.sync = async (syncNotice) => {
      if (!this.checkSettingsConfigured()) {
        return;
      }
      for (let i_ in this.fitSync) {
        let i = Number(i_);
        const fitSync = this.fitSync[i];
        const syncRecords = await fitSync.sync(syncNotice);
        if (!syncRecords)
          continue;
        let { ops, clash } = syncRecords;
        const basepath = this.storage.repo[i].settings.syncPath;
        clash = clash.map(
          (el) => {
            return {
              ...el,
              path: basepath + el.path
            };
          }
        );
        if (this.storage.notifyConflicts)
          showUnappliedConflicts(clash);
        if (this.storage.notifyChanges)
          showFileOpsRecord(ops);
      }
    };
    // wrapper to convert error to notice, return true if error is caught
    this.catchErrorAndNotify = async (func, notice, ...args) => {
      try {
        const result = await func(notice, ...args);
        return result;
      } catch (error) {
        if (error instanceof OctokitHttpError) {
          console.log("error.status");
          console.log(error.status);
          switch (error.source) {
            case "getTree":
            case "getRef":
              console.error("Caught error from getRef: ", error.message);
              if (error.status === 404) {
                notice.setMessage("Failed to get ref, make sure your repo name and branch name are set correctly.", true);
                return true;
              }
              notice.setMessage("Unknown error in getting ref, refers to console for details.", true);
              return true;
            case "getCommitTreeSha":
            case "getRemoteTreeSha":
            case "createBlob":
            case "createTreeNodeFromFile":
            case "createCommit":
            case "updateRef":
            case "getBlob":
          }
          return true;
        }
        console.error("Caught unknown error: ", error);
        notice.setMessage("Unable to sync, if you are not connected to the internet, turn off auto sync.", true);
        return true;
      }
    };
  }
  // if settings not configured, open settings to let user quickly setup
  // Note: this is not a stable feature and might be disabled at any point in the future
  openPluginSettings() {
    const appWithSetting = this.app;
    appWithSetting.setting.open();
    appWithSetting.setting.openTabById("fit");
  }
  async checkSettingsConfigured() {
    const actionItems = [];
    const settings = this.storage.repo;
    const folders = await this.vaultOps.getFoldersInVault();
    const setSyncPath = /* @__PURE__ */ new Set();
    for (let i_ in settings) {
      const i = Number(i_);
      const currentSetting = settings[i].settings;
      if (currentSetting.pat === "") {
        actionItems.push(`provide GitHub personal access token for repository: ${i + 1}`);
      }
      if (currentSetting.owner === "") {
        actionItems.push(`enter your Github nickname for repository: ${i + 1}`);
      }
      if (currentSetting.repo === "") {
        actionItems.push(`enter a repository to sync: ${i + 1}`);
      }
      if (currentSetting.branch === "") {
        actionItems.push(`enter a branch to sync: ${i + 1}`);
      }
      if (!folders.contains(currentSetting.syncPath)) {
        actionItems.push(`enter a directory (syncPath): ${i + 1}`);
      }
      for (let exlude of currentSetting.excludes) {
        if (exlude.startsWith(currentSetting.syncPath)) {
          continue;
        }
        actionItems.push(`enter a proper exlude (in syncPath) for repository: ${i + 1}`);
        break;
      }
      setSyncPath.add(currentSetting.syncPath);
    }
    if (setSyncPath.size != settings.length) {
      actionItems.push("Remove duplicate syncPaths");
    }
    if (actionItems.length > 0) {
      const initialMessage = "Settings not configured, please complete the following action items:\n" + actionItems.join("\n");
      const settingsNotice = new FitNotice(["static"], initialMessage);
      settingsNotice.remove("static");
      return false;
    }
    return true;
  }
  // TODO change
  async getDiff() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      console.log("\u041D\u0435\u0442 \u0430\u043A\u0442\u0438\u0432\u043D\u043E\u0433\u043E \u0444\u0430\u0439\u043B\u0430");
      return;
    }
    const fileName = activeFile.basename;
    const filePath = activeFile.path;
    let leaf = this.app.workspace.getLeavesOfType(VIEW_TYPE)[0];
    if (!leaf) {
      leaf = this.app.workspace.getLeaf(false);
      await leaf.setViewState({
        type: VIEW_TYPE,
        active: true
      });
    }
    this.app.workspace.revealLeaf(leaf);
    const view = leaf.view;
    if (view instanceof FileNameView) {
      view.updateContent(fileName, filePath);
    }
  }
  loadRibbonIcons() {
    this.fitSyncRibbonIconEl = this.addRibbonIcon("github", "Fit Sync", async (evt) => {
      if (this.syncing || this.autoSyncing) {
        return;
      }
      this.syncing = true;
      this.fitSyncRibbonIconEl.addClass("animate-icon");
      const syncNotice = new FitNotice(["loading"], "Initiating sync");
      const errorCaught = await this.catchErrorAndNotify(this.sync, syncNotice);
      this.fitSyncRibbonIconEl.removeClass("animate-icon");
      if (errorCaught === true) {
        syncNotice.remove("error");
        this.syncing = false;
        return;
      }
      syncNotice.remove("done");
      this.syncing = false;
    });
    this.fitSyncRibbonIconEl.addClass("fit-sync-ribbon-el");
    this.addRibbonIcon(
      "git-compare-arrows",
      "Fit: show diff",
      async () => {
        const res = await this.getDiff();
      }
    );
    this.registerView(VIEW_TYPE, (leaf) => new FileNameView(leaf));
  }
  async autoSync() {
    if (this.syncing || this.autoSyncing) {
      return;
    }
    this.autoSyncing = true;
    const syncNotice = new FitNotice(
      ["loading"],
      "Auto syncing",
      0,
      this.storage.autoSync === "muted"
    );
    const errorCaught = await this.catchErrorAndNotify(this.sync, syncNotice);
    if (errorCaught === true) {
      syncNotice.remove("error");
    } else {
      syncNotice.remove();
    }
    this.autoSyncing = false;
  }
  async autoUpdate() {
    if (!(this.storage.autoSync === "off") && !this.syncing && !this.autoSyncing && await this.checkSettingsConfigured()) {
      if (this.storage.autoSync === "on" || this.storage.autoSync === "muted") {
        await this.autoSync();
      } else if (this.storage.autoSync === "remind") {
        for (let fit of this.fits) {
          const { updated } = await fit.remoteUpdated();
          if (updated) {
            const initialMessage = "Remote update detected, please pull the latest changes.";
            const intervalNotice = new FitNotice(["static"], initialMessage);
            intervalNotice.remove("static");
          }
        }
      }
    }
  }
  async startOrUpdateAutoSyncInterval() {
    if (this.autoSyncIntervalId !== null) {
      window.clearInterval(this.autoSyncIntervalId);
      this.autoSyncIntervalId = null;
    }
    this.autoSyncIntervalId = window.setInterval(async () => {
      await this.autoUpdate();
    }, this.storage.checkEveryXMinutes * 60 * 1e3);
  }
  async onload() {
    await this.loadSettings();
    this.vaultOps = new VaultOperations(this.app.vault);
    const excludes = this.getExcludes();
    for (let repo_ of this.storage.repo) {
      let repo = structuredClone(repo_);
      for (let exclude of excludes) {
        if (exclude === repo.settings.syncPath)
          continue;
        repo.settings.excludes.push(exclude);
      }
      const fit = new Fit(repo, this.vaultOps);
      this.fits.push(fit);
      this.fitSync.push(
        new FitSync(fit, this.vaultOps, this.saveLocalStoreCallback)
      );
    }
    this.syncing = false;
    this.autoSyncing = false;
    this.settingTab = new FitSettingTab(this.app, this);
    this.loadRibbonIcons();
    this.addSettingTab(new FitSettingTab(this.app, this));
    await this.startOrUpdateAutoSyncInterval();
  }
  onunload() {
    if (this.autoSyncIntervalId !== null) {
      window.clearInterval(this.autoSyncIntervalId);
      this.autoSyncIntervalId = null;
    }
  }
  async loadSettings() {
    const userSetting = await this.loadData();
    const settings = Object.assign({}, DEFAULT_SETTINGS, userSetting);
    const settingsObj = Object.keys(DEFAULT_SETTINGS).reduce(
      (obj, key) => {
        if (settings.hasOwnProperty(key)) {
          if (key == "checkEveryXMinutes") {
            obj[key] = Number(settings[key]);
          } else if (key === "notifyChanges" || key === "notifyConflicts") {
            obj[key] = Boolean(settings[key]);
          } else {
            obj[key] = settings[key];
          }
        }
        return obj;
      },
      {}
    );
    this.storage = settingsObj;
  }
  // allow saving of local stores property, passed in properties will override existing stored value
  async saveSettings() {
    const data = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    const result = { ...data, ...this.storage };
    await this.saveData(result);
    const excludes = this.getExcludes();
    for (let i in this.fits) {
      let repo = structuredClone(this.storage.repo[i]);
      for (let exclude of excludes) {
        if (exclude === repo.settings.syncPath)
          continue;
        repo.settings.excludes.push(exclude);
      }
      this.fits[i].loadSettings(repo);
    }
    this.startOrUpdateAutoSyncInterval();
  }
  getExcludes() {
    const excludes = [];
    for (let repo of this.storage.repo) {
      const path = repo.settings.syncPath;
      if (path)
        excludes.push(path);
    }
    return excludes;
  }
};
var FileNameView = class extends import_obsidian7.ItemView {
  constructor(leaf) {
    super(leaf);
  }
  getViewType() {
    return "file-name-view";
  }
  getDisplayText() {
    return "\u0418\u043C\u044F \u0444\u0430\u0439\u043B\u0430";
  }
  getIcon() {
    return "document";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    this.contentEl = container.createDiv("file-name-content");
    this.contentEl.setText("\u041D\u0430\u0436\u043C\u0438\u0442\u0435 \u043D\u0430 \u0438\u043A\u043E\u043D\u043A\u0443 \u0432 ribbon \u0434\u043B\u044F \u043E\u0442\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u0438\u043C\u0435\u043D\u0438 \u0444\u0430\u0439\u043B\u0430");
  }
  async onClose() {
    if (this.contentEl) {
      this.contentEl.empty();
    }
  }
  // Метод для обновления содержимого
  updateContent(fileName, filePath) {
    if (this.contentEl) {
      this.contentEl.empty();
      this.contentEl.createEl("h2", { text: "\u0418\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u044F \u043E \u0444\u0430\u0439\u043B\u0435" });
      this.contentEl.createEl("p", { text: `\u0418\u043C\u044F \u0444\u0430\u0439\u043B\u0430: ${fileName}` });
      this.contentEl.createEl("p", { text: `\u041F\u0443\u0442\u044C: ${filePath}` });
      this.contentEl.createEl("p", {
        text: "\u042D\u0442\u043E view \u0441\u043E\u0437\u0434\u0430\u043D\u043E \u043F\u043B\u0430\u0433\u0438\u043D\u043E\u043C",
        cls: "file-name-description"
      });
    }
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyIsICJzcmMvY29uc3QudHMiLCAibm9kZV9tb2R1bGVzL0BvY3Rva2l0L2NvcmUvbm9kZV9tb2R1bGVzL3VuaXZlcnNhbC11c2VyLWFnZW50L2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9iZWZvcmUtYWZ0ZXItaG9vay9saWIvcmVnaXN0ZXIuanMiLCAibm9kZV9tb2R1bGVzL2JlZm9yZS1hZnRlci1ob29rL2xpYi9hZGQuanMiLCAibm9kZV9tb2R1bGVzL2JlZm9yZS1hZnRlci1ob29rL2xpYi9yZW1vdmUuanMiLCAibm9kZV9tb2R1bGVzL2JlZm9yZS1hZnRlci1ob29rL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ab2N0b2tpdC9lbmRwb2ludC9ub2RlX21vZHVsZXMvdW5pdmVyc2FsLXVzZXItYWdlbnQvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BvY3Rva2l0L2VuZHBvaW50L2Rpc3QtYnVuZGxlL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ab2N0b2tpdC9yZXF1ZXN0L25vZGVfbW9kdWxlcy91bml2ZXJzYWwtdXNlci1hZ2VudC9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQG9jdG9raXQvcmVxdWVzdC9ub2RlX21vZHVsZXMvQG9jdG9raXQvcmVxdWVzdC1lcnJvci9kaXN0LXNyYy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQG9jdG9raXQvcmVxdWVzdC9kaXN0LWJ1bmRsZS9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQG9jdG9raXQvZ3JhcGhxbC9ub2RlX21vZHVsZXMvdW5pdmVyc2FsLXVzZXItYWdlbnQvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BvY3Rva2l0L2dyYXBocWwvZGlzdC1idW5kbGUvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BvY3Rva2l0L2F1dGgtdG9rZW4vZGlzdC1idW5kbGUvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BvY3Rva2l0L2NvcmUvZGlzdC1zcmMvdmVyc2lvbi5qcyIsICJub2RlX21vZHVsZXMvQG9jdG9raXQvY29yZS9kaXN0LXNyYy9pbmRleC5qcyIsICJzcmMvdXRpbHMudHMiLCAic3JjL2ZpdC50cyIsICJzcmMvZml0Tm90aWNlLnRzIiwgInNyYy9maXRTZXR0aW5nLnRzIiwgInNyYy9maXRTeW5jLnRzIiwgInNyYy9maXRQdWxsLnRzIiwgInNyYy9maXRQdXNoLnRzIiwgInNyYy92YXVsdE9wcy50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgUGx1Z2luLCBTZXR0aW5nVGFiLCBJdGVtVmlldywgV29ya3NwYWNlTGVhZiwgVmlldyB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IGNvbmZsaWN0UmVzb2x1dGlvbkZvbGRlciwgVklFV19UWVBFIH0gZnJvbSAnc3JjL2NvbnN0JztcbmltcG9ydCB7IEZpdCwgT2N0b2tpdEh0dHBFcnJvciB9IGZyb20gJ3NyYy9maXQnO1xuaW1wb3J0IEZpdE5vdGljZSBmcm9tICdzcmMvZml0Tm90aWNlJztcbmltcG9ydCBGaXRTZXR0aW5nVGFiIGZyb20gJ3NyYy9maXRTZXR0aW5nJztcbmltcG9ydCB7IEZpdFN5bmMgfSBmcm9tICdzcmMvZml0U3luYyc7XG5pbXBvcnQgeyBzaG93RmlsZU9wc1JlY29yZCwgc2hvd1VuYXBwbGllZENvbmZsaWN0cyB9IGZyb20gJ3NyYy91dGlscyc7XG5pbXBvcnQgeyBWYXVsdE9wZXJhdGlvbnMgfSBmcm9tICdzcmMvdmF1bHRPcHMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFN5bmNTZXR0aW5nIHtcbiAgICBwYXQ6IHN0cmluZztcbiAgICBvd25lcjogc3RyaW5nO1xuICAgIGF2YXRhclVybDogc3RyaW5nO1xuICAgIHJlcG86IHN0cmluZztcbiAgICBicmFuY2g6IHN0cmluZztcbiAgICBzeW5jUGF0aDogc3RyaW5nO1xuICAgIGRldmljZU5hbWU6IHN0cmluZztcbiAgICBleGNsdWRlczogc3RyaW5nW11cbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2NhbFN0b3JlcyB7XG4gICAgbG9jYWxTaGE6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgICBsYXN0RmV0Y2hlZENvbW1pdFNoYTogc3RyaW5nIHwgbnVsbFxuICAgIGxhc3RGZXRjaGVkUmVtb3RlU2hhOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVwb3NpdG9yeSB7XG4gICAgc2V0dGluZ3M6IFN5bmNTZXR0aW5nXG4gICAgbG9jYWxTdG9yZTogTG9jYWxTdG9yZXNcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGaXRTdG9yYWdlIHtcbiAgICByZXBvOiBSZXBvc2l0b3J5W11cblxuICAgIGNoZWNrRXZlcnlYTWludXRlczogbnVtYmVyO1xuICAgIGF1dG9TeW5jOiBcIm9uXCIgfCBcIm9mZlwiIHwgXCJtdXRlZFwiIHwgXCJyZW1pbmRcIjtcbiAgICBub3RpZnlDaGFuZ2VzOiBib29sZWFuO1xuICAgIG5vdGlmeUNvbmZsaWN0czogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfTE9DQUxfU1RPUkU6IExvY2FsU3RvcmVzID0ge1xuICAgIGxvY2FsU2hhOiB7fSxcbiAgICBsYXN0RmV0Y2hlZENvbW1pdFNoYTogbnVsbCxcbiAgICBsYXN0RmV0Y2hlZFJlbW90ZVNoYToge31cbn1cblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfUkVQT1NJVE9SWSA9IHtcbiAgICBzZXR0aW5nczoge1xuICAgICAgICBwYXQ6IFwiXCIsXG4gICAgICAgIG93bmVyOiBcIlwiLFxuICAgICAgICBhdmF0YXJVcmw6IFwiXCIsXG4gICAgICAgIHJlcG86IFwiXCIsXG4gICAgICAgIGJyYW5jaDogXCJcIixcbiAgICAgICAgc3luY1BhdGg6IFwiXCIsXG4gICAgICAgIGRldmljZU5hbWU6IFwiXCIsXG4gICAgICAgIGV4Y2x1ZGVzOiBbXVxuICAgIH0sXG4gICAgbG9jYWxTdG9yZTogey4uLkRFRkFVTFRfTE9DQUxfU1RPUkV9XG59XG5cblxuY29uc3QgREVGQVVMVF9TRVRUSU5HUzogRml0U3RvcmFnZSA9IHtcbiAgICByZXBvOiBbREVGQVVMVF9SRVBPU0lUT1JZXSxcbiAgICBjaGVja0V2ZXJ5WE1pbnV0ZXM6IDUsXG4gICAgYXV0b1N5bmM6IFwib2ZmXCIsXG4gICAgbm90aWZ5Q2hhbmdlczogdHJ1ZSxcbiAgICBub3RpZnlDb25mbGljdHM6IHRydWUsXG59XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRml0UGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcbiAgICBzdG9yYWdlOiBGaXRTdG9yYWdlO1xuXG4gICAgc2V0dGluZ1RhYjogRml0U2V0dGluZ1RhYlxuICAgIC8vIGxvY2FsU3RvcmU6IExvY2FsU3RvcmVzXG5cbiAgICBmaXRzOiBGaXRbXSA9IFtdO1xuICAgIGZpdFN5bmM6IEZpdFN5bmNbXSA9IFtdXG5cbiAgICB2YXVsdE9wczogVmF1bHRPcGVyYXRpb25zO1xuICAgIGF1dG9TeW5jaW5nOiBib29sZWFuXG4gICAgc3luY2luZzogYm9vbGVhblxuICAgIGF1dG9TeW5jSW50ZXJ2YWxJZDogbnVtYmVyIHwgbnVsbFxuICAgIGZpdFB1bGxSaWJib25JY29uRWw6IEhUTUxFbGVtZW50XG4gICAgZml0UHVzaFJpYmJvbkljb25FbDogSFRNTEVsZW1lbnRcbiAgICBmaXRTeW5jUmliYm9uSWNvbkVsOiBIVE1MRWxlbWVudFxuXG4gICAgLy8gaWYgc2V0dGluZ3Mgbm90IGNvbmZpZ3VyZWQsIG9wZW4gc2V0dGluZ3MgdG8gbGV0IHVzZXIgcXVpY2tseSBzZXR1cFxuICAgIC8vIE5vdGU6IHRoaXMgaXMgbm90IGEgc3RhYmxlIGZlYXR1cmUgYW5kIG1pZ2h0IGJlIGRpc2FibGVkIGF0IGFueSBwb2ludCBpbiB0aGUgZnV0dXJlXG4gICAgb3BlblBsdWdpblNldHRpbmdzKCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCBhcHBXaXRoU2V0dGluZyA9IHRoaXMuYXBwIGFzIGFueSBhcyB7XG4gICAgICAgICAgICBzZXR0aW5nOiB7XG4gICAgICAgICAgICAgICAgb3BlbigpOiB2b2lkO1xuICAgICAgICAgICAgICAgIG9wZW5UYWJCeUlkKGlkOiBzdHJpbmcpOiBTZXR0aW5nVGFiIHwgbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhcHBXaXRoU2V0dGluZy5zZXR0aW5nLm9wZW4oKVxuICAgICAgICBhcHBXaXRoU2V0dGluZy5zZXR0aW5nLm9wZW5UYWJCeUlkKFwiZml0XCIpXG4gICAgfVxuXG4gICAgYXN5bmMgY2hlY2tTZXR0aW5nc0NvbmZpZ3VyZWQoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICAgIGNvbnN0IGFjdGlvbkl0ZW1zOiBBcnJheTxzdHJpbmc+ID0gW11cbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB0aGlzLnN0b3JhZ2UucmVwbztcblxuICAgICAgICBjb25zdCBmb2xkZXJzID0gYXdhaXQgdGhpcy52YXVsdE9wcy5nZXRGb2xkZXJzSW5WYXVsdCgpXG4gICAgICAgIGNvbnN0IHNldFN5bmNQYXRoID0gbmV3IFNldCgpXG5cbiAgICAgICAgZm9yIChsZXQgaV8gaW4gc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBOdW1iZXIoaV8pXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U2V0dGluZyA9IHNldHRpbmdzW2ldLnNldHRpbmdzXG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50U2V0dGluZy5wYXQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25JdGVtcy5wdXNoKGBwcm92aWRlIEdpdEh1YiBwZXJzb25hbCBhY2Nlc3MgdG9rZW4gZm9yIHJlcG9zaXRvcnk6ICR7aSsxfWApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudFNldHRpbmcub3duZXIgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25JdGVtcy5wdXNoKGBlbnRlciB5b3VyIEdpdGh1YiBuaWNrbmFtZSBmb3IgcmVwb3NpdG9yeTogJHtpKzF9YClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50U2V0dGluZy5yZXBvID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uSXRlbXMucHVzaChgZW50ZXIgYSByZXBvc2l0b3J5IHRvIHN5bmM6ICR7aSsxfWApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudFNldHRpbmcuYnJhbmNoID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uSXRlbXMucHVzaChgZW50ZXIgYSBicmFuY2ggdG8gc3luYzogJHtpKzF9YClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICggIWZvbGRlcnMuY29udGFpbnMoY3VycmVudFNldHRpbmcuc3luY1BhdGgpICkge1xuICAgICAgICAgICAgICAgIGFjdGlvbkl0ZW1zLnB1c2goYGVudGVyIGEgZGlyZWN0b3J5IChzeW5jUGF0aCk6ICR7aSsxfWApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBleGx1ZGUgb2YgY3VycmVudFNldHRpbmcuZXhjbHVkZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhsdWRlLnN0YXJ0c1dpdGgoY3VycmVudFNldHRpbmcuc3luY1BhdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFjdGlvbkl0ZW1zLnB1c2goYGVudGVyIGEgcHJvcGVyIGV4bHVkZSAoaW4gc3luY1BhdGgpIGZvciByZXBvc2l0b3J5OiAke2krMX1gKVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldFN5bmNQYXRoLmFkZChjdXJyZW50U2V0dGluZy5zeW5jUGF0aClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXRTeW5jUGF0aC5zaXplICE9IHNldHRpbmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgYWN0aW9uSXRlbXMucHVzaChcIlJlbW92ZSBkdXBsaWNhdGUgc3luY1BhdGhzXCIpXG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmIChhY3Rpb25JdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBpbml0aWFsTWVzc2FnZSA9IFwiU2V0dGluZ3Mgbm90IGNvbmZpZ3VyZWQsIHBsZWFzZSBjb21wbGV0ZSB0aGUgZm9sbG93aW5nIGFjdGlvbiBpdGVtczpcXG5cIiArIGFjdGlvbkl0ZW1zLmpvaW4oXCJcXG5cIilcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzTm90aWNlID0gbmV3IEZpdE5vdGljZShbXCJzdGF0aWNcIl0sIGluaXRpYWxNZXNzYWdlKVxuICAgICAgICAgICAgLy8gdGhpcy5vcGVuUGx1Z2luU2V0dGluZ3MoKVxuICAgICAgICAgICAgc2V0dGluZ3NOb3RpY2UucmVtb3ZlKFwic3RhdGljXCIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoaXMuZml0LmxvYWRTZXR0aW5ncyhjdXJyZW50U2V0dGluZylcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICAvLyB1c2Ugb2YgYXJyb3cgZnVuY3Rpb25zIHRvIGVuc3VyZSB0aGlzIHJlZmVycyB0byB0aGUgRml0UGx1Z2luIGNsYXNzXG4gICAgc2F2ZUxvY2FsU3RvcmVDYWxsYmFjayA9IGFzeW5jIChwYXRoOiBzdHJpbmcsIGxvY2FsU3RvcmU6IFBhcnRpYWw8TG9jYWxTdG9yZXM+KTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgICAgIGNvbnN0IGkgPSB0aGlzLnN0b3JhZ2UucmVwby5maW5kSW5kZXgoXG4gICAgICAgICAgICAoc3RvcmFnZSwgXykgPT4gc3RvcmFnZS5zZXR0aW5ncy5zeW5jUGF0aCA9PT0gcGF0aFxuICAgICAgICApXG5cbiAgICAgICAgaWYgKGkgPCAwKSB7XG4gICAgICAgICAgICAvLyBUT0RPIHNob3cgZXJyb3JcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKVxuXG4gICAgICAgIHRoaXMuc3RvcmFnZS5yZXBvW2ldLmxvY2FsU3RvcmUgPSB7XG4gICAgICAgICAgICAuLi50aGlzLnN0b3JhZ2UucmVwb1tpXS5sb2NhbFN0b3JlLFxuICAgICAgICAgICAgLi4ubG9jYWxTdG9yZVxuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgdGhpcy5zYXZlU2V0dGluZ3MoKVxuICAgIH1cblxuICAgIHN5bmMgPSBhc3luYyAoc3luY05vdGljZTogRml0Tm90aWNlKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgICAgIGlmICghdGhpcy5jaGVja1NldHRpbmdzQ29uZmlndXJlZCgpKSB7IHJldHVybiB9XG4gICAgICAgIC8vIGF3YWl0IHRoaXMubG9hZExvY2FsU3RvcmUoKVxuICAgICAgICBmb3IgKGxldCBpXyBpbiB0aGlzLmZpdFN5bmMpIHtcbiAgICAgICAgICAgIGxldCBpID0gTnVtYmVyKGlfKVxuICAgICAgICAgICAgY29uc3QgZml0U3luYyA9IHRoaXMuZml0U3luY1tpXVxuXG4gICAgICAgICAgICBjb25zdCBzeW5jUmVjb3JkcyA9IGF3YWl0IGZpdFN5bmMuc3luYyhzeW5jTm90aWNlKVxuICAgICAgICAgICAgaWYgKCFzeW5jUmVjb3JkcylcbiAgICAgICAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgICAgICBsZXQgeyBvcHMsIGNsYXNoIH0gPSBzeW5jUmVjb3Jkc1xuICAgICAgICAgICAgY29uc3QgYmFzZXBhdGggPSB0aGlzLnN0b3JhZ2UucmVwb1tpXS5zZXR0aW5ncy5zeW5jUGF0aFxuICAgICAgICAgICAgY2xhc2ggPSBjbGFzaC5tYXAoXG4gICAgICAgICAgICAgICAgZWwgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBiYXNlcGF0aCArIGVsLnBhdGhcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3JhZ2Uubm90aWZ5Q29uZmxpY3RzKVxuICAgICAgICAgICAgICAgIHNob3dVbmFwcGxpZWRDb25mbGljdHMoY2xhc2gpXG5cbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3JhZ2Uubm90aWZ5Q2hhbmdlcylcbiAgICAgICAgICAgICAgICBzaG93RmlsZU9wc1JlY29yZChvcHMpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB3cmFwcGVyIHRvIGNvbnZlcnQgZXJyb3IgdG8gbm90aWNlLCByZXR1cm4gdHJ1ZSBpZiBlcnJvciBpcyBjYXVnaHRcbiAgICBjYXRjaEVycm9yQW5kTm90aWZ5ID0gYXN5bmMgPFAgZXh0ZW5kcyB1bmtub3duW10sIFI+KGZ1bmM6IChub3RpY2U6IEZpdE5vdGljZSwgLi4uYXJnczogUCkgPT4gUHJvbWlzZTxSPiwgbm90aWNlOiBGaXROb3RpY2UsIC4uLmFyZ3M6IFApOiBQcm9taXNlPFIgfCB0cnVlPiA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmdW5jKG5vdGljZSwgLi4uYXJncylcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIE9jdG9raXRIdHRwRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImVycm9yLnN0YXR1c1wiKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9yLnN0YXR1cylcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGVycm9yLnNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdnZXRUcmVlJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZ2V0UmVmJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDYXVnaHQgZXJyb3IgZnJvbSBnZXRSZWY6IFwiLCBlcnJvci5tZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90aWNlLnNldE1lc3NhZ2UoXCJGYWlsZWQgdG8gZ2V0IHJlZiwgbWFrZSBzdXJlIHlvdXIgcmVwbyBuYW1lIGFuZCBicmFuY2ggbmFtZSBhcmUgc2V0IGNvcnJlY3RseS5cIiwgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbm90aWNlLnNldE1lc3NhZ2UoXCJVbmtub3duIGVycm9yIGluIGdldHRpbmcgcmVmLCByZWZlcnMgdG8gY29uc29sZSBmb3IgZGV0YWlscy5cIiwgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2dldENvbW1pdFRyZWVTaGEnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdnZXRSZW1vdGVUcmVlU2hhJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY3JlYXRlQmxvYic6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NyZWF0ZVRyZWVOb2RlRnJvbUZpbGUnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdjcmVhdGVDb21taXQnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICd1cGRhdGVSZWYnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdnZXRCbG9iJzpcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDYXVnaHQgdW5rbm93biBlcnJvcjogXCIsIGVycm9yKVxuICAgICAgICAgICAgbm90aWNlLnNldE1lc3NhZ2UoXCJVbmFibGUgdG8gc3luYywgaWYgeW91IGFyZSBub3QgY29ubmVjdGVkIHRvIHRoZSBpbnRlcm5ldCwgdHVybiBvZmYgYXV0byBzeW5jLlwiLCB0cnVlKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE8gY2hhbmdlXG4gICAgYXN5bmMgZ2V0RGlmZigpIHtcbiAgICAgICAgLy8gVE9ETyBcdTA0M0ZcdTA0NDBcdTA0M0VcdTA0MzJcdTA0MzVcdTA0NDBcdTA0NEZcdTA0NDJcdTA0NEMsIFx1MDQ0N1x1MDQ0Mlx1MDQzRSBcdTA0MzVcdTA0NDFcdTA0NDJcdTA0NEMgXHUwNDQ0XHUwNDMwXHUwNDM5XHUwNDNCXHUwNDRCIF9maXQvY29uZmxpY3QgZWxzZSBlcnJvclxuICAgICAgICAvKiBUT0RPXG4gICAgICAgIFx1MDQxNVx1MDQ0MVx1MDQzQlx1MDQzOCBcdTA0NDRcdTA0MzBcdTA0MzlcdTA0M0IgXHUwNDMxXHUwNDM4XHUwNDNEXHUwNDMwXHUwNDQwXHUwNDNEXHUwNDRCXHUwNDM5LCBcdTA0NDJcdTA0M0UgXHUwNDNGXHUwNDQwXHUwNDNFXHUwNDQxXHUwNDQyXHUwNDNFIFx1MDQzRlx1MDQzOFx1MDQ0MVx1MDQzMFx1MDQ0Mlx1MDQ0QywgXHUwNDQ3XHUwNDQyXHUwNDNFIFx1MDQzRVx1MDQzRCBcdTA0MzhcdTA0MzdcdTA0M0NcdTA0MzVcdTA0M0RcdTA0MzVcdTA0M0RcbiAgICAgICAgXHUwNDE1XHUwNDQxXHUwNDNCXHUwNDM4IFx1MDQ0NFx1MDQzMFx1MDQzOVx1MDQzQlx1MDQzMCBcdTA0M0RcdTA0MzVcdTA0NDIgXHUwNDMyIFx1MDQ0MFx1MDQzNVx1MDQzRlx1MDQzRVx1MDQzN1x1MDQzOFx1MDQ0Mlx1MDQzRVx1MDQ0MFx1MDQzOFx1MDQzOCwgXHUwNDNEXHUwNDNFIFx1MDQzNVx1MDQ0MVx1MDQ0Mlx1MDQ0QyBcdTA0MzIgZml0LCBcdTA0NDJcdTA0M0UgXHUwNDNGXHUwNDM4XHUwNDQxXHUwNDMwXHUwNDQyXHUwNDRDLCBcdTA0NDdcdTA0NDJcdTA0M0UgXHUwNDQ0XHUwNDMwXHUwNDM5XHUwNDNCIFx1MDQzMVx1MDQ0Qlx1MDQzQiBcdTA0NDNcdTA0MzRcdTA0MzBcdTA0M0JcdTA0MzVcdTA0M0QsIFx1MDQzRFx1MDQzRSBcdTA0M0NcdTA0NEIgXHUwNDM1XHUwNDMzXHUwNDNFIFx1MDQzRlx1MDQzRVx1MDQzQ1x1MDQzNVx1MDQzRFx1MDQ0Rlx1MDQzQlx1MDQzOFxuICAgICAgICBcdTA0MjFcdTA0M0VcdTA0MzdcdTA0MzRcdTA0MzBcdTA0MzJcdTA0MzBcdTA0NDJcdTA0NEMgXHUwNDM3XHUwNDMwXHUwNDNDXHUwNDM1XHUwNDQyXHUwNDNBXHUwNDQzIGNvbmZsaWN0Q2FuZ2VzIFx1MDQzMiBfZml0IFx1MDQxM1x1MDQzNFx1MDQzNSBcdTA0MzFcdTA0NDNcdTA0MzRcdTA0MzVcdTA0NDIgXHUwNDQyXHUwNDMwXHUwNDNBXHUwNDMwXHUwNDRGIFx1MDQ0MVx1MDQ0Mlx1MDQ0MFx1MDQ0M1x1MDQzQVx1MDQ0Mlx1MDQ0M1x1MDQ0MFx1MDQzMFxuICAgICAgICBcdTA0NERcdTA0NDJcdTA0M0VcdTA0NDIgXHUwNDQ0XHUwNDMwXHUwNDM5XHUwNDNCIFx1MDQzMVx1MDQ0M1x1MDQzNFx1MDQzNVx1MDQ0MiBcdTA0NDFcdTA0M0VcdTA0MzdcdTA0MzRcdTA0MzBcdTA0MzJcdTA0MzBcdTA0NDJcdTA0NENcdTA0NDFcdTA0NEYgXHUwNDNGXHUwNDQwXHUwNDM4IFx1MDQzRFx1MDQzMFx1MDQzNlx1MDQzMFx1MDQ0Mlx1MDQzOFx1MDQzOCBcdTA0M0RcdTA0MzAgXHUwNDNBXHUwNDNEXHUwNDNFXHUwNDNGXHUwNDNBXHUwNDQzIFx1MDQzOCBcdTA0M0ZcdTA0MzVcdTA0NDBcdTA0MzVcdTA0MzdcdTA0MzBcdTA0M0ZcdTA0MzhcdTA0NDFcdTA0NEJcdTA0MzJcdTA0MzBcdTA0NDJcdTA0NENcdTA0NDFcdTA0NEYsIFx1MDQzNVx1MDQ0MVx1MDQzQlx1MDQzOCBcdTA0M0VcdTA0M0QgXHUwNDM1XHUwNDQxXHUwNDQyXHUwNDRDXG4gICAgICAgID4+Pj4+Pj4+Pj4tLS0tLS0tLS0tc3RhcnQgb2YgdGhlIDxmaWxlIHBhdGg+XG4gICAgICAgIC0tLWxvY2FsIGxpbmVcbiAgICAgICAgPGNvbnRlbnQ+XG4gICAgICAgIC0tLXJlbW90ZSBsaW5lXG4gICAgICAgIDxjb250ZW50PlxuXG4gICAgICAgID4+Pj4+Pj4+Pj4tLS0tLS0tLS0tc3RhcnQgb2YgdGhlIDxmaWxlIHBhdGg+XG4gICAgICAgIGxvY2FsOiAgY2hhbmdlZFxuICAgICAgICByZW1vdGU6IGRlbGV0ZWRcblxuICAgICAgICAqL1xuICAgICAgICAvLyBcdTA0MUZcdTA0M0VcdTA0M0JcdTA0NDNcdTA0NDdcdTA0MzBcdTA0MzVcdTA0M0MgXHUwNDMwXHUwNDNBXHUwNDQyXHUwNDM4XHUwNDMyXHUwNDNEXHUwNDRCXHUwNDM5IFx1MDQ0NFx1MDQzMFx1MDQzOVx1MDQzQlxuICAgICAgICBjb25zdCBhY3RpdmVGaWxlID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcblxuICAgICAgICBpZiAoIWFjdGl2ZUZpbGUpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gYWRkIFx1MDQzRVx1MDQ0OFx1MDQzOFx1MDQzMVx1MDQzQVx1MDQ0M1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1x1MDQxRFx1MDQzNVx1MDQ0MiBcdTA0MzBcdTA0M0FcdTA0NDJcdTA0MzhcdTA0MzJcdTA0M0RcdTA0M0VcdTA0MzNcdTA0M0UgXHUwNDQ0XHUwNDMwXHUwNDM5XHUwNDNCXHUwNDMwJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmaWxlTmFtZSA9IGFjdGl2ZUZpbGUuYmFzZW5hbWU7IC8vIFx1MDQxOFx1MDQzQ1x1MDQ0RiBcdTA0NDRcdTA0MzBcdTA0MzlcdTA0M0JcdTA0MzAgXHUwNDMxXHUwNDM1XHUwNDM3IFx1MDQ0MFx1MDQzMFx1MDQ0MVx1MDQ0OFx1MDQzOFx1MDQ0MFx1MDQzNVx1MDQzRFx1MDQzOFx1MDQ0RlxuICAgICAgICBjb25zdCBmaWxlUGF0aCA9IGFjdGl2ZUZpbGUucGF0aDsgLy8gXHUwNDFGXHUwNDNFXHUwNDNCXHUwNDNEXHUwNDRCXHUwNDM5IFx1MDQzRlx1MDQ0M1x1MDQ0Mlx1MDQ0Q1xuXG4gICAgICAgIC8vIFx1MDQxRlx1MDQzRVx1MDQzQlx1MDQ0M1x1MDQ0N1x1MDQzMFx1MDQzNVx1MDQzQyBcdTA0MzhcdTA0M0JcdTA0MzggXHUwNDQxXHUwNDNFXHUwNDM3XHUwNDM0XHUwNDMwXHUwNDM1XHUwNDNDIHZpZXdcbiAgICAgICAgbGV0IGxlYWYgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0TGVhdmVzT2ZUeXBlKFZJRVdfVFlQRSlbMF1cblxuICAgICAgICBpZiAoIWxlYWYpIHtcbiAgICAgICAgICBsZWFmID0gdGhpcy5hcHAud29ya3NwYWNlLmdldExlYWYoZmFsc2UpO1xuICAgICAgICAgIGF3YWl0IGxlYWYuc2V0Vmlld1N0YXRlKHtcbiAgICAgICAgICAgIHR5cGU6IFZJRVdfVFlQRSxcbiAgICAgICAgICAgIGFjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hcHAud29ya3NwYWNlLnJldmVhbExlYWYobGVhZik7XG5cbiAgICAgICAgY29uc3QgdmlldyA9IGxlYWYudmlld1xuICAgICAgICBpZiAodmlldyBpbnN0YW5jZW9mIEZpbGVOYW1lVmlldykge1xuICAgICAgICAgICAgdmlldy51cGRhdGVDb250ZW50KGZpbGVOYW1lLCBmaWxlUGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zdCBmaWxlcyA9IGF3YWl0IHRoaXMudmF1bHRPcHMuZ2V0RmlsZXNJblZhdWx0KClcbiAgICAgICAgLy8gY29uc3QgY29uZmxpY3RGaWxlcyA9IGZpbGVzLmZpbHRlcihcbiAgICAgICAgLy8gICAgIGVsID0+IGVsLnN0YXJ0c1dpdGgoY29uZmxpY3RSZXNvbHV0aW9uRm9sZGVyKVxuICAgICAgICAvLyApXG4gICAgICAgIC8vIHJldHVyblxuICAgIH1cblxuICAgIGxvYWRSaWJib25JY29ucygpIHtcbiAgICAgICAgLy8gUHVsbCBmcm9tIHJlbW90ZSB0aGVuIFB1c2ggdG8gcmVtb3RlIGlmIG5vIGNsYXNoaW5nIGNoYW5nZXMgZGV0ZWN0ZWQgZHVyaW5nIHB1bGxcbiAgICAgICAgdGhpcy5maXRTeW5jUmliYm9uSWNvbkVsID0gdGhpcy5hZGRSaWJib25JY29uKCdnaXRodWInLCAnRml0IFN5bmMnLCBhc3luYyAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5zeW5jaW5nIHx8IHRoaXMuYXV0b1N5bmNpbmcpIHsgcmV0dXJuIH1cbiAgICAgICAgICAgIHRoaXMuc3luY2luZyA9IHRydWVcbiAgICAgICAgICAgIHRoaXMuZml0U3luY1JpYmJvbkljb25FbC5hZGRDbGFzcygnYW5pbWF0ZS1pY29uJyk7XG4gICAgICAgICAgICBjb25zdCBzeW5jTm90aWNlID0gbmV3IEZpdE5vdGljZShbXCJsb2FkaW5nXCJdLCBcIkluaXRpYXRpbmcgc3luY1wiKTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yQ2F1Z2h0ID0gYXdhaXQgdGhpcy5jYXRjaEVycm9yQW5kTm90aWZ5KHRoaXMuc3luYywgc3luY05vdGljZSk7XG4gICAgICAgICAgICB0aGlzLmZpdFN5bmNSaWJib25JY29uRWwucmVtb3ZlQ2xhc3MoJ2FuaW1hdGUtaWNvbicpO1xuICAgICAgICAgICAgaWYgKGVycm9yQ2F1Z2h0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgc3luY05vdGljZS5yZW1vdmUoXCJlcnJvclwiKVxuICAgICAgICAgICAgICAgIHRoaXMuc3luY2luZyA9IGZhbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzeW5jTm90aWNlLnJlbW92ZShcImRvbmVcIilcbiAgICAgICAgICAgIHRoaXMuc3luY2luZyA9IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZpdFN5bmNSaWJib25JY29uRWwuYWRkQ2xhc3MoJ2ZpdC1zeW5jLXJpYmJvbi1lbCcpO1xuXG4gICAgICAgIHRoaXMuYWRkUmliYm9uSWNvbihcbiAgICAgICAgICAgIFwiZ2l0LWNvbXBhcmUtYXJyb3dzXCIsXG4gICAgICAgICAgICBcIkZpdDogc2hvdyBkaWZmXCIsXG4gICAgICAgICAgICBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5nZXREaWZmKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgKVxuXG4gICAgICAgIHRoaXMucmVnaXN0ZXJWaWV3KFZJRVdfVFlQRSwgKGxlYWYpID0+IG5ldyBGaWxlTmFtZVZpZXcobGVhZikpXG4gICAgfVxuXG4gICAgYXN5bmMgYXV0b1N5bmMoKSB7XG4gICAgICAgIGlmICh0aGlzLnN5bmNpbmcgfHwgdGhpcy5hdXRvU3luY2luZykgeyByZXR1cm4gfVxuICAgICAgICB0aGlzLmF1dG9TeW5jaW5nID0gdHJ1ZVxuICAgICAgICBjb25zdCBzeW5jTm90aWNlID0gbmV3IEZpdE5vdGljZShcbiAgICAgICAgICAgIFtcImxvYWRpbmdcIl0sXG4gICAgICAgICAgICBcIkF1dG8gc3luY2luZ1wiLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5hdXRvU3luYyA9PT0gXCJtdXRlZFwiXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGVycm9yQ2F1Z2h0ID0gYXdhaXQgdGhpcy5jYXRjaEVycm9yQW5kTm90aWZ5KHRoaXMuc3luYywgc3luY05vdGljZSk7XG4gICAgICAgIGlmIChlcnJvckNhdWdodCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgc3luY05vdGljZS5yZW1vdmUoXCJlcnJvclwiKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3luY05vdGljZS5yZW1vdmUoKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXV0b1N5bmNpbmcgPSBmYWxzZVxuICAgIH1cblxuICAgIGFzeW5jIGF1dG9VcGRhdGUoKSB7XG4gICAgICAgIGlmICghKHRoaXMuc3RvcmFnZS5hdXRvU3luYyA9PT0gXCJvZmZcIikgJiYgIXRoaXMuc3luY2luZyAmJiAhdGhpcy5hdXRvU3luY2luZyAmJiBhd2FpdCB0aGlzLmNoZWNrU2V0dGluZ3NDb25maWd1cmVkKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3JhZ2UuYXV0b1N5bmMgPT09IFwib25cIiB8fCB0aGlzLnN0b3JhZ2UuYXV0b1N5bmMgPT09IFwibXV0ZWRcIikge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYXV0b1N5bmMoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdG9yYWdlLmF1dG9TeW5jID09PSBcInJlbWluZFwiKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZml0IG9mIHRoaXMuZml0cykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHVwZGF0ZWQgfSA9IGF3YWl0IGZpdC5yZW1vdGVVcGRhdGVkKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHVwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGluaXRpYWxNZXNzYWdlID0gXCJSZW1vdGUgdXBkYXRlIGRldGVjdGVkLCBwbGVhc2UgcHVsbCB0aGUgbGF0ZXN0IGNoYW5nZXMuXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnRlcnZhbE5vdGljZSA9IG5ldyBGaXROb3RpY2UoW1wic3RhdGljXCJdLCBpbml0aWFsTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbE5vdGljZS5yZW1vdmUoXCJzdGF0aWNcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGFzeW5jIHN0YXJ0T3JVcGRhdGVBdXRvU3luY0ludGVydmFsKCkge1xuICAgICAgICAvLyBDbGVhciBleGlzdGluZyBpbnRlcnZhbCBpZiBpdCBleGlzdHNcbiAgICAgICAgaWYgKHRoaXMuYXV0b1N5bmNJbnRlcnZhbElkICE9PSBudWxsKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLmF1dG9TeW5jSW50ZXJ2YWxJZCk7XG4gICAgICAgICAgICB0aGlzLmF1dG9TeW5jSW50ZXJ2YWxJZCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayByZW1vdGUgZXZlcnkgWCBtaW51dGVzIChzZXQgaW4gc2V0dGluZ3MpXG4gICAgICAgIHRoaXMuYXV0b1N5bmNJbnRlcnZhbElkID0gd2luZG93LnNldEludGVydmFsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXV0b1VwZGF0ZSgpO1xuICAgICAgICB9LCB0aGlzLnN0b3JhZ2UuY2hlY2tFdmVyeVhNaW51dGVzICogNjAgKiAxMDAwKTtcbiAgICB9XG5cbiAgICBhc3luYyBvbmxvYWQoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XG5cbiAgICAgICAgdGhpcy52YXVsdE9wcyA9IG5ldyBWYXVsdE9wZXJhdGlvbnModGhpcy5hcHAudmF1bHQpXG5cbiAgICAgICAgY29uc3QgZXhjbHVkZXMgPSB0aGlzLmdldEV4Y2x1ZGVzKClcbiAgICAgICAgZm9yIChsZXQgcmVwb18gb2YgdGhpcy5zdG9yYWdlLnJlcG8pIHtcbiAgICAgICAgICAgIGxldCByZXBvID0gc3RydWN0dXJlZENsb25lKHJlcG9fKVxuXG4gICAgICAgICAgICBmb3IgKGxldCBleGNsdWRlIG9mIGV4Y2x1ZGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4Y2x1ZGUgPT09IHJlcG8uc2V0dGluZ3Muc3luY1BhdGgpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgICAgICAgICByZXBvLnNldHRpbmdzLmV4Y2x1ZGVzLnB1c2goZXhjbHVkZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZml0ID0gbmV3IEZpdChyZXBvLCB0aGlzLnZhdWx0T3BzKVxuXG4gICAgICAgICAgICB0aGlzLmZpdHMucHVzaChmaXQpXG4gICAgICAgICAgICB0aGlzLmZpdFN5bmMucHVzaChcbiAgICAgICAgICAgICAgICBuZXcgRml0U3luYyhmaXQsIHRoaXMudmF1bHRPcHMsIHRoaXMuc2F2ZUxvY2FsU3RvcmVDYWxsYmFjaylcbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3luY2luZyA9IGZhbHNlXG4gICAgICAgIHRoaXMuYXV0b1N5bmNpbmcgPSBmYWxzZVxuICAgICAgICB0aGlzLnNldHRpbmdUYWIgPSBuZXcgRml0U2V0dGluZ1RhYih0aGlzLmFwcCwgdGhpcylcbiAgICAgICAgdGhpcy5sb2FkUmliYm9uSWNvbnMoKTtcblxuICAgICAgICAvLyBUaGlzIGFkZHMgYSBzZXR0aW5ncyB0YWIgc28gdGhlIHVzZXIgY2FuIGNvbmZpZ3VyZSB2YXJpb3VzIGFzcGVjdHMgb2YgdGhlIHBsdWdpblxuICAgICAgICB0aGlzLmFkZFNldHRpbmdUYWIobmV3IEZpdFNldHRpbmdUYWIodGhpcy5hcHAsIHRoaXMpKTtcblxuICAgICAgICAvLyByZWdpc3RlciBpbnRlcnZhbCB0byByZXBlYXQgYXV0byBjaGVja1xuICAgICAgICBhd2FpdCB0aGlzLnN0YXJ0T3JVcGRhdGVBdXRvU3luY0ludGVydmFsKCk7XG4gICAgfVxuXG4gICAgb251bmxvYWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmF1dG9TeW5jSW50ZXJ2YWxJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy5hdXRvU3luY0ludGVydmFsSWQpO1xuICAgICAgICAgICAgdGhpcy5hdXRvU3luY0ludGVydmFsSWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgbG9hZFNldHRpbmdzKCkge1xuICAgICAgICBjb25zdCB1c2VyU2V0dGluZyA9IGF3YWl0IHRoaXMubG9hZERhdGEoKVxuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfU0VUVElOR1MsIHVzZXJTZXR0aW5nKTtcbiAgICAgICAgY29uc3Qgc2V0dGluZ3NPYmo6IEZpdFN0b3JhZ2UgPSBPYmplY3Qua2V5cyhERUZBVUxUX1NFVFRJTkdTKS5yZWR1Y2UoXG4gICAgICAgICAgICAob2JqLCBrZXk6IGtleW9mIEZpdFN0b3JhZ2UpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09IFwiY2hlY2tFdmVyeVhNaW51dGVzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gTnVtYmVyKHNldHRpbmdzW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJub3RpZnlDaGFuZ2VzXCIgfHwga2V5ID09PSBcIm5vdGlmeUNvbmZsaWN0c1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IEJvb2xlYW4oc2V0dGluZ3Nba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHNldHRpbmdzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH0sIHt9IGFzIEZpdFN0b3JhZ2UpO1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBzZXR0aW5nc09ialxuICAgIH1cblxuICAgIC8vIGFsbG93IHNhdmluZyBvZiBsb2NhbCBzdG9yZXMgcHJvcGVydHksIHBhc3NlZCBpbiBwcm9wZXJ0aWVzIHdpbGwgb3ZlcnJpZGUgZXhpc3Rpbmcgc3RvcmVkIHZhbHVlXG4gICAgYXN5bmMgc2F2ZVNldHRpbmdzKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9TRVRUSU5HUywgYXdhaXQgdGhpcy5sb2FkRGF0YSgpKTtcbiAgICAgICAgLy8gY29uc3QgZGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfU0VUVElOR1MsIHRoaXMuc3RvcmFnZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdDogRml0U3RvcmFnZSA9IHsgLi4uZGF0YSwgLi4udGhpcy5zdG9yYWdlIH1cblxuICAgICAgICBhd2FpdCB0aGlzLnNhdmVEYXRhKHJlc3VsdCk7XG5cbiAgICAgICAgY29uc3QgZXhjbHVkZXMgPSB0aGlzLmdldEV4Y2x1ZGVzKClcblxuICAgICAgICAvLyBzeW5jIHNldHRpbmdzIHRvIEZpdCBjbGFzcyBhcyB3ZWxsIHVwb24gc2F2aW5nXG4gICAgICAgIGZvciAobGV0IGkgaW4gdGhpcy5maXRzKSB7XG4gICAgICAgICAgICBsZXQgcmVwbyA9IHN0cnVjdHVyZWRDbG9uZSh0aGlzLnN0b3JhZ2UucmVwb1tpXSlcblxuICAgICAgICAgICAgZm9yIChsZXQgZXhjbHVkZSBvZiBleGNsdWRlcykge1xuICAgICAgICAgICAgICAgIGlmIChleGNsdWRlID09PSByZXBvLnNldHRpbmdzLnN5bmNQYXRoKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgICAgICAgICAgcmVwby5zZXR0aW5ncy5leGNsdWRlcy5wdXNoKGV4Y2x1ZGUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZml0c1tpXS5sb2FkU2V0dGluZ3MocmVwbylcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSBhdXRvIHN5bmMgaW50ZXJ2YWwgd2l0aCBuZXcgc2V0dGluZ1xuICAgICAgICB0aGlzLnN0YXJ0T3JVcGRhdGVBdXRvU3luY0ludGVydmFsKCk7XG4gICAgfVxuXG4gICAgZ2V0RXhjbHVkZXMoKTogc3RyaW5nW10ge1xuICAgICAgICBjb25zdCBleGNsdWRlcyA9IFtdXG4gICAgICAgIGZvciAobGV0IHJlcG8gb2YgdGhpcy5zdG9yYWdlLnJlcG8pIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSByZXBvLnNldHRpbmdzLnN5bmNQYXRoXG4gICAgICAgICAgICBpZiAocGF0aClcbiAgICAgICAgICAgICAgICBleGNsdWRlcy5wdXNoKHBhdGgpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhjbHVkZXNcbiAgICB9XG5cbn1cblxuY2xhc3MgRmlsZU5hbWVWaWV3IGV4dGVuZHMgSXRlbVZpZXcge1xuICAgIGNvbnN0cnVjdG9yKGxlYWY6IFdvcmtzcGFjZUxlYWYpIHtcbiAgICAgICAgc3VwZXIobGVhZik7XG4gICAgfVxuXG4gICAgZ2V0Vmlld1R5cGUoKSB7XG4gICAgICAgIHJldHVybiAnZmlsZS1uYW1lLXZpZXcnO1xuICAgIH1cblxuICAgIGdldERpc3BsYXlUZXh0KCkge1xuICAgICAgICByZXR1cm4gJ1x1MDQxOFx1MDQzQ1x1MDQ0RiBcdTA0NDRcdTA0MzBcdTA0MzlcdTA0M0JcdTA0MzAnO1xuICAgIH1cblxuICAgIGdldEljb24oKSB7XG4gICAgICAgIHJldHVybiAnZG9jdW1lbnQnO1xuICAgIH1cblxuICAgIGFzeW5jIG9uT3BlbigpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXJFbC5jaGlsZHJlblsxXTtcbiAgICAgICAgY29udGFpbmVyLmVtcHR5KCk7XG5cbiAgICAgICAgLy8gXHUwNDIxXHUwNDNFXHUwNDM3XHUwNDM0XHUwNDMwXHUwNDM1XHUwNDNDIFx1MDQzQVx1MDQzRVx1MDQzRFx1MDQ0Mlx1MDQzNVx1MDQzOVx1MDQzRFx1MDQzNVx1MDQ0MCBcdTA0MzRcdTA0M0JcdTA0NEYgXHUwNDQxXHUwNDNFXHUwNDM0XHUwNDM1XHUwNDQwXHUwNDM2XHUwNDM4XHUwNDNDXHUwNDNFXHUwNDMzXHUwNDNFXG4gICAgICAgIHRoaXMuY29udGVudEVsID0gY29udGFpbmVyLmNyZWF0ZURpdignZmlsZS1uYW1lLWNvbnRlbnQnKTtcbiAgICAgICAgdGhpcy5jb250ZW50RWwuc2V0VGV4dCgnXHUwNDFEXHUwNDMwXHUwNDM2XHUwNDNDXHUwNDM4XHUwNDQyXHUwNDM1IFx1MDQzRFx1MDQzMCBcdTA0MzhcdTA0M0FcdTA0M0VcdTA0M0RcdTA0M0FcdTA0NDMgXHUwNDMyIHJpYmJvbiBcdTA0MzRcdTA0M0JcdTA0NEYgXHUwNDNFXHUwNDQyXHUwNDNFXHUwNDMxXHUwNDQwXHUwNDMwXHUwNDM2XHUwNDM1XHUwNDNEXHUwNDM4XHUwNDRGIFx1MDQzOFx1MDQzQ1x1MDQzNVx1MDQzRFx1MDQzOCBcdTA0NDRcdTA0MzBcdTA0MzlcdTA0M0JcdTA0MzAnKTtcbiAgICB9XG5cbiAgICBhc3luYyBvbkNsb3NlKCkge1xuICAgICAgICAvLyBcdTA0MUVcdTA0NDdcdTA0MzhcdTA0NDlcdTA0MzBcdTA0MzVcdTA0M0MgXHUwNDNGXHUwNDQwXHUwNDM4IFx1MDQzN1x1MDQzMFx1MDQzQVx1MDQ0MFx1MDQ0Qlx1MDQ0Mlx1MDQzOFx1MDQzOFxuICAgICAgICBpZiAodGhpcy5jb250ZW50RWwpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudEVsLmVtcHR5KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBcdTA0MUNcdTA0MzVcdTA0NDJcdTA0M0VcdTA0MzQgXHUwNDM0XHUwNDNCXHUwNDRGIFx1MDQzRVx1MDQzMVx1MDQzRFx1MDQzRVx1MDQzMlx1MDQzQlx1MDQzNVx1MDQzRFx1MDQzOFx1MDQ0RiBcdTA0NDFcdTA0M0VcdTA0MzRcdTA0MzVcdTA0NDBcdTA0MzZcdTA0MzhcdTA0M0NcdTA0M0VcdTA0MzNcdTA0M0VcbiAgICB1cGRhdGVDb250ZW50KGZpbGVOYW1lOiBzdHJpbmcsIGZpbGVQYXRoOiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudEVsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRFbC5lbXB0eSgpO1xuXG4gICAgICAgICAgICAvLyBcdTA0MTRcdTA0M0VcdTA0MzFcdTA0MzBcdTA0MzJcdTA0M0JcdTA0NEZcdTA0MzVcdTA0M0MgXHUwNDM4XHUwNDNEXHUwNDQ0XHUwNDNFXHUwNDQwXHUwNDNDXHUwNDMwXHUwNDQ2XHUwNDM4XHUwNDRFIFx1MDQzRSBcdTA0NDRcdTA0MzBcdTA0MzlcdTA0M0JcdTA0MzVcbiAgICAgICAgICAgIHRoaXMuY29udGVudEVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ1x1MDQxOFx1MDQzRFx1MDQ0NFx1MDQzRVx1MDQ0MFx1MDQzQ1x1MDQzMFx1MDQ0Nlx1MDQzOFx1MDQ0RiBcdTA0M0UgXHUwNDQ0XHUwNDMwXHUwNDM5XHUwNDNCXHUwNDM1JyB9KTtcbiAgICAgICAgICAgIHRoaXMuY29udGVudEVsLmNyZWF0ZUVsKCdwJywgeyB0ZXh0OiBgXHUwNDE4XHUwNDNDXHUwNDRGIFx1MDQ0NFx1MDQzMFx1MDQzOVx1MDQzQlx1MDQzMDogJHtmaWxlTmFtZX1gIH0pO1xuICAgICAgICAgICAgdGhpcy5jb250ZW50RWwuY3JlYXRlRWwoJ3AnLCB7IHRleHQ6IGBcdTA0MUZcdTA0NDNcdTA0NDJcdTA0NEM6ICR7ZmlsZVBhdGh9YCB9KTtcbiAgICAgICAgICAgIHRoaXMuY29udGVudEVsLmNyZWF0ZUVsKCdwJywge1xuICAgICAgICAgICAgICAgIHRleHQ6ICdcdTA0MkRcdTA0NDJcdTA0M0UgdmlldyBcdTA0NDFcdTA0M0VcdTA0MzdcdTA0MzRcdTA0MzBcdTA0M0RcdTA0M0UgXHUwNDNGXHUwNDNCXHUwNDMwXHUwNDMzXHUwNDM4XHUwNDNEXHUwNDNFXHUwNDNDJyxcbiAgICAgICAgICAgICAgICBjbHM6ICdmaWxlLW5hbWUtZGVzY3JpcHRpb24nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsICJjb25zdCByb290Rml0Rm9sZGVyID0gXCJfZml0XCJcblxuZXhwb3J0IGNvbnN0IGNvbmZsaWN0UmVzb2x1dGlvbkZvbGRlciA9IHJvb3RGaXRGb2xkZXIgKyBcIi9jb25mbGljdFwiXG5cbmV4cG9ydCBjb25zdCBWSUVXX1RZUEUgPSBcImZpdC12aWV3XCJcblxuLy8gZXhwb3J0IGNvbnN0IGNoYW5nZXMgPSByb290Rml0Rm9sZGVyICsgXCIvY2hhbmdlc1wiXG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGdldFVzZXJBZ2VudCgpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09IFwib2JqZWN0XCIgJiYgXCJ1c2VyQWdlbnRcIiBpbiBuYXZpZ2F0b3IpIHtcbiAgICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzLnZlcnNpb24gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBgTm9kZS5qcy8ke3Byb2Nlc3MudmVyc2lvbi5zdWJzdHIoMSl9ICgke3Byb2Nlc3MucGxhdGZvcm19OyAke1xuICAgICAgcHJvY2Vzcy5hcmNoXG4gICAgfSlgO1xuICB9XG5cbiAgcmV0dXJuIFwiPGVudmlyb25tZW50IHVuZGV0ZWN0YWJsZT5cIjtcbn1cbiIsICIvLyBAdHMtY2hlY2tcblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyKHN0YXRlLCBuYW1lLCBtZXRob2QsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBtZXRob2QgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm1ldGhvZCBmb3IgYmVmb3JlIGhvb2sgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobmFtZSkpIHtcbiAgICByZXR1cm4gbmFtZS5yZXZlcnNlKCkucmVkdWNlKChjYWxsYmFjaywgbmFtZSkgPT4ge1xuICAgICAgcmV0dXJuIHJlZ2lzdGVyLmJpbmQobnVsbCwgc3RhdGUsIG5hbWUsIGNhbGxiYWNrLCBvcHRpb25zKTtcbiAgICB9LCBtZXRob2QpKCk7XG4gIH1cblxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgaWYgKCFzdGF0ZS5yZWdpc3RyeVtuYW1lXSkge1xuICAgICAgcmV0dXJuIG1ldGhvZChvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhdGUucmVnaXN0cnlbbmFtZV0ucmVkdWNlKChtZXRob2QsIHJlZ2lzdGVyZWQpID0+IHtcbiAgICAgIHJldHVybiByZWdpc3RlcmVkLmhvb2suYmluZChudWxsLCBtZXRob2QsIG9wdGlvbnMpO1xuICAgIH0sIG1ldGhvZCkoKTtcbiAgfSk7XG59XG4iLCAiLy8gQHRzLWNoZWNrXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRIb29rKHN0YXRlLCBraW5kLCBuYW1lLCBob29rKSB7XG4gIGNvbnN0IG9yaWcgPSBob29rO1xuICBpZiAoIXN0YXRlLnJlZ2lzdHJ5W25hbWVdKSB7XG4gICAgc3RhdGUucmVnaXN0cnlbbmFtZV0gPSBbXTtcbiAgfVxuXG4gIGlmIChraW5kID09PSBcImJlZm9yZVwiKSB7XG4gICAgaG9vayA9IChtZXRob2QsIG9wdGlvbnMpID0+IHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAudGhlbihvcmlnLmJpbmQobnVsbCwgb3B0aW9ucykpXG4gICAgICAgIC50aGVuKG1ldGhvZC5iaW5kKG51bGwsIG9wdGlvbnMpKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKGtpbmQgPT09IFwiYWZ0ZXJcIikge1xuICAgIGhvb2sgPSAobWV0aG9kLCBvcHRpb25zKSA9PiB7XG4gICAgICBsZXQgcmVzdWx0O1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgIC50aGVuKG1ldGhvZC5iaW5kKG51bGwsIG9wdGlvbnMpKVxuICAgICAgICAudGhlbigocmVzdWx0XykgPT4ge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdF87XG4gICAgICAgICAgcmV0dXJuIG9yaWcocmVzdWx0LCBvcHRpb25zKTtcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH07XG4gIH1cblxuICBpZiAoa2luZCA9PT0gXCJlcnJvclwiKSB7XG4gICAgaG9vayA9IChtZXRob2QsIG9wdGlvbnMpID0+IHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAudGhlbihtZXRob2QuYmluZChudWxsLCBvcHRpb25zKSlcbiAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgIHJldHVybiBvcmlnKGVycm9yLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIHN0YXRlLnJlZ2lzdHJ5W25hbWVdLnB1c2goe1xuICAgIGhvb2s6IGhvb2ssXG4gICAgb3JpZzogb3JpZyxcbiAgfSk7XG59XG4iLCAiLy8gQHRzLWNoZWNrXG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVIb29rKHN0YXRlLCBuYW1lLCBtZXRob2QpIHtcbiAgaWYgKCFzdGF0ZS5yZWdpc3RyeVtuYW1lXSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGluZGV4ID0gc3RhdGUucmVnaXN0cnlbbmFtZV1cbiAgICAubWFwKChyZWdpc3RlcmVkKSA9PiB7XG4gICAgICByZXR1cm4gcmVnaXN0ZXJlZC5vcmlnO1xuICAgIH0pXG4gICAgLmluZGV4T2YobWV0aG9kKTtcblxuICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3RhdGUucmVnaXN0cnlbbmFtZV0uc3BsaWNlKGluZGV4LCAxKTtcbn1cbiIsICIvLyBAdHMtY2hlY2tcblxuaW1wb3J0IHsgcmVnaXN0ZXIgfSBmcm9tIFwiLi9saWIvcmVnaXN0ZXIuanNcIjtcbmltcG9ydCB7IGFkZEhvb2sgfSBmcm9tIFwiLi9saWIvYWRkLmpzXCI7XG5pbXBvcnQgeyByZW1vdmVIb29rIH0gZnJvbSBcIi4vbGliL3JlbW92ZS5qc1wiO1xuXG4vLyBiaW5kIHdpdGggYXJyYXkgb2YgYXJndW1lbnRzOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjE3OTI5MTNcbmNvbnN0IGJpbmQgPSBGdW5jdGlvbi5iaW5kO1xuY29uc3QgYmluZGFibGUgPSBiaW5kLmJpbmQoYmluZCk7XG5cbmZ1bmN0aW9uIGJpbmRBcGkoaG9vaywgc3RhdGUsIG5hbWUpIHtcbiAgY29uc3QgcmVtb3ZlSG9va1JlZiA9IGJpbmRhYmxlKHJlbW92ZUhvb2ssIG51bGwpLmFwcGx5KFxuICAgIG51bGwsXG4gICAgbmFtZSA/IFtzdGF0ZSwgbmFtZV0gOiBbc3RhdGVdXG4gICk7XG4gIGhvb2suYXBpID0geyByZW1vdmU6IHJlbW92ZUhvb2tSZWYgfTtcbiAgaG9vay5yZW1vdmUgPSByZW1vdmVIb29rUmVmO1xuICBbXCJiZWZvcmVcIiwgXCJlcnJvclwiLCBcImFmdGVyXCIsIFwid3JhcFwiXS5mb3JFYWNoKChraW5kKSA9PiB7XG4gICAgY29uc3QgYXJncyA9IG5hbWUgPyBbc3RhdGUsIGtpbmQsIG5hbWVdIDogW3N0YXRlLCBraW5kXTtcbiAgICBob29rW2tpbmRdID0gaG9vay5hcGlba2luZF0gPSBiaW5kYWJsZShhZGRIb29rLCBudWxsKS5hcHBseShudWxsLCBhcmdzKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIFNpbmd1bGFyKCkge1xuICBjb25zdCBzaW5ndWxhckhvb2tOYW1lID0gU3ltYm9sKFwiU2luZ3VsYXJcIik7XG4gIGNvbnN0IHNpbmd1bGFySG9va1N0YXRlID0ge1xuICAgIHJlZ2lzdHJ5OiB7fSxcbiAgfTtcbiAgY29uc3Qgc2luZ3VsYXJIb29rID0gcmVnaXN0ZXIuYmluZChudWxsLCBzaW5ndWxhckhvb2tTdGF0ZSwgc2luZ3VsYXJIb29rTmFtZSk7XG4gIGJpbmRBcGkoc2luZ3VsYXJIb29rLCBzaW5ndWxhckhvb2tTdGF0ZSwgc2luZ3VsYXJIb29rTmFtZSk7XG4gIHJldHVybiBzaW5ndWxhckhvb2s7XG59XG5cbmZ1bmN0aW9uIENvbGxlY3Rpb24oKSB7XG4gIGNvbnN0IHN0YXRlID0ge1xuICAgIHJlZ2lzdHJ5OiB7fSxcbiAgfTtcblxuICBjb25zdCBob29rID0gcmVnaXN0ZXIuYmluZChudWxsLCBzdGF0ZSk7XG4gIGJpbmRBcGkoaG9vaywgc3RhdGUpO1xuXG4gIHJldHVybiBob29rO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7IFNpbmd1bGFyLCBDb2xsZWN0aW9uIH07XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGdldFVzZXJBZ2VudCgpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09IFwib2JqZWN0XCIgJiYgXCJ1c2VyQWdlbnRcIiBpbiBuYXZpZ2F0b3IpIHtcbiAgICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzLnZlcnNpb24gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBgTm9kZS5qcy8ke3Byb2Nlc3MudmVyc2lvbi5zdWJzdHIoMSl9ICgke3Byb2Nlc3MucGxhdGZvcm19OyAke1xuICAgICAgcHJvY2Vzcy5hcmNoXG4gICAgfSlgO1xuICB9XG5cbiAgcmV0dXJuIFwiPGVudmlyb25tZW50IHVuZGV0ZWN0YWJsZT5cIjtcbn1cbiIsICIvLyBwa2cvZGlzdC1zcmMvZGVmYXVsdHMuanNcbmltcG9ydCB7IGdldFVzZXJBZ2VudCB9IGZyb20gXCJ1bml2ZXJzYWwtdXNlci1hZ2VudFwiO1xuXG4vLyBwa2cvZGlzdC1zcmMvdmVyc2lvbi5qc1xudmFyIFZFUlNJT04gPSBcIjAuMC4wLWRldmVsb3BtZW50XCI7XG5cbi8vIHBrZy9kaXN0LXNyYy9kZWZhdWx0cy5qc1xudmFyIHVzZXJBZ2VudCA9IGBvY3Rva2l0LWVuZHBvaW50LmpzLyR7VkVSU0lPTn0gJHtnZXRVc2VyQWdlbnQoKX1gO1xudmFyIERFRkFVTFRTID0ge1xuICBtZXRob2Q6IFwiR0VUXCIsXG4gIGJhc2VVcmw6IFwiaHR0cHM6Ly9hcGkuZ2l0aHViLmNvbVwiLFxuICBoZWFkZXJzOiB7XG4gICAgYWNjZXB0OiBcImFwcGxpY2F0aW9uL3ZuZC5naXRodWIudjMranNvblwiLFxuICAgIFwidXNlci1hZ2VudFwiOiB1c2VyQWdlbnRcbiAgfSxcbiAgbWVkaWFUeXBlOiB7XG4gICAgZm9ybWF0OiBcIlwiXG4gIH1cbn07XG5cbi8vIHBrZy9kaXN0LXNyYy91dGlsL2xvd2VyY2FzZS1rZXlzLmpzXG5mdW5jdGlvbiBsb3dlcmNhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIW9iamVjdCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmtleXMob2JqZWN0KS5yZWR1Y2UoKG5ld09iaiwga2V5KSA9PiB7XG4gICAgbmV3T2JqW2tleS50b0xvd2VyQ2FzZSgpXSA9IG9iamVjdFtrZXldO1xuICAgIHJldHVybiBuZXdPYmo7XG4gIH0sIHt9KTtcbn1cblxuLy8gcGtnL2Rpc3Qtc3JjL3V0aWwvaXMtcGxhaW4tb2JqZWN0LmpzXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT09IG51bGwpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIilcbiAgICByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgaWYgKHByb3RvID09PSBudWxsKVxuICAgIHJldHVybiB0cnVlO1xuICBjb25zdCBDdG9yID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCBcImNvbnN0cnVjdG9yXCIpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJiBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbChDdG9yKSA9PT0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwodmFsdWUpO1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvdXRpbC9tZXJnZS1kZWVwLmpzXG5mdW5jdGlvbiBtZXJnZURlZXAoZGVmYXVsdHMsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMpO1xuICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBpZiAoaXNQbGFpbk9iamVjdChvcHRpb25zW2tleV0pKSB7XG4gICAgICBpZiAoIShrZXkgaW4gZGVmYXVsdHMpKVxuICAgICAgICBPYmplY3QuYXNzaWduKHJlc3VsdCwgeyBba2V5XTogb3B0aW9uc1trZXldIH0pO1xuICAgICAgZWxzZVxuICAgICAgICByZXN1bHRba2V5XSA9IG1lcmdlRGVlcChkZWZhdWx0c1trZXldLCBvcHRpb25zW2tleV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBPYmplY3QuYXNzaWduKHJlc3VsdCwgeyBba2V5XTogb3B0aW9uc1trZXldIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHBrZy9kaXN0LXNyYy91dGlsL3JlbW92ZS11bmRlZmluZWQtcHJvcGVydGllcy5qc1xuZnVuY3Rpb24gcmVtb3ZlVW5kZWZpbmVkUHJvcGVydGllcyhvYmopIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKG9ialtrZXldID09PSB2b2lkIDApIHtcbiAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLy8gcGtnL2Rpc3Qtc3JjL21lcmdlLmpzXG5mdW5jdGlvbiBtZXJnZShkZWZhdWx0cywgcm91dGUsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiByb3V0ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGxldCBbbWV0aG9kLCB1cmxdID0gcm91dGUuc3BsaXQoXCIgXCIpO1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHVybCA/IHsgbWV0aG9kLCB1cmwgfSA6IHsgdXJsOiBtZXRob2QgfSwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHJvdXRlKTtcbiAgfVxuICBvcHRpb25zLmhlYWRlcnMgPSBsb3dlcmNhc2VLZXlzKG9wdGlvbnMuaGVhZGVycyk7XG4gIHJlbW92ZVVuZGVmaW5lZFByb3BlcnRpZXMob3B0aW9ucyk7XG4gIHJlbW92ZVVuZGVmaW5lZFByb3BlcnRpZXMob3B0aW9ucy5oZWFkZXJzKTtcbiAgY29uc3QgbWVyZ2VkT3B0aW9ucyA9IG1lcmdlRGVlcChkZWZhdWx0cyB8fCB7fSwgb3B0aW9ucyk7XG4gIGlmIChvcHRpb25zLnVybCA9PT0gXCIvZ3JhcGhxbFwiKSB7XG4gICAgaWYgKGRlZmF1bHRzICYmIGRlZmF1bHRzLm1lZGlhVHlwZS5wcmV2aWV3cz8ubGVuZ3RoKSB7XG4gICAgICBtZXJnZWRPcHRpb25zLm1lZGlhVHlwZS5wcmV2aWV3cyA9IGRlZmF1bHRzLm1lZGlhVHlwZS5wcmV2aWV3cy5maWx0ZXIoXG4gICAgICAgIChwcmV2aWV3KSA9PiAhbWVyZ2VkT3B0aW9ucy5tZWRpYVR5cGUucHJldmlld3MuaW5jbHVkZXMocHJldmlldylcbiAgICAgICkuY29uY2F0KG1lcmdlZE9wdGlvbnMubWVkaWFUeXBlLnByZXZpZXdzKTtcbiAgICB9XG4gICAgbWVyZ2VkT3B0aW9ucy5tZWRpYVR5cGUucHJldmlld3MgPSAobWVyZ2VkT3B0aW9ucy5tZWRpYVR5cGUucHJldmlld3MgfHwgW10pLm1hcCgocHJldmlldykgPT4gcHJldmlldy5yZXBsYWNlKC8tcHJldmlldy8sIFwiXCIpKTtcbiAgfVxuICByZXR1cm4gbWVyZ2VkT3B0aW9ucztcbn1cblxuLy8gcGtnL2Rpc3Qtc3JjL3V0aWwvYWRkLXF1ZXJ5LXBhcmFtZXRlcnMuanNcbmZ1bmN0aW9uIGFkZFF1ZXJ5UGFyYW1ldGVycyh1cmwsIHBhcmFtZXRlcnMpIHtcbiAgY29uc3Qgc2VwYXJhdG9yID0gL1xcPy8udGVzdCh1cmwpID8gXCImXCIgOiBcIj9cIjtcbiAgY29uc3QgbmFtZXMgPSBPYmplY3Qua2V5cyhwYXJhbWV0ZXJzKTtcbiAgaWYgKG5hbWVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgcmV0dXJuIHVybCArIHNlcGFyYXRvciArIG5hbWVzLm1hcCgobmFtZSkgPT4ge1xuICAgIGlmIChuYW1lID09PSBcInFcIikge1xuICAgICAgcmV0dXJuIFwicT1cIiArIHBhcmFtZXRlcnMucS5zcGxpdChcIitcIikubWFwKGVuY29kZVVSSUNvbXBvbmVudCkuam9pbihcIitcIik7XG4gICAgfVxuICAgIHJldHVybiBgJHtuYW1lfT0ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbWV0ZXJzW25hbWVdKX1gO1xuICB9KS5qb2luKFwiJlwiKTtcbn1cblxuLy8gcGtnL2Rpc3Qtc3JjL3V0aWwvZXh0cmFjdC11cmwtdmFyaWFibGUtbmFtZXMuanNcbnZhciB1cmxWYXJpYWJsZVJlZ2V4ID0gL1xce1tefV0rXFx9L2c7XG5mdW5jdGlvbiByZW1vdmVOb25DaGFycyh2YXJpYWJsZU5hbWUpIHtcbiAgcmV0dXJuIHZhcmlhYmxlTmFtZS5yZXBsYWNlKC9eXFxXK3xcXFcrJC9nLCBcIlwiKS5zcGxpdCgvLC8pO1xufVxuZnVuY3Rpb24gZXh0cmFjdFVybFZhcmlhYmxlTmFtZXModXJsKSB7XG4gIGNvbnN0IG1hdGNoZXMgPSB1cmwubWF0Y2godXJsVmFyaWFibGVSZWdleCk7XG4gIGlmICghbWF0Y2hlcykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gbWF0Y2hlcy5tYXAocmVtb3ZlTm9uQ2hhcnMpLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYiksIFtdKTtcbn1cblxuLy8gcGtnL2Rpc3Qtc3JjL3V0aWwvb21pdC5qc1xuZnVuY3Rpb24gb21pdChvYmplY3QsIGtleXNUb09taXQpIHtcbiAgY29uc3QgcmVzdWx0ID0geyBfX3Byb3RvX186IG51bGwgfTtcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob2JqZWN0KSkge1xuICAgIGlmIChrZXlzVG9PbWl0LmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gb2JqZWN0W2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHBrZy9kaXN0LXNyYy91dGlsL3VybC10ZW1wbGF0ZS5qc1xuZnVuY3Rpb24gZW5jb2RlUmVzZXJ2ZWQoc3RyKSB7XG4gIHJldHVybiBzdHIuc3BsaXQoLyglWzAtOUEtRmEtZl17Mn0pL2cpLm1hcChmdW5jdGlvbihwYXJ0KSB7XG4gICAgaWYgKCEvJVswLTlBLUZhLWZdLy50ZXN0KHBhcnQpKSB7XG4gICAgICBwYXJ0ID0gZW5jb2RlVVJJKHBhcnQpLnJlcGxhY2UoLyU1Qi9nLCBcIltcIikucmVwbGFjZSgvJTVEL2csIFwiXVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnQ7XG4gIH0pLmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiBlbmNvZGVVbnJlc2VydmVkKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cikucmVwbGFjZSgvWyEnKCkqXS9nLCBmdW5jdGlvbihjKSB7XG4gICAgcmV0dXJuIFwiJVwiICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGVuY29kZVZhbHVlKG9wZXJhdG9yLCB2YWx1ZSwga2V5KSB7XG4gIHZhbHVlID0gb3BlcmF0b3IgPT09IFwiK1wiIHx8IG9wZXJhdG9yID09PSBcIiNcIiA/IGVuY29kZVJlc2VydmVkKHZhbHVlKSA6IGVuY29kZVVucmVzZXJ2ZWQodmFsdWUpO1xuICBpZiAoa2V5KSB7XG4gICAgcmV0dXJuIGVuY29kZVVucmVzZXJ2ZWQoa2V5KSArIFwiPVwiICsgdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5mdW5jdGlvbiBpc0RlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2b2lkIDAgJiYgdmFsdWUgIT09IG51bGw7XG59XG5mdW5jdGlvbiBpc0tleU9wZXJhdG9yKG9wZXJhdG9yKSB7XG4gIHJldHVybiBvcGVyYXRvciA9PT0gXCI7XCIgfHwgb3BlcmF0b3IgPT09IFwiJlwiIHx8IG9wZXJhdG9yID09PSBcIj9cIjtcbn1cbmZ1bmN0aW9uIGdldFZhbHVlcyhjb250ZXh0LCBvcGVyYXRvciwga2V5LCBtb2RpZmllcikge1xuICB2YXIgdmFsdWUgPSBjb250ZXh0W2tleV0sIHJlc3VsdCA9IFtdO1xuICBpZiAoaXNEZWZpbmVkKHZhbHVlKSAmJiB2YWx1ZSAhPT0gXCJcIikge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIGlmIChtb2RpZmllciAmJiBtb2RpZmllciAhPT0gXCIqXCIpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgcGFyc2VJbnQobW9kaWZpZXIsIDEwKSk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaChcbiAgICAgICAgZW5jb2RlVmFsdWUob3BlcmF0b3IsIHZhbHVlLCBpc0tleU9wZXJhdG9yKG9wZXJhdG9yKSA/IGtleSA6IFwiXCIpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobW9kaWZpZXIgPT09IFwiKlwiKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlLmZpbHRlcihpc0RlZmluZWQpLmZvckVhY2goZnVuY3Rpb24odmFsdWUyKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAgICAgZW5jb2RlVmFsdWUob3BlcmF0b3IsIHZhbHVlMiwgaXNLZXlPcGVyYXRvcihvcGVyYXRvcikgPyBrZXkgOiBcIlwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWZpbmVkKHZhbHVlW2tdKSkge1xuICAgICAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGVWYWx1ZShvcGVyYXRvciwgdmFsdWVba10sIGspKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdG1wID0gW107XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlLmZpbHRlcihpc0RlZmluZWQpLmZvckVhY2goZnVuY3Rpb24odmFsdWUyKSB7XG4gICAgICAgICAgICB0bXAucHVzaChlbmNvZGVWYWx1ZShvcGVyYXRvciwgdmFsdWUyKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgT2JqZWN0LmtleXModmFsdWUpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgICAgICAgaWYgKGlzRGVmaW5lZCh2YWx1ZVtrXSkpIHtcbiAgICAgICAgICAgICAgdG1wLnB1c2goZW5jb2RlVW5yZXNlcnZlZChrKSk7XG4gICAgICAgICAgICAgIHRtcC5wdXNoKGVuY29kZVZhbHVlKG9wZXJhdG9yLCB2YWx1ZVtrXS50b1N0cmluZygpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzS2V5T3BlcmF0b3Iob3BlcmF0b3IpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlVW5yZXNlcnZlZChrZXkpICsgXCI9XCIgKyB0bXAuam9pbihcIixcIikpO1xuICAgICAgICB9IGVsc2UgaWYgKHRtcC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh0bXAuam9pbihcIixcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChvcGVyYXRvciA9PT0gXCI7XCIpIHtcbiAgICAgIGlmIChpc0RlZmluZWQodmFsdWUpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGVuY29kZVVucmVzZXJ2ZWQoa2V5KSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gXCJcIiAmJiAob3BlcmF0b3IgPT09IFwiJlwiIHx8IG9wZXJhdG9yID09PSBcIj9cIikpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGVuY29kZVVucmVzZXJ2ZWQoa2V5KSArIFwiPVwiKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBcIlwiKSB7XG4gICAgICByZXN1bHQucHVzaChcIlwiKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBhcnNlVXJsKHRlbXBsYXRlKSB7XG4gIHJldHVybiB7XG4gICAgZXhwYW5kOiBleHBhbmQuYmluZChudWxsLCB0ZW1wbGF0ZSlcbiAgfTtcbn1cbmZ1bmN0aW9uIGV4cGFuZCh0ZW1wbGF0ZSwgY29udGV4dCkge1xuICB2YXIgb3BlcmF0b3JzID0gW1wiK1wiLCBcIiNcIiwgXCIuXCIsIFwiL1wiLCBcIjtcIiwgXCI/XCIsIFwiJlwiXTtcbiAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5yZXBsYWNlKFxuICAgIC9cXHsoW15cXHtcXH1dKylcXH18KFteXFx7XFx9XSspL2csXG4gICAgZnVuY3Rpb24oXywgZXhwcmVzc2lvbiwgbGl0ZXJhbCkge1xuICAgICAgaWYgKGV4cHJlc3Npb24pIHtcbiAgICAgICAgbGV0IG9wZXJhdG9yID0gXCJcIjtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgICAgIGlmIChvcGVyYXRvcnMuaW5kZXhPZihleHByZXNzaW9uLmNoYXJBdCgwKSkgIT09IC0xKSB7XG4gICAgICAgICAgb3BlcmF0b3IgPSBleHByZXNzaW9uLmNoYXJBdCgwKTtcbiAgICAgICAgICBleHByZXNzaW9uID0gZXhwcmVzc2lvbi5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwcmVzc2lvbi5zcGxpdCgvLC9nKS5mb3JFYWNoKGZ1bmN0aW9uKHZhcmlhYmxlKSB7XG4gICAgICAgICAgdmFyIHRtcCA9IC8oW146XFwqXSopKD86OihcXGQrKXwoXFwqKSk/Ly5leGVjKHZhcmlhYmxlKTtcbiAgICAgICAgICB2YWx1ZXMucHVzaChnZXRWYWx1ZXMoY29udGV4dCwgb3BlcmF0b3IsIHRtcFsxXSwgdG1wWzJdIHx8IHRtcFszXSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9wZXJhdG9yICYmIG9wZXJhdG9yICE9PSBcIitcIikge1xuICAgICAgICAgIHZhciBzZXBhcmF0b3IgPSBcIixcIjtcbiAgICAgICAgICBpZiAob3BlcmF0b3IgPT09IFwiP1wiKSB7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBcIiZcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdG9yICE9PSBcIiNcIikge1xuICAgICAgICAgICAgc2VwYXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAodmFsdWVzLmxlbmd0aCAhPT0gMCA/IG9wZXJhdG9yIDogXCJcIikgKyB2YWx1ZXMuam9pbihzZXBhcmF0b3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB2YWx1ZXMuam9pbihcIixcIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVSZXNlcnZlZChsaXRlcmFsKTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG4gIGlmICh0ZW1wbGF0ZSA9PT0gXCIvXCIpIHtcbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRlbXBsYXRlLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcbiAgfVxufVxuXG4vLyBwa2cvZGlzdC1zcmMvcGFyc2UuanNcbmZ1bmN0aW9uIHBhcnNlKG9wdGlvbnMpIHtcbiAgbGV0IG1ldGhvZCA9IG9wdGlvbnMubWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gIGxldCB1cmwgPSAob3B0aW9ucy51cmwgfHwgXCIvXCIpLnJlcGxhY2UoLzooW2Etel1cXHcrKS9nLCBcInskMX1cIik7XG4gIGxldCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgbGV0IGJvZHk7XG4gIGxldCBwYXJhbWV0ZXJzID0gb21pdChvcHRpb25zLCBbXG4gICAgXCJtZXRob2RcIixcbiAgICBcImJhc2VVcmxcIixcbiAgICBcInVybFwiLFxuICAgIFwiaGVhZGVyc1wiLFxuICAgIFwicmVxdWVzdFwiLFxuICAgIFwibWVkaWFUeXBlXCJcbiAgXSk7XG4gIGNvbnN0IHVybFZhcmlhYmxlTmFtZXMgPSBleHRyYWN0VXJsVmFyaWFibGVOYW1lcyh1cmwpO1xuICB1cmwgPSBwYXJzZVVybCh1cmwpLmV4cGFuZChwYXJhbWV0ZXJzKTtcbiAgaWYgKCEvXmh0dHAvLnRlc3QodXJsKSkge1xuICAgIHVybCA9IG9wdGlvbnMuYmFzZVVybCArIHVybDtcbiAgfVxuICBjb25zdCBvbWl0dGVkUGFyYW1ldGVycyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpLmZpbHRlcigob3B0aW9uKSA9PiB1cmxWYXJpYWJsZU5hbWVzLmluY2x1ZGVzKG9wdGlvbikpLmNvbmNhdChcImJhc2VVcmxcIik7XG4gIGNvbnN0IHJlbWFpbmluZ1BhcmFtZXRlcnMgPSBvbWl0KHBhcmFtZXRlcnMsIG9taXR0ZWRQYXJhbWV0ZXJzKTtcbiAgY29uc3QgaXNCaW5hcnlSZXF1ZXN0ID0gL2FwcGxpY2F0aW9uXFwvb2N0ZXQtc3RyZWFtL2kudGVzdChoZWFkZXJzLmFjY2VwdCk7XG4gIGlmICghaXNCaW5hcnlSZXF1ZXN0KSB7XG4gICAgaWYgKG9wdGlvbnMubWVkaWFUeXBlLmZvcm1hdCkge1xuICAgICAgaGVhZGVycy5hY2NlcHQgPSBoZWFkZXJzLmFjY2VwdC5zcGxpdCgvLC8pLm1hcChcbiAgICAgICAgKGZvcm1hdCkgPT4gZm9ybWF0LnJlcGxhY2UoXG4gICAgICAgICAgL2FwcGxpY2F0aW9uXFwvdm5kKFxcLlxcdyspKFxcLnYzKT8oXFwuXFx3Kyk/KFxcK2pzb24pPyQvLFxuICAgICAgICAgIGBhcHBsaWNhdGlvbi92bmQkMSQyLiR7b3B0aW9ucy5tZWRpYVR5cGUuZm9ybWF0fWBcbiAgICAgICAgKVxuICAgICAgKS5qb2luKFwiLFwiKTtcbiAgICB9XG4gICAgaWYgKHVybC5lbmRzV2l0aChcIi9ncmFwaHFsXCIpKSB7XG4gICAgICBpZiAob3B0aW9ucy5tZWRpYVR5cGUucHJldmlld3M/Lmxlbmd0aCkge1xuICAgICAgICBjb25zdCBwcmV2aWV3c0Zyb21BY2NlcHRIZWFkZXIgPSBoZWFkZXJzLmFjY2VwdC5tYXRjaCgvW1xcdy1dKyg/PS1wcmV2aWV3KS9nKSB8fCBbXTtcbiAgICAgICAgaGVhZGVycy5hY2NlcHQgPSBwcmV2aWV3c0Zyb21BY2NlcHRIZWFkZXIuY29uY2F0KG9wdGlvbnMubWVkaWFUeXBlLnByZXZpZXdzKS5tYXAoKHByZXZpZXcpID0+IHtcbiAgICAgICAgICBjb25zdCBmb3JtYXQgPSBvcHRpb25zLm1lZGlhVHlwZS5mb3JtYXQgPyBgLiR7b3B0aW9ucy5tZWRpYVR5cGUuZm9ybWF0fWAgOiBcIitqc29uXCI7XG4gICAgICAgICAgcmV0dXJuIGBhcHBsaWNhdGlvbi92bmQuZ2l0aHViLiR7cHJldmlld30tcHJldmlldyR7Zm9ybWF0fWA7XG4gICAgICAgIH0pLmpvaW4oXCIsXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoW1wiR0VUXCIsIFwiSEVBRFwiXS5pbmNsdWRlcyhtZXRob2QpKSB7XG4gICAgdXJsID0gYWRkUXVlcnlQYXJhbWV0ZXJzKHVybCwgcmVtYWluaW5nUGFyYW1ldGVycyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKFwiZGF0YVwiIGluIHJlbWFpbmluZ1BhcmFtZXRlcnMpIHtcbiAgICAgIGJvZHkgPSByZW1haW5pbmdQYXJhbWV0ZXJzLmRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhyZW1haW5pbmdQYXJhbWV0ZXJzKS5sZW5ndGgpIHtcbiAgICAgICAgYm9keSA9IHJlbWFpbmluZ1BhcmFtZXRlcnM7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSAmJiB0eXBlb2YgYm9keSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gPSBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIjtcbiAgfVxuICBpZiAoW1wiUEFUQ0hcIiwgXCJQVVRcIl0uaW5jbHVkZXMobWV0aG9kKSAmJiB0eXBlb2YgYm9keSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGJvZHkgPSBcIlwiO1xuICB9XG4gIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgIHsgbWV0aG9kLCB1cmwsIGhlYWRlcnMgfSxcbiAgICB0eXBlb2YgYm9keSAhPT0gXCJ1bmRlZmluZWRcIiA/IHsgYm9keSB9IDogbnVsbCxcbiAgICBvcHRpb25zLnJlcXVlc3QgPyB7IHJlcXVlc3Q6IG9wdGlvbnMucmVxdWVzdCB9IDogbnVsbFxuICApO1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvZW5kcG9pbnQtd2l0aC1kZWZhdWx0cy5qc1xuZnVuY3Rpb24gZW5kcG9pbnRXaXRoRGVmYXVsdHMoZGVmYXVsdHMsIHJvdXRlLCBvcHRpb25zKSB7XG4gIHJldHVybiBwYXJzZShtZXJnZShkZWZhdWx0cywgcm91dGUsIG9wdGlvbnMpKTtcbn1cblxuLy8gcGtnL2Rpc3Qtc3JjL3dpdGgtZGVmYXVsdHMuanNcbmZ1bmN0aW9uIHdpdGhEZWZhdWx0cyhvbGREZWZhdWx0cywgbmV3RGVmYXVsdHMpIHtcbiAgY29uc3QgREVGQVVMVFMyID0gbWVyZ2Uob2xkRGVmYXVsdHMsIG5ld0RlZmF1bHRzKTtcbiAgY29uc3QgZW5kcG9pbnQyID0gZW5kcG9pbnRXaXRoRGVmYXVsdHMuYmluZChudWxsLCBERUZBVUxUUzIpO1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihlbmRwb2ludDIsIHtcbiAgICBERUZBVUxUUzogREVGQVVMVFMyLFxuICAgIGRlZmF1bHRzOiB3aXRoRGVmYXVsdHMuYmluZChudWxsLCBERUZBVUxUUzIpLFxuICAgIG1lcmdlOiBtZXJnZS5iaW5kKG51bGwsIERFRkFVTFRTMiksXG4gICAgcGFyc2VcbiAgfSk7XG59XG5cbi8vIHBrZy9kaXN0LXNyYy9pbmRleC5qc1xudmFyIGVuZHBvaW50ID0gd2l0aERlZmF1bHRzKG51bGwsIERFRkFVTFRTKTtcbmV4cG9ydCB7XG4gIGVuZHBvaW50XG59O1xuIiwgImV4cG9ydCBmdW5jdGlvbiBnZXRVc2VyQWdlbnQoKSB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSBcIm9iamVjdFwiICYmIFwidXNlckFnZW50XCIgaW4gbmF2aWdhdG9yKSB7XG4gICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gIH1cblxuICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2Vzcy52ZXJzaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gYE5vZGUuanMvJHtwcm9jZXNzLnZlcnNpb24uc3Vic3RyKDEpfSAoJHtwcm9jZXNzLnBsYXRmb3JtfTsgJHtcbiAgICAgIHByb2Nlc3MuYXJjaFxuICAgIH0pYDtcbiAgfVxuXG4gIHJldHVybiBcIjxlbnZpcm9ubWVudCB1bmRldGVjdGFibGU+XCI7XG59XG4iLCAiY2xhc3MgUmVxdWVzdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBuYW1lO1xuICAvKipcbiAgICogaHR0cCBzdGF0dXMgY29kZVxuICAgKi9cbiAgc3RhdHVzO1xuICAvKipcbiAgICogUmVxdWVzdCBvcHRpb25zIHRoYXQgbGVhZCB0byB0aGUgZXJyb3IuXG4gICAqL1xuICByZXF1ZXN0O1xuICAvKipcbiAgICogUmVzcG9uc2Ugb2JqZWN0IGlmIGEgcmVzcG9uc2Ugd2FzIHJlY2VpdmVkXG4gICAqL1xuICByZXNwb25zZTtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzQ29kZSwgb3B0aW9ucykge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuICAgIHRoaXMubmFtZSA9IFwiSHR0cEVycm9yXCI7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXNDb2RlO1xuICAgIGlmIChcInJlc3BvbnNlXCIgaW4gb3B0aW9ucykge1xuICAgICAgdGhpcy5yZXNwb25zZSA9IG9wdGlvbnMucmVzcG9uc2U7XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3RDb3B5ID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5yZXF1ZXN0KTtcbiAgICBpZiAob3B0aW9ucy5yZXF1ZXN0LmhlYWRlcnMuYXV0aG9yaXphdGlvbikge1xuICAgICAgcmVxdWVzdENvcHkuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMucmVxdWVzdC5oZWFkZXJzLCB7XG4gICAgICAgIGF1dGhvcml6YXRpb246IG9wdGlvbnMucmVxdWVzdC5oZWFkZXJzLmF1dGhvcml6YXRpb24ucmVwbGFjZShcbiAgICAgICAgICAvIC4qJC8sXG4gICAgICAgICAgXCIgW1JFREFDVEVEXVwiXG4gICAgICAgIClcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXF1ZXN0Q29weS51cmwgPSByZXF1ZXN0Q29weS51cmwucmVwbGFjZSgvXFxiY2xpZW50X3NlY3JldD1cXHcrL2csIFwiY2xpZW50X3NlY3JldD1bUkVEQUNURURdXCIpLnJlcGxhY2UoL1xcYmFjY2Vzc190b2tlbj1cXHcrL2csIFwiYWNjZXNzX3Rva2VuPVtSRURBQ1RFRF1cIik7XG4gICAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdENvcHk7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIFJlcXVlc3RFcnJvclxufTtcbiIsICIvLyBwa2cvZGlzdC1zcmMvaW5kZXguanNcbmltcG9ydCB7IGVuZHBvaW50IH0gZnJvbSBcIkBvY3Rva2l0L2VuZHBvaW50XCI7XG5pbXBvcnQgeyBnZXRVc2VyQWdlbnQgfSBmcm9tIFwidW5pdmVyc2FsLXVzZXItYWdlbnRcIjtcblxuLy8gcGtnL2Rpc3Qtc3JjL3ZlcnNpb24uanNcbnZhciBWRVJTSU9OID0gXCIwLjAuMC1kZXZlbG9wbWVudFwiO1xuXG4vLyBwa2cvZGlzdC1zcmMvaXMtcGxhaW4tb2JqZWN0LmpzXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT09IG51bGwpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIilcbiAgICByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgaWYgKHByb3RvID09PSBudWxsKVxuICAgIHJldHVybiB0cnVlO1xuICBjb25zdCBDdG9yID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCBcImNvbnN0cnVjdG9yXCIpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJiBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbChDdG9yKSA9PT0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwodmFsdWUpO1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvZmV0Y2gtd3JhcHBlci5qc1xuaW1wb3J0IHsgUmVxdWVzdEVycm9yIH0gZnJvbSBcIkBvY3Rva2l0L3JlcXVlc3QtZXJyb3JcIjtcblxuLy8gcGtnL2Rpc3Qtc3JjL2dldC1idWZmZXItcmVzcG9uc2UuanNcbmZ1bmN0aW9uIGdldEJ1ZmZlclJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gIHJldHVybiByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvZmV0Y2gtd3JhcHBlci5qc1xuZnVuY3Rpb24gZmV0Y2hXcmFwcGVyKHJlcXVlc3RPcHRpb25zKSB7XG4gIGNvbnN0IGxvZyA9IHJlcXVlc3RPcHRpb25zLnJlcXVlc3QgJiYgcmVxdWVzdE9wdGlvbnMucmVxdWVzdC5sb2cgPyByZXF1ZXN0T3B0aW9ucy5yZXF1ZXN0LmxvZyA6IGNvbnNvbGU7XG4gIGNvbnN0IHBhcnNlU3VjY2Vzc1Jlc3BvbnNlQm9keSA9IHJlcXVlc3RPcHRpb25zLnJlcXVlc3Q/LnBhcnNlU3VjY2Vzc1Jlc3BvbnNlQm9keSAhPT0gZmFsc2U7XG4gIGlmIChpc1BsYWluT2JqZWN0KHJlcXVlc3RPcHRpb25zLmJvZHkpIHx8IEFycmF5LmlzQXJyYXkocmVxdWVzdE9wdGlvbnMuYm9keSkpIHtcbiAgICByZXF1ZXN0T3B0aW9ucy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkocmVxdWVzdE9wdGlvbnMuYm9keSk7XG4gIH1cbiAgbGV0IGhlYWRlcnMgPSB7fTtcbiAgbGV0IHN0YXR1cztcbiAgbGV0IHVybDtcbiAgbGV0IHsgZmV0Y2ggfSA9IGdsb2JhbFRoaXM7XG4gIGlmIChyZXF1ZXN0T3B0aW9ucy5yZXF1ZXN0Py5mZXRjaCkge1xuICAgIGZldGNoID0gcmVxdWVzdE9wdGlvbnMucmVxdWVzdC5mZXRjaDtcbiAgfVxuICBpZiAoIWZldGNoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJmZXRjaCBpcyBub3Qgc2V0LiBQbGVhc2UgcGFzcyBhIGZldGNoIGltcGxlbWVudGF0aW9uIGFzIG5ldyBPY3Rva2l0KHsgcmVxdWVzdDogeyBmZXRjaCB9fSkuIExlYXJuIG1vcmUgYXQgaHR0cHM6Ly9naXRodWIuY29tL29jdG9raXQvb2N0b2tpdC5qcy8jZmV0Y2gtbWlzc2luZ1wiXG4gICAgKTtcbiAgfVxuICByZXR1cm4gZmV0Y2gocmVxdWVzdE9wdGlvbnMudXJsLCB7XG4gICAgbWV0aG9kOiByZXF1ZXN0T3B0aW9ucy5tZXRob2QsXG4gICAgYm9keTogcmVxdWVzdE9wdGlvbnMuYm9keSxcbiAgICAvLyBIZWFkZXIgdmFsdWVzIG11c3QgYmUgYHN0cmluZ2BcbiAgICBoZWFkZXJzOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBPYmplY3QuZW50cmllcyhyZXF1ZXN0T3B0aW9ucy5oZWFkZXJzKS5tYXAoKFtuYW1lLCB2YWx1ZV0pID0+IFtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgU3RyaW5nKHZhbHVlKVxuICAgICAgXSlcbiAgICApLFxuICAgIHNpZ25hbDogcmVxdWVzdE9wdGlvbnMucmVxdWVzdD8uc2lnbmFsLFxuICAgIC8vIGR1cGxleCBtdXN0IGJlIHNldCBpZiByZXF1ZXN0LmJvZHkgaXMgUmVhZGFibGVTdHJlYW0gb3IgQXN5bmMgSXRlcmFibGVzLlxuICAgIC8vIFNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLXJlcXVlc3Rpbml0LWR1cGxleC5cbiAgICAuLi5yZXF1ZXN0T3B0aW9ucy5ib2R5ICYmIHsgZHVwbGV4OiBcImhhbGZcIiB9XG4gIH0pLnRoZW4oYXN5bmMgKHJlc3BvbnNlKSA9PiB7XG4gICAgdXJsID0gcmVzcG9uc2UudXJsO1xuICAgIHN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1cztcbiAgICBmb3IgKGNvbnN0IGtleUFuZFZhbHVlIG9mIHJlc3BvbnNlLmhlYWRlcnMpIHtcbiAgICAgIGhlYWRlcnNba2V5QW5kVmFsdWVbMF1dID0ga2V5QW5kVmFsdWVbMV07XG4gICAgfVxuICAgIGlmIChcImRlcHJlY2F0aW9uXCIgaW4gaGVhZGVycykge1xuICAgICAgY29uc3QgbWF0Y2hlcyA9IGhlYWRlcnMubGluayAmJiBoZWFkZXJzLmxpbmsubWF0Y2goLzwoW14+XSspPjsgcmVsPVwiZGVwcmVjYXRpb25cIi8pO1xuICAgICAgY29uc3QgZGVwcmVjYXRpb25MaW5rID0gbWF0Y2hlcyAmJiBtYXRjaGVzLnBvcCgpO1xuICAgICAgbG9nLndhcm4oXG4gICAgICAgIGBbQG9jdG9raXQvcmVxdWVzdF0gXCIke3JlcXVlc3RPcHRpb25zLm1ldGhvZH0gJHtyZXF1ZXN0T3B0aW9ucy51cmx9XCIgaXMgZGVwcmVjYXRlZC4gSXQgaXMgc2NoZWR1bGVkIHRvIGJlIHJlbW92ZWQgb24gJHtoZWFkZXJzLnN1bnNldH0ke2RlcHJlY2F0aW9uTGluayA/IGAuIFNlZSAke2RlcHJlY2F0aW9uTGlua31gIDogXCJcIn1gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSAyMDQgfHwgc3RhdHVzID09PSAyMDUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJlcXVlc3RPcHRpb25zLm1ldGhvZCA9PT0gXCJIRUFEXCIpIHtcbiAgICAgIGlmIChzdGF0dXMgPCA0MDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFJlcXVlc3RFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0LCBzdGF0dXMsIHtcbiAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgZGF0YTogdm9pZCAwXG4gICAgICAgIH0sXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RPcHRpb25zXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHN0YXR1cyA9PT0gMzA0KSB7XG4gICAgICB0aHJvdyBuZXcgUmVxdWVzdEVycm9yKFwiTm90IG1vZGlmaWVkXCIsIHN0YXR1cywge1xuICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgIHVybCxcbiAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBkYXRhOiBhd2FpdCBnZXRSZXNwb25zZURhdGEocmVzcG9uc2UpXG4gICAgICAgIH0sXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RPcHRpb25zXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHN0YXR1cyA+PSA0MDApIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXRSZXNwb25zZURhdGEocmVzcG9uc2UpO1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgUmVxdWVzdEVycm9yKHRvRXJyb3JNZXNzYWdlKGRhdGEpLCBzdGF0dXMsIHtcbiAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgZGF0YVxuICAgICAgICB9LFxuICAgICAgICByZXF1ZXN0OiByZXF1ZXN0T3B0aW9uc1xuICAgICAgfSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlU3VjY2Vzc1Jlc3BvbnNlQm9keSA/IGF3YWl0IGdldFJlc3BvbnNlRGF0YShyZXNwb25zZSkgOiByZXNwb25zZS5ib2R5O1xuICB9KS50aGVuKChkYXRhKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1cyxcbiAgICAgIHVybCxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBkYXRhXG4gICAgfTtcbiAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgUmVxdWVzdEVycm9yKVxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIpXG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICBsZXQgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgaWYgKGVycm9yLm5hbWUgPT09IFwiVHlwZUVycm9yXCIgJiYgXCJjYXVzZVwiIGluIGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IuY2F1c2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBtZXNzYWdlID0gZXJyb3IuY2F1c2UubWVzc2FnZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVycm9yLmNhdXNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBlcnJvci5jYXVzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IFJlcXVlc3RFcnJvcihtZXNzYWdlLCA1MDAsIHtcbiAgICAgIHJlcXVlc3Q6IHJlcXVlc3RPcHRpb25zXG4gICAgfSk7XG4gIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0UmVzcG9uc2VEYXRhKHJlc3BvbnNlKSB7XG4gIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIik7XG4gIGlmICgvYXBwbGljYXRpb25cXC9qc29uLy50ZXN0KGNvbnRlbnRUeXBlKSkge1xuICAgIHJldHVybiByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gcmVzcG9uc2UudGV4dCgpKS5jYXRjaCgoKSA9PiBcIlwiKTtcbiAgfVxuICBpZiAoIWNvbnRlbnRUeXBlIHx8IC9edGV4dFxcL3xjaGFyc2V0PXV0Zi04JC8udGVzdChjb250ZW50VHlwZSkpIHtcbiAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICB9XG4gIHJldHVybiBnZXRCdWZmZXJSZXNwb25zZShyZXNwb25zZSk7XG59XG5mdW5jdGlvbiB0b0Vycm9yTWVzc2FnZShkYXRhKSB7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gZGF0YTtcbiAgbGV0IHN1ZmZpeDtcbiAgaWYgKFwiZG9jdW1lbnRhdGlvbl91cmxcIiBpbiBkYXRhKSB7XG4gICAgc3VmZml4ID0gYCAtICR7ZGF0YS5kb2N1bWVudGF0aW9uX3VybH1gO1xuICB9IGVsc2Uge1xuICAgIHN1ZmZpeCA9IFwiXCI7XG4gIH1cbiAgaWYgKFwibWVzc2FnZVwiIGluIGRhdGEpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhLmVycm9ycykpIHtcbiAgICAgIHJldHVybiBgJHtkYXRhLm1lc3NhZ2V9OiAke2RhdGEuZXJyb3JzLm1hcChKU09OLnN0cmluZ2lmeSkuam9pbihcIiwgXCIpfSR7c3VmZml4fWA7XG4gICAgfVxuICAgIHJldHVybiBgJHtkYXRhLm1lc3NhZ2V9JHtzdWZmaXh9YDtcbiAgfVxuICByZXR1cm4gYFVua25vd24gZXJyb3I6ICR7SlNPTi5zdHJpbmdpZnkoZGF0YSl9YDtcbn1cblxuLy8gcGtnL2Rpc3Qtc3JjL3dpdGgtZGVmYXVsdHMuanNcbmZ1bmN0aW9uIHdpdGhEZWZhdWx0cyhvbGRFbmRwb2ludCwgbmV3RGVmYXVsdHMpIHtcbiAgY29uc3QgZW5kcG9pbnQyID0gb2xkRW5kcG9pbnQuZGVmYXVsdHMobmV3RGVmYXVsdHMpO1xuICBjb25zdCBuZXdBcGkgPSBmdW5jdGlvbihyb3V0ZSwgcGFyYW1ldGVycykge1xuICAgIGNvbnN0IGVuZHBvaW50T3B0aW9ucyA9IGVuZHBvaW50Mi5tZXJnZShyb3V0ZSwgcGFyYW1ldGVycyk7XG4gICAgaWYgKCFlbmRwb2ludE9wdGlvbnMucmVxdWVzdCB8fCAhZW5kcG9pbnRPcHRpb25zLnJlcXVlc3QuaG9vaykge1xuICAgICAgcmV0dXJuIGZldGNoV3JhcHBlcihlbmRwb2ludDIucGFyc2UoZW5kcG9pbnRPcHRpb25zKSk7XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3QyID0gKHJvdXRlMiwgcGFyYW1ldGVyczIpID0+IHtcbiAgICAgIHJldHVybiBmZXRjaFdyYXBwZXIoXG4gICAgICAgIGVuZHBvaW50Mi5wYXJzZShlbmRwb2ludDIubWVyZ2Uocm91dGUyLCBwYXJhbWV0ZXJzMikpXG4gICAgICApO1xuICAgIH07XG4gICAgT2JqZWN0LmFzc2lnbihyZXF1ZXN0Miwge1xuICAgICAgZW5kcG9pbnQ6IGVuZHBvaW50MixcbiAgICAgIGRlZmF1bHRzOiB3aXRoRGVmYXVsdHMuYmluZChudWxsLCBlbmRwb2ludDIpXG4gICAgfSk7XG4gICAgcmV0dXJuIGVuZHBvaW50T3B0aW9ucy5yZXF1ZXN0Lmhvb2socmVxdWVzdDIsIGVuZHBvaW50T3B0aW9ucyk7XG4gIH07XG4gIHJldHVybiBPYmplY3QuYXNzaWduKG5ld0FwaSwge1xuICAgIGVuZHBvaW50OiBlbmRwb2ludDIsXG4gICAgZGVmYXVsdHM6IHdpdGhEZWZhdWx0cy5iaW5kKG51bGwsIGVuZHBvaW50MilcbiAgfSk7XG59XG5cbi8vIHBrZy9kaXN0LXNyYy9pbmRleC5qc1xudmFyIHJlcXVlc3QgPSB3aXRoRGVmYXVsdHMoZW5kcG9pbnQsIHtcbiAgaGVhZGVyczoge1xuICAgIFwidXNlci1hZ2VudFwiOiBgb2N0b2tpdC1yZXF1ZXN0LmpzLyR7VkVSU0lPTn0gJHtnZXRVc2VyQWdlbnQoKX1gXG4gIH1cbn0pO1xuZXhwb3J0IHtcbiAgcmVxdWVzdFxufTtcbiIsICJleHBvcnQgZnVuY3Rpb24gZ2V0VXNlckFnZW50KCkge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gXCJvYmplY3RcIiAmJiBcInVzZXJBZ2VudFwiIGluIG5hdmlnYXRvcikge1xuICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MudmVyc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGBOb2RlLmpzLyR7cHJvY2Vzcy52ZXJzaW9uLnN1YnN0cigxKX0gKCR7cHJvY2Vzcy5wbGF0Zm9ybX07ICR7XG4gICAgICBwcm9jZXNzLmFyY2hcbiAgICB9KWA7XG4gIH1cblxuICByZXR1cm4gXCI8ZW52aXJvbm1lbnQgdW5kZXRlY3RhYmxlPlwiO1xufVxuIiwgIi8vIHBrZy9kaXN0LXNyYy9pbmRleC5qc1xuaW1wb3J0IHsgcmVxdWVzdCB9IGZyb20gXCJAb2N0b2tpdC9yZXF1ZXN0XCI7XG5pbXBvcnQgeyBnZXRVc2VyQWdlbnQgfSBmcm9tIFwidW5pdmVyc2FsLXVzZXItYWdlbnRcIjtcblxuLy8gcGtnL2Rpc3Qtc3JjL3ZlcnNpb24uanNcbnZhciBWRVJTSU9OID0gXCIwLjAuMC1kZXZlbG9wbWVudFwiO1xuXG4vLyBwa2cvZGlzdC1zcmMvd2l0aC1kZWZhdWx0cy5qc1xuaW1wb3J0IHsgcmVxdWVzdCBhcyBSZXF1ZXN0MiB9IGZyb20gXCJAb2N0b2tpdC9yZXF1ZXN0XCI7XG5cbi8vIHBrZy9kaXN0LXNyYy9ncmFwaHFsLmpzXG5pbXBvcnQgeyByZXF1ZXN0IGFzIFJlcXVlc3QgfSBmcm9tIFwiQG9jdG9raXQvcmVxdWVzdFwiO1xuXG4vLyBwa2cvZGlzdC1zcmMvZXJyb3IuanNcbmZ1bmN0aW9uIF9idWlsZE1lc3NhZ2VGb3JSZXNwb25zZUVycm9ycyhkYXRhKSB7XG4gIHJldHVybiBgUmVxdWVzdCBmYWlsZWQgZHVlIHRvIGZvbGxvd2luZyByZXNwb25zZSBlcnJvcnM6XG5gICsgZGF0YS5lcnJvcnMubWFwKChlKSA9PiBgIC0gJHtlLm1lc3NhZ2V9YCkuam9pbihcIlxcblwiKTtcbn1cbnZhciBHcmFwaHFsUmVzcG9uc2VFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihyZXF1ZXN0MiwgaGVhZGVycywgcmVzcG9uc2UpIHtcbiAgICBzdXBlcihfYnVpbGRNZXNzYWdlRm9yUmVzcG9uc2VFcnJvcnMocmVzcG9uc2UpKTtcbiAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0MjtcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICB0aGlzLmVycm9ycyA9IHJlc3BvbnNlLmVycm9ycztcbiAgICB0aGlzLmRhdGEgPSByZXNwb25zZS5kYXRhO1xuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuICB9XG4gIG5hbWUgPSBcIkdyYXBocWxSZXNwb25zZUVycm9yXCI7XG4gIGVycm9ycztcbiAgZGF0YTtcbn07XG5cbi8vIHBrZy9kaXN0LXNyYy9ncmFwaHFsLmpzXG52YXIgTk9OX1ZBUklBQkxFX09QVElPTlMgPSBbXG4gIFwibWV0aG9kXCIsXG4gIFwiYmFzZVVybFwiLFxuICBcInVybFwiLFxuICBcImhlYWRlcnNcIixcbiAgXCJyZXF1ZXN0XCIsXG4gIFwicXVlcnlcIixcbiAgXCJtZWRpYVR5cGVcIlxuXTtcbnZhciBGT1JCSURERU5fVkFSSUFCTEVfT1BUSU9OUyA9IFtcInF1ZXJ5XCIsIFwibWV0aG9kXCIsIFwidXJsXCJdO1xudmFyIEdIRVNfVjNfU1VGRklYX1JFR0VYID0gL1xcL2FwaVxcL3YzXFwvPyQvO1xuZnVuY3Rpb24gZ3JhcGhxbChyZXF1ZXN0MiwgcXVlcnksIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSBcInN0cmluZ1wiICYmIFwicXVlcnlcIiBpbiBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgIG5ldyBFcnJvcihgW0BvY3Rva2l0L2dyYXBocWxdIFwicXVlcnlcIiBjYW5ub3QgYmUgdXNlZCBhcyB2YXJpYWJsZSBuYW1lYClcbiAgICAgICk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgIGlmICghRk9SQklEREVOX1ZBUklBQkxFX09QVElPTlMuaW5jbHVkZXMoa2V5KSlcbiAgICAgICAgY29udGludWU7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICBgW0BvY3Rva2l0L2dyYXBocWxdIFwiJHtrZXl9XCIgY2Fubm90IGJlIHVzZWQgYXMgdmFyaWFibGUgbmFtZWBcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcGFyc2VkT3B0aW9ucyA9IHR5cGVvZiBxdWVyeSA9PT0gXCJzdHJpbmdcIiA/IE9iamVjdC5hc3NpZ24oeyBxdWVyeSB9LCBvcHRpb25zKSA6IHF1ZXJ5O1xuICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5rZXlzKFxuICAgIHBhcnNlZE9wdGlvbnNcbiAgKS5yZWR1Y2UoKHJlc3VsdCwga2V5KSA9PiB7XG4gICAgaWYgKE5PTl9WQVJJQUJMRV9PUFRJT05TLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gcGFyc2VkT3B0aW9uc1trZXldO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKCFyZXN1bHQudmFyaWFibGVzKSB7XG4gICAgICByZXN1bHQudmFyaWFibGVzID0ge307XG4gICAgfVxuICAgIHJlc3VsdC52YXJpYWJsZXNba2V5XSA9IHBhcnNlZE9wdGlvbnNba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCB7fSk7XG4gIGNvbnN0IGJhc2VVcmwgPSBwYXJzZWRPcHRpb25zLmJhc2VVcmwgfHwgcmVxdWVzdDIuZW5kcG9pbnQuREVGQVVMVFMuYmFzZVVybDtcbiAgaWYgKEdIRVNfVjNfU1VGRklYX1JFR0VYLnRlc3QoYmFzZVVybCkpIHtcbiAgICByZXF1ZXN0T3B0aW9ucy51cmwgPSBiYXNlVXJsLnJlcGxhY2UoR0hFU19WM19TVUZGSVhfUkVHRVgsIFwiL2FwaS9ncmFwaHFsXCIpO1xuICB9XG4gIHJldHVybiByZXF1ZXN0MihyZXF1ZXN0T3B0aW9ucykudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICBpZiAocmVzcG9uc2UuZGF0YS5lcnJvcnMpIHtcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHJlc3BvbnNlLmhlYWRlcnMpKSB7XG4gICAgICAgIGhlYWRlcnNba2V5XSA9IHJlc3BvbnNlLmhlYWRlcnNba2V5XTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBHcmFwaHFsUmVzcG9uc2VFcnJvcihcbiAgICAgICAgcmVxdWVzdE9wdGlvbnMsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIHJlc3BvbnNlLmRhdGFcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZS5kYXRhLmRhdGE7XG4gIH0pO1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvd2l0aC1kZWZhdWx0cy5qc1xuZnVuY3Rpb24gd2l0aERlZmF1bHRzKHJlcXVlc3QyLCBuZXdEZWZhdWx0cykge1xuICBjb25zdCBuZXdSZXF1ZXN0ID0gcmVxdWVzdDIuZGVmYXVsdHMobmV3RGVmYXVsdHMpO1xuICBjb25zdCBuZXdBcGkgPSAocXVlcnksIG9wdGlvbnMpID0+IHtcbiAgICByZXR1cm4gZ3JhcGhxbChuZXdSZXF1ZXN0LCBxdWVyeSwgb3B0aW9ucyk7XG4gIH07XG4gIHJldHVybiBPYmplY3QuYXNzaWduKG5ld0FwaSwge1xuICAgIGRlZmF1bHRzOiB3aXRoRGVmYXVsdHMuYmluZChudWxsLCBuZXdSZXF1ZXN0KSxcbiAgICBlbmRwb2ludDogbmV3UmVxdWVzdC5lbmRwb2ludFxuICB9KTtcbn1cblxuLy8gcGtnL2Rpc3Qtc3JjL2luZGV4LmpzXG52YXIgZ3JhcGhxbDIgPSB3aXRoRGVmYXVsdHMocmVxdWVzdCwge1xuICBoZWFkZXJzOiB7XG4gICAgXCJ1c2VyLWFnZW50XCI6IGBvY3Rva2l0LWdyYXBocWwuanMvJHtWRVJTSU9OfSAke2dldFVzZXJBZ2VudCgpfWBcbiAgfSxcbiAgbWV0aG9kOiBcIlBPU1RcIixcbiAgdXJsOiBcIi9ncmFwaHFsXCJcbn0pO1xuZnVuY3Rpb24gd2l0aEN1c3RvbVJlcXVlc3QoY3VzdG9tUmVxdWVzdCkge1xuICByZXR1cm4gd2l0aERlZmF1bHRzKGN1c3RvbVJlcXVlc3QsIHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIHVybDogXCIvZ3JhcGhxbFwiXG4gIH0pO1xufVxuZXhwb3J0IHtcbiAgR3JhcGhxbFJlc3BvbnNlRXJyb3IsXG4gIGdyYXBocWwyIGFzIGdyYXBocWwsXG4gIHdpdGhDdXN0b21SZXF1ZXN0XG59O1xuIiwgIi8vIHBrZy9kaXN0LXNyYy9hdXRoLmpzXG52YXIgUkVHRVhfSVNfSU5TVEFMTEFUSU9OX0xFR0FDWSA9IC9edjFcXC4vO1xudmFyIFJFR0VYX0lTX0lOU1RBTExBVElPTiA9IC9eZ2hzXy87XG52YXIgUkVHRVhfSVNfVVNFUl9UT19TRVJWRVIgPSAvXmdodV8vO1xuYXN5bmMgZnVuY3Rpb24gYXV0aCh0b2tlbikge1xuICBjb25zdCBpc0FwcCA9IHRva2VuLnNwbGl0KC9cXC4vKS5sZW5ndGggPT09IDM7XG4gIGNvbnN0IGlzSW5zdGFsbGF0aW9uID0gUkVHRVhfSVNfSU5TVEFMTEFUSU9OX0xFR0FDWS50ZXN0KHRva2VuKSB8fCBSRUdFWF9JU19JTlNUQUxMQVRJT04udGVzdCh0b2tlbik7XG4gIGNvbnN0IGlzVXNlclRvU2VydmVyID0gUkVHRVhfSVNfVVNFUl9UT19TRVJWRVIudGVzdCh0b2tlbik7XG4gIGNvbnN0IHRva2VuVHlwZSA9IGlzQXBwID8gXCJhcHBcIiA6IGlzSW5zdGFsbGF0aW9uID8gXCJpbnN0YWxsYXRpb25cIiA6IGlzVXNlclRvU2VydmVyID8gXCJ1c2VyLXRvLXNlcnZlclwiIDogXCJvYXV0aFwiO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidG9rZW5cIixcbiAgICB0b2tlbixcbiAgICB0b2tlblR5cGVcbiAgfTtcbn1cblxuLy8gcGtnL2Rpc3Qtc3JjL3dpdGgtYXV0aG9yaXphdGlvbi1wcmVmaXguanNcbmZ1bmN0aW9uIHdpdGhBdXRob3JpemF0aW9uUHJlZml4KHRva2VuKSB7XG4gIGlmICh0b2tlbi5zcGxpdCgvXFwuLykubGVuZ3RoID09PSAzKSB7XG4gICAgcmV0dXJuIGBiZWFyZXIgJHt0b2tlbn1gO1xuICB9XG4gIHJldHVybiBgdG9rZW4gJHt0b2tlbn1gO1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvaG9vay5qc1xuYXN5bmMgZnVuY3Rpb24gaG9vayh0b2tlbiwgcmVxdWVzdCwgcm91dGUsIHBhcmFtZXRlcnMpIHtcbiAgY29uc3QgZW5kcG9pbnQgPSByZXF1ZXN0LmVuZHBvaW50Lm1lcmdlKFxuICAgIHJvdXRlLFxuICAgIHBhcmFtZXRlcnNcbiAgKTtcbiAgZW5kcG9pbnQuaGVhZGVycy5hdXRob3JpemF0aW9uID0gd2l0aEF1dGhvcml6YXRpb25QcmVmaXgodG9rZW4pO1xuICByZXR1cm4gcmVxdWVzdChlbmRwb2ludCk7XG59XG5cbi8vIHBrZy9kaXN0LXNyYy9pbmRleC5qc1xudmFyIGNyZWF0ZVRva2VuQXV0aCA9IGZ1bmN0aW9uIGNyZWF0ZVRva2VuQXV0aDIodG9rZW4pIHtcbiAgaWYgKCF0b2tlbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIltAb2N0b2tpdC9hdXRoLXRva2VuXSBObyB0b2tlbiBwYXNzZWQgdG8gY3JlYXRlVG9rZW5BdXRoXCIpO1xuICB9XG4gIGlmICh0eXBlb2YgdG9rZW4gIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIltAb2N0b2tpdC9hdXRoLXRva2VuXSBUb2tlbiBwYXNzZWQgdG8gY3JlYXRlVG9rZW5BdXRoIGlzIG5vdCBhIHN0cmluZ1wiXG4gICAgKTtcbiAgfVxuICB0b2tlbiA9IHRva2VuLnJlcGxhY2UoL14odG9rZW58YmVhcmVyKSArL2ksIFwiXCIpO1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihhdXRoLmJpbmQobnVsbCwgdG9rZW4pLCB7XG4gICAgaG9vazogaG9vay5iaW5kKG51bGwsIHRva2VuKVxuICB9KTtcbn07XG5leHBvcnQge1xuICBjcmVhdGVUb2tlbkF1dGhcbn07XG4iLCAiY29uc3QgVkVSU0lPTiA9IFwiNi4wLjFcIjtcbmV4cG9ydCB7XG4gIFZFUlNJT05cbn07XG4iLCAiaW1wb3J0IHsgZ2V0VXNlckFnZW50IH0gZnJvbSBcInVuaXZlcnNhbC11c2VyLWFnZW50XCI7XG5pbXBvcnQgSG9vayBmcm9tIFwiYmVmb3JlLWFmdGVyLWhvb2tcIjtcbmltcG9ydCB7IHJlcXVlc3QgfSBmcm9tIFwiQG9jdG9raXQvcmVxdWVzdFwiO1xuaW1wb3J0IHsgZ3JhcGhxbCwgd2l0aEN1c3RvbVJlcXVlc3QgfSBmcm9tIFwiQG9jdG9raXQvZ3JhcGhxbFwiO1xuaW1wb3J0IHsgY3JlYXRlVG9rZW5BdXRoIH0gZnJvbSBcIkBvY3Rva2l0L2F1dGgtdG9rZW5cIjtcbmltcG9ydCB7IFZFUlNJT04gfSBmcm9tIFwiLi92ZXJzaW9uLmpzXCI7XG5jb25zdCBub29wID0gKCkgPT4ge1xufTtcbmNvbnN0IGNvbnNvbGVXYXJuID0gY29uc29sZS53YXJuLmJpbmQoY29uc29sZSk7XG5jb25zdCBjb25zb2xlRXJyb3IgPSBjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSk7XG5jb25zdCB1c2VyQWdlbnRUcmFpbCA9IGBvY3Rva2l0LWNvcmUuanMvJHtWRVJTSU9OfSAke2dldFVzZXJBZ2VudCgpfWA7XG5jbGFzcyBPY3Rva2l0IHtcbiAgc3RhdGljIFZFUlNJT04gPSBWRVJTSU9OO1xuICBzdGF0aWMgZGVmYXVsdHMoZGVmYXVsdHMpIHtcbiAgICBjb25zdCBPY3Rva2l0V2l0aERlZmF1bHRzID0gY2xhc3MgZXh0ZW5kcyB0aGlzIHtcbiAgICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGFyZ3NbMF0gfHwge307XG4gICAgICAgIGlmICh0eXBlb2YgZGVmYXVsdHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHN1cGVyKGRlZmF1bHRzKG9wdGlvbnMpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoXG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgZGVmYXVsdHMsXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgb3B0aW9ucy51c2VyQWdlbnQgJiYgZGVmYXVsdHMudXNlckFnZW50ID8ge1xuICAgICAgICAgICAgICB1c2VyQWdlbnQ6IGAke29wdGlvbnMudXNlckFnZW50fSAke2RlZmF1bHRzLnVzZXJBZ2VudH1gXG4gICAgICAgICAgICB9IDogbnVsbFxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBPY3Rva2l0V2l0aERlZmF1bHRzO1xuICB9XG4gIHN0YXRpYyBwbHVnaW5zID0gW107XG4gIC8qKlxuICAgKiBBdHRhY2ggYSBwbHVnaW4gKG9yIG1hbnkpIHRvIHlvdXIgT2N0b2tpdCBpbnN0YW5jZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgQVBJID0gT2N0b2tpdC5wbHVnaW4ocGx1Z2luMSwgcGx1Z2luMiwgcGx1Z2luMywgLi4uKVxuICAgKi9cbiAgc3RhdGljIHBsdWdpbiguLi5uZXdQbHVnaW5zKSB7XG4gICAgY29uc3QgY3VycmVudFBsdWdpbnMgPSB0aGlzLnBsdWdpbnM7XG4gICAgY29uc3QgTmV3T2N0b2tpdCA9IGNsYXNzIGV4dGVuZHMgdGhpcyB7XG4gICAgICBzdGF0aWMgcGx1Z2lucyA9IGN1cnJlbnRQbHVnaW5zLmNvbmNhdChcbiAgICAgICAgbmV3UGx1Z2lucy5maWx0ZXIoKHBsdWdpbikgPT4gIWN1cnJlbnRQbHVnaW5zLmluY2x1ZGVzKHBsdWdpbikpXG4gICAgICApO1xuICAgIH07XG4gICAgcmV0dXJuIE5ld09jdG9raXQ7XG4gIH1cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgaG9vayA9IG5ldyBIb29rLkNvbGxlY3Rpb24oKTtcbiAgICBjb25zdCByZXF1ZXN0RGVmYXVsdHMgPSB7XG4gICAgICBiYXNlVXJsOiByZXF1ZXN0LmVuZHBvaW50LkRFRkFVTFRTLmJhc2VVcmwsXG4gICAgICBoZWFkZXJzOiB7fSxcbiAgICAgIHJlcXVlc3Q6IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMucmVxdWVzdCwge1xuICAgICAgICAvLyBAdHMtaWdub3JlIGludGVybmFsIHVzYWdlIG9ubHksIG5vIG5lZWQgdG8gdHlwZVxuICAgICAgICBob29rOiBob29rLmJpbmQobnVsbCwgXCJyZXF1ZXN0XCIpXG4gICAgICB9KSxcbiAgICAgIG1lZGlhVHlwZToge1xuICAgICAgICBwcmV2aWV3czogW10sXG4gICAgICAgIGZvcm1hdDogXCJcIlxuICAgICAgfVxuICAgIH07XG4gICAgcmVxdWVzdERlZmF1bHRzLmhlYWRlcnNbXCJ1c2VyLWFnZW50XCJdID0gb3B0aW9ucy51c2VyQWdlbnQgPyBgJHtvcHRpb25zLnVzZXJBZ2VudH0gJHt1c2VyQWdlbnRUcmFpbH1gIDogdXNlckFnZW50VHJhaWw7XG4gICAgaWYgKG9wdGlvbnMuYmFzZVVybCkge1xuICAgICAgcmVxdWVzdERlZmF1bHRzLmJhc2VVcmwgPSBvcHRpb25zLmJhc2VVcmw7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnByZXZpZXdzKSB7XG4gICAgICByZXF1ZXN0RGVmYXVsdHMubWVkaWFUeXBlLnByZXZpZXdzID0gb3B0aW9ucy5wcmV2aWV3cztcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudGltZVpvbmUpIHtcbiAgICAgIHJlcXVlc3REZWZhdWx0cy5oZWFkZXJzW1widGltZS16b25lXCJdID0gb3B0aW9ucy50aW1lWm9uZTtcbiAgICB9XG4gICAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdC5kZWZhdWx0cyhyZXF1ZXN0RGVmYXVsdHMpO1xuICAgIHRoaXMuZ3JhcGhxbCA9IHdpdGhDdXN0b21SZXF1ZXN0KHRoaXMucmVxdWVzdCkuZGVmYXVsdHMocmVxdWVzdERlZmF1bHRzKTtcbiAgICB0aGlzLmxvZyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICB7XG4gICAgICAgIGRlYnVnOiBub29wLFxuICAgICAgICBpbmZvOiBub29wLFxuICAgICAgICB3YXJuOiBjb25zb2xlV2FybixcbiAgICAgICAgZXJyb3I6IGNvbnNvbGVFcnJvclxuICAgICAgfSxcbiAgICAgIG9wdGlvbnMubG9nXG4gICAgKTtcbiAgICB0aGlzLmhvb2sgPSBob29rO1xuICAgIGlmICghb3B0aW9ucy5hdXRoU3RyYXRlZ3kpIHtcbiAgICAgIGlmICghb3B0aW9ucy5hdXRoKSB7XG4gICAgICAgIHRoaXMuYXV0aCA9IGFzeW5jICgpID0+ICh7XG4gICAgICAgICAgdHlwZTogXCJ1bmF1dGhlbnRpY2F0ZWRcIlxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGF1dGggPSBjcmVhdGVUb2tlbkF1dGgob3B0aW9ucy5hdXRoKTtcbiAgICAgICAgaG9vay53cmFwKFwicmVxdWVzdFwiLCBhdXRoLmhvb2spO1xuICAgICAgICB0aGlzLmF1dGggPSBhdXRoO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7IGF1dGhTdHJhdGVneSwgLi4ub3RoZXJPcHRpb25zIH0gPSBvcHRpb25zO1xuICAgICAgY29uc3QgYXV0aCA9IGF1dGhTdHJhdGVneShcbiAgICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXF1ZXN0OiB0aGlzLnJlcXVlc3QsXG4gICAgICAgICAgICBsb2c6IHRoaXMubG9nLFxuICAgICAgICAgICAgLy8gd2UgcGFzcyB0aGUgY3VycmVudCBvY3Rva2l0IGluc3RhbmNlIGFzIHdlbGwgYXMgaXRzIGNvbnN0cnVjdG9yIG9wdGlvbnNcbiAgICAgICAgICAgIC8vIHRvIGFsbG93IGZvciBhdXRoZW50aWNhdGlvbiBzdHJhdGVnaWVzIHRoYXQgcmV0dXJuIGEgbmV3IG9jdG9raXQgaW5zdGFuY2VcbiAgICAgICAgICAgIC8vIHRoYXQgc2hhcmVzIHRoZSBzYW1lIGludGVybmFsIHN0YXRlIGFzIHRoZSBjdXJyZW50IG9uZS4gVGhlIG9yaWdpbmFsXG4gICAgICAgICAgICAvLyByZXF1aXJlbWVudCBmb3IgdGhpcyB3YXMgdGhlIFwiZXZlbnQtb2N0b2tpdFwiIGF1dGhlbnRpY2F0aW9uIHN0cmF0ZWd5XG4gICAgICAgICAgICAvLyBvZiBodHRwczovL2dpdGh1Yi5jb20vcHJvYm90L29jdG9raXQtYXV0aC1wcm9ib3QuXG4gICAgICAgICAgICBvY3Rva2l0OiB0aGlzLFxuICAgICAgICAgICAgb2N0b2tpdE9wdGlvbnM6IG90aGVyT3B0aW9uc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb3B0aW9ucy5hdXRoXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBob29rLndyYXAoXCJyZXF1ZXN0XCIsIGF1dGguaG9vayk7XG4gICAgICB0aGlzLmF1dGggPSBhdXRoO1xuICAgIH1cbiAgICBjb25zdCBjbGFzc0NvbnN0cnVjdG9yID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsYXNzQ29uc3RydWN0b3IucGx1Z2lucy5sZW5ndGg7ICsraSkge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjbGFzc0NvbnN0cnVjdG9yLnBsdWdpbnNbaV0odGhpcywgb3B0aW9ucykpO1xuICAgIH1cbiAgfVxuICAvLyBhc3NpZ25lZCBkdXJpbmcgY29uc3RydWN0b3JcbiAgcmVxdWVzdDtcbiAgZ3JhcGhxbDtcbiAgbG9nO1xuICBob29rO1xuICAvLyBUT0RPOiB0eXBlIGBvY3Rva2l0LmF1dGhgIGJhc2VkIG9uIHBhc3NlZCBvcHRpb25zLmF1dGhTdHJhdGVneVxuICBhdXRoO1xufVxuZXhwb3J0IHtcbiAgT2N0b2tpdFxufTtcbiIsICJpbXBvcnQgeyBOb3RpY2UgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IENsYXNoU3RhdHVzLCBGaWxlT3BSZWNvcmQsIExvY2FsRmlsZVN0YXR1cywgUmVtb3RlQ2hhbmdlVHlwZSB9IGZyb20gXCIuL2ZpdFR5cGVzXCI7XG5pbXBvcnQgeyBjb25mbGljdFJlc29sdXRpb25Gb2xkZXIgfSBmcm9tIFwiLi9jb25zdFwiO1xuXG50eXBlIFN0YXR1cyA9IFJlbW90ZUNoYW5nZVR5cGUgfCBMb2NhbEZpbGVTdGF0dXNcblxudHlwZSBGaWxlTG9jYXRpb24gPSBcInJlbW90ZVwiIHwgXCJsb2NhbFwiXG5cbnR5cGUgQ29tcGFyaXNvblJlc3VsdDxFbnYgZXh0ZW5kcyBGaWxlTG9jYXRpb24+ID0ge1xuICAgIHBhdGg6IHN0cmluZyxcbiAgICBzdGF0dXM6IEVudiBleHRlbmRzIFwibG9jYWxcIiA/IExvY2FsRmlsZVN0YXR1czogUmVtb3RlQ2hhbmdlVHlwZVxuICAgIGN1cnJlbnRTaGE/OiBzdHJpbmdcbiAgICBleHRlbnNpb24/OiBzdHJpbmdcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVPck51bGwob2JqOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LCBrZXk6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICAgIHJldHVybiBvYmouaGFzT3duUHJvcGVydHkoa2V5KSA/IG9ialtrZXldIDogbnVsbDtcbn1cblxuXG4vLyBjb21wYXJlIGN1cnJlbnRTaGEgd2l0aCBzdG9yZWRTaGEgYW5kIGNoZWNrIGZvciBkaWZmZXJlbmNlcywgZmlsZXMgb25seSBpbiBjdXJyZW50U2hhXG4vLyAgYXJlIGNvbnNpZGVyZCBhZGRlZCwgd2hpbGUgZmlsZXMgb25seSBpbiBzdG9yZWRTaGEgYXJlIGNvbnNpZGVyZWQgcmVtb3ZlZFxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVTaGE8RW52IGV4dGVuZHMgRmlsZUxvY2F0aW9uPihcbiAgICBjdXJyZW50U2hhTWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LFxuICAgIHN0b3JlZFNoYU1hcDogUmVjb3JkPHN0cmluZywgc3RyaW5nPixcbiAgICBlbnY6IEVudik6IENvbXBhcmlzb25SZXN1bHQ8RW52PltdIHtcbiAgICAgICAgY29uc3QgZGV0ZXJtaW5lU3RhdHVzID0gKGN1cnJlbnRTaGE6IHN0cmluZyB8IG51bGwsIHN0b3JlZFNoYTogc3RyaW5nIHwgbnVsbCk6IFN0YXR1cyB8IG51bGwgID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50U2hhICYmIHN0b3JlZFNoYSAmJiBjdXJyZW50U2hhICE9PSBzdG9yZWRTaGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW52ID09PSBcImxvY2FsXCIgPyBcImNoYW5nZWRcIiA6IFwiTU9ESUZJRURcIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFNoYSAmJiAhc3RvcmVkU2hhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudiA9PT0gXCJsb2NhbFwiID8gXCJjcmVhdGVkXCIgOiBcIkFEREVEXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFjdXJyZW50U2hhICYmIHN0b3JlZFNoYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbnYgPT09IFwibG9jYWxcIiA/IFwiZGVsZXRlZFwiIDogXCJSRU1PVkVEXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHsgLi4uY3VycmVudFNoYU1hcCwgLi4uc3RvcmVkU2hhTWFwIH0pLmZsYXRNYXAoKHBhdGgpOiBDb21wYXJpc29uUmVzdWx0PEVudj5bXSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbY3VycmVudFNoYSwgc3RvcmVkU2hhXSA9IFtnZXRWYWx1ZU9yTnVsbChjdXJyZW50U2hhTWFwLCBwYXRoKSwgZ2V0VmFsdWVPck51bGwoc3RvcmVkU2hhTWFwLCBwYXRoKV07XG4gICAgICAgICAgICBjb25zdCBzdGF0dXMgPSBkZXRlcm1pbmVTdGF0dXMoY3VycmVudFNoYSwgc3RvcmVkU2hhKTtcbiAgICAgICAgICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXMgYXMgRW52IGV4dGVuZHMgXCJsb2NhbFwiID8gTG9jYWxGaWxlU3RhdHVzIDogUmVtb3RlQ2hhbmdlVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNoYTogY3VycmVudFNoYSA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbjogZXh0cmFjdEV4dGVuc2lvbihwYXRoKVxuICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9KTtcbn1cblxuZXhwb3J0IGNvbnN0IFJFQ09HTklaRURfVFhUX0VYVCA9IFtcInR4dFwiLCBcIm1kXCJdXG5cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0RXh0ZW5zaW9uKHBhdGg6IHN0cmluZyk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHBhdGgubWF0Y2goL1teLl0rJC8pPy5bMF07XG59XG5cbi8vIFVzaW5nIGZpbGUgZXh0ZW5zaW9uIHRvIGRldGVybWluZSBlbmNvZGluZyBvZiBmaWxlcyAod29ya3MgaW4gbW9zdCBjYXNlcylcbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWxlRW5jb2RpbmcocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBleHRlbnNpb24gPSBwYXRoLm1hdGNoKC9bXi5dKyQvKT8uWzBdO1xuICAgIGNvbnN0IGlzVHh0ID0gZXh0ZW5zaW9uICYmIFJFQ09HTklaRURfVFhUX0VYVC5pbmNsdWRlcyhleHRlbnNpb24pO1xuICAgIGlmIChpc1R4dCkge1xuICAgICAgICByZXR1cm4gXCJ1dGYtOFwiXG4gICAgfVxuICAgIHJldHVybiBcImJhc2U2NFwiXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRFcXVhbDxUPihhcnIxOiBBcnJheTxUPiwgYXJyMjogQXJyYXk8VD4pIHtcbiAgICBjb25zdCBzZXQxID0gbmV3IFNldChhcnIxKTtcbiAgICBjb25zdCBzZXQyID0gbmV3IFNldChhcnIyKTtcbiAgICBjb25zdCBpc0VxdWFsID0gc2V0MS5zaXplID09PSBzZXQyLnNpemUgJiYgWy4uLnNldDFdLmV2ZXJ5KHZhbHVlID0+IHNldDIuaGFzKHZhbHVlKSk7XG4gICAgcmV0dXJuIGlzRXF1YWxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUxpbmVFbmRpbmdzRnJvbUJhc2U2NFN0cmluZyhjb250ZW50OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBjb250ZW50LnJlcGxhY2UoL1xccj9cXG58XFxyfFxcbi9nLCAnJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG93RmlsZU9wc1JlY29yZChyZWNvcmRzOiBBcnJheTx7aGVhZGluZzogc3RyaW5nLCBvcHM6IEZpbGVPcFJlY29yZFtdfT4pOiB2b2lkIHtcbiAgICBpZiAocmVjb3Jkcy5sZW5ndGggPT09IDAgfHwgcmVjb3Jkcy5ldmVyeShyPT5yLm9wcy5sZW5ndGg9PT0wKSkge3JldHVybn1cbiAgICBjb25zdCBmaWxlT3BzTm90aWNlID0gbmV3IE5vdGljZShcIlwiLCAwKVxuICAgIHJlY29yZHMubWFwKHJlY29yZFNldCA9PiB7XG4gICAgICAgIGlmIChyZWNvcmRTZXQub3BzLmxlbmd0aCA9PT0gMCkge3JldHVybn1cbiAgICAgICAgY29uc3QgaGVhZGluZyA9IGZpbGVPcHNOb3RpY2Uubm90aWNlRWwuY3JlYXRlRWwoXCJzcGFuXCIsIHtcbiAgICAgICAgICAgIGNsczogXCJmaWxlLWNoYW5nZXMtaGVhZGluZ1wiXG4gICAgICAgIH0pXG4gICAgICAgIGhlYWRpbmcuc2V0VGV4dChgJHtyZWNvcmRTZXQuaGVhZGluZ31cXG5gKVxuICAgICAgICBjb25zdCBmaWxlQ2hhbmdlcyA9IHtcbiAgICAgICAgICAgIGNyZWF0ZWQ6IFtdIGFzIEFycmF5PHN0cmluZz4sXG4gICAgICAgICAgICBjaGFuZ2VkOiBbXSBhcyBBcnJheTxzdHJpbmc+LFxuICAgICAgICAgICAgZGVsZXRlZDogW10gYXMgQXJyYXk8c3RyaW5nPlxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qgb3Agb2YgcmVjb3JkU2V0Lm9wcykge1xuICAgICAgICAgICAgZmlsZUNoYW5nZXNbb3Auc3RhdHVzXS5wdXNoKG9wLnBhdGgpXG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbY2hhbmdlVHlwZSwgcGF0aHNdIG9mIE9iamVjdC5lbnRyaWVzKGZpbGVDaGFuZ2VzKSkge1xuICAgICAgICAgICAgaWYgKHBhdGhzLmxlbmd0aCA9PT0gMCkge2NvbnRpbnVlfVxuICAgICAgICAgICAgY29uc3QgaGVhZGluZyA9IGZpbGVPcHNOb3RpY2Uubm90aWNlRWwuY3JlYXRlRWwoXCJzcGFuXCIpXG4gICAgICAgICAgICBoZWFkaW5nLnNldFRleHQoYCR7Y2hhbmdlVHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGNoYW5nZVR5cGUuc2xpY2UoMSl9XFxuYClcbiAgICAgICAgICAgIGhlYWRpbmcuYWRkQ2xhc3MoYGZpbGUtY2hhbmdlcy1zdWJoZWFkaW5nYClcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpc3RJdGVtID0gZmlsZU9wc05vdGljZS5ub3RpY2VFbC5jcmVhdGVFbChcImxpXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgY2xzOiBcImZpbGUtdXBkYXRlLXJvd1wiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbGlzdEl0ZW0uc2V0VGV4dChgJHtwYXRofWApO1xuICAgICAgICAgICAgICAgIGxpc3RJdGVtLmFkZENsYXNzKGBmaWxlLSR7Y2hhbmdlVHlwZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG93VW5hcHBsaWVkQ29uZmxpY3RzKGNsYXNoZWRGaWxlczogQXJyYXk8Q2xhc2hTdGF0dXM+KTogdm9pZCB7XG4gICAgaWYgKGNsYXNoZWRGaWxlcy5sZW5ndGggPT09IDApIHtyZXR1cm59XG4gICAgY29uc3QgbG9jYWxTdGF0dXNNYXAgPSB7XG4gICAgICAgIGNyZWF0ZWQ6IFwiY3JlYXRlXCIsXG4gICAgICAgIGNoYW5nZWQ6IFwiY2hhbmdlXCIsXG4gICAgICAgIGRlbGV0ZWQ6IFwiZGVsZXRlXCJcbiAgICB9XG4gICAgY29uc3QgcmVtb3RlU3RhdHVzTWFwID0ge1xuICAgICAgICBBRERFRDogIFwiY3JlYXRlXCIsXG4gICAgICAgIE1PRElGSUVEOiBcImNoYW5nZVwiLFxuICAgICAgICBSRU1PVkVEOiBcImRlbGV0ZVwiXG4gICAgfVxuICAgIGNvbnN0IGNvbmZsaWN0Tm90aWNlID0gbmV3IE5vdGljZShcIlwiLCAwKVxuICAgIGNvbnN0IGhlYWRpbmcgPSBjb25mbGljdE5vdGljZS5ub3RpY2VFbC5jcmVhdGVFbChcInNwYW5cIilcbiAgICBoZWFkaW5nLnNldFRleHQoYENoYW5nZSBjb25mbGljdHM6XFxuYClcbiAgICBoZWFkaW5nLmFkZENsYXNzKGBmaWxlLWNoYW5nZXMtc3ViaGVhZGluZ2ApXG4gICAgY29uc3QgY29uZmxpY3RTdGF0dXMgPSBjb25mbGljdE5vdGljZS5ub3RpY2VFbC5jcmVhdGVEaXYoe1xuICAgICAgICBjbHM6IFwiZmlsZS1jb25mbGljdC1yb3dcIlxuICAgIH0pO1xuICAgIGNvbmZsaWN0U3RhdHVzLmNyZWF0ZURpdigpLnNldFRleHQoXCJMb2NhbFwiKVxuICAgIGNvbmZsaWN0U3RhdHVzLmNyZWF0ZURpdigpLnNldFRleHQoXCJSZW1vdGVcIilcbiAgICBmb3IgKGNvbnN0IGNsYXNoIG9mIGNsYXNoZWRGaWxlcykge1xuICAgICAgICBjb25zdCBjb25mbGljdEl0ZW0gPSBjb25mbGljdE5vdGljZS5ub3RpY2VFbC5jcmVhdGVEaXYoe1xuICAgICAgICAgICAgY2xzOiBcImZpbGUtY29uZmxpY3Qtcm93XCJcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbmZsaWN0SXRlbS5jcmVhdGVEaXYoe1xuICAgICAgICAgICAgY2xzOiBgZmlsZS1jb25mbGljdC0ke2xvY2FsU3RhdHVzTWFwW2NsYXNoLmxvY2FsU3RhdHVzXX1gXG4gICAgICAgIH0pO1xuICAgICAgICBjb25mbGljdEl0ZW0uY3JlYXRlRGl2KFwiZGl2XCIpXG4gICAgICAgICAgICAuc2V0VGV4dChjbGFzaC5wYXRoKTtcbiAgICAgICAgY29uZmxpY3RJdGVtLmNyZWF0ZURpdih7XG4gICAgICAgICAgICBjbHM6IGBmaWxlLWNvbmZsaWN0LSR7cmVtb3RlU3RhdHVzTWFwW2NsYXNoLnJlbW90ZVN0YXR1c119YFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgZm9vdGVyID0gY29uZmxpY3ROb3RpY2Uubm90aWNlRWwuY3JlYXRlRGl2KHtcbiAgICAgICAgY2xzOiBcImZpbGUtY29uZmxpY3Qtcm93XCJcbiAgICB9KVxuICAgIGZvb3Rlci5zZXRUZXh0KFwiTm90ZTpcIilcbiAgICBmb290ZXIuc3R5bGUuZm9udFdlaWdodCA9IFwiYm9sZFwiO1xuICAgIGNvbmZsaWN0Tm90aWNlLm5vdGljZUVsLmNyZWF0ZUVsKFwibGlcIiwge2NsczogXCJmaWxlLWNvbmZsaWN0LW5vdGVcIn0pXG4gICAgICAgIC5zZXRUZXh0KGBSZW1vdGUgY2hhbmdlcyBpbiAke2NvbmZsaWN0UmVzb2x1dGlvbkZvbGRlcn1gKVxuICAgIGNvbmZsaWN0Tm90aWNlLm5vdGljZUVsLmNyZWF0ZUVsKFwibGlcIiwge2NsczogXCJmaWxlLWNvbmZsaWN0LW5vdGVcIn0pXG4gICAgICAgIC5zZXRUZXh0KGAke2NvbmZsaWN0UmVzb2x1dGlvbkZvbGRlcn0gZm9sZGVyIGlzIG92ZXJ3cml0dGVuIG9uIGNvbmZsaWN0LCBjb3B5IG5lZWRlZCBjaGFuZ2VzIG91dHNpZGUgJHtjb25mbGljdFJlc29sdXRpb25Gb2xkZXJ9LmApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3Rpb24oc2V0QTogU2V0PGFueT4sIHNldEI6IFNldDxhbnk+KSB7XG4gICAgcmV0dXJuIG5ldyBTZXQoWy4uLnNldEFdLmZpbHRlcih4ID0+IHNldEIuaGFzKHgpKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWZmZXJlbmNlKHNldEE6IFNldDxhbnk+LCBzZXRCOiBTZXQ8YW55Pikge1xuICAgIHJldHVybiBuZXcgU2V0KFsuLi5zZXRBXS5maWx0ZXIoeCA9PiAhc2V0Qi5oYXMoeCkpKTtcbn1cbiIsICJpbXBvcnQgeyBMb2NhbFN0b3JlcywgUmVwb3NpdG9yeSwgU3luY1NldHRpbmcgfSBmcm9tIFwibWFpblwiXG5pbXBvcnQgeyBPY3Rva2l0IH0gZnJvbSBcIkBvY3Rva2l0L2NvcmVcIlxuaW1wb3J0IHsgUkVDT0dOSVpFRF9UWFRfRVhULCBjb21wYXJlU2hhLCBleHRyYWN0RXh0ZW5zaW9uIH0gZnJvbSBcIi4vdXRpbHNcIlxuaW1wb3J0IHsgVmF1bHRPcGVyYXRpb25zIH0gZnJvbSBcIi4vdmF1bHRPcHNcIlxuaW1wb3J0IHsgTG9jYWxDaGFuZ2UsIExvY2FsRmlsZVN0YXR1cywgUmVtb3RlQ2hhbmdlLCBSZW1vdGVDaGFuZ2VUeXBlIH0gZnJvbSBcIi4vZml0VHlwZXNcIlxuaW1wb3J0IHsgYXJyYXlCdWZmZXJUb0Jhc2U2NCB9IGZyb20gXCJvYnNpZGlhblwiXG5pbXBvcnQgeyBjb25mbGljdFJlc29sdXRpb25Gb2xkZXIgfSBmcm9tIFwiLi9jb25zdFwiXG5cbnR5cGUgQWRkVG9Mb2NhbCA9IHtcbiAgICBwYXRoOiBzdHJpbmc7XG4gICAgY29udGVudDogc3RyaW5nO1xufVxuXG5cbmV4cG9ydCB0eXBlIFRyZWVOb2RlID0ge1xuICAgIHBhdGg6IHN0cmluZyxcbiAgICBtb2RlOiBcIjEwMDY0NFwiIHwgXCIxMDA3NTVcIiB8IFwiMDQwMDAwXCIgfCBcIjE2MDAwMFwiIHwgXCIxMjAwMDBcIiB8IHVuZGVmaW5lZCxcbiAgICB0eXBlOiBcImNvbW1pdFwiIHwgXCJibG9iXCIgfCBcInRyZWVcIiB8IHVuZGVmaW5lZCxcbiAgICBzaGE6IHN0cmluZyB8IG51bGx9XG5cbnR5cGUgT2N0b2tpdENhbGxNZXRob2RzID0ge1xuICAgIC8vIGdldFVzZXI6ICgpID0+IFByb21pc2U8e293bmVyOiBzdHJpbmcsIGF2YXRhclVybDogc3RyaW5nfT5cbiAgICBnZXRSZXBvczogKCkgPT4gUHJvbWlzZTxzdHJpbmdbXT5cbiAgICBnZXRSZWY6IChyZWY6IHN0cmluZykgPT4gUHJvbWlzZTxzdHJpbmc+XG4gICAgZ2V0VHJlZTogKHRyZWVfc2hhOiBzdHJpbmcpID0+IFByb21pc2U8VHJlZU5vZGVbXT5cbiAgICBnZXRDb21taXRUcmVlU2hhOiAocmVmOiBzdHJpbmcpID0+IFByb21pc2U8c3RyaW5nPlxuICAgIGdldFJlbW90ZVRyZWVTaGE6ICh0cmVlX3NoYTogc3RyaW5nKSA9PiBQcm9taXNlPHtbazpzdHJpbmddOiBzdHJpbmd9PlxuICAgIGNyZWF0ZUJsb2I6IChjb250ZW50OiBzdHJpbmcsIGVuY29kaW5nOiBzdHJpbmcpID0+UHJvbWlzZTxzdHJpbmc+XG4gICAgY3JlYXRlVHJlZU5vZGVGcm9tRmlsZTogKHtwYXRoLCBzdGF0dXMsIGV4dGVuc2lvbn06IExvY2FsQ2hhbmdlLCByZW1vdGVUcmVlOiBUcmVlTm9kZVtdKSA9PiBQcm9taXNlPFRyZWVOb2RlfG51bGw+XG4gICAgY3JlYXRlQ29tbWl0OiAodHJlZVNoYTogc3RyaW5nLCBwYXJlbnRTaGE6IHN0cmluZykgPT5Qcm9taXNlPHN0cmluZz5cbiAgICB1cGRhdGVSZWY6IChzaGE6IHN0cmluZywgcmVmOiBzdHJpbmcpID0+IFByb21pc2U8c3RyaW5nPlxuICAgIGdldEJsb2I6IChmaWxlX3NoYTpzdHJpbmcpID0+UHJvbWlzZTxzdHJpbmc+XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUZpdCBleHRlbmRzIE9jdG9raXRDYWxsTWV0aG9kc3tcbiAgICBvd25lcjogc3RyaW5nXG4gICAgcmVwbzogc3RyaW5nXG4gICAgYnJhbmNoOiBzdHJpbmdcbiAgICBoZWFkZXJzOiB7W2s6IHN0cmluZ106IHN0cmluZ31cbiAgICBkZXZpY2VOYW1lOiBzdHJpbmdcbiAgICBsb2NhbFNoYTogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICAgIGxhc3RGZXRjaGVkQ29tbWl0U2hhOiBzdHJpbmcgfCBudWxsXG4gICAgbGFzdEZldGNoZWRSZW1vdGVTaGE6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgICBvY3Rva2l0OiBPY3Rva2l0XG4gICAgdmF1bHRPcHM6IFZhdWx0T3BlcmF0aW9uc1xuICAgIGZpbGVTaGExOiAocGF0aDogc3RyaW5nKSA9PiBQcm9taXNlPHN0cmluZz5cbn1cblxuLy8gRGVmaW5lIGEgY3VzdG9tIEh0dHBFcnJvciBjbGFzcyB0aGF0IGV4dGVuZHMgRXJyb3JcbmV4cG9ydCBjbGFzcyBPY3Rva2l0SHR0cEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIHN0YXR1czogbnVtYmVyO1xuICAgIHNvdXJjZToga2V5b2YgT2N0b2tpdENhbGxNZXRob2RzXG5cbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHN0YXR1czogbnVtYmVyLCBzb3VyY2U6IGtleW9mIE9jdG9raXRDYWxsTWV0aG9kcykge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0h0dHBFcnJvcic7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZVxuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIEZpdCBpbXBsZW1lbnRzIElGaXQge1xuICAgIG93bmVyOiBzdHJpbmdcbiAgICByZXBvOiBzdHJpbmdcbiAgICBhdXRoOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgICBicmFuY2g6IHN0cmluZ1xuICAgIHN5bmNQYXRoOiBzdHJpbmdcbiAgICBoZWFkZXJzOiB7W2s6IHN0cmluZ106IHN0cmluZ31cbiAgICBkZXZpY2VOYW1lOiBzdHJpbmdcbiAgICBsb2NhbFNoYTogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICAgIGxhc3RGZXRjaGVkQ29tbWl0U2hhOiBzdHJpbmcgfCBudWxsXG4gICAgbGFzdEZldGNoZWRSZW1vdGVTaGE6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgICBvY3Rva2l0OiBPY3Rva2l0XG4gICAgdmF1bHRPcHM6IFZhdWx0T3BlcmF0aW9uc1xuICAgIGV4Y2x1ZGVzOiBzdHJpbmdbXVxuXG5cbiAgICBjb25zdHJ1Y3RvcihyZXBvOiBSZXBvc2l0b3J5LCB2YXVsdE9wczogVmF1bHRPcGVyYXRpb25zKSB7XG4gICAgICAgIHRoaXMubG9hZFNldHRpbmdzKHJlcG8pXG4gICAgICAgIHRoaXMudmF1bHRPcHMgPSB2YXVsdE9wc1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSB7XG4gICAgICAgICAgICAvLyBIYWNrIHRvIGRpc2FibGUgY2FjaGluZyB3aGljaCBsZWFkcyB0byBpbmNvbnNpc3RlbmN5IGZvclxuICAgICAgICAgICAgLy8gcmVhZCBhZnRlciB3cml0ZSBodHRwczovL2dpdGh1Yi5jb20vb2N0b2tpdC9vY3Rva2l0LmpzL2lzc3Vlcy84OTBcbiAgICAgICAgICAgIFwiSWYtTm9uZS1NYXRjaFwiOiAnJyxcbiAgICAgICAgICAgICdYLUdpdEh1Yi1BcGktVmVyc2lvbic6ICcyMDIyLTExLTI4J1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbG9hZFNldHRpbmdzKHJlcG86IFJlcG9zaXRvcnkpIHtcbiAgICAgICAgY29uc3Qge3NldHRpbmdzLCBsb2NhbFN0b3JlfSA9IHJlcG9cbiAgICAgICAgdGhpcy5yZXBvID0gc2V0dGluZ3MucmVwb1xuICAgICAgICB0aGlzLm93bmVyID0gc2V0dGluZ3Mub3duZXJcbiAgICAgICAgdGhpcy5icmFuY2ggPSBzZXR0aW5ncy5icmFuY2hcbiAgICAgICAgdGhpcy5leGNsdWRlcyA9IHNldHRpbmdzLmV4Y2x1ZGVzXG4gICAgICAgIHRoaXMuc3luY1BhdGggPSBzZXR0aW5ncy5zeW5jUGF0aFxuICAgICAgICB0aGlzLmRldmljZU5hbWUgPSBzZXR0aW5ncy5kZXZpY2VOYW1lXG5cbiAgICAgICAgdGhpcy5vY3Rva2l0ID0gbmV3IE9jdG9raXQoe2F1dGg6IHNldHRpbmdzLnBhdH0pXG5cbiAgICAgICAgLy8gXHUwNDIyXHUwNDMwXHUwNDNBXHUwNDM2XHUwNDM1IFx1MDQzRFx1MDQ0M1x1MDQzNlx1MDQzRFx1MDQzRSBcdTA0NDFcdTA0M0VcdTA0NDVcdTA0NDBcdTA0MzBcdTA0M0RcdTA0MzhcdTA0NDJcdTA0NEMgXHUwNDM0XHUwNDQwXHUwNDQzXHUwNDMzXHUwNDM4XHUwNDM1IFx1MDQzRlx1MDQzRVx1MDQzQlx1MDQ0RiBcdTA0MzVcdTA0NDFcdTA0M0JcdTA0MzggXHUwNDNFXHUwNDNEXHUwNDM4IFx1MDQzOFx1MDQ0MVx1MDQzRlx1MDQzRVx1MDQzQlx1MDQ0Q1x1MDQzN1x1MDQ0M1x1MDQ0RVx1MDQ0Mlx1MDQ0MVx1MDQ0RiBcdTA0MzIgXHUwNDNBXHUwNDNCXHUwNDMwXHUwNDQxXHUwNDQxXHUwNDM1IEZpdFxuICAgICAgICAvLyB0aGlzLnBhdCA9IHNldHRpbmcucGF0O1xuICAgICAgICAvLyB0aGlzLmF2YXRhclVybCA9IHNldHRpbmcuYXZhdGFyVXJsO1xuICAgICAgICAvLyB0aGlzLnN5bmNQYXRoID0gc2V0dGluZy5zeW5jUGF0aDtcblxuICAgICAgICB0aGlzLmxvY2FsU2hhID0gbG9jYWxTdG9yZS5sb2NhbFNoYVxuICAgICAgICB0aGlzLmxhc3RGZXRjaGVkQ29tbWl0U2hhID0gbG9jYWxTdG9yZS5sYXN0RmV0Y2hlZENvbW1pdFNoYVxuICAgICAgICB0aGlzLmxhc3RGZXRjaGVkUmVtb3RlU2hhID0gbG9jYWxTdG9yZS5sYXN0RmV0Y2hlZFJlbW90ZVNoYVxuICAgIH1cblxuICAgIGFzeW5jIGZpbGVTaGExKGZpbGVDb250ZW50OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBjb25zdCBlbmMgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICAgICAgY29uc3QgaGFzaEJ1ZiA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KCdTSEEtMScsIGVuYy5lbmNvZGUoZmlsZUNvbnRlbnQpKVxuICAgICAgICBjb25zdCBoYXNoQXJyYXkgPSBBcnJheS5mcm9tKG5ldyBVaW50OEFycmF5KGhhc2hCdWYpKTtcbiAgICAgICAgY29uc3QgaGFzaEhleCA9IGhhc2hBcnJheS5tYXAoYiA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKS5qb2luKCcnKTtcbiAgICAgICAgcmV0dXJuIGhhc2hIZXg7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBjb21wdXRlRmlsZUxvY2FsU2hhKHBhdGg6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nfG51bGw+IHtcbiAgICAgICAgY29uc3QgZnVsbFBhdGggPSB0aGlzLnN5bmNQYXRoICsgcGF0aFxuXG4gICAgICAgIC8vIGNvbXB1dGUgc2hhMSBiYXNlZCBvbiBwYXRoIGFuZCBmaWxlIGNvbnRlbnRcbiAgICAgICAgbGV0IGNvbnRlbnQ6IHN0cmluZztcblxuICAgICAgICAvLyBUT0RPIHJlZmFjdG9yXG4gICAgICAgIC8vIE5vdGU6IG9ubHkgc3VwcG9ydCBURmlsZSBub3csIGludmVzdGlnYXRlIG5lZWQgZm9yIHN1cHBvcnRpbmcgVEZvbGRlciBsYXRlciBvblxuICAgICAgICBjb25zdCBmaWxlID0gYXdhaXQgdGhpcy52YXVsdE9wcy5nZXRURmlsZShmdWxsUGF0aClcbiAgICAgICAgaWYgKGZpbGUpIHtcbiAgICAgICAgICAgIGlmIChSRUNPR05JWkVEX1RYVF9FWFQuaW5jbHVkZXMoZmlsZS5leHRlbnNpb24pKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IGF3YWl0IHRoaXMudmF1bHRPcHMudmF1bHQucmVhZChmaWxlKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gYXJyYXlCdWZmZXJUb0Jhc2U2NChhd2FpdCB0aGlzLnZhdWx0T3BzLnZhdWx0LnJlYWRCaW5hcnkoZmlsZSkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBleHRlbnNpb24gPSBleHRyYWN0RXh0ZW5zaW9uKHBhdGgpXG4gICAgICAgICAgICBpZiAoIWV4dGVuc2lvbiB8fCAhUkVDT0dOSVpFRF9UWFRfRVhULmluY2x1ZGVzKGV4dGVuc2lvbikpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gYXJyYXlCdWZmZXJUb0Jhc2U2NChcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy52YXVsdE9wcy52YXVsdC5hZGFwdGVyLnJlYWRCaW5hcnkoZnVsbFBhdGgpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gYXdhaXQgdGhpcy52YXVsdE9wcy52YXVsdC5hZGFwdGVyLnJlYWQoZnVsbFBhdGgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5maWxlU2hhMShwYXRoICsgY29udGVudClcbiAgICB9XG5cbiAgICBhc3luYyBjb21wdXRlTG9jYWxTaGEoKTogUHJvbWlzZTx7W2s6c3RyaW5nXTpzdHJpbmd9PiB7XG4gICAgICAgIGNvbnN0IGFsbFBhdGhzID0gYXdhaXQgdGhpcy52YXVsdE9wcy5nZXRGaWxlc0luVmF1bHQoKVxuICAgICAgICBjb25zdCBwYXRocyA9IFtdXG4gICAgICAgIGZvciAobGV0IHBhdGggb2YgYWxsUGF0aHMpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gXHUwNDNEXHUwNDQzXHUwNDM2XHUwNDNEXHUwNDRCIFx1MDQzQlx1MDQzOCBcdTA0M0NcdTA0M0RcdTA0MzUgXHUwNDREXHUwNDQyXHUwNDM4IFx1MDQ0NFx1MDQzMFx1MDQzOVx1MDQzQlx1MDQ0QiBcdTA0MzIgXHUwNDMxXHUwNDQzXHUwNDM0XHUwNDQzXHUwNDQ5XHUwNDM1XHUwNDNDP1xuICAgICAgICAgICAgbGV0IGlzRXhjbHVkZWQgPSBwYXRoLnN0YXJ0c1dpdGgoY29uZmxpY3RSZXNvbHV0aW9uRm9sZGVyKVxuICAgICAgICAgICAgICAgIHx8ICFwYXRoLnN0YXJ0c1dpdGgodGhpcy5zeW5jUGF0aClcbiAgICAgICAgICAgICAgICB8fCB0aGlzLmV4Y2x1ZGVzLmNvbnRhaW5zKHBhdGgpXG5cbiAgICAgICAgICAgICAgICB8fCB0aGlzLmV4Y2x1ZGVzLnNvbWUoXG4gICAgICAgICAgICAgICAgICAgICAgICBleGNsdWRlID0+IHBhdGguc3RhcnRzV2l0aChleGNsdWRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmICF0aGlzLnN5bmNQYXRoLnN0YXJ0c1dpdGgoZXhjbHVkZSkgLy8gTk9URSBpZiBvbmUgc3luY1BhdGggbmVzdGVkIGluIGFub3RoZXIgc3luY1BhdGhcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcGF0aC5yZXBsYWNlKHRoaXMuc3luY1BhdGgsIFwiXCIpXG5cbiAgICAgICAgICAgIGlmICghaXNFeGNsdWRlZClcbiAgICAgICAgICAgICAgICBwYXRocy5wdXNoKHJlc3VsdClcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhc3luY0NvbXB1dGUgPSBwYXRocy5tYXAoXG4gICAgICAgICAgICBhc3luYyAocGF0aCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNoYSA9IGF3YWl0IHRoaXMuY29tcHV0ZUZpbGVMb2NhbFNoYShwYXRoKVxuICAgICAgICAgICAgICAgIHJldHVybiBbcGF0aCwgc2hhXVxuICAgICAgICAgICAgfVxuICAgICAgICApXG5cbiAgICAgICAgY29uc3QgY29tcHV0ZWQgPSBhd2FpdCBQcm9taXNlLmFsbChhc3luY0NvbXB1dGUpXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbXB1dGVkLmZpbHRlcihlbCA9PiAhIWVsWzFdKVxuXG4gICAgICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMocmVzdWx0KVxuICAgIH1cblxuICAgIGFzeW5jIHJlbW90ZVVwZGF0ZWQoKTogUHJvbWlzZTx7cmVtb3RlQ29tbWl0U2hhOiBzdHJpbmcsIHVwZGF0ZWQ6IGJvb2xlYW59PiB7XG4gICAgICAgIGNvbnN0IHJlbW90ZUNvbW1pdFNoYSA9IGF3YWl0IHRoaXMuZ2V0UmVmKClcbiAgICAgICAgcmV0dXJuIHtyZW1vdGVDb21taXRTaGEsIHVwZGF0ZWQ6IHJlbW90ZUNvbW1pdFNoYSAhPT0gdGhpcy5sYXN0RmV0Y2hlZENvbW1pdFNoYX1cbiAgICB9XG5cbiAgICBhc3luYyBnZXRMb2NhbENoYW5nZXMoY3VycmVudExvY2FsU2hhPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPik6IFByb21pc2U8TG9jYWxDaGFuZ2VbXT4ge1xuICAgICAgICBpZiAoIWN1cnJlbnRMb2NhbFNoYSkge1xuICAgICAgICAgICAgY3VycmVudExvY2FsU2hhID0gYXdhaXQgdGhpcy5jb21wdXRlTG9jYWxTaGEoKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxvY2FsQ2hhbmdlcyA9IGNvbXBhcmVTaGEoY3VycmVudExvY2FsU2hhLCB0aGlzLmxvY2FsU2hhLCBcImxvY2FsXCIpXG4gICAgICAgIHJldHVybiBsb2NhbENoYW5nZXNcbiAgICB9XG5cbiAgICBhc3luYyBnZXRSZW1vdGVDaGFuZ2VzKHJlbW90ZVRyZWVTaGE6IHtbazogc3RyaW5nXTogc3RyaW5nfSk6IFByb21pc2U8UmVtb3RlQ2hhbmdlW10+IHtcbiAgICAgICAgY29uc3QgcmVtb3RlQ2hhbmdlcyA9IGNvbXBhcmVTaGEocmVtb3RlVHJlZVNoYSwgdGhpcy5sYXN0RmV0Y2hlZFJlbW90ZVNoYSwgXCJyZW1vdGVcIilcbiAgICAgICAgcmV0dXJuIHJlbW90ZUNoYW5nZXNcbiAgICB9XG5cbiAgICBnZXRDbGFzaGVkQ2hhbmdlcyhsb2NhbENoYW5nZXM6IExvY2FsQ2hhbmdlW10sIHJlbW90ZUNoYW5nZXM6UmVtb3RlQ2hhbmdlW10pOlxuICAgICAgICBBcnJheTx7cGF0aDogc3RyaW5nLCBsb2NhbFN0YXR1czogTG9jYWxGaWxlU3RhdHVzLCByZW1vdGVTdGF0dXM6IFJlbW90ZUNoYW5nZVR5cGV9PlxuICAgIHtcbiAgICAgICAgLy8gVE9ETyBmZmV6dF9jaGVja2luZyBcdTA0MzdcdTA0MzRcdTA0MzVcdTA0NDFcdTA0NEMgXHUwNDMyXHUwNDQwXHUwNDNFXHUwNDM0XHUwNDM1IFx1MDQzRFx1MDQzNVx1MDQ0MVx1MDQzRVx1MDQzMlx1MDQzQ1x1MDQzNVx1MDQ0MVx1MDQ0Mlx1MDQzOFx1MDQzQ1x1MDQ0Qlx1MDQzNSBcdTA0MzhcdTA0MzdcdTA0M0NcdTA0MzVcdTA0M0RcdTA0MzVcdTA0M0RcdTA0MzhcdTA0NEYgXHUwNDNGXHUwNDNFXHUwNDRGXHUwNDMyXHUwNDNCXHUwNDRGXHUwNDRFXHUwNDQyXHUwNDQxXHUwNDRGXG5cbiAgICAgICAgY29uc3QgbG9jYWxDaGFuZ2VQYXRocyA9IGxvY2FsQ2hhbmdlcy5tYXAoXG4gICAgICAgICAgICBjID0+IGMucGF0aC5yZXBsYWNlKHRoaXMuc3luY1BhdGgsICcnKVxuICAgICAgICApXG4gICAgICAgIGNvbnN0IHJlbW90ZUNoYW5nZVBhdGhzID0gcmVtb3RlQ2hhbmdlcy5tYXAoYz0+Yy5wYXRoKVxuXG4gICAgICAgIGNvbnN0IGNsYXNoZWRGaWxlcyA9IGxvY2FsQ2hhbmdlUGF0aHMubWFwKFxuICAgICAgICAgICAgKHBhdGgsIGxvY2FsSW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZW1vdGVJbmRleCA9IHJlbW90ZUNoYW5nZVBhdGhzLmluZGV4T2YocGF0aClcbiAgICAgICAgICAgICAgICBpZiAocmVtb3RlSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7cGF0aCwgbG9jYWxJbmRleCwgcmVtb3RlSW5kZXh9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgICkuZmlsdGVyKEJvb2xlYW4pIGFzIEFycmF5PHtwYXRoOiBzdHJpbmcsIGxvY2FsSW5kZXg6IG51bWJlciwgcmVtb3RlSW5kZXg6bnVtYmVyfT5cblxuICAgICAgICByZXR1cm4gY2xhc2hlZEZpbGVzLm1hcChcbiAgICAgICAgICAgICh7cGF0aCwgbG9jYWxJbmRleCwgcmVtb3RlSW5kZXh9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTdGF0dXM6IGxvY2FsQ2hhbmdlc1tsb2NhbEluZGV4XS5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZVN0YXR1czogcmVtb3RlQ2hhbmdlc1tyZW1vdGVJbmRleF0uc3RhdHVzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICB9XG5cbiAgICBhc3luYyBnZXRSZXBvcygpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgICAgIGNvbnN0IGFsbFJlcG9zOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBsZXQgcGFnZSA9IDE7XG4gICAgICAgIGNvbnN0IHBlclBhZ2UgPSAxMDA7IC8vIFNldCB0byB0aGUgbWF4aW11bSB2YWx1ZSBvZiAxMDBcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IGhhc01vcmVQYWdlcyA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSAoaGFzTW9yZVBhZ2VzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiByZXNwb25zZSB9ID0gYXdhaXQgdGhpcy5vY3Rva2l0LnJlcXVlc3QoXG4gICAgICAgICAgICAgICAgICAgIGBHRVQgL3VzZXIvcmVwb3NgLCB7XG4gICAgICAgICAgICAgICAgICAgIGFmZmlsaWF0aW9uOiBcIm93bmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgcGVyX3BhZ2U6IHBlclBhZ2UsIC8vIE51bWJlciBvZiByZXBvc2l0b3JpZXMgdG8gaW1wb3J0IHBlciBwYWdlICh1cCB0byAxMDApXG4gICAgICAgICAgICAgICAgICAgIHBhZ2U6IHBhZ2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBhbGxSZXBvcy5wdXNoKC4uLnJlc3BvbnNlLm1hcChyID0+IHIubmFtZSkpO1xuXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHlvdSBoYXZlIHRoZSBmb2xsb3dpbmcgcGFnZXNcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UubGVuZ3RoIDwgcGVyUGFnZSkge1xuICAgICAgICAgICAgICAgICAgICBoYXNNb3JlUGFnZXMgPSBmYWxzZTsgLy8gRXhpdCB3aGVuIHRoZXJlIGFyZSBubyBtb3JlIHJlcG9zaXRvcmllc1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBhZ2UrKzsgLy8gR28gdG8gdGhlIG5leHQgcGFnZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYWxsUmVwb3M7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT2N0b2tpdEh0dHBFcnJvcihlcnJvci5tZXNzYWdlLCBlcnJvci5zdGF0dXMsIFwiZ2V0UmVwb3NcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBnZXRCcmFuY2hlcygpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7ZGF0YTogcmVzcG9uc2V9ID0gYXdhaXQgdGhpcy5vY3Rva2l0LnJlcXVlc3QoXG4gICAgICAgICAgICAgICAgYEdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vYnJhbmNoZXNgLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgb3duZXI6IHRoaXMub3duZXIsXG4gICAgICAgICAgICAgICAgICAgIHJlcG86IHRoaXMucmVwbyxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLm1hcChyID0+IHIubmFtZSlcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPY3Rva2l0SHR0cEVycm9yKGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YXR1cywgXCJnZXRSZXBvc1wiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEdldCB0aGUgc2hhIG9mIHRoZSBsYXRlc3QgY29tbWl0IGluIHRoZSBkZWZhdWx0IGJyYW5jaCAoc2V0IGJ5IHVzZXIgaW4gc2V0dGluZylcbiAgICBhc3luYyBnZXRSZWYocmVmOiBzdHJpbmcgPSBgaGVhZHMvJHt0aGlzLmJyYW5jaH1gKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHtkYXRhOiByZXNwb25zZX0gPSBhd2FpdCB0aGlzLm9jdG9raXQucmVxdWVzdChcbiAgICAgICAgICAgICAgICBgR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9naXQvcmVmL3tyZWZ9YCwge1xuICAgICAgICAgICAgICAgICAgICBvd25lcjogdGhpcy5vd25lcixcbiAgICAgICAgICAgICAgICAgICAgcmVwbzogdGhpcy5yZXBvLFxuICAgICAgICAgICAgICAgICAgICByZWY6IHJlZixcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLm9iamVjdC5zaGFcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPY3Rva2l0SHR0cEVycm9yKGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YXR1cywgXCJnZXRSZWZcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZWYgQ2FuIGJlIGEgY29tbWl0IFNIQSwgYnJhbmNoIG5hbWUgKGhlYWRzL0JSQU5DSF9OQU1FKSwgb3IgdGFnIG5hbWUgKHRhZ3MvVEFHX05BTUUpLFxuICAgIC8vIHJlZmVycyB0byBodHRwczovL2dpdC1zY20uY29tL2Jvb2svZW4vdjIvR2l0LUludGVybmFscy1HaXQtUmVmZXJlbmNlc1xuICAgIGFzeW5jIGdldENvbW1pdFRyZWVTaGEocmVmOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBjb25zdCB7ZGF0YTogY29tbWl0fSA9ICBhd2FpdCB0aGlzLm9jdG9raXQucmVxdWVzdChcbiAgICAgICAgICAgIGBHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2NvbW1pdHMve3JlZn1gLCB7XG4gICAgICAgICAgICBvd25lcjogdGhpcy5vd25lcixcbiAgICAgICAgICAgIHJlcG86IHRoaXMucmVwbyxcbiAgICAgICAgICAgIHJlZixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVyc1xuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gY29tbWl0LmNvbW1pdC50cmVlLnNoYVxuICAgIH1cblxuICAgIGFzeW5jIGdldFRyZWUodHJlZV9zaGE6IHN0cmluZyk6IFByb21pc2U8VHJlZU5vZGVbXT4ge1xuICAgICAgICBjb25zdCB7IGRhdGE6IHRyZWUgfSA9ICBhd2FpdCB0aGlzLm9jdG9raXQucmVxdWVzdChcbiAgICAgICAgICAgIGBHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2dpdC90cmVlcy97dHJlZV9zaGF9YCwge1xuICAgICAgICAgICAgb3duZXI6IHRoaXMub3duZXIsXG4gICAgICAgICAgICByZXBvOiB0aGlzLnJlcG8sXG4gICAgICAgICAgICB0cmVlX3NoYSxcbiAgICAgICAgICAgIHJlY3Vyc2l2ZTogJ3RydWUnLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiB0cmVlLnRyZWUgYXMgVHJlZU5vZGVbXVxuICAgIH1cblxuICAgIC8vIGdldCB0aGUgcmVtb3RlIHRyZWUgc2hhIGluIHRoZSBmb3JtYXQgY29tcGF0aWJsZSB3aXRoIGxvY2FsIHN0b3JlXG4gICAgYXN5bmMgZ2V0UmVtb3RlVHJlZVNoYSh0cmVlX3NoYTogc3RyaW5nKTogUHJvbWlzZTx7W2s6c3RyaW5nXTogc3RyaW5nfT4ge1xuICAgICAgICBjb25zdCByZW1vdGVUcmVlID0gYXdhaXQgdGhpcy5nZXRUcmVlKHRyZWVfc2hhKVxuICAgICAgICBjb25zdCByZW1vdGVTaGEgPSBPYmplY3QuZnJvbUVudHJpZXMocmVtb3RlVHJlZS5tYXAoKG5vZGU6IFRyZWVOb2RlKSA6IFtzdHJpbmcsIHN0cmluZ10gfCBudWxsPT57XG4gICAgICAgICAgICAvLyBjdXJyZW50bHkgaWdub3JpbmcgZGlyZWN0b3J5IGNoYW5nZXMsIGlmIHlvdSdkIGxpa2UgdG8gdXBsb2FkIGEgbmV3IGRpcmVjdG9yeSxcbiAgICAgICAgICAgIC8vIGEgcXVpY2sgaGFjayB3b3VsZCBiZSBjcmVhdGluZyBhbiBlbXB0eSBmaWxlIGluc2lkZVxuICAgICAgICAgICAgaWYgKG5vZGUudHlwZT09XCJibG9iXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUucGF0aCB8fCAhbm9kZS5zaGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGF0aCBvciBzaGEgbm90IGZvdW5kIGZvciBibG9iIG5vZGUgaW4gcmVtb3RlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgY2hhbmdlcyBpbiB0aGUgX2ZpdC8gZGlyZWN0b3J5XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUucGF0aC5zdGFydHNXaXRoKGNvbmZsaWN0UmVzb2x1dGlvbkZvbGRlcikpIHtyZXR1cm4gbnVsbH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW25vZGUucGF0aCwgbm9kZS5zaGFdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9KS5maWx0ZXIoQm9vbGVhbikgYXMgW3N0cmluZywgc3RyaW5nXVtdKVxuICAgICAgICByZXR1cm4gcmVtb3RlU2hhXG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlQmxvYihjb250ZW50OiBzdHJpbmcsIGVuY29kaW5nOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBjb25zdCB7ZGF0YTogYmxvYn0gPSBhd2FpdCB0aGlzLm9jdG9raXQucmVxdWVzdChcbiAgICAgICAgICAgIGBQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9naXQvYmxvYnNgLCB7XG4gICAgICAgICAgICBvd25lcjogdGhpcy5vd25lcixcbiAgICAgICAgICAgIHJlcG86IHRoaXMucmVwbyxcbiAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICBlbmNvZGluZyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVyc1xuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gYmxvYi5zaGFcbiAgICB9XG5cblxuICAgIGFzeW5jIGNyZWF0ZVRyZWVOb2RlRnJvbUZpbGUoe3BhdGgsIHN0YXR1cywgZXh0ZW5zaW9ufTogTG9jYWxDaGFuZ2UsIHJlbW90ZVRyZWU6IEFycmF5PFRyZWVOb2RlPik6IFByb21pc2U8VHJlZU5vZGV8bnVsbD4ge1xuICAgICAgICBpZiAoc3RhdHVzID09PSBcImRlbGV0ZWRcIikge1xuICAgICAgICAgICAgLy8gc2tpcCBjcmVhdGluZyBkZWxldGlvbiBub2RlIGlmIGZpbGUgbm90IGZvdW5kIG9uIHJlbW90ZVxuICAgICAgICAgICAgaWYgKHJlbW90ZVRyZWUuZXZlcnkobm9kZSA9PiBub2RlLnBhdGggIT09IHBhdGgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICBtb2RlOiAnMTAwNjQ0JyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYmxvYicsXG4gICAgICAgICAgICAgICAgc2hhOiBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnVsbFBhdGggPSB0aGlzLnN5bmNQYXRoICsgcGF0aFxuICAgICAgICAvLyBjb25zdCBmaWxlID0gYXdhaXQgdGhpcy52YXVsdE9wcy5nZXRURmlsZSh0aGlzLnN5bmNQYXRoICsgcGF0aClcbiAgICAgICAgLy8gaWYgKCFmaWxlKVxuICAgICAgICAvLyAgICAgcmV0dXJuIG51bGxcblxuICAgICAgICBsZXQgZW5jb2Rpbmc6IHN0cmluZztcbiAgICAgICAgbGV0IGNvbnRlbnQ6IHN0cmluZ1xuICAgICAgICAvLyBUT0RPIGNoZWNrIHdoZXRoZXIgZXZlcnkgZmlsZXMgaW5jbHVkaW5nIG1kIGNhbiBiZSByZWFkIHVzaW5nIHJlYWRCaW5hcnkgdG8gcmVkdWNlIGNvZGUgY29tcGxleGl0eVxuICAgICAgICAvLyBUT0RPIFx1MDQzNVx1MDQ0MVx1MDQ0Mlx1MDQ0QyBcdTA0NDRcdTA0NDNcdTA0M0RcdTA0M0FcdTA0NDZcdTA0MzhcdTA0NEYsIGdldEZpbGVFbmNvZGluZ1xuICAgICAgICBpZiAoZXh0ZW5zaW9uICYmICFSRUNPR05JWkVEX1RYVF9FWFQuaW5jbHVkZXMoZXh0ZW5zaW9uKSkge1xuICAgICAgICAgICAgZW5jb2RpbmcgPSBcImJhc2U2NFwiXG5cbiAgICAgICAgICAgIGNvbnN0IGZpbGVBcnJheUJ1ZiA9IGF3YWl0IHRoaXMudmF1bHRPcHMudmF1bHQuYWRhcHRlci5yZWFkQmluYXJ5KGZ1bGxQYXRoKVxuICAgICAgICAgICAgLy8gY29uc3QgZmlsZUFycmF5QnVmID0gYXdhaXQgdGhpcy52YXVsdE9wcy52YXVsdC5yZWFkQmluYXJ5KGZpbGUpXG4gICAgICAgICAgICBjb25zdCB1aW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZmlsZUFycmF5QnVmKTtcbiAgICAgICAgICAgIGxldCBiaW5hcnlTdHJpbmcgPSAnJztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdWludDhBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGJpbmFyeVN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHVpbnQ4QXJyYXlbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGVudCA9IGJ0b2EoYmluYXJ5U3RyaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVuY29kaW5nID0gJ3V0Zi04J1xuICAgICAgICAgICAgLy8gY29udGVudCA9IGF3YWl0IHRoaXMudmF1bHRPcHMudmF1bHQucmVhZChmaWxlKVxuICAgICAgICAgICAgY29udGVudCA9IGF3YWl0IHRoaXMudmF1bHRPcHMudmF1bHQuYWRhcHRlci5yZWFkKGZ1bGxQYXRoKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2JTaGEgPSBhd2FpdCB0aGlzLmNyZWF0ZUJsb2IoY29udGVudCwgZW5jb2RpbmcpXG4gICAgICAgIC8vIHNraXAgY3JlYXRpbmcgbm9kZSBpZiBmaWxlIGZvdW5kIG9uIHJlbW90ZSBpcyB0aGUgc2FtZSBhcyB0aGUgY3JlYXRlZCBibG9iXG4gICAgICAgIGlmIChyZW1vdGVUcmVlLnNvbWUobm9kZSA9PiBub2RlLnBhdGggPT09IHBhdGggJiYgbm9kZS5zaGEgPT09IGJsb2JTaGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgbW9kZTogJzEwMDY0NCcsXG4gICAgICAgICAgICB0eXBlOiAnYmxvYicsXG4gICAgICAgICAgICBzaGE6IGJsb2JTaGEsXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVUcmVlKFxuICAgICAgICB0cmVlTm9kZXM6IEFycmF5PFRyZWVOb2RlPixcbiAgICAgICAgYmFzZV90cmVlX3NoYTogc3RyaW5nKTpcbiAgICAgICAgUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgICAgIGNvbnN0IHtkYXRhOiBuZXdUcmVlfSA9IGF3YWl0IHRoaXMub2N0b2tpdC5yZXF1ZXN0KFxuICAgICAgICAgICAgICAgIGBQT1NUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9naXQvdHJlZXNgLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgb3duZXI6IHRoaXMub3duZXIsXG4gICAgICAgICAgICAgICAgICAgIHJlcG86IHRoaXMucmVwbyxcbiAgICAgICAgICAgICAgICAgICAgdHJlZTogdHJlZU5vZGVzLFxuICAgICAgICAgICAgICAgICAgICBiYXNlX3RyZWU6IGJhc2VfdHJlZV9zaGEsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVyc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiBuZXdUcmVlLnNoYVxuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZUNvbW1pdCh0cmVlU2hhOiBzdHJpbmcsIHBhcmVudFNoYTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBDb21taXQgZnJvbSAke3RoaXMuZGV2aWNlTmFtZX0gb24gJHtuZXcgRGF0ZSgpLnRvTG9jYWxlU3RyaW5nKCl9YFxuICAgICAgICBjb25zdCB7IGRhdGE6IGNyZWF0ZWRDb21taXQgfSA9IGF3YWl0IHRoaXMub2N0b2tpdC5yZXF1ZXN0KFxuICAgICAgICAgICAgYFBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2dpdC9jb21taXRzYCAsIHtcbiAgICAgICAgICAgIG93bmVyOiB0aGlzLm93bmVyLFxuICAgICAgICAgICAgcmVwbzogdGhpcy5yZXBvLFxuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgIHRyZWU6IHRyZWVTaGEsXG4gICAgICAgICAgICBwYXJlbnRzOiBbcGFyZW50U2hhXSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVyc1xuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gY3JlYXRlZENvbW1pdC5zaGFcbiAgICB9XG5cbiAgICBhc3luYyB1cGRhdGVSZWYoc2hhOiBzdHJpbmcsIHJlZiA9IGBoZWFkcy8ke3RoaXMuYnJhbmNofWApOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBjb25zdCB7IGRhdGE6dXBkYXRlZFJlZiB9ID0gYXdhaXQgdGhpcy5vY3Rva2l0LnJlcXVlc3QoXG4gICAgICAgICAgICBgUEFUQ0ggL3JlcG9zL3tvd25lcn0ve3JlcG99L2dpdC9yZWZzL3tyZWZ9YCwge1xuICAgICAgICAgICAgb3duZXI6IHRoaXMub3duZXIsXG4gICAgICAgICAgICByZXBvOiB0aGlzLnJlcG8sXG4gICAgICAgICAgICByZWYsXG4gICAgICAgICAgICBzaGEsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnNcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIHVwZGF0ZWRSZWYub2JqZWN0LnNoYVxuICAgIH1cblxuICAgIGFzeW5jIGdldEJsb2IoZmlsZV9zaGE6c3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3QgeyBkYXRhOiBibG9iIH0gPSBhd2FpdCB0aGlzLm9jdG9raXQucmVxdWVzdChcbiAgICAgICAgICAgIGBHRVQgL3JlcG9zL3tvd25lcn0ve3JlcG99L2dpdC9ibG9icy97ZmlsZV9zaGF9YCwge1xuICAgICAgICAgICAgb3duZXI6IHRoaXMub3duZXIsXG4gICAgICAgICAgICByZXBvOiB0aGlzLnJlcG8sXG4gICAgICAgICAgICBmaWxlX3NoYSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVyc1xuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gYmxvYi5jb250ZW50XG4gICAgfVxuXG4gICAgZ2V0QWRkVG9Mb2NhbChhZGRUb0xvY2FsXzogQWRkVG9Mb2NhbFtdKTogQWRkVG9Mb2NhbFtdIHtcbiAgICAgICAgY29uc3QgYmFzZXBhdGggPSB0aGlzLnN5bmNQYXRoXG4gICAgICAgIGNvbnN0IGFkZFRvTG9jYWw6IEFkZFRvTG9jYWxbXSA9IHN0cnVjdHVyZWRDbG9uZShhZGRUb0xvY2FsXylcblxuICAgICAgICByZXR1cm4gYWRkVG9Mb2NhbC5tYXAoXG4gICAgICAgICAgICAoe3BhdGgsIGNvbnRlbnR9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogYmFzZXBhdGgrcGF0aCxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgICAuZmlsdGVyKFxuICAgICAgICAgICAgZmlsZSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhjbHVkZXMgPSB0aGlzLmV4Y2x1ZGVzXG4gICAgICAgICAgICAgICAgaWYgKCFleGNsdWRlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4Y2x1ZGVzLnNvbWUoXG4gICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGUgPT4gIWZpbGUucGF0aC5zdGFydHNXaXRoKGV4Y2x1ZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCB0aGlzLnN5bmNQYXRoLnN0YXJ0c1dpdGgoZXhjbHVkZSkgLy8gTk9URSBpZiBvbmUgc3luY1BhdGggbmVzdGVkIGluIGFub3RoZXIgc3luY1BhdGhcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgIClcbiAgICB9XG5cbiAgICBnZXREZWxldGVGcm9tTG9jYWwoZGVsZXRlRnJvbUxvY2FsXzogc3RyaW5nW10pOiBzdHJpbmdbXSB7XG4gICAgICAgIGNvbnN0IGJhc2VwYXRoID0gdGhpcy5zeW5jUGF0aFxuICAgICAgICBjb25zdCBkZWxldGVGcm9tTG9jYWw6IHN0cmluZ1tdID0gc3RydWN0dXJlZENsb25lKGRlbGV0ZUZyb21Mb2NhbF8pXG5cbiAgICAgICAgcmV0dXJuIGRlbGV0ZUZyb21Mb2NhbFxuICAgICAgICAgICAgLm1hcChcbiAgICAgICAgICAgICAgICBwYXRoID0+IGJhc2VwYXRoICsgcGF0aFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLmZpbHRlcihcbiAgICAgICAgICAgICAgICBwYXRoID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhjbHVkZXMgPSB0aGlzLmV4Y2x1ZGVzXG4gICAgICAgICAgICAgICAgICAgIGlmICghZXhjbHVkZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhjbHVkZXMuc29tZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGUgPT4gIXBhdGguc3RhcnRzV2l0aChleGNsdWRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHRoaXMuc3luY1BhdGguc3RhcnRzV2l0aChleGNsdWRlKSAgLy8gTk9URSBpZiBvbmUgc3luY1BhdGggbmVzdGVkIGluIGFub3RoZXIgc3luY1BhdGhcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcbiAgICB9XG5cbn1cbiIsICJpbXBvcnQgeyBOb3RpY2UgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IEZpdCB9IGZyb20gXCIuL2ZpdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaXROb3RpY2Uge1xuICAgIGZpdDogRml0XG4gICAgbXV0ZWQ6IGJvb2xlYW5cbiAgICBub3RpY2U6IG51bGwgfCBOb3RpY2VcbiAgICBjbGFzc2VzOiBBcnJheTxzdHJpbmc+XG5cbiAgICBjb25zdHJ1Y3RvcihhZGRDbGFzc2VzOiBBcnJheTxzdHJpbmc+ID0gW10sIGluaXRpYWxNZXNzYWdlPzogc3RyaW5nLCBkdXJhdGlvbiA9IDAsIG11dGVkID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5tdXRlZCA9IG11dGVkXG4gICAgICAgIHRoaXMuY2xhc3NlcyA9IFsnZml0LW5vdGljZSddXG4gICAgICAgIGlmIChpbml0aWFsTWVzc2FnZSAmJiAhdGhpcy5tdXRlZCkge1xuICAgICAgICAgICAgdGhpcy5zaG93KGluaXRpYWxNZXNzYWdlLCBhZGRDbGFzc2VzLCBkdXJhdGlvbilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NlcyA9IFsuLi50aGlzLmNsYXNzZXMsIC4uLmFkZENsYXNzZXNdXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtdXRlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLm11dGVkID0gdHJ1ZVxuICAgICAgICBpZiAodGhpcy5ub3RpY2UpIHtcbiAgICAgICAgICAgIHRoaXMubm90aWNlLmhpZGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdW5tdXRlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLm11dGVkID0gZmFsc2VcbiAgICB9XG5cbiAgICBzaG93KGluaXRpYWxNZXNzYWdlPzogc3RyaW5nLCBhZGRDbGFzc2VzOiBBcnJheTxzdHJpbmc+ID0gW10sIGR1cmF0aW9uID0gMCk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMubm90aWNlICYmICF0aGlzLm11dGVkKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gKGluaXRpYWxNZXNzYWdlICYmIGluaXRpYWxNZXNzYWdlLmxlbmd0aCA+IDApPyBpbml0aWFsTWVzc2FnZSA6IFwiIFwiXG4gICAgICAgICAgICB0aGlzLm5vdGljZSA9IG5ldyBOb3RpY2UobWVzc2FnZSwgZHVyYXRpb24pXG4gICAgICAgICAgICB0aGlzLm5vdGljZS5ub3RpY2VFbC5hZGRDbGFzc2VzKFsuLi50aGlzLmNsYXNzZXMsIC4uLmFkZENsYXNzZXNdKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlQ2xhc3NlcyhhZGRDbGFzc2VzOiBBcnJheTxzdHJpbmc+ID0gW10sIHJlbW92ZUNsYXNzZXM6IEFycmF5PHN0cmluZz4gPSBbXSk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5tdXRlZCkge3JldHVybn1cbiAgICAgICAgdGhpcy5jbGFzc2VzID0gdGhpcy5jbGFzc2VzLmZpbHRlcihjID0+ICFyZW1vdmVDbGFzc2VzLmluY2x1ZGVzKGMpKVxuICAgICAgICBpZiAodGhpcy5ub3RpY2UpIHtcbiAgICAgICAgICAgIHRoaXMubm90aWNlLm5vdGljZUVsLnJlbW92ZUNsYXNzZXMocmVtb3ZlQ2xhc3NlcylcbiAgICAgICAgICAgIHRoaXMubm90aWNlLm5vdGljZUVsLmFkZENsYXNzZXMoYWRkQ2xhc3NlcylcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsYXNzZXMgPSBbLi4udGhpcy5jbGFzc2VzLCAuLi5hZGRDbGFzc2VzXVxuICAgIH1cblxuICAgIC8vIGFsbG93cyBlcnJvciBkaXNwbGF5IHRvIG92ZXJyaWRlIG11dGVkXG4gICAgc2V0TWVzc2FnZShtZXNzYWdlOiBzdHJpbmcsIGlzRXJyb3I/OiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIGlmIChpc0Vycm9yKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMubm90aWNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpY2UgPSBuZXcgTm90aWNlKG1lc3NhZ2UsIDApXG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpY2Uubm90aWNlRWwuYWRkQ2xhc3NlcyhbJ2ZpdC1ub3RpY2UnLCAnZXJyb3InXSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpY2Uuc2V0TWVzc2FnZShtZXNzYWdlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMubm90aWNlICYmICF0aGlzLm11dGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpY2Uuc2V0TWVzc2FnZShtZXNzYWdlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVtb3ZlKGZpbmFsQ2xhc3M/OiBzdHJpbmcsIGR1cmF0aW9uID0gNTAwMCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5tdXRlZCkge3JldHVybn1cbiAgICAgICAgdGhpcy5ub3RpY2U/Lm5vdGljZUVsLnJlbW92ZUNsYXNzZXModGhpcy5jbGFzc2VzLmZpbHRlcihjID0+IGMgIT09IFwiZml0LW5vdGljZVwiKSlcbiAgICAgICAgaWYgKGZpbmFsQ2xhc3MpIHtcbiAgICAgICAgICAgIHRoaXMubm90aWNlPy5ub3RpY2VFbC5hZGRDbGFzcyhmaW5hbENsYXNzKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ub3RpY2U/Lm5vdGljZUVsLmFkZENsYXNzKFwiZG9uZVwiKVxuICAgICAgICB9XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5ub3RpY2U/LmhpZGUoKSwgZHVyYXRpb24pXG4gICAgfVxuXG59XG4iLCAiaW1wb3J0IEZpdFBsdWdpbiwgeyBERUZBVUxUX1JFUE9TSVRPUlksIFN5bmNTZXR0aW5nLCBERUZBVUxUX0xPQ0FMX1NUT1JFIH0gZnJvbSBcIm1haW5cIjtcbmltcG9ydCB7IEFwcCwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZywgTm90aWNlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBkaWZmZXJlbmNlLCBpbnRlcnNlY3Rpb24sIHNldEVxdWFsIH0gZnJvbSBcIi4vdXRpbHNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRml0U2V0dGluZ1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xuICAgIHBsdWdpbjogRml0UGx1Z2luO1xuICAgIC8vIGF1dGhlbnRpY2F0aW5nOiBib29sZWFuO1xuICAgIGF1dGhVc2VyQXZhdGFyOiBIVE1MRGl2RWxlbWVudDtcbiAgICBhdXRoVXNlckhhbmRsZTogSFRNTFNwYW5FbGVtZW50O1xuICAgIC8vIHBhdFNldHRpbmc6IFNldHRpbmc7XG4gICAgLy8gb3duZXJTZXR0aW5nOiBTZXR0aW5nO1xuICAgIC8vIHJlcG9TZXR0aW5nOiBTZXR0aW5nO1xuICAgIC8vIGJyYW5jaFNldHRpbmc6IFNldHRpbmc7XG4gICAgLy8gc3luY1BhdGhTZXR0aW5nOiBTZXR0aW5nO1xuICAgIC8vIGV4aXN0aW5nUmVwb3M6IEFycmF5PHN0cmluZz47XG4gICAgLy8gZXhpc3RpbmdCcmFuY2hlczogQXJyYXk8c3RyaW5nPjtcbiAgICAvLyByZXBvTGluazogc3RyaW5nO1xuICAgIC8vIHN5bmNQYXRoOiBzdHJpbmc7XG4gICAgY3VycmVudFN5bmNJbmRleDogbnVtYmVyID0gMDtcblxuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IEZpdFBsdWdpbikge1xuICAgICAgICBzdXBlcihhcHAsIHBsdWdpbik7XG4gICAgICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuICAgICAgICAvLyB0aGlzLmN1cnJlbnRTeW5jSW5kZXggPSBwbHVnaW4uc2V0dGluZ3MuY3VycmVudFN5bmNJbmRleCB8fCAwO1xuICAgICAgICAvLyB0aGlzLnJlcG9MaW5rID0gdGhpcy5nZXRMYXRlc3RMaW5rKCk7XG4gICAgICAgIC8vIHRoaXMuYXV0aGVudGljYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gdGhpcy5leGlzdGluZ1JlcG9zID0gW107XG4gICAgICAgIC8vIHRoaXMuZXhpc3RpbmdCcmFuY2hlcyA9IFtdO1xuICAgIH1cblxuICAgIGdldEN1cnJlbnRTeW5jU2V0dGluZygpOiBTeW5jU2V0dGluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLnBsdWdpbi5zdG9yYWdlLnJlcG9bdGhpcy5jdXJyZW50U3luY0luZGV4XS5zZXR0aW5ncztcbiAgICB9XG5cbiAgICBnZXRMYXRlc3RMaW5rID0gKCk6IHN0cmluZyA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTZXR0aW5nID0gdGhpcy5nZXRDdXJyZW50U3luY1NldHRpbmcoKTtcbiAgICAgICAgY29uc3Qge293bmVyLCByZXBvLCBicmFuY2h9ID0gY3VycmVudFNldHRpbmc7XG4gICAgICAgIGlmIChvd25lci5sZW5ndGggPiAwICYmIHJlcG8ubGVuZ3RoID4gMCAmJiBicmFuY2gubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGBodHRwczovL2dpdGh1Yi5jb20vJHtvd25lcn0vJHtyZXBvfS90cmVlLyR7YnJhbmNofWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuXG4gICAgYXN5bmMgZ2l0aHViVXNlckluZm9CbG9jaygpIHtcbiAgICAgICAgY29uc3Qge2NvbnRhaW5lckVsfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTZXR0aW5nID0gdGhpcy5nZXRDdXJyZW50U3luY1NldHRpbmcoKTtcblxuICAgICAgICBjb25zdCB7Zm9sZGVycywgZmlsZXN9ID0gYXdhaXQgdGhpcy5wbHVnaW4udmF1bHRPcHMuZ2V0QWxsSW5WYXVsdCgpXG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpLnNldEhlYWRpbmcoKVxuICAgICAgICAgICAgLnNldE5hbWUoYEdpdEh1YiB1c2VyIGluZm8gKFJlcG9zaXRvcnkgJHt0aGlzLmN1cnJlbnRTeW5jSW5kZXggKyAxfSlgKVxuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ0dpdGh1YiB1c2VybmFtZScpXG4gICAgICAgICAgICAuc2V0RGVzYygnRW50ZXIgeW91ciBuYW1lIG9uIEdpdGh1YicpXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ0dpdEh1YiB1c2VybmFtZScpXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKGN1cnJlbnRTZXR0aW5nLm93bmVyKVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNldHRpbmcub3duZXIgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSkpXG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnR2l0aHViIHBlcnNvbmFsIGFjY2VzcyB0b2tlbicpXG4gICAgICAgICAgICAuc2V0RGVzYygnUmVtZW1iZXIgdG8gZ2l2ZSBpdCBhY2Nlc3MgZm9yIHJlYWRpbmcgYW5kIHdyaXRpbmcgdG8gdGhlIHN0b3JhZ2UgcmVwby4nKVxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdHaXRIdWIgcGVyc29uYWwgYWNjZXNzIHRva2VuJylcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUoY3VycmVudFNldHRpbmcucGF0KVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNldHRpbmcucGF0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgLmFkZEV4dHJhQnV0dG9uKGJ1dHRvbj0+YnV0dG9uXG4gICAgICAgICAgICAgICAgLnNldEljb24oJ2V4dGVybmFsLWxpbmsnKVxuICAgICAgICAgICAgICAgIC5zZXRUb29sdGlwKFwiQ3JlYXRlIGEgdG9rZW5cIilcbiAgICAgICAgICAgICAgICAub25DbGljayhhc3luYyAoKT0+e1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cub3BlbihcImh0dHBzOi8vZ2l0aHViLmNvbS9zZXR0aW5ncy90b2tlbnMvbmV3XCIsICdfYmxhbmsnKTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnRGV2aWNlIG5hbWUnKVxuICAgICAgICAgICAgLnNldERlc2MoJ1NpZ24gY29tbWl0IG1lc3NhZ2Ugd2l0aCB0aGlzIGRldmljZSBuYW1lLicpXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ0RldmljZSBuYW1lJylcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUoY3VycmVudFNldHRpbmcuZGV2aWNlTmFtZSlcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXR0aW5nLmRldmljZU5hbWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4vLyBleHBvcnQgaW50ZXJmYWNlIFN5bmNTZXR0aW5nIHtcbi8vICAgICBwYXQ6IHN0cmluZzsgK1xuLy8gICAgIG93bmVyOiBzdHJpbmc7ICtcbi8vICAgICBhdmF0YXJVcmw6IHN0cmluZztcbi8vICAgICByZXBvOiBzdHJpbmc7ICtcbi8vICAgICBicmFuY2g6IHN0cmluZzsgK1xuLy8gICAgIHN5bmNQYXRoOiBzdHJpbmc7ICtcbi8vICAgICBkZXZpY2VOYW1lOiBzdHJpbmc7ICtcbi8vICAgICBleGNsdWRlczogc3RyaW5nW11cbi8vIH1cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnUmVwb3NpdG9yeSBuYW1lJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdTZWxlY3QgYSByZXBvLicpXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ1JlcG9zaXRvcnknKVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShjdXJyZW50U2V0dGluZy5yZXBvKVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNldHRpbmcucmVwbyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnQnJhbmNoIG5hbWUnKVxuICAgICAgICAgICAgLnNldERlc2MoJ1NlbGVjdCBhIGJyYW5jaC4nKVxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdCcmFuY2gnKVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShjdXJyZW50U2V0dGluZy5icmFuY2gpXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2V0dGluZy5icmFuY2ggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ1N5bmMgcGF0aCcpXG4gICAgICAgICAgICAuc2V0RGVzYygnU2VsZWN0IGEgbG9jYWwgcGF0aCB0byBzeW5jIHdpdGggdGhlIHJlcG8uIElmIHRoZSBmaWVsZCBpcyBlbXB0eSwgdGhlIGVudGlyZSB2YXVsdCB3aWxsIGJlIHN5bmNlZC4nKVxuICAgICAgICAgICAgLmFkZFRleHQoYXN5bmMgKHRleHQpID0+IHtcbiAgICAgICAgICAgICAgICB0ZXh0LnNldFBsYWNlaG9sZGVyKCdFbnRlciBmb2xkZXIgcGF0aCcpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShjdXJyZW50U2V0dGluZy5zeW5jUGF0aCB8fCAnJylcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmb2xkZXJzLmNvbnRhaW5zKHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cblxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFNldHRpbmcuc3luY1BhdGggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFMaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGF0YWxpc3QnKTtcbiAgICAgICAgICAgICAgICBkYXRhTGlzdC5pZCA9IGBmb2xkZXItc3VnZ2VzdGlvbnNgO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb3RoZXJTeW5jUGF0aCA9IG5ldyBTZXQoKVxuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnN0b3JhZ2UucmVwby5mb3JFYWNoKFxuICAgICAgICAgICAgICAgICAgICAoZWwsIGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09IHRoaXMuY3VycmVudFN5bmNJbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cblxuICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJTeW5jUGF0aC5hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwuc2V0dGluZ3Muc3luY1BhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICAgIGNvbnN0IGFsbEZvbGRlcnMgPSBuZXcgU2V0KFxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi52YXVsdE9wcy5nZXRGb2xkZXJzSW5WYXVsdCgpXG4gICAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAgICAgY29uc3QgZm9sZGVycyA9IEFycmF5LmZyb20oXG4gICAgICAgICAgICAgICAgICAgIGRpZmZlcmVuY2UoYWxsRm9sZGVycywgb3RoZXJTeW5jUGF0aClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSBpbiBmb2xkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvbGRlciA9IGZvbGRlcnNbaV1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uLnZhbHVlID0gZm9sZGVyO1xuICAgICAgICAgICAgICAgICAgICBkYXRhTGlzdC5hcHBlbmRDaGlsZChvcHRpb24pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRleHQuaW5wdXRFbC5zZXRBdHRyaWJ1dGUoJ2xpc3QnLCBgZm9sZGVyLXN1Z2dlc3Rpb25zYCk7XG4gICAgICAgICAgICAgICAgdGV4dC5pbnB1dEVsLnBhcmVudEVsZW1lbnQ/LmFwcGVuZENoaWxkKGRhdGFMaXN0KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoXCJWaWV3IHlvdXIgdmF1bHQgb24gR2l0SHViXCIpXG4gICAgICAgICAgICAuYWRkRXh0cmFCdXR0b24oYnV0dG9uID0+IGJ1dHRvblxuICAgICAgICAgICAgICAgIC5zZXRUb29sdGlwKFwiT3BlbiBvbiBHaXRIdWJcIilcbiAgICAgICAgICAgICAgICAuc2V0SWNvbignZXh0ZXJuYWwtbGluaycpXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5rID0gdGhpcy5nZXRMYXRlc3RMaW5rKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYG9wZW5pbmcgJHtsaW5rfWApO1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cub3BlbihsaW5rKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLmRlc2NFbC5hZGRDbGFzcyhcImxpbmstZGVzY1wiKTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdFeGNsdWRlZCBmaWxlcy9mb2xkZXJzJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdGaWxlcyBvciBmb2xkZXJzIHdpdGhpbiBzeW5jIHBhdGggdGhhdCB3aWxsIG5vdCBiZSBzeW5jZWQnKVxuICAgICAgICAgICAgLmFkZEJ1dHRvbihidXR0b24gPT4gYnV0dG9uXG4gICAgICAgICAgICAgICAgLnNldEJ1dHRvblRleHQoJ0FkZCBleGNsdXNpb24nKVxuICAgICAgICAgICAgICAgIC5zZXRDdGEoKVxuICAgICAgICAgICAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50U2V0dGluZy5leGNsdWRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFNldHRpbmcuZXhjbHVkZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2V0dGluZy5leGNsdWRlcy5wdXNoKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheSgpO1xuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICBjb25zdCBhbGxJdGVtcyA9IGF3YWl0IHRoaXMucGx1Z2luLnZhdWx0T3BzLmdldEFsbEluVmF1bHQoKTtcbiAgICAgICAgY29uc3QgYWxsUGF0aHMgPSBbLi4uYWxsSXRlbXMuZm9sZGVycywgLi4uYWxsSXRlbXMuZmlsZXNdO1xuXG4gICAgICAgIGlmIChjdXJyZW50U2V0dGluZy5leGNsdWRlcz8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY3VycmVudFNldHRpbmcuZXhjbHVkZXMuZm9yRWFjaCgoZXhjbHVkZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgICAgICAgICAgLnNldE5hbWUoYEV4Y2x1c2lvbiAke2luZGV4ICsgMX1gKVxuICAgICAgICAgICAgICAgICAgICAvLyAuc2V0RGVzYygnUGF0aCByZWxhdGl2ZSB0byBzeW5jIHBhdGgnKVxuICAgICAgICAgICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQuc2V0UGxhY2Vob2xkZXIoJ3BhdGgvdG8vZXhjbHVkZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKGV4Y2x1ZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZvbGRlcnMuY29udGFpbnModmFsdWUpICYmICFmaWxlcy5jb250YWlucyh2YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2V0dGluZy5leGNsdWRlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBcdTA0MzggXHUwNDM4XHUwNDQxXHUwNDNBXHUwNDNCXHUwNDRFXHUwNDQ3XHUwNDM1XHUwNDNEXHUwNDM4XHUwNDRGIFx1MDQzRFx1MDQzNSBcdTA0MzRcdTA0M0VcdTA0M0JcdTA0MzZcdTA0M0RcdTA0NEIgXHUwNDNGXHUwNDNFXHUwNDMyXHUwNDQyXHUwNDNFXHUwNDQwXHUwNDRGXHUwNDQyXHUwNDRDXHUwNDQxXHUwNDRGLCBcdTA0M0RcdTA0M0UgXHUwNDREXHUwNDQyXHUwNDNFIFx1MDQzRlx1MDQzRVx1MDQ0NFx1MDQzOFx1MDQzM1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gXHUwNDE0XHUwNDNFXHUwNDMxXHUwNDMwXHUwNDMyXHUwNDNCXHUwNDRGXHUwNDM1XHUwNDNDIGRhdGFsaXN0IFx1MDQzNFx1MDQzQlx1MDQ0RiBcdTA0MzBcdTA0MzJcdTA0NDJcdTA0M0VcdTA0MzRcdTA0M0VcdTA0M0ZcdTA0M0VcdTA0M0JcdTA0M0RcdTA0MzVcdTA0M0RcdTA0MzhcdTA0NEZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFMaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGF0YWxpc3QnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFMaXN0LmlkID0gYGV4Y2x1ZGUtc3VnZ2VzdGlvbnMtJHtpbmRleH1gO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBcdTA0MjRcdTA0MzhcdTA0M0JcdTA0NENcdTA0NDJcdTA0NDBcdTA0NDNcdTA0MzVcdTA0M0MgXHUwNDNGXHUwNDQzXHUwNDQyXHUwNDM4OiBcdTA0NDJcdTA0M0VcdTA0M0JcdTA0NENcdTA0M0FcdTA0M0UgXHUwNDQyXHUwNDM1LCBcdTA0M0FcdTA0M0VcdTA0NDJcdTA0M0VcdTA0NDBcdTA0NEJcdTA0MzUgXHUwNDNEXHUwNDMwXHUwNDQ1XHUwNDNFXHUwNDM0XHUwNDRGXHUwNDQyXHUwNDQxXHUwNDRGIFx1MDQzMlx1MDQzRFx1MDQ0M1x1MDQ0Mlx1MDQ0MFx1MDQzOCBzeW5jUGF0aCAoXHUwNDM1XHUwNDQxXHUwNDNCXHUwNDM4IFx1MDQzRVx1MDQzRCBcdTA0MzdcdTA0MzBcdTA0MzRcdTA0MzBcdTA0M0QpXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmlsdGVyZWRQYXRocyA9IGFsbFBhdGhzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTZXR0aW5nLnN5bmNQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWRQYXRocyA9IGFsbFBhdGhzLmZpbHRlcihwYXRoID0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguc3RhcnRzV2l0aChjdXJyZW50U2V0dGluZy5zeW5jUGF0aCArICcvJykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9PT0gY3VycmVudFNldHRpbmcuc3luY1BhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZFBhdGhzLmZvckVhY2gocGF0aCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uLnZhbHVlID0gcGF0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhTGlzdC5hcHBlbmRDaGlsZChvcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQuaW5wdXRFbC5zZXRBdHRyaWJ1dGUoJ2xpc3QnLCBgZXhjbHVkZS1zdWdnZXN0aW9ucy0ke2luZGV4fWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dC5pbnB1dEVsLnBhcmVudEVsZW1lbnQ/LmFwcGVuZENoaWxkKGRhdGFMaXN0KTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmFkZEJ1dHRvbihidXR0b24gPT4gYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0SWNvbigndHJhc2gnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldFRvb2x0aXAoJ1JlbW92ZSB0aGlzIGV4Y2x1c2lvbicpXG4gICAgICAgICAgICAgICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFNldHRpbmcuZXhjbHVkZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXkoKTsgLy8gXHUwNDFGXHUwNDM1XHUwNDQwXHUwNDM1XHUwNDQwXHUwNDM4XHUwNDQxXHUwNDNFXHUwNDMyXHUwNDRCXHUwNDMyXHUwNDMwXHUwNDM1XHUwNDNDIFx1MDQzRlx1MDQzRVx1MDQ0MVx1MDQzQlx1MDQzNSBcdTA0NDNcdTA0MzRcdTA0MzBcdTA0M0JcdTA0MzVcdTA0M0RcdTA0MzhcdTA0NEZcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBhc3luYyBnZXRJdGVtc0luU3luY1BhdGgoKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50U2V0dGluZyA9IHRoaXMuZ2V0Q3VycmVudFN5bmNTZXR0aW5nKCk7XG4gICAgICAgIGlmICghY3VycmVudFNldHRpbmcuc3luY1BhdGgpIHJldHVybiBbXTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc3luY1BhdGggPSBjdXJyZW50U2V0dGluZy5zeW5jUGF0aDtcbiAgICAgICAgICAgIGNvbnN0IGFsbEl0ZW1zOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgICAgICAgICBjb25zdCBhbGwgPSBhd2FpdCB0aGlzLnBsdWdpbi52YXVsdE9wcy5nZXRBbGxJblZhdWx0KClcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmlsZSBpbiBhbGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3luY1BhdGggPT0gXCJcIlxuICAgICAgICAgICAgICAgICAgICB8fCBmaWxlLnN0YXJ0c1dpdGgoc3luY1BhdGggKyAnLycpXG4gICAgICAgICAgICAgICAgICAgIHx8IGZpbGUgPT09IHN5bmNQYXRoKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsSXRlbXMucHVzaChmaWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhbGxJdGVtcy5zb3J0KCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZ2V0dGluZyBpdGVtcyBpbiBzeW5jIHBhdGg6XCIsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxvY2FsQ29uZmlnQmxvY2sgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHtjb250YWluZXJFbH0gPSB0aGlzO1xuICAgICAgICAvLyBjb25zdCBjdXJyZW50U2V0dGluZyA9IHRoaXMuZ2V0Q3VycmVudFN5bmNTZXR0aW5nKCk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpLnNldEhlYWRpbmcoKS5zZXROYW1lKFwiTG9jYWwgY29uZmlndXJhdGlvbnNcIik7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZShcIkF1dG8gc3luY1wiKVxuICAgICAgICAgICAgLnNldERlc2MoYEF1dG9tYXRpY2FsbHkgc3luYyB5b3VyIHZhdWx0IHdoZW4gcmVtb3RlIGhhcyB1cGRhdGVzLiAoTXV0ZWQ6IHN5bmMgaW4gdGhlIGJhY2tncm91bmQgd2l0aG91dCBkaXNwbGF5aW5nIG5vdGljZXMsIGV4Y2VwdCBmb3IgZmlsZSBjaGFuZ2VzIGFuZCBjb25mbGljdHMgbm90aWNlKWApXG4gICAgICAgICAgICAuYWRkRHJvcGRvd24oZHJvcGRvd24gPT4ge1xuICAgICAgICAgICAgICAgIGRyb3Bkb3duXG4gICAgICAgICAgICAgICAgLmFkZE9wdGlvbignb2ZmJywgJ09mZicpXG4gICAgICAgICAgICAgICAgLmFkZE9wdGlvbignbXV0ZWQnLCAnTXV0ZWQnKVxuICAgICAgICAgICAgICAgIC5hZGRPcHRpb24oJ3JlbWluZCcsICdSZW1pbmQgb25seScpXG4gICAgICAgICAgICAgICAgLmFkZE9wdGlvbignb24nLCAnT24nKVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zdG9yYWdlLmF1dG9TeW5jID8gdGhpcy5wbHVnaW4uc3RvcmFnZS5hdXRvU3luYyA6ICdvZmYnKVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc3RvcmFnZS5hdXRvU3luYyA9IHZhbHVlIGFzIFwib2ZmXCIgfCBcIm11dGVkXCIgfCBcInJlbWluZFwiIHwgXCJvblwiO1xuICAgICAgICAgICAgICAgICAgICBjaGVja0ludGVydmFsU2xpZGVyLnNldHRpbmdFbC5hZGRDbGFzcyh2YWx1ZSA9PT0gXCJvZmZcIiA/IFwiY2xlYXJcIiA6IFwicmVzdG9yZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tJbnRlcnZhbFNsaWRlci5zZXR0aW5nRWwucmVtb3ZlQ2xhc3ModmFsdWUgPT09IFwib2ZmXCIgPyBcInJlc3RvcmVcIiA6IFwiY2xlYXJcIik7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIGNvbnN0IGNoZWNrSW50ZXJ2YWxTbGlkZXIgPSBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdBdXRvIGNoZWNrIGludGVydmFsJylcbiAgICAgICAgICAgIC5zZXREZXNjKGBBdXRvbWF0aWNhbGx5IGNoZWNrIGZvciByZW1vdGUgY2hhbmdlcyBpbiB0aGUgYmFja2dyb3VuZCBldmVyeSAke3RoaXMucGx1Z2luLnN0b3JhZ2UuY2hlY2tFdmVyeVhNaW51dGVzfSBtaW51dGVzLmApXG4gICAgICAgICAgICAuYWRkU2xpZGVyKHNsaWRlciA9PiBzbGlkZXJcbiAgICAgICAgICAgICAgICAuc2V0TGltaXRzKDEsIDYwLCAxKVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zdG9yYWdlLmNoZWNrRXZlcnlYTWludXRlcylcbiAgICAgICAgICAgICAgICAuc2V0RHluYW1pY1Rvb2x0aXAoKVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc3RvcmFnZS5jaGVja0V2ZXJ5WE1pbnV0ZXMgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrSW50ZXJ2YWxTbGlkZXIuc2V0RGVzYyhgQXV0b21hdGljYWxseSBjaGVjayBmb3IgcmVtb3RlIGNoYW5nZXMgaW4gdGhlIGJhY2tncm91bmQgZXZlcnkgJHt2YWx1ZX0gbWludXRlcy5gKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApXG5cbiAgICAgICAgaWYgKHRoaXMucGx1Z2luLnN0b3JhZ2UuYXV0b1N5bmMgPT09IFwib2ZmXCIpIHtcbiAgICAgICAgICAgIGNoZWNrSW50ZXJ2YWxTbGlkZXIuc2V0dGluZ0VsLmFkZENsYXNzKFwiY2xlYXJcIilcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5vdGljZUNvbmZpZ0Jsb2NrID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB7Y29udGFpbmVyRWx9ID0gdGhpcztcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRDb2wgPSBcInZhcigtLWludGVyYWN0aXZlLWFjY2VudClcIjtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRUeHRDb2wgPSBcInZhcigtLXRleHQtb24tYWNjZW50KVwiO1xuICAgICAgICBjb25zdCB1bnNlbGVjdGVkQ29sb3IgPSBcInZhcigtLWludGVyYWN0aXZlLW5vcm1hbClcIjtcbiAgICAgICAgY29uc3QgdW5zZWxlY3RlZFR4dENvbCA9IFwidmFyKC0tdGV4dC1ub3JtYWwpXCI7XG4gICAgICAgIGNvbnN0IHN0YXRlVGV4dE1hcCA9IChub3RpZnlDb25mbGljdHM6IGJvb2xlYW4sIG5vdGlmeUNoYW5nZXM6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgICAgIGlmIChub3RpZnlDb25mbGljdHMgJiYgbm90aWZ5Q2hhbmdlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIkRpc3BsYXlpbmcgZmlsZSBjaGFuZ2VzIGFuZCBjb25mbGljdHMgXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFub3RpZnlDb25mbGljdHMgJiYgbm90aWZ5Q2hhbmdlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIkRpc3BsYXlpbmcgZmlsZSBjaGFuZ2VzIFwiO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChub3RpZnlDb25mbGljdHMgJiYgIW5vdGlmeUNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJEaXNwbGF5aW5nIGNoYW5nZSBjb25mbGljdHMgXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIk5vIG5vdGljZSBkaXNwbGF5ZWQgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG5vdGljZURpc3BsYXkgPSBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKFwiTm90aWNlIGRpc3BsYXlcIilcbiAgICAgICAgICAgIC5zZXREZXNjKGAke3N0YXRlVGV4dE1hcCh0aGlzLnBsdWdpbi5zdG9yYWdlLm5vdGlmeUNvbmZsaWN0cywgdGhpcy5wbHVnaW4uc3RvcmFnZS5ub3RpZnlDaGFuZ2VzKX0gYWZ0ZXIgc3luYy5gKVxuICAgICAgICAgICAgLmFkZEJ1dHRvbihidXR0b24gPT4ge1xuICAgICAgICAgICAgICAgIGJ1dHRvbi5zZXRCdXR0b25UZXh0KFwiQ2hhbmdlIGNvbmZsaWN0c1wiKTtcbiAgICAgICAgICAgICAgICBidXR0b24ub25DbGljayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vdGlmeUNvbmZsaWN0cyA9ICF0aGlzLnBsdWdpbi5zdG9yYWdlLm5vdGlmeUNvbmZsaWN0cztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc3RvcmFnZS5ub3RpZnlDb25mbGljdHMgPSBub3RpZnlDb25mbGljdHM7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICBidXR0b24uYnV0dG9uRWwuc2V0Q3NzU3R5bGVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZFwiOiBub3RpZnlDb25mbGljdHMgPyBzZWxlY3RlZENvbCA6IHVuc2VsZWN0ZWRDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiY29sb3JcIjogbm90aWZ5Q29uZmxpY3RzID8gc2VsZWN0ZWRUeHRDb2wgOiB1bnNlbGVjdGVkVHh0Q29sLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgbm90aWNlRGlzcGxheS5zZXREZXNjKGAke3N0YXRlVGV4dE1hcChub3RpZnlDb25mbGljdHMsIHRoaXMucGx1Z2luLnN0b3JhZ2Uubm90aWZ5Q2hhbmdlcyl9IGFmdGVyIHN5bmMuYCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnV0dG9uLmJ1dHRvbkVsLnNldENzc1N0eWxlcyh7XG4gICAgICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZFwiOiB0aGlzLnBsdWdpbi5zdG9yYWdlLm5vdGlmeUNvbmZsaWN0cyA/IHNlbGVjdGVkQ29sIDogdW5zZWxlY3RlZENvbG9yLFxuICAgICAgICAgICAgICAgICAgICBcImNvbG9yXCI6IHRoaXMucGx1Z2luLnN0b3JhZ2Uubm90aWZ5Q29uZmxpY3RzID8gc2VsZWN0ZWRUeHRDb2wgOiB1bnNlbGVjdGVkVHh0Q29sLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5hZGRCdXR0b24oYnV0dG9uID0+IHtcbiAgICAgICAgICAgICAgICBidXR0b24uc2V0QnV0dG9uVGV4dChcIkZpbGUgY2hhbmdlc1wiKTtcbiAgICAgICAgICAgICAgICBidXR0b24ub25DbGljayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vdGlmeUNoYW5nZXMgPSAhdGhpcy5wbHVnaW4uc3RvcmFnZS5ub3RpZnlDaGFuZ2VzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zdG9yYWdlLm5vdGlmeUNoYW5nZXMgPSBub3RpZnlDaGFuZ2VzO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uLmJ1dHRvbkVsLnNldENzc1N0eWxlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImJhY2tncm91bmRcIjogbm90aWZ5Q2hhbmdlcyA/IHNlbGVjdGVkQ29sIDogdW5zZWxlY3RlZENvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJjb2xvclwiOiBub3RpZnlDaGFuZ2VzID8gc2VsZWN0ZWRUeHRDb2wgOiB1bnNlbGVjdGVkVHh0Q29sLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgbm90aWNlRGlzcGxheS5zZXREZXNjKGAke3N0YXRlVGV4dE1hcCh0aGlzLnBsdWdpbi5zdG9yYWdlLm5vdGlmeUNvbmZsaWN0cywgbm90aWZ5Q2hhbmdlcyl9IGFmdGVyIHN5bmMuYCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnV0dG9uLmJ1dHRvbkVsLnNldENzc1N0eWxlcyh7XG4gICAgICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZFwiOiB0aGlzLnBsdWdpbi5zdG9yYWdlLm5vdGlmeUNoYW5nZXMgPyBzZWxlY3RlZENvbCA6IHVuc2VsZWN0ZWRDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgXCJjb2xvclwiOiB0aGlzLnBsdWdpbi5zdG9yYWdlLm5vdGlmeUNoYW5nZXMgPyBzZWxlY3RlZFR4dENvbCA6IHVuc2VsZWN0ZWRUeHRDb2wsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjb3VudGVyUmVwb0Jsb2NrID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB7Y29udGFpbmVyRWx9ID0gdGhpcztcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdNYW5hZ2UgcmVwb3NpdG9yaWVzJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdBZGQgb3IgcmVtb3ZlIHJlcG9zaXRvcnkgY29uZmlndXJhdGlvbnMnKVxuICAgICAgICAgICAgLmFkZEJ1dHRvbihidXR0b24gPT4gYnV0dG9uXG4gICAgICAgICAgICAgICAgLnNldEJ1dHRvblRleHQoJ0FkZCBSZXBvc2l0b3J5JylcbiAgICAgICAgICAgICAgICAuc2V0Q3RhKClcbiAgICAgICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnN0b3JhZ2UucmVwby5wdXNoKERFRkFVTFRfUkVQT1NJVE9SWSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXkoKTtcbiAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIC5hZGRCdXR0b24oYnV0dG9uID0+IGJ1dHRvblxuICAgICAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KCdSZW1vdmUgUmVwb3NpdG9yeScpXG4gICAgICAgICAgICAgICAgLnNldFdhcm5pbmcoKVxuICAgICAgICAgICAgICAgIC5zZXREaXNhYmxlZCh0aGlzLnBsdWdpbi5zdG9yYWdlLnJlcG8ubGVuZ3RoIDw9IDEpXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wbHVnaW4uc3RvcmFnZS5yZXBvLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnN0b3JhZ2UucmVwby5zcGxpY2UodGhpcy5jdXJyZW50U3luY0luZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRTeW5jSW5kZXggPj0gdGhpcy5wbHVnaW4uc3RvcmFnZS5yZXBvLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFN5bmNJbmRleCA9IHRoaXMucGx1Z2luLnN0b3JhZ2UucmVwby5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdDdXJyZW50IHJlcG9zaXRvcnknKVxuICAgICAgICAgICAgLnNldERlc2MoJ1NlbGVjdCB3aGljaCByZXBvc2l0b3J5IGNvbmZpZ3VyYXRpb24gdG8gZWRpdCcpXG4gICAgICAgICAgICAuYWRkRHJvcGRvd24oZHJvcGRvd24gPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnN0b3JhZ2UucmVwby5mb3JFYWNoKChfLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBkcm9wZG93bi5hZGRPcHRpb24oaW5kZXgudG9TdHJpbmcoKSwgYFJlcG9zaXRvcnkgJHtpbmRleCArIDF9YCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZHJvcGRvd24uc2V0VmFsdWUodGhpcy5jdXJyZW50U3luY0luZGV4LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIGRyb3Bkb3duLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTeW5jSW5kZXggPSBwYXJzZUludCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXkoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlc2V0QmxvY2sgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHtjb250YWluZXJFbH0gPSB0aGlzO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ1Jlc2V0IHNldHRpbmdzJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdSZW1vdmUgU3luYyBzdG9yYWdlIG9yIFNldHRpbmdzJylcbiAgICAgICAgICAgIC5hZGRCdXR0b24oYnV0dG9uID0+IGJ1dHRvblxuICAgICAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KCdSZXNldCBzdG9yYWdlJylcbiAgICAgICAgICAgICAgICAuc2V0V2FybmluZygpXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBzdG9yYWdlIG9mIHRoaXMucGx1Z2luLnN0b3JhZ2UucmVwbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmFnZS5sb2NhbFN0b3JlID0gREVGQVVMVF9MT0NBTF9TVE9SRVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gYWRkIG5vdGljZShcIkRvbmVcIilcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheSgpO1xuICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgLmFkZEJ1dHRvbihidXR0b24gPT4gYnV0dG9uXG4gICAgICAgICAgICAgICAgLnNldEJ1dHRvblRleHQoJ1Jlc2V0IFNldHRpbmdzJylcbiAgICAgICAgICAgICAgICAuc2V0V2FybmluZygpXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zdG9yYWdlLnJlcG8gPSBbREVGQVVMVF9SRVBPU0lUT1JZXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBhZGQgbm90aWNlKFwiRG9uZVwiKVxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5KCk7XG4gICAgICAgICAgICAgICAgfSkpXG5cbiAgICB9XG5cbiAgICBpbXBvcnRFeHBvcnQoKSB7XG4gICAgICAgIGNvbnN0IHtjb250YWluZXJFbH0gPSB0aGlzO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ0ltcG9ydC9FeHBvcnQgc2V0dGluZ3MnKVxuICAgICAgICAgICAgLnNldERlc2MoJ0JhY2t1cCBvciByZXN0b3JlIHlvdXIgcGx1Z2luIGNvbmZpZ3VyYXRpb24nKVxuICAgICAgICAgICAgLnNldEhlYWRpbmcoKTtcblxuICAgICAgICAvLyBcdTA0MjJcdTA0MzVcdTA0M0FcdTA0NDFcdTA0NDJcdTA0M0VcdTA0MzJcdTA0M0VcdTA0MzUgXHUwNDNGXHUwNDNFXHUwNDNCXHUwNDM1IFx1MDQzNFx1MDQzQlx1MDQ0RiBcdTA0M0VcdTA0NDJcdTA0M0VcdTA0MzFcdTA0NDBcdTA0MzBcdTA0MzZcdTA0MzVcdTA0M0RcdTA0MzhcdTA0NEYvXHUwNDMyXHUwNDMyXHUwNDNFXHUwNDM0XHUwNDMwIFx1MDQzQVx1MDQzRVx1MDQzRFx1MDQ0NFx1MDQzOFx1MDQzM1x1MDQ0M1x1MDQ0MFx1MDQzMFx1MDQ0Nlx1MDQzOFx1MDQzOFxuICAgICAgICBjb25zdCB0ZXh0QXJlYUNvbnRhaW5lciA9IGNvbnRhaW5lckVsLmNyZWF0ZURpdignaW1wb3J0LWV4cG9ydC1jb250YWluZXInKTtcbiAgICAgICAgY29uc3QgdGV4dEFyZWEgPSB0ZXh0QXJlYUNvbnRhaW5lci5jcmVhdGVFbCgndGV4dGFyZWEnLCB7XG4gICAgICAgICAgICBhdHRyOiB7XG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICdDb25maWd1cmF0aW9uIEpTT04gd2lsbCBhcHBlYXIgaGVyZS4uLicsXG4gICAgICAgICAgICAgICAgcm93czogJzEwJyxcbiAgICAgICAgICAgICAgICBzdHlsZTogJ3dpZHRoOiAxMDAlOyBmb250LWZhbWlseTogbW9ub3NwYWNlOydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbHM6ICdpbXBvcnQtZXhwb3J0LXRleHRhcmVhJ1xuICAgICAgICB9KTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5hZGRCdXR0b24oYnV0dG9uID0+IGJ1dHRvblxuICAgICAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KCdFeHBvcnQgdG8gVGV4dCBGaWVsZCcpXG4gICAgICAgICAgICAgICAgLnNldEN0YSgpXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cG9ydFRvVGV4dEZpZWxkKHRleHRBcmVhKTtcbiAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIC5hZGRCdXR0b24oYnV0dG9uID0+IGJ1dHRvblxuICAgICAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KCdJbXBvcnQgZnJvbSBUZXh0IEZpZWxkJylcbiAgICAgICAgICAgICAgICAuc2V0V2FybmluZygpXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmltcG9ydEZyb21UZXh0RmllbGQodGV4dEFyZWEpO1xuICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgLmFkZEJ1dHRvbihidXR0b24gPT4gYnV0dG9uXG4gICAgICAgICAgICAgICAgLnNldEJ1dHRvblRleHQoJ0NsZWFyIEZpZWxkJylcbiAgICAgICAgICAgICAgICAuc2V0SWNvbigndHJhc2gnKVxuICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dEFyZWEudmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBleHBvcnRUb1RleHRGaWVsZCh0ZXh0QXJlYTogSFRNTFRleHRBcmVhRWxlbWVudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0OiBhbnkgPSBzdHJ1Y3R1cmVkQ2xvbmUodGhpcy5wbHVnaW4uc3RvcmFnZSlcbiAgICAgICAgICAgIGZvcihsZXQgaSBpbiByZXN1bHQucmVwbykge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN1bHQucmVwb1tpXS5sb2NhbFN0b3JlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzSnNvbiA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdCwgbnVsbCwgNCk7XG5cbiAgICAgICAgICAgIHRleHRBcmVhLnZhbHVlID0gc2V0dGluZ3NKc29uO1xuICAgICAgICAgICAgdGV4dEFyZWEuZm9jdXMoKTtcbiAgICAgICAgICAgIHRleHRBcmVhLnNlbGVjdCgpO1xuXG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBleHBvcnRpbmcgc2V0dGluZ3M6JywgZXJyb3IpO1xuICAgICAgICAgICAgbmV3IE5vdGljZSgnRXJyb3IgZXhwb3J0aW5nIGNvbmZpZ3VyYXRpb24nLCAzMDAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgaW1wb3J0RnJvbVRleHRGaWVsZCh0ZXh0QXJlYTogSFRNTFRleHRBcmVhRWxlbWVudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QganNvbkNvbnRlbnQgPSB0ZXh0QXJlYS52YWx1ZS50cmltKCk7XG5cbiAgICAgICAgICAgIGlmICghanNvbkNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdUZXh0IGZpZWxkIGlzIGVtcHR5JywgMzAwMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBpbXBvcnRlZFNldHRpbmdzID0gSlNPTi5wYXJzZShqc29uQ29udGVudCk7XG5cbiAgICAgICAgICAgIC8vIFx1MDQxMlx1MDQzMFx1MDQzQlx1MDQzOFx1MDQzNFx1MDQzMFx1MDQ0Nlx1MDQzOFx1MDQ0RiBcdTA0MzhcdTA0M0NcdTA0M0ZcdTA0M0VcdTA0NDBcdTA0NDJcdTA0MzhcdTA0NDBcdTA0M0VcdTA0MzJcdTA0MzBcdTA0M0RcdTA0M0RcdTA0NEJcdTA0NDUgXHUwNDNEXHUwNDMwXHUwNDQxXHUwNDQyXHUwNDQwXHUwNDNFXHUwNDM1XHUwNDNBXG4gICAgICAgICAgICBpZiAodGhpcy52YWxpZGF0ZUltcG9ydGVkU2V0dGluZ3MoaW1wb3J0ZWRTZXR0aW5ncykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCByZXBvIG9mIGltcG9ydGVkU2V0dGluZ3MucmVwbykge1xuICAgICAgICAgICAgICAgICAgICByZXBvLmxvY2FsU3RvcmUgPSBERUZBVUxUX0xPQ0FMX1NUT1JFXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc3RvcmFnZSA9IGltcG9ydGVkU2V0dGluZ3NcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblxuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ1NldHRpbmdzIGltcG9ydGVkIHN1Y2Nlc3NmdWxseSEnLCAzMDAwKTtcblxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZGlzcGxheSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdJbnZhbGlkIHNldHRpbmdzIGZvcm1hdCBpbiB0ZXh0IGZpZWxkJywgNDAwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbXBvcnRpbmcgc2V0dGluZ3MgZnJvbSB0ZXh0IGZpZWxkOicsIGVycm9yKTtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ0Vycm9yIHBhcnNpbmcgSlNPTiBjb25maWd1cmF0aW9uJywgNDAwMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHZhbGlkYXRlSW1wb3J0ZWRTZXR0aW5ncyhzZXR0aW5nczogYW55KTogYm9vbGVhbiB7XG4gICAgICAgIC8vIEJhc2ljIHZhbGlkYXRpb25cbiAgICAgICAgcmV0dXJuIHNldHRpbmdzICYmXG4gICAgICAgICAgICB0eXBlb2Ygc2V0dGluZ3MgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHNldHRpbmdzLnJlcG8pICYmXG4gICAgICAgICAgICBzZXR0aW5ncy5yZXBvLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIHNldHRpbmdzLnJlcG9bMF0uc2V0dGluZ3MgJiZcbiAgICAgICAgICAgIHR5cGVvZiBzZXR0aW5ncy5yZXBvWzBdLnNldHRpbmdzID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgJ3N5bmNQYXRoJyBpbiBzZXR0aW5ncy5yZXBvWzBdLnNldHRpbmdzO1xuICAgIH1cblxuICAgIGFzeW5jIGRpc3BsYXkoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IHtjb250YWluZXJFbH0gPSB0aGlzO1xuXG4gICAgICAgIGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cblxuICAgICAgICB0aGlzLmxvY2FsQ29uZmlnQmxvY2soKTtcbiAgICAgICAgdGhpcy5ub3RpY2VDb25maWdCbG9jaygpO1xuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbCgnaHInKTtcblxuICAgICAgICBhd2FpdCB0aGlzLmltcG9ydEV4cG9ydCgpXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdocicpO1xuXG4gICAgICAgIHRoaXMuY291bnRlclJlcG9CbG9jaygpO1xuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbCgnaHInKTtcblxuICAgICAgICAvLyBUT0RPIFx1MDQzRFx1MDQzMFx1MDQzRlx1MDQzOFx1MDQ0MVx1MDQzMFx1MDQ0Mlx1MDQ0QywgXHUwNDQ3XHUwNDQyXHUwNDNFIFx1MDQ0Mlx1MDQ0M1x1MDQ0MiBcdTA0MzRcdTA0M0JcdTA0NEYgYWxsU2V0dGluZ3MsIFx1MDQzMCBcdTA0M0RcdTA0MzUgXHUwNDNFXHUwNDQyXHUwNDM0XHUwNDM1XHUwNDNCXHUwNDRDXHUwNDNEXHUwNDRCXHUwNDM5IFx1MDQ0MFx1MDQzNVx1MDQzRlx1MDQzRVx1MDQzN1x1MDQzOFx1MDQ0Mlx1MDQzRVx1MDQ0MFx1MDQzOFx1MDQzOVxuICAgICAgICAvLyBUT0RPIGFkZCBwcnVuZSBzZXR0aW5ncyBleGFjdGx5IGZvciBvbmUgcmVwb1xuICAgICAgICB0aGlzLnJlc2V0QmxvY2soKVxuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbCgnaHInKTtcblxuICAgICAgICBhd2FpdCB0aGlzLmdpdGh1YlVzZXJJbmZvQmxvY2soKTtcbiAgICB9XG59XG5cbi8vIGNsYXNzIEZvbGRlclN1Z2dlc3RNb2RhbCBleHRlbmRzIFN1Z2dlc3RNb2RhbDxzdHJpbmc+IHtcbi8vICAgICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcHJpdmF0ZSBmb2xkZXJzOiBzdHJpbmdbXSwgcHJpdmF0ZSBjYWxsYmFjazogKGZvbGRlcjogc3RyaW5nKSA9PiB2b2lkKSB7XG4vLyAgICAgICAgIHN1cGVyKGFwcCk7XG4vLyAgICAgfVxuXG4vLyAgICAgZ2V0U3VnZ2VzdGlvbnMocXVlcnk6IHN0cmluZyk6IHN0cmluZ1tdIHtcbi8vICAgICAgICAgcmV0dXJuIHRoaXMuZm9sZGVycy5maWx0ZXIoZm9sZGVyID0+XG4vLyAgICAgICAgICAgICBmb2xkZXIudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhxdWVyeS50b0xvd2VyQ2FzZSgpKVxuLy8gICAgICAgICApO1xuLy8gICAgIH1cblxuLy8gICAgIHJlbmRlclN1Z2dlc3Rpb24oZm9sZGVyOiBzdHJpbmcsIGVsOiBIVE1MRWxlbWVudCkge1xuLy8gICAgICAgICBlbC5jcmVhdGVFbCgnZGl2JywgeyB0ZXh0OiBmb2xkZXIgfSk7XG4vLyAgICAgfVxuXG4vLyAgICAgb25DaG9vc2VTdWdnZXN0aW9uKGZvbGRlcjogc3RyaW5nLCBldnQ6IE1vdXNlRXZlbnQgfCBLZXlib2FyZEV2ZW50KSB7XG4vLyAgICAgICAgIHRoaXMuY2FsbGJhY2soZm9sZGVyKTtcbi8vICAgICB9XG4vLyB9XG4iLCAiaW1wb3J0IHsgYXJyYXlCdWZmZXJUb0Jhc2U2NCB9IGZyb20gXCJvYnNpZGlhblwiXG5pbXBvcnQgeyBGaXQgfSBmcm9tIFwiLi9maXRcIlxuaW1wb3J0IHsgQ2xhc2hTdGF0dXMsIENvbmZsaWN0UmVwb3J0LCBDb25mbGljdFJlc29sdXRpb25SZXN1bHQsIEZpbGVPcFJlY29yZCwgTG9jYWxDaGFuZ2UsIExvY2FsVXBkYXRlLCBSZW1vdGVDaGFuZ2UsIFJlbW90ZVVwZGF0ZSB9IGZyb20gXCIuL2ZpdFR5cGVzXCJcbmltcG9ydCB7IFJFQ09HTklaRURfVFhUX0VYVCwgZXh0cmFjdEV4dGVuc2lvbiwgcmVtb3ZlTGluZUVuZGluZ3NGcm9tQmFzZTY0U3RyaW5nIH0gZnJvbSBcIi4vdXRpbHNcIlxuaW1wb3J0IHsgRml0UHVsbCB9IGZyb20gXCIuL2ZpdFB1bGxcIlxuaW1wb3J0IHsgRml0UHVzaCB9IGZyb20gXCIuL2ZpdFB1c2hcIlxuaW1wb3J0IHsgVmF1bHRPcGVyYXRpb25zIH0gZnJvbSBcIi4vdmF1bHRPcHNcIlxuaW1wb3J0IHsgTG9jYWxTdG9yZXMgfSBmcm9tIFwibWFpblwiXG5pbXBvcnQgRml0Tm90aWNlIGZyb20gXCIuL2ZpdE5vdGljZVwiXG5pbXBvcnQgeyBjb25mbGljdFJlc29sdXRpb25Gb2xkZXIgfSBmcm9tIFwiLi9jb25zdFwiXG5cbmV4cG9ydCBpbnRlcmZhY2UgSUZpdFN5bmMge1xuICAgIGZpdDogRml0XG59XG5cbmV4cG9ydCB0eXBlIFJlc29sdmVDb25mbGljdCA9IHtcbiAgICBub0NvbmZsaWN0OiBib29sZWFuLFxuICAgIHVucmVzb2x2ZWRGaWxlczogQ2xhc2hTdGF0dXNbXSxcbiAgICBmaWxlT3BzUmVjb3JkOiBGaWxlT3BSZWNvcmRbXSxcbiAgICAvLyBkaWZmOiBhbnlcbn1cblxudHlwZSBQcmVTeW5jQ2hlY2tSZXN1bHQgPSAge1xuICAgIHN0YXR1czogXCJpblN5bmNcIlxufSB8IHtcbiAgICBzdGF0dXM6IEV4Y2x1ZGU8UHJlU3luY0NoZWNrUmVzdWx0VHlwZSwgXCJpblN5bmNcIj5cbiAgICByZW1vdGVVcGRhdGU6IFJlbW90ZVVwZGF0ZVxuICAgIGxvY2FsQ2hhbmdlczogTG9jYWxDaGFuZ2VbXVxuICAgIGxvY2FsVHJlZVNoYTogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxufVxuXG50eXBlIFByZVN5bmNDaGVja1Jlc3VsdFR5cGUgPSAoXG4gICAgXCJpblN5bmNcIiB8XG4gICAgXCJvbmx5TG9jYWxDaGFuZ2VkXCIgfFxuICAgIFwib25seVJlbW90ZUNoYW5nZWRcIiB8XG4gICAgXCJvbmx5UmVtb3RlQ29tbWl0U2hhQ2hhbmdlZFwiIHxcbiAgICBcImxvY2FsQW5kUmVtb3RlQ2hhbmdlc0NvbXBhdGlibGVcIiB8XG4gICAgXCJsb2NhbEFuZFJlbW90ZUNoYW5nZXNDbGFzaGVkXCJcbilcblxuZXhwb3J0IGNsYXNzIEZpdFN5bmMgaW1wbGVtZW50cyBJRml0U3luYyB7XG4gICAgZml0OiBGaXRcbiAgICBmaXRQdWxsOiBGaXRQdWxsXG4gICAgZml0UHVzaDogRml0UHVzaFxuICAgIHZhdWx0T3BzOiBWYXVsdE9wZXJhdGlvbnNcbiAgICBzYXZlTG9jYWxTdG9yZUNhbGxiYWNrOiAocGF0aDogc3RyaW5nLCBsb2NhbFN0b3JlOiBQYXJ0aWFsPExvY2FsU3RvcmVzPikgPT4gUHJvbWlzZTx2b2lkPlxuXG5cbiAgICBjb25zdHJ1Y3RvcihmaXQ6IEZpdCxcbiAgICAgICAgdmF1bHRPcHM6IFZhdWx0T3BlcmF0aW9ucyxcbiAgICAgICAgc2F2ZUxvY2FsU3RvcmVDYWxsYmFjazogKHBhdGg6IHN0cmluZywgbG9jYWxTdG9yZTogUGFydGlhbDxMb2NhbFN0b3Jlcz4pXG4gICAgICAgICAgICA9PiBQcm9taXNlPHZvaWQ+KVxuICAgIHtcbiAgICAgICAgdGhpcy5maXQgPSBmaXRcbiAgICAgICAgdGhpcy5maXRQdWxsID0gbmV3IEZpdFB1bGwoZml0KVxuICAgICAgICB0aGlzLmZpdFB1c2ggPSBuZXcgRml0UHVzaChmaXQpXG4gICAgICAgIHRoaXMudmF1bHRPcHMgPSB2YXVsdE9wc1xuICAgICAgICB0aGlzLnNhdmVMb2NhbFN0b3JlQ2FsbGJhY2sgPSBzYXZlTG9jYWxTdG9yZUNhbGxiYWNrXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBwZXJmb3JtUHJlU3luY0NoZWNrcygpOiBQcm9taXNlPFByZVN5bmNDaGVja1Jlc3VsdD4ge1xuICAgICAgICBjb25zdCBjdXJyZW50TG9jYWxTaGEgPSBhd2FpdCB0aGlzLmZpdC5jb21wdXRlTG9jYWxTaGEoKVxuICAgICAgICBjb25zdCBsb2NhbENoYW5nZXMgPSBhd2FpdCB0aGlzLmZpdC5nZXRMb2NhbENoYW5nZXMoY3VycmVudExvY2FsU2hhKVxuICAgICAgICBjb25zdCB7cmVtb3RlQ29tbWl0U2hhLCB1cGRhdGVkOiByZW1vdGVVcGRhdGVkfSA9IGF3YWl0IHRoaXMuZml0LnJlbW90ZVVwZGF0ZWQoKTtcbiAgICAgICAgaWYgKGxvY2FsQ2hhbmdlcy5sZW5ndGggPT09IDAgJiYgIXJlbW90ZVVwZGF0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7c3RhdHVzOiBcImluU3luY1wifVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVtb3RlVHJlZVNoYSA9IGF3YWl0IHRoaXMuZml0LmdldFJlbW90ZVRyZWVTaGEocmVtb3RlQ29tbWl0U2hhKVxuICAgICAgICBjb25zdCByZW1vdGVDaGFuZ2VzID0gYXdhaXQgdGhpcy5maXQuZ2V0UmVtb3RlQ2hhbmdlcyhyZW1vdGVUcmVlU2hhKVxuICAgICAgICBsZXQgY2xhc2hlczogQ2xhc2hTdGF0dXNbXSA9IFtdO1xuICAgICAgICBsZXQgc3RhdHVzOiBQcmVTeW5jQ2hlY2tSZXN1bHRUeXBlXG5cbiAgICAgICAgaWYgKGxvY2FsQ2hhbmdlcy5sZW5ndGggPiAwICYmICFyZW1vdGVVcGRhdGVkKSB7XG4gICAgICAgICAgICBzdGF0dXMgPSBcIm9ubHlMb2NhbENoYW5nZWRcIlxuICAgICAgICB9IGVsc2UgaWYgKHJlbW90ZVVwZGF0ZWQgJiYgbG9jYWxDaGFuZ2VzLmxlbmd0aCA9PT0gMCAmJiByZW1vdGVDaGFuZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgc3RhdHVzID0gXCJvbmx5UmVtb3RlQ29tbWl0U2hhQ2hhbmdlZFwiXG4gICAgICAgIH0gZWxzZSBpZiAobG9jYWxDaGFuZ2VzLmxlbmd0aCA9PT0gMCAmJiByZW1vdGVVcGRhdGVkKSB7XG4gICAgICAgICAgICBzdGF0dXMgPSBcIm9ubHlSZW1vdGVDaGFuZ2VkXCJcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsYXNoZXMgPSB0aGlzLmZpdC5nZXRDbGFzaGVkQ2hhbmdlcyhsb2NhbENoYW5nZXMsIHJlbW90ZUNoYW5nZXMpXG4gICAgICAgICAgICBpZiAoY2xhc2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBcImxvY2FsQW5kUmVtb3RlQ2hhbmdlc0NvbXBhdGlibGVcIlxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSAgXCJsb2NhbEFuZFJlbW90ZUNoYW5nZXNDbGFzaGVkXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgICAgcmVtb3RlVXBkYXRlOiB7XG4gICAgICAgICAgICAgICAgcmVtb3RlQ2hhbmdlcyxcbiAgICAgICAgICAgICAgICByZW1vdGVUcmVlU2hhLFxuICAgICAgICAgICAgICAgIGxhdGVzdFJlbW90ZUNvbW1pdFNoYTogcmVtb3RlQ29tbWl0U2hhLFxuICAgICAgICAgICAgICAgIGNsYXNoZWRGaWxlczogY2xhc2hlc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxvY2FsQ2hhbmdlcyxcbiAgICAgICAgICAgIGxvY2FsVHJlZVNoYTogY3VycmVudExvY2FsU2hhXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGdlbmVyYXRlQ29uZmxpY3RSZXBvcnQocGF0aDogc3RyaW5nLCBsb2NhbENvbnRlbnQ6IHN0cmluZywgcmVtb3RlQ29udGVudDogc3RyaW5nKTogQ29uZmxpY3RSZXBvcnQge1xuICAgICAgICBjb25zdCBkZXRlY3RlZEV4dGVuc2lvbiA9IGV4dHJhY3RFeHRlbnNpb24ocGF0aClcblxuICAgICAgICAvLyBhc3N1bWUgZmlsZSBlbmNvZGluZyBpcyB1dGY4IGlmIGV4dGVuc2lvbiBpcyBub3Qga25vd25cbiAgICAgICAgbGV0IHJlc29sdXRpb25TdHJhdGVneTogXCJ1dGYtOFwiIHwgXCJiaW5hcnlcIiA9IFwidXRmLThcIlxuXG4gICAgICAgIC8vIFRPRE8gXHUwNDM1XHUwNDQxXHUwNDQyXHUwNDRDIGdldEZpbGVFbmNvZGluZ1xuICAgICAgICBpZiAoZGV0ZWN0ZWRFeHRlbnNpb24gJiYgIVJFQ09HTklaRURfVFhUX0VYVC5pbmNsdWRlcyhkZXRlY3RlZEV4dGVuc2lvbikpXG4gICAgICAgICAgICByZXNvbHV0aW9uU3RyYXRlZ3kgPSBcImJpbmFyeVwiXG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICByZXNvbHV0aW9uU3RyYXRlZ3k6IHJlc29sdXRpb25TdHJhdGVneSxcbiAgICAgICAgICAgIGxvY2FsQ29udGVudCxcbiAgICAgICAgICAgIHJlbW90ZUNvbnRlbnQsXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIGhhbmRsZUJpbmFyeUNvbmZsaWN0KHBhdGg6IHN0cmluZywgbG9jYWxDb250ZW50OiBzdHJpbmcsIHJlbW90ZUNvbnRlbnQ6IHN0cmluZyk6IFByb21pc2U8RmlsZU9wUmVjb3JkfG51bGw+IHtcblxuICAgICAgICBjb25zdCBjb25mbGljdFBhdGggPSB0aGlzLmZpdC5zeW5jUGF0aCtwYXRoXG4gICAgICAgIGNvbnN0IGNvbmZsaWN0UmVzb2x1dGlvblBhdGggPSBjb25mbGljdFJlc29sdXRpb25Gb2xkZXIgKyBjb25mbGljdFBhdGhcblxuICAgICAgICBjb25zdCBleGNsdWRlcyA9IHRoaXMuZml0LmV4Y2x1ZGVzXG5cbiAgICAgICAgbGV0IGlzRXhjbHVkZWQgPSBmYWxzZVxuICAgICAgICBpZiAoZXhjbHVkZXMubGVuZ3RoKSB7XG4gICAgICAgICAgaXNFeGNsdWRlZCA9IGV4Y2x1ZGVzLnNvbWUoZWwgPT4gY29uZmxpY3RSZXNvbHV0aW9uUGF0aC5zdGFydHNXaXRoKGVsKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0V4Y2x1ZGVkKVxuICAgICAgICAgICAgcmV0dXJuIG51bGxcblxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICB0aGlzLmZpdC52YXVsdE9wcy53cml0ZVRvTG9jYWwoY29uZmxpY3RQYXRoLCByZW1vdGVDb250ZW50KSxcbiAgICAgICAgICAgIHRoaXMuZml0LnZhdWx0T3BzLndyaXRlVG9Mb2NhbChjb25mbGljdFJlc29sdXRpb25QYXRoLCBsb2NhbENvbnRlbnQpLFxuICAgICAgICBdKVxuXG4gICAgICAgIC8vIFRPRE8gYWRkXG4gICAgICAgIC8qXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBhdGg6IGNvbmZsaWN0UGF0aCxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IFwiY2hhbmdlZFwiXG4gICAgICAgICAgICB9XG4gICAgICAgICovXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXRoOiBjb25mbGljdFJlc29sdXRpb25QYXRoLFxuICAgICAgICAgICAgc3RhdHVzOiBcImNyZWF0ZWRcIlxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBoYW5kbGVVVEY4Q29uZmxpY3QocGF0aDogc3RyaW5nLCBsb2NhbENvbnRlbnQ6IHN0cmluZywgcmVtb3RlQ29udGVudDogc3RyaW5nKTogUHJvbWlzZTxGaWxlT3BSZWNvcmR8bnVsbD4ge1xuICAgICAgICBjb25zdCBjb25mbGljdFBhdGggPSB0aGlzLmZpdC5zeW5jUGF0aCArIHBhdGhcbiAgICAgICAgY29uc3QgY29uZmxpY3RSZXNvbHV0aW9uUGF0aCA9IGNvbmZsaWN0UmVzb2x1dGlvbkZvbGRlciArIGNvbmZsaWN0UGF0aFxuXG4gICAgICAgIGNvbnN0IGV4Y2x1ZGVzID0gdGhpcy5maXQuZXhjbHVkZXNcblxuICAgICAgICBsZXQgaXNFeGNsdWRlZCA9IGZhbHNlXG4gICAgICAgIGlmIChleGNsdWRlcy5sZW5ndGgpIHtcbiAgICAgICAgICBpc0V4Y2x1ZGVkID0gZXhjbHVkZXMuc29tZShlbCA9PiBjb25mbGljdFJlc29sdXRpb25QYXRoLnN0YXJ0c1dpdGgoZWwpKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRXhjbHVkZWQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHRoaXMuZml0LnZhdWx0T3BzLndyaXRlVG9Mb2NhbChjb25mbGljdFBhdGgsIHJlbW90ZUNvbnRlbnQpLFxuICAgICAgICAgICAgdGhpcy5maXQudmF1bHRPcHMud3JpdGVUb0xvY2FsKGNvbmZsaWN0UmVzb2x1dGlvblBhdGgsIGxvY2FsQ29udGVudCksXG4gICAgICAgIF0pXG5cbiAgICAgICAgLy8gVE9ETyBhZGRcbiAgICAgICAgLypcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcGF0aDogY29uZmxpY3RQYXRoLFxuICAgICAgICAgICAgICAgIHN0YXR1czogXCJjaGFuZ2VkXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhdGg6IGNvbmZsaWN0UmVzb2x1dGlvblBhdGgsXG4gICAgICAgICAgICBzdGF0dXM6IFwiY3JlYXRlZFwiXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIGhhbmRsZUxvY2FsRGVsZXRpb25Db25mbGljdChwYXRoOiBzdHJpbmcsIHJlbW90ZUNvbnRlbnQ6IHN0cmluZyk6IFByb21pc2U8RmlsZU9wUmVjb3JkfG51bGw+IHtcbiAgICAgICAgLy8gY29uc3QgY29uZmxpY3RSZXNvbHV0aW9uUGF0aCA9IGNvbmZsaWN0UmVzb2x1dGlvbkZvbGRlciArIGNvbmZsaWN0UGF0aFxuICAgICAgICBjb25zdCBjb25mbGljdFJlc29sdXRpb25QYXRoID0gdGhpcy5maXQuc3luY1BhdGggKyBwYXRoXG5cbiAgICAgICAgY29uc3QgZXhjbHVkZXMgPSB0aGlzLmZpdC5leGNsdWRlc1xuXG4gICAgICAgIGxldCBpc0V4Y2x1ZGVkID0gZmFsc2VcbiAgICAgICAgaWYgKGV4Y2x1ZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgaXNFeGNsdWRlZCA9IGV4Y2x1ZGVzLnNvbWUoZWwgPT4gY29uZmxpY3RSZXNvbHV0aW9uUGF0aC5zdGFydHNXaXRoKGVsKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0V4Y2x1ZGVkKVxuICAgICAgICAgICAgcmV0dXJuIG51bGxcblxuICAgICAgICBhd2FpdCB0aGlzLmZpdC52YXVsdE9wcy53cml0ZVRvTG9jYWwoY29uZmxpY3RSZXNvbHV0aW9uUGF0aCwgcmVtb3RlQ29udGVudClcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGF0aDogY29uZmxpY3RSZXNvbHV0aW9uUGF0aCxcbiAgICAgICAgICAgIHN0YXR1czogXCJjcmVhdGVkXCJcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgcmVzb2x2ZUZpbGVDb25mbGljdChjbGFzaDogQ2xhc2hTdGF0dXMsIGxhdGVzdFJlbW90ZUZpbGVTaGE6IHN0cmluZyk6IFByb21pc2U8Q29uZmxpY3RSZXNvbHV0aW9uUmVzdWx0IHwgbnVsbD4ge1xuICAgICAgICBpZiAoY2xhc2gubG9jYWxTdGF0dXMgPT09IFwiZGVsZXRlZFwiICYmIGNsYXNoLnJlbW90ZVN0YXR1cyA9PT0gXCJSRU1PVkVEXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7cGF0aDogY2xhc2gucGF0aCwgbm9EaWZmOiB0cnVlfVxuICAgICAgICB9IGVsc2UgaWYgKGNsYXNoLmxvY2FsU3RhdHVzID09PSBcImRlbGV0ZWRcIikge1xuICAgICAgICAgICAgY29uc3QgcmVtb3RlQ29udGVudCA9IGF3YWl0IHRoaXMuZml0LmdldEJsb2IobGF0ZXN0UmVtb3RlRmlsZVNoYSlcbiAgICAgICAgICAgIGNvbnN0IGZpbGVPcCA9IGF3YWl0IHRoaXMuaGFuZGxlTG9jYWxEZWxldGlvbkNvbmZsaWN0KGNsYXNoLnBhdGgsIHJlbW90ZUNvbnRlbnQpXG4gICAgICAgICAgICAvLyBOT1RFIGRpZG4ndCBkZWxldGUgc2luY2UgaXQncyBpbiBleGNsdWRlXG4gICAgICAgICAgICBpZiAoIWZpbGVPcClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuXG4gICAgICAgICAgICByZXR1cm4ge3BhdGg6IGNsYXNoLnBhdGgsIG5vRGlmZjogZmFsc2UsIGZpbGVPcDogZmlsZU9wfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGF0aCA9IHRoaXMuZml0LnN5bmNQYXRoICsgY2xhc2gucGF0aFxuXG4gICAgICAgIC8vIE5PVEUgdXNlIGFkYXB0ZXIgZm9yIGZpbGVzIGluIHRoZSAub2JzaWRpYW4vLi4uXG4gICAgICAgIGNvbnN0IGxvY2FsRmlsZUNvbnRlbnQgPSBhcnJheUJ1ZmZlclRvQmFzZTY0KFxuICAgICAgICAgICAgYXdhaXQgdGhpcy5maXQudmF1bHRPcHMudmF1bHQuYWRhcHRlci5yZWFkQmluYXJ5KHBhdGgpXG4gICAgICAgIClcblxuICAgICAgICBpZiAoIWxhdGVzdFJlbW90ZUZpbGVTaGEpXG4gICAgICAgICAgICAvLyBhc3N1bWVzIHJlbW90ZSBmaWxlIGlzIGRlbGV0ZWQgaWYgc2hhIG5vdCBmb3VuZCBpbiBsYXRlc3RSZW1vdGVUcmVlU2hhLlxuICAgICAgICAgICAgcmV0dXJuIHsgcGF0aDogY2xhc2gucGF0aCwgbm9EaWZmOiBmYWxzZSB9XG5cblxuICAgICAgICBjb25zdCByZW1vdGVDb250ZW50ID0gYXdhaXQgdGhpcy5maXQuZ2V0QmxvYihsYXRlc3RSZW1vdGVGaWxlU2hhKVxuICAgICAgICBpZiAocmVtb3ZlTGluZUVuZGluZ3NGcm9tQmFzZTY0U3RyaW5nKHJlbW90ZUNvbnRlbnQpICE9PSByZW1vdmVMaW5lRW5kaW5nc0Zyb21CYXNlNjRTdHJpbmcobG9jYWxGaWxlQ29udGVudCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcG9ydCA9IHRoaXMuZ2VuZXJhdGVDb25mbGljdFJlcG9ydChjbGFzaC5wYXRoLCBsb2NhbEZpbGVDb250ZW50LCByZW1vdGVDb250ZW50KVxuXG4gICAgICAgICAgICBsZXQgZmlsZU9wOiBGaWxlT3BSZWNvcmQgfCBudWxsXG4gICAgICAgICAgICBpZiAocmVwb3J0LnJlc29sdXRpb25TdHJhdGVneSA9PT0gXCJiaW5hcnlcIikge1xuICAgICAgICAgICAgICAgIGZpbGVPcCA9IGF3YWl0IHRoaXMuaGFuZGxlQmluYXJ5Q29uZmxpY3QoY2xhc2gucGF0aCwgcmVwb3J0LmxvY2FsQ29udGVudCwgcmVwb3J0LnJlbW90ZUNvbnRlbnQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWxlT3AgPSBhd2FpdCB0aGlzLmhhbmRsZVVURjhDb25mbGljdChjbGFzaC5wYXRoLCByZXBvcnQubG9jYWxDb250ZW50LCByZXBvcnQucmVtb3RlQ29udGVudClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTk9URSBkaWRuJ3QgZGVsZXRlIHNpbmNlIGl0J3MgaW4gZXhjbHVkZVxuICAgICAgICAgICAgaWYgKCFmaWxlT3ApXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGxcblxuICAgICAgICAgICAgcmV0dXJuIHtwYXRoOiBjbGFzaC5wYXRoLCBub0RpZmY6IGZhbHNlLCBmaWxlT3A6IGZpbGVPcH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBwYXRoOiBjbGFzaC5wYXRoLCBub0RpZmY6IHRydWUgfVxuICAgIH1cblxuICAgIGFzeW5jIHJlc29sdmVDb25mbGljdHMoXG4gICAgICAgIGNsYXNoZWRGaWxlczogQXJyYXk8Q2xhc2hTdGF0dXM+LCBsYXRlc3RSZW1vdGVUcmVlU2hhOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KVxuICAgICAgICAgICAgOiBQcm9taXNlPFJlc29sdmVDb25mbGljdD5cbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgZmlsZVJlc29sdXRpb25zID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICAgICAgY2xhc2hlZEZpbGVzLm1hcChcbiAgICAgICAgICAgICAgICAgICAgYXN5bmMgKGNsYXNoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5yZXNvbHZlRmlsZUNvbmZsaWN0KGNsYXNoLCBsYXRlc3RSZW1vdGVUcmVlU2hhW2NsYXNoLnBhdGhdKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICBjb25zdCB1bnJlc29sdmVkRmlsZXMgPSBmaWxlUmVzb2x1dGlvbnMubWFwKChyZXMsIGkpPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcmVzPy5ub0RpZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsYXNoZWRGaWxlc1tpXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgICAgfSkuZmlsdGVyKEJvb2xlYW4pIGFzIEFycmF5PENsYXNoU3RhdHVzPlxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5vQ29uZmxpY3Q6IGZpbGVSZXNvbHV0aW9ucy5ldmVyeShyZXM9PnJlcz8ubm9EaWZmKSxcbiAgICAgICAgICAgICAgICB1bnJlc29sdmVkRmlsZXMsXG4gICAgICAgICAgICAgICAgZmlsZU9wc1JlY29yZDogZmlsZVJlc29sdXRpb25zLm1hcChyID0+IHI/LmZpbGVPcCkuZmlsdGVyKEJvb2xlYW4pIGFzIEZpbGVPcFJlY29yZFtdXG4gICAgICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgc3luY0NvbXBhdGlibGVDaGFuZ2VzKFxuICAgICAgICBsb2NhbFVwZGF0ZTogTG9jYWxVcGRhdGUsXG4gICAgICAgIHJlbW90ZVVwZGF0ZTogUmVtb3RlVXBkYXRlLFxuICAgICAgICBzeW5jTm90aWNlOiBGaXROb3RpY2UpOiBQcm9taXNlPHtsb2NhbE9wczogTG9jYWxDaGFuZ2VbXSwgcmVtb3RlT3BzOiBGaWxlT3BSZWNvcmRbXX0+IHtcbiAgICAgICAgICAgIGxldCB7YWRkVG9Mb2NhbCwgZGVsZXRlRnJvbUxvY2FsfSA9IGF3YWl0IHRoaXMuZml0UHVsbC5wcmVwYXJlQ2hhbmdlc1RvRXhlY3V0ZShcbiAgICAgICAgICAgICAgICByZW1vdGVVcGRhdGUucmVtb3RlQ2hhbmdlcylcbiAgICAgICAgICAgIHN5bmNOb3RpY2Uuc2V0TWVzc2FnZShcIlVwbG9hZGluZyBsb2NhbCBjaGFuZ2VzXCIpXG4gICAgICAgICAgICBjb25zdCByZW1vdGVUcmVlID0gYXdhaXQgdGhpcy5maXQuZ2V0VHJlZShsb2NhbFVwZGF0ZS5wYXJlbnRDb21taXRTaGEpXG4gICAgICAgICAgICBjb25zdCBjcmVhdGVDb21taXRSZXN1bHQgPSBhd2FpdCB0aGlzLmZpdFB1c2guY3JlYXRlQ29tbWl0RnJvbUxvY2FsVXBkYXRlKGxvY2FsVXBkYXRlLCByZW1vdGVUcmVlKVxuICAgICAgICAgICAgbGV0IGxhdGVzdFJlbW90ZVRyZWVTaGE6IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gICAgICAgICAgICBsZXQgbGF0ZXN0Q29tbWl0U2hhOiBzdHJpbmc7XG4gICAgICAgICAgICBsZXQgcHVzaGVkQ2hhbmdlczogQXJyYXk8TG9jYWxDaGFuZ2U+O1xuICAgICAgICAgICAgaWYgKGNyZWF0ZUNvbW1pdFJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHtjcmVhdGVkQ29tbWl0U2hhfSA9IGNyZWF0ZUNvbW1pdFJlc3VsdFxuICAgICAgICAgICAgICAgIGNvbnN0IGxhdGVzdFJlZlNoYSA9IGF3YWl0IHRoaXMuZml0LnVwZGF0ZVJlZihjcmVhdGVkQ29tbWl0U2hhKVxuICAgICAgICAgICAgICAgIGxhdGVzdFJlbW90ZVRyZWVTaGEgPSBhd2FpdCB0aGlzLmZpdC5nZXRSZW1vdGVUcmVlU2hhKGxhdGVzdFJlZlNoYSlcbiAgICAgICAgICAgICAgICBsYXRlc3RDb21taXRTaGEgPSBjcmVhdGVkQ29tbWl0U2hhXG4gICAgICAgICAgICAgICAgcHVzaGVkQ2hhbmdlcyA9IGNyZWF0ZUNvbW1pdFJlc3VsdC5wdXNoZWRDaGFuZ2VzXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxhdGVzdFJlbW90ZVRyZWVTaGEgPSByZW1vdGVVcGRhdGUucmVtb3RlVHJlZVNoYVxuICAgICAgICAgICAgICAgIGxhdGVzdENvbW1pdFNoYSA9IHJlbW90ZVVwZGF0ZS5sYXRlc3RSZW1vdGVDb21taXRTaGFcbiAgICAgICAgICAgICAgICBwdXNoZWRDaGFuZ2VzID0gW11cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3luY05vdGljZS5zZXRNZXNzYWdlKFwiV3JpdGluZyByZW1vdGUgY2hhbmdlcyB0byBsb2NhbFwiKVxuXG4gICAgICAgICAgICBjb25zdCBiYXNlcGF0aCA9IHRoaXMuZml0LnN5bmNQYXRoXG4gICAgICAgICAgICBhZGRUb0xvY2FsID0gdGhpcy5maXQuZ2V0QWRkVG9Mb2NhbChhZGRUb0xvY2FsKVxuICAgICAgICAgICAgZGVsZXRlRnJvbUxvY2FsID0gdGhpcy5maXQuZ2V0RGVsZXRlRnJvbUxvY2FsKGRlbGV0ZUZyb21Mb2NhbClcblxuXG4gICAgICAgICAgICBjb25zdCBsb2NhbEZpbGVPcHNSZWNvcmQgPSBhd2FpdCB0aGlzLnZhdWx0T3BzLnVwZGF0ZUxvY2FsRmlsZXMoYWRkVG9Mb2NhbCwgZGVsZXRlRnJvbUxvY2FsKVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zYXZlTG9jYWxTdG9yZUNhbGxiYWNrKFxuICAgICAgICAgICAgICAgIGJhc2VwYXRoLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdEZldGNoZWRSZW1vdGVTaGE6IGxhdGVzdFJlbW90ZVRyZWVTaGEsXG4gICAgICAgICAgICAgICAgICAgIGxhc3RGZXRjaGVkQ29tbWl0U2hhOiBsYXRlc3RDb21taXRTaGEsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU2hhOiBhd2FpdCB0aGlzLmZpdC5jb21wdXRlTG9jYWxTaGEoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIHN5bmNOb3RpY2Uuc2V0TWVzc2FnZShcIlN5bmMgc3VjY2Vzc2Z1bFwiKVxuICAgICAgICAgICAgcmV0dXJuIHtsb2NhbE9wczogbG9jYWxGaWxlT3BzUmVjb3JkLCByZW1vdGVPcHM6IHB1c2hlZENoYW5nZXN9XG4gICAgfVxuXG5cbiAgICBhc3luYyBzeW5jV2l0aENvbmZsaWN0cyhcbiAgICAgICAgbG9jYWxDaGFuZ2VzOiBMb2NhbENoYW5nZVtdLFxuICAgICAgICByZW1vdGVVcGRhdGU6IFJlbW90ZVVwZGF0ZSxcbiAgICAgICAgc3luY05vdGljZTogRml0Tm90aWNlKSA6IFByb21pc2U8e3VucmVzb2x2ZWRGaWxlczogQ2xhc2hTdGF0dXNbXSwgbG9jYWxPcHM6IExvY2FsQ2hhbmdlW10sIHJlbW90ZU9wczogTG9jYWxDaGFuZ2VbXX0gfCBudWxsPlxuICAgIHtcbiAgICAgICAgY29uc3Qge2xhdGVzdFJlbW90ZUNvbW1pdFNoYSwgY2xhc2hlZEZpbGVzLCByZW1vdGVUcmVlU2hhOiBsYXRlc3RSZW1vdGVUcmVlU2hhfSA9IHJlbW90ZVVwZGF0ZVxuICAgICAgICBjb25zdCB7bm9Db25mbGljdCwgdW5yZXNvbHZlZEZpbGVzLCBmaWxlT3BzUmVjb3JkfSA9IGF3YWl0IHRoaXMucmVzb2x2ZUNvbmZsaWN0cyhjbGFzaGVkRmlsZXMsIGxhdGVzdFJlbW90ZVRyZWVTaGEpXG4gICAgICAgIGxldCBsb2NhbENoYW5nZXNUb1B1c2g6IEFycmF5PExvY2FsQ2hhbmdlPjtcbiAgICAgICAgbGV0IHJlbW90ZUNoYW5nZXNUb1dyaXRlOiBBcnJheTxSZW1vdGVDaGFuZ2U+XG4gICAgICAgIGlmIChub0NvbmZsaWN0KSB7XG4gICAgICAgICAgICAvLyBubyBjb25mbGljdCBkZXRlY3RlZCBhbW9uZyBjbGFzaGVkIGZpbGVzLCBqdXN0IHB1bGwgY2hhbmdlcyBvbmx5IG1hZGUgb24gcmVtb3RlIGFuZCBwdXNoIGNoYW5nZXMgb25seSBtYWRlIG9uIGxvY2FsXG4gICAgICAgICAgICByZW1vdGVDaGFuZ2VzVG9Xcml0ZSA9IHJlbW90ZVVwZGF0ZS5yZW1vdGVDaGFuZ2VzLmZpbHRlcihjID0+ICFsb2NhbENoYW5nZXMuc29tZShsID0+IGwucGF0aCA9PT0gYy5wYXRoKSlcbiAgICAgICAgICAgIGxvY2FsQ2hhbmdlc1RvUHVzaCA9IGxvY2FsQ2hhbmdlcy5maWx0ZXIoYyA9PiAhcmVtb3RlVXBkYXRlLnJlbW90ZUNoYW5nZXMuc29tZShyID0+IHIucGF0aCA9PT0gYy5wYXRoKSlcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3luY05vdGljZS5zZXRNZXNzYWdlKGBDaGFuZ2UgY29uZmxpY3RzIGRldGVjdGVkYClcbiAgICAgICAgICAgIC8vIGRvIG5vdCBtb2RpZnkgdW5yZXNvbHZlZCBmaWxlcyBsb2NhbGx5XG4gICAgICAgICAgICByZW1vdGVDaGFuZ2VzVG9Xcml0ZSA9IHJlbW90ZVVwZGF0ZS5yZW1vdGVDaGFuZ2VzLmZpbHRlcihjID0+ICF1bnJlc29sdmVkRmlsZXMuc29tZShsID0+IGwucGF0aCA9PT0gYy5wYXRoKSlcbiAgICAgICAgICAgIC8vIHB1c2ggY2hhbmdlIGV2ZW4gaWYgdGhleSBhcmUgaW4gdW5yZXNvbHZlZCBmaWxlcywgc28gcmVtb3RlIGhhcyBhIHJlY29yZCBvZiB0aGVtLFxuICAgICAgICAgICAgLy8gc28gdXNlciBjYW4gcmVzb2x2ZSBsYXRlciBieSBtb2RpZnlpbmcgbG9jYWwgYW5kIHB1c2ggYWdhaW5cbiAgICAgICAgICAgIGxvY2FsQ2hhbmdlc1RvUHVzaCA9IGxvY2FsQ2hhbmdlc1xuICAgICAgICB9XG4gICAgICAgIGxldCB7YWRkVG9Mb2NhbCwgZGVsZXRlRnJvbUxvY2FsfSA9IGF3YWl0IHRoaXMuZml0UHVsbC5wcmVwYXJlQ2hhbmdlc1RvRXhlY3V0ZShyZW1vdGVDaGFuZ2VzVG9Xcml0ZSlcbiAgICAgICAgY29uc3Qgc3luY0xvY2FsVXBkYXRlID0ge1xuICAgICAgICAgICAgbG9jYWxDaGFuZ2VzOiBsb2NhbENoYW5nZXNUb1B1c2gsXG4gICAgICAgICAgICBwYXJlbnRDb21taXRTaGE6IGxhdGVzdFJlbW90ZUNvbW1pdFNoYVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHB1c2hSZXN1bHQgPSBhd2FpdCB0aGlzLmZpdFB1c2gucHVzaENoYW5nZWRGaWxlc1RvUmVtb3RlKHN5bmNMb2NhbFVwZGF0ZSlcbiAgICAgICAgbGV0IHB1c2hlZENoYW5nZXM6IExvY2FsQ2hhbmdlW107XG4gICAgICAgIGxldCBsYXN0RmV0Y2hlZENvbW1pdFNoYTogc3RyaW5nO1xuICAgICAgICBsZXQgbGFzdEZldGNoZWRSZW1vdGVTaGE6IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gICAgICAgIGlmIChwdXNoUmVzdWx0KSB7XG4gICAgICAgICAgICBwdXNoZWRDaGFuZ2VzID0gcHVzaFJlc3VsdC5wdXNoZWRDaGFuZ2VzXG4gICAgICAgICAgICBsYXN0RmV0Y2hlZENvbW1pdFNoYSA9IHB1c2hSZXN1bHQubGFzdEZldGNoZWRDb21taXRTaGFcbiAgICAgICAgICAgIGxhc3RGZXRjaGVkUmVtb3RlU2hhID0gcHVzaFJlc3VsdC5sYXN0RmV0Y2hlZFJlbW90ZVNoYVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZGlkIG5vdCBwdXNoIGFueSBjaGFuZ2VzXG4gICAgICAgICAgICBwdXNoZWRDaGFuZ2VzID0gW11cbiAgICAgICAgICAgIGxhc3RGZXRjaGVkQ29tbWl0U2hhID0gcmVtb3RlVXBkYXRlLmxhdGVzdFJlbW90ZUNvbW1pdFNoYVxuICAgICAgICAgICAgbGFzdEZldGNoZWRSZW1vdGVTaGEgPSByZW1vdGVVcGRhdGUucmVtb3RlVHJlZVNoYVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYmFzZXBhdGggPSB0aGlzLmZpdC5zeW5jUGF0aFxuICAgICAgICBhZGRUb0xvY2FsID0gdGhpcy5maXQuZ2V0QWRkVG9Mb2NhbChhZGRUb0xvY2FsKVxuICAgICAgICBkZWxldGVGcm9tTG9jYWwgPSB0aGlzLmZpdC5nZXREZWxldGVGcm9tTG9jYWwoZGVsZXRlRnJvbUxvY2FsKVxuXG4gICAgICAgIGNvbnN0IGxvY2FsRmlsZU9wc1JlY29yZCA9IGF3YWl0IHRoaXMudmF1bHRPcHMudXBkYXRlTG9jYWxGaWxlcyhcbiAgICAgICAgICAgIGFkZFRvTG9jYWwsXG4gICAgICAgICAgICBkZWxldGVGcm9tTG9jYWxcbiAgICAgICAgKVxuXG4gICAgICAgIGF3YWl0IHRoaXMuc2F2ZUxvY2FsU3RvcmVDYWxsYmFjayhcbiAgICAgICAgICAgIGJhc2VwYXRoLFxuICAgICAgICB7XG4gICAgICAgICAgICBsYXN0RmV0Y2hlZFJlbW90ZVNoYSxcbiAgICAgICAgICAgIGxhc3RGZXRjaGVkQ29tbWl0U2hhLFxuICAgICAgICAgICAgbG9jYWxTaGE6IGF3YWl0IHRoaXMuZml0LmNvbXB1dGVMb2NhbFNoYSgpXG4gICAgICAgIH0pXG4gICAgICAgIGNvbnN0IG9wcyA9IGxvY2FsRmlsZU9wc1JlY29yZC5jb25jYXQoZmlsZU9wc1JlY29yZClcbiAgICAgICAgaWYgKHVucmVzb2x2ZWRGaWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHN5bmNOb3RpY2Uuc2V0TWVzc2FnZShgU3luYyBzdWNjZXNzZnVsYClcbiAgICAgICAgfSBlbHNlIGlmICh1bnJlc29sdmVkRmlsZXMuc29tZShmID0+IGYucmVtb3RlU3RhdHVzICE9PSBcIlJFTU9WRURcIikpIHtcbiAgICAgICAgICAgIC8vIGxldCB1c2VyIGtub3dzIHJlbW90ZSBmaWxlIGNoYW5nZXMgaGF2ZSBiZWVuIHdyaXR0ZW4gdG8gX2ZpdCBpZiBub24tZGVsZXRpb24gY2hhbmdlIG9uIHJlbW90ZSBjbGFzaGVkIHdpdGggbG9jYWwgY2hhbmdlc1xuICAgICAgICAgICAgc3luY05vdGljZS5zZXRNZXNzYWdlKGBTeW5jZWQgd2l0aCByZW1vdGUsIHVucmVzb2x2ZWQgY29uZmxpY3RzIHdyaXR0ZW4gdG8gJHtjb25mbGljdFJlc29sdXRpb25Gb2xkZXJ9YClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN5bmNOb3RpY2Uuc2V0TWVzc2FnZShgU3luY2VkIHdpdGggcmVtb3RlLCBpZ25vcmVkIHJlbW90ZSBkZWxldGlvbiBvZiBsb2NhbGx5IGNoYW5nZWQgZmlsZXNgKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7dW5yZXNvbHZlZEZpbGVzLCBsb2NhbE9wczogb3BzLCByZW1vdGVPcHM6IHB1c2hlZENoYW5nZXN9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyB1bnJlc29sdmVkQ2hhbmdlc0NvbmZsaWN0cygpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudmF1bHRPcHMudmF1bHQuYWRhcHRlci5leGlzdHMoY29uZmxpY3RSZXNvbHV0aW9uRm9sZGVyKVxuICAgIH1cblxuICAgIGFzeW5jIHN5bmMoc3luY05vdGljZTogRml0Tm90aWNlKTpcbiAgICAgICAgICAgIFByb21pc2U8e1xuICAgICAgICAgICAgICAgICAgICBvcHM6IEFycmF5PHtoZWFkaW5nOiBzdHJpbmcsIG9wczogRmlsZU9wUmVjb3JkW119PixcbiAgICAgICAgICAgICAgICAgICAgY2xhc2g6IENsYXNoU3RhdHVzW10sXG4gICAgICAgICAgICAgICAgICAgIC8vIGJhc2VwYXRoOiBzdHJpbmdcbiAgICAgICAgICAgICAgICB9IHwgdm9pZFxuICAgICAgICAgICAgPlxuICAgIHtcbiAgICAgICAgc3luY05vdGljZS5zZXRNZXNzYWdlKFwiUGVyZm9ybWluZyBwcmUgc3luYyBjaGVja3MuXCIpXG4gICAgICAgIGlmIChhd2FpdCB0aGlzLnVucmVzb2x2ZWRDaGFuZ2VzQ29uZmxpY3RzKCkpIHtcbiAgICAgICAgICAgIHN5bmNOb3RpY2Uuc2V0TWVzc2FnZShgVGhlcmUgYXJlIHVucmVzb2x2ZWQgZmlsZXM6IHBscywgcmVzb2x2ZSBmaWxlcyBpbjogJHtjb25mbGljdFJlc29sdXRpb25Gb2xkZXJ9LmApXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHByZVN5bmNDaGVja1Jlc3VsdCA9IGF3YWl0IHRoaXMucGVyZm9ybVByZVN5bmNDaGVja3MoKTtcblxuICAgICAgICAvLyBjb252ZXJ0IHRvIHN3aXRjaCBzdGF0ZW1lbnQgbGF0ZXIgb24gZm9yIGJldHRlciBtYWludGFpbmFiaWxpdHlcbiAgICAgICAgaWYgKHByZVN5bmNDaGVja1Jlc3VsdC5zdGF0dXMgPT09IFwiaW5TeW5jXCIpIHtcbiAgICAgICAgICAgIHN5bmNOb3RpY2Uuc2V0TWVzc2FnZShcIlN5bmMgc3VjY2Vzc2Z1bFwiKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJlU3luY0NoZWNrUmVzdWx0LnN0YXR1cyA9PT0gXCJvbmx5UmVtb3RlQ29tbWl0U2hhQ2hhbmdlZFwiKSB7XG4gICAgICAgICAgICBjb25zdCB7IGxhdGVzdFJlbW90ZUNvbW1pdFNoYSB9ID0gcHJlU3luY0NoZWNrUmVzdWx0LnJlbW90ZVVwZGF0ZVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zYXZlTG9jYWxTdG9yZUNhbGxiYWNrKFxuICAgICAgICAgICAgICAgIHRoaXMuZml0LnN5bmNQYXRoLFxuICAgICAgICAgICAgICAgIHtsYXN0RmV0Y2hlZENvbW1pdFNoYTogbGF0ZXN0UmVtb3RlQ29tbWl0U2hhfVxuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICBzeW5jTm90aWNlLnNldE1lc3NhZ2UoXCJTeW5jIHN1Y2Nlc3NmdWxcIilcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVtb3RlVXBkYXRlID0gcHJlU3luY0NoZWNrUmVzdWx0LnJlbW90ZVVwZGF0ZVxuICAgICAgICBpZiAocHJlU3luY0NoZWNrUmVzdWx0LnN0YXR1cyA9PT0gXCJvbmx5UmVtb3RlQ2hhbmdlZFwiKSB7XG4gICAgICAgICAgICBjb25zdCBmaWxlT3BzUmVjb3JkID0gYXdhaXQgdGhpcy5maXRQdWxsLnB1bGxSZW1vdGVUb0xvY2FsKFxuICAgICAgICAgICAgICAgIHJlbW90ZVVwZGF0ZSxcbiAgICAgICAgICAgICAgICB0aGlzLnNhdmVMb2NhbFN0b3JlQ2FsbGJhY2tcbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgc3luY05vdGljZS5zZXRNZXNzYWdlKFwiU3luYyBzdWNjZXNzZnVsXCIpXG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb3BzOiBbe2hlYWRpbmc6IFwiTG9jYWwgZmlsZSB1cGRhdGVzOlwiLCBvcHM6IGZpbGVPcHNSZWNvcmR9XSxcbiAgICAgICAgICAgICAgICBjbGFzaDogW10sXG4gICAgICAgICAgICAgICAgLy8gYmFzZXBhdGg6IHRoaXMuZml0LnN5bmNQYXRoXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7bG9jYWxDaGFuZ2VzLCBsb2NhbFRyZWVTaGF9ID0gcHJlU3luY0NoZWNrUmVzdWx0XG4gICAgICAgIGNvbnN0IGxvY2FsVXBkYXRlID0ge1xuICAgICAgICAgICAgbG9jYWxDaGFuZ2VzLFxuICAgICAgICAgICAgcGFyZW50Q29tbWl0U2hhOiByZW1vdGVVcGRhdGUubGF0ZXN0UmVtb3RlQ29tbWl0U2hhXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZVN5bmNDaGVja1Jlc3VsdC5zdGF0dXMgPT09IFwib25seUxvY2FsQ2hhbmdlZFwiKSB7XG4gICAgICAgICAgICBzeW5jTm90aWNlLnNldE1lc3NhZ2UoXCJVcGxvYWRpbmcgbG9jYWwgY2hhbmdlc1wiKVxuICAgICAgICAgICAgY29uc3QgcHVzaFJlc3VsdCA9IGF3YWl0IHRoaXMuZml0UHVzaC5wdXNoQ2hhbmdlZEZpbGVzVG9SZW1vdGUobG9jYWxVcGRhdGUpXG4gICAgICAgICAgICBzeW5jTm90aWNlLnNldE1lc3NhZ2UoXCJTeW5jIHN1Y2Nlc3NmdWxcIilcbiAgICAgICAgICAgIGlmIChwdXNoUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zYXZlTG9jYWxTdG9yZUNhbGxiYWNrKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpdC5zeW5jUGF0aCxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTaGE6IGxvY2FsVHJlZVNoYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RGZXRjaGVkUmVtb3RlU2hhOiBwdXNoUmVzdWx0Lmxhc3RGZXRjaGVkUmVtb3RlU2hhLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEZldGNoZWRDb21taXRTaGE6IHB1c2hSZXN1bHQubGFzdEZldGNoZWRDb21taXRTaGFcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBvcHM6IFt7aGVhZGluZzogXCJMb2NhbCBmaWxlIHVwZGF0ZXM6XCIsIG9wczogcHVzaFJlc3VsdC5wdXNoZWRDaGFuZ2VzfV0sXG4gICAgICAgICAgICAgICAgICAgIGNsYXNoOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgLy8gYmFzZXBhdGg6IHRoaXMuZml0LnN5bmNQYXRoXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBkbyBib3RoIHB1bGwgYW5kIHB1c2ggKG9yZGVycyBvZiBleGVjdXRpb24gZGlmZmVyZW50IGZyb20gcHVsbFJlbW90ZVRvTG9jYWwgYW5kXG4gICAgICAgIC8vIHB1c2hDaGFuZ2VkRmlsZXNUb1JlbW90ZSB0byBtYWtlIHRoaXMgbW9yZSB0cmFuc2FjdGlvbiBsaWtlLCBpLmUuIG1haW50YWluIG9yaWdpbmFsXG4gICAgICAgIC8vIHN0YXRlIGlmIHRoZSB0cmFuc2FjdGlvbiBmYWlsZWQpIElmIHlvdSBoYXZlIGlkZWFzIG9uIGhvdyB0byBtYWtlIHRoaXMgbW9yZSB0cmFuc2FjdGlvbi1saWtlLFxuICAgICAgICAvLyAgcGxlYXNlIG9wZW4gYW4gaXNzdWUgb24gdGhlIGZpdCByZXBvXG4gICAgICAgIGlmIChwcmVTeW5jQ2hlY2tSZXN1bHQuc3RhdHVzID09PSBcImxvY2FsQW5kUmVtb3RlQ2hhbmdlc0NvbXBhdGlibGVcIikge1xuICAgICAgICAgICAgY29uc3Qge2xvY2FsT3BzLCByZW1vdGVPcHN9ID0gYXdhaXQgdGhpcy5zeW5jQ29tcGF0aWJsZUNoYW5nZXMoXG4gICAgICAgICAgICAgICAgbG9jYWxVcGRhdGUsIHJlbW90ZVVwZGF0ZSwgc3luY05vdGljZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICAgICAgb3BzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7aGVhZGluZzogXCJMb2NhbCBmaWxlIHVwZGF0ZXM6XCIsIG9wczogbG9jYWxPcHN9LFxuICAgICAgICAgICAgICAgICAgICAgICAge2hlYWRpbmc6IFwiUmVtb3RlIGZpbGUgdXBkYXRlczpcIiwgb3BzOiByZW1vdGVPcHN9LFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBjbGFzaDogW10sXG4gICAgICAgICAgICAgICAgICAgIC8vIGJhc2VwYXRoOiB0aGlzLmZpdC5zeW5jUGF0aFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJlU3luY0NoZWNrUmVzdWx0LnN0YXR1cyA9PT0gXCJsb2NhbEFuZFJlbW90ZUNoYW5nZXNDbGFzaGVkXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmZsaWN0UmVzb2x1dGlvblJlc3VsdCA9IGF3YWl0IHRoaXMuc3luY1dpdGhDb25mbGljdHMoXG4gICAgICAgICAgICAgICAgbG9jYWxVcGRhdGUubG9jYWxDaGFuZ2VzLCByZW1vdGVVcGRhdGUsIHN5bmNOb3RpY2VcbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgaWYgKGNvbmZsaWN0UmVzb2x1dGlvblJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHt1bnJlc29sdmVkRmlsZXMsIGxvY2FsT3BzLCByZW1vdGVPcHN9ID0gY29uZmxpY3RSZXNvbHV0aW9uUmVzdWx0XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICAgICAgb3BzOltcbiAgICAgICAgICAgICAgICAgICAgICAgIHtoZWFkaW5nOiBcIkxvY2FsIGZpbGUgdXBkYXRlczpcIiwgb3BzOiBsb2NhbE9wc30sXG4gICAgICAgICAgICAgICAgICAgICAgICB7aGVhZGluZzogXCJSZW1vdGUgZmlsZSB1cGRhdGVzOlwiLCBvcHM6IHJlbW90ZU9wc30sXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIGNsYXNoOiB1bnJlc29sdmVkRmlsZXMsXG4gICAgICAgICAgICAgICAgICAgIC8vIGJhc2VwYXRoOiB0aGlzLmZpdC5zeW5jUGF0aFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgRml0IH0gZnJvbSBcIi4vZml0XCI7XG5pbXBvcnQgeyBMb2NhbFN0b3JlcyB9IGZyb20gXCJtYWluXCI7XG5pbXBvcnQgeyBGaWxlT3BSZWNvcmQsIExvY2FsQ2hhbmdlLCBSZW1vdGVDaGFuZ2UsIFJlbW90ZVVwZGF0ZSB9IGZyb20gXCIuL2ZpdFR5cGVzXCI7XG5cbnR5cGUgUHJlUHVsbENoZWNrUmVzdWx0VHlwZSA9IChcbiAgICBcImxvY2FsQ29weVVwVG9EYXRlXCIgfFxuICAgIFwibG9jYWxDaGFuZ2VzQ2xhc2hXaXRoUmVtb3RlQ2hhbmdlc1wiIHxcbiAgICBcInJlbW90ZUNoYW5nZXNDYW5CZU1lcmdlZFwiIHxcbiAgICBcIm5vUmVtb3RlQ2hhbmdlc0RldGVjdGVkXCJcbilcblxudHlwZSBQcmVQdWxsQ2hlY2tSZXN1bHQgPSAoXG4gICAgeyBzdGF0dXM6IFwibG9jYWxDb3B5VXBUb0RhdGVcIiwgcmVtb3RlVXBkYXRlOiBudWxsIH0gfFxuICAgIHsgc3RhdHVzOiBFeGNsdWRlPFByZVB1bGxDaGVja1Jlc3VsdFR5cGUsIFwibG9jYWxDb3B5VXBUb0RhdGVcIj4sIHJlbW90ZVVwZGF0ZTogUmVtb3RlVXBkYXRlIH1cbik7XG5cbnR5cGUgU2F2ZUNhbGxiYWNrID0gKHBhdGg6IHN0cmluZywgbG9jYWxTdG9yZTogUGFydGlhbDxMb2NhbFN0b3Jlcz4pID0+IFByb21pc2U8dm9pZD5cblxuZXhwb3J0IGludGVyZmFjZSBJRml0UHVsbCB7XG4gICAgZml0OiBGaXRcbn1cblxuZXhwb3J0IGNsYXNzIEZpdFB1bGwgaW1wbGVtZW50cyBJRml0UHVsbCB7XG4gICAgZml0OiBGaXRcblxuXG4gICAgY29uc3RydWN0b3IoZml0OiBGaXQpIHtcbiAgICAgICAgdGhpcy5maXQgPSBmaXRcbiAgICB9XG5cbiAgICBhc3luYyBwZXJmb3JtUHJlUHVsbENoZWNrcyhsb2NhbENoYW5nZXM/OiBMb2NhbENoYW5nZVtdKTogUHJvbWlzZTxQcmVQdWxsQ2hlY2tSZXN1bHQ+IHtcbiAgICAgICAgY29uc3Qge3JlbW90ZUNvbW1pdFNoYSwgdXBkYXRlZH0gPSBhd2FpdCB0aGlzLmZpdC5yZW1vdGVVcGRhdGVkKClcbiAgICAgICAgaWYgKCF1cGRhdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4ge3N0YXR1czogXCJsb2NhbENvcHlVcFRvRGF0ZVwiLCByZW1vdGVVcGRhdGU6IG51bGx9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsb2NhbENoYW5nZXMpIHtcbiAgICAgICAgICAgIGxvY2FsQ2hhbmdlcyA9IGF3YWl0IHRoaXMuZml0LmdldExvY2FsQ2hhbmdlcygpXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVtb3RlVHJlZVNoYSA9IGF3YWl0IHRoaXMuZml0LmdldFJlbW90ZVRyZWVTaGEocmVtb3RlQ29tbWl0U2hhKVxuICAgICAgICBjb25zdCByZW1vdGVDaGFuZ2VzID0gYXdhaXQgdGhpcy5maXQuZ2V0UmVtb3RlQ2hhbmdlcyhyZW1vdGVUcmVlU2hhKVxuICAgICAgICBjb25zdCBjbGFzaGVkRmlsZXMgPSB0aGlzLmZpdC5nZXRDbGFzaGVkQ2hhbmdlcyhsb2NhbENoYW5nZXMsIHJlbW90ZUNoYW5nZXMpXG4gICAgICAgIC8vIFRPRE8gaGFuZGxlIGNsYXNoZXMgd2l0aG91dCBjb21wbGV0ZWx5IGJsb2NraW5nIHB1bGxcbiAgICAgICAgY29uc3QgcHJlUHVsbENoZWNrU3RhdHVzID0gKFxuICAgICAgICAgICAgKHJlbW90ZUNoYW5nZXMubGVuZ3RoID4gMCkgPyAoXG4gICAgICAgICAgICAgICAgKGNsYXNoZWRGaWxlcy5sZW5ndGggPiAwKSA/IFwibG9jYWxDaGFuZ2VzQ2xhc2hXaXRoUmVtb3RlQ2hhbmdlc1wiIDogXCJyZW1vdGVDaGFuZ2VzQ2FuQmVNZXJnZWRcIik6XG4gICAgICAgICAgICAgICAgXCJub1JlbW90ZUNoYW5nZXNEZXRlY3RlZFwiKVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0dXM6IHByZVB1bGxDaGVja1N0YXR1cyxcbiAgICAgICAgICAgIHJlbW90ZVVwZGF0ZToge1xuICAgICAgICAgICAgICAgIHJlbW90ZUNoYW5nZXMsIHJlbW90ZVRyZWVTaGEsIGxhdGVzdFJlbW90ZUNvbW1pdFNoYTogcmVtb3RlQ29tbWl0U2hhLCBjbGFzaGVkRmlsZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEdldCBjaGFuZ2VzIGZyb20gcmVtb3RlLCBwYXRoU2hhTWFwIGlzIGNvdXBsZWQgdG8gdGhlIEZpdCBwbHVnaW4gZGVzaWduXG4gICAgYXN5bmMgZ2V0UmVtb3RlTm9uRGVsZXRpb25DaGFuZ2VzQ29udGVudChwYXRoU2hhTWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KSB7XG4gICAgICAgIGNvbnN0IHJlbW90ZUNoYW5nZXMgPSBPYmplY3QuZW50cmllcyhwYXRoU2hhTWFwKS5tYXAoYXN5bmMgKFtwYXRoLCBmaWxlX3NoYV0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLmZpdC5nZXRCbG9iKGZpbGVfc2hhKTtcbiAgICAgICAgICAgIHJldHVybiB7cGF0aCwgY29udGVudH07XG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChyZW1vdGVDaGFuZ2VzKVxuICAgIH1cblxuICAgIGFzeW5jIHByZXBhcmVDaGFuZ2VzVG9FeGVjdXRlKHJlbW90ZUNoYW5nZXM6IFJlbW90ZUNoYW5nZVtdKSB7XG4gICAgICAgIGNvbnN0IGRlbGV0ZUZyb21Mb2NhbCA9IHJlbW90ZUNoYW5nZXMuZmlsdGVyKGM9PmMuc3RhdHVzPT1cIlJFTU9WRURcIikubWFwKGM9PmMucGF0aClcbiAgICAgICAgY29uc3QgY2hhbmdlc1RvUHJvY2VzcyA9IHJlbW90ZUNoYW5nZXMuZmlsdGVyKGM9PmMuc3RhdHVzIT1cIlJFTU9WRURcIikucmVkdWNlKFxuICAgICAgICAgICAgKGFjYywgY2hhbmdlKSA9PiB7XG4gICAgICAgICAgICAgICAgYWNjW2NoYW5nZS5wYXRoXSA9IGNoYW5nZS5jdXJyZW50U2hhIGFzIHN0cmluZztcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30gYXMgUmVjb3JkPHN0cmluZywgc3RyaW5nPik7XG5cbiAgICAgICAgY29uc3QgYWRkVG9Mb2NhbCA9IGF3YWl0IHRoaXMuZ2V0UmVtb3RlTm9uRGVsZXRpb25DaGFuZ2VzQ29udGVudChjaGFuZ2VzVG9Qcm9jZXNzKVxuXG4gICAgICAgIHJldHVybiB7YWRkVG9Mb2NhbCwgZGVsZXRlRnJvbUxvY2FsfVxuICAgIH1cblxuICAgIGFzeW5jIHB1bGxSZW1vdGVUb0xvY2FsKFxuICAgICAgICByZW1vdGVVcGRhdGU6IFJlbW90ZVVwZGF0ZSxcbiAgICAgICAgc2F2ZUxvY2FsU3RvcmVDYWxsYmFjazogU2F2ZUNhbGxiYWNrXG4gICAgKSA6IFByb21pc2U8RmlsZU9wUmVjb3JkW10+XG4gICAge1xuICAgICAgICAgICAgY29uc3Qge3JlbW90ZUNoYW5nZXMsIHJlbW90ZVRyZWVTaGEsIGxhdGVzdFJlbW90ZUNvbW1pdFNoYX0gPSByZW1vdGVVcGRhdGVcbiAgICAgICAgICAgIGxldCB7YWRkVG9Mb2NhbCwgZGVsZXRlRnJvbUxvY2FsfSA9IGF3YWl0IHRoaXMucHJlcGFyZUNoYW5nZXNUb0V4ZWN1dGUocmVtb3RlQ2hhbmdlcylcblxuICAgICAgICAgICAgY29uc3QgYmFzZXBhdGggPSB0aGlzLmZpdC5zeW5jUGF0aFxuICAgICAgICAgICAgYWRkVG9Mb2NhbCA9IHRoaXMuZml0LmdldEFkZFRvTG9jYWwoYWRkVG9Mb2NhbClcbiAgICAgICAgICAgIGRlbGV0ZUZyb21Mb2NhbCA9IHRoaXMuZml0LmdldERlbGV0ZUZyb21Mb2NhbChkZWxldGVGcm9tTG9jYWwpXG5cbiAgICAgICAgICAgIGNvbnN0IGZpbGVPcHNSZWNvcmQgPSBhd2FpdCB0aGlzLmZpdC52YXVsdE9wcy51cGRhdGVMb2NhbEZpbGVzKFxuICAgICAgICAgICAgICAgIGFkZFRvTG9jYWwsXG4gICAgICAgICAgICAgICAgZGVsZXRlRnJvbUxvY2FsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBhd2FpdCBzYXZlTG9jYWxTdG9yZUNhbGxiYWNrKFxuICAgICAgICAgICAgICAgIGJhc2VwYXRoLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdEZldGNoZWRSZW1vdGVTaGE6IHJlbW90ZVRyZWVTaGEsXG4gICAgICAgICAgICAgICAgICAgIGxhc3RGZXRjaGVkQ29tbWl0U2hhOiBsYXRlc3RSZW1vdGVDb21taXRTaGEsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU2hhOiBhd2FpdCB0aGlzLmZpdC5jb21wdXRlTG9jYWxTaGEoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiBmaWxlT3BzUmVjb3JkXG4gICAgfVxufVxuIiwgImltcG9ydCB7IEZpdCwgVHJlZU5vZGUgfSBmcm9tIFwiLi9maXRcIjtcbmltcG9ydCB7IExvY2FsQ2hhbmdlLCBMb2NhbFVwZGF0ZSB9IGZyb20gXCIuL2ZpdFR5cGVzXCI7XG5cblxuZXhwb3J0IGludGVyZmFjZSBJRml0UHVzaCB7XG4gICAgbG9jYWxTaGE6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgICBmaXQ6IEZpdFxufVxuXG5leHBvcnQgY2xhc3MgRml0UHVzaCBpbXBsZW1lbnRzIElGaXRQdXNoIHtcbiAgICBsb2NhbFNoYTogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgICBmaXQ6IEZpdFxuXG5cbiAgICBjb25zdHJ1Y3RvcihmaXQ6IEZpdCkge1xuICAgICAgICB0aGlzLmZpdCA9IGZpdFxuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZUNvbW1pdEZyb21Mb2NhbFVwZGF0ZShsb2NhbFVwZGF0ZTogTG9jYWxVcGRhdGUsIHJlbW90ZVRyZWU6IEFycmF5PFRyZWVOb2RlPik6IFByb21pc2U8e2NyZWF0ZWRDb21taXRTaGE6IHN0cmluZywgcHVzaGVkQ2hhbmdlczogTG9jYWxDaGFuZ2VbXX0gfCBudWxsPiB7XG4gICAgICAgIGNvbnN0IHtsb2NhbENoYW5nZXMsIHBhcmVudENvbW1pdFNoYX0gPSBsb2NhbFVwZGF0ZVxuICAgICAgICBjb25zdCBwdXNoZWRDaGFuZ2VzOiBMb2NhbENoYW5nZVtdID0gW107XG4gICAgICAgIGNvbnN0IHRyZWVOb2RlcyA9IChhd2FpdCBQcm9taXNlLmFsbChsb2NhbENoYW5nZXMubWFwKGFzeW5jIChmLCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gIGF3YWl0IHRoaXMuZml0LmNyZWF0ZVRyZWVOb2RlRnJvbUZpbGUoZiwgcmVtb3RlVHJlZSlcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgcHVzaGVkQ2hhbmdlcy5wdXNoKGxvY2FsQ2hhbmdlc1tpXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSkpLmZpbHRlcihCb29sZWFuKSBhcyBBcnJheTxUcmVlTm9kZT5cbiAgICAgICAgY29uc29sZS5sb2codHJlZU5vZGVzKVxuICAgICAgICBpZiAodHJlZU5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXRlc3RSZW1vdGVDb21taXRUcmVlU2hhID0gYXdhaXQgdGhpcy5maXQuZ2V0Q29tbWl0VHJlZVNoYShwYXJlbnRDb21taXRTaGEpXG4gICAgICAgIGNvbnN0IGNyZWF0ZWRUcmVlU2hhID0gYXdhaXQgdGhpcy5maXQuY3JlYXRlVHJlZSh0cmVlTm9kZXMsIGxhdGVzdFJlbW90ZUNvbW1pdFRyZWVTaGEpXG4gICAgICAgIGNvbnN0IGNyZWF0ZWRDb21taXRTaGEgPSBhd2FpdCB0aGlzLmZpdC5jcmVhdGVDb21taXQoY3JlYXRlZFRyZWVTaGEsIHBhcmVudENvbW1pdFNoYSlcbiAgICAgICAgcmV0dXJuIHtjcmVhdGVkQ29tbWl0U2hhLCBwdXNoZWRDaGFuZ2VzfVxuICAgIH1cblxuXG5cbiAgICBhc3luYyBwdXNoQ2hhbmdlZEZpbGVzVG9SZW1vdGUoXG4gICAgICAgIGxvY2FsVXBkYXRlOiBMb2NhbFVwZGF0ZSxcbiAgICAgICAgKTogUHJvbWlzZTx7cHVzaGVkQ2hhbmdlczogTG9jYWxDaGFuZ2VbXSwgbGFzdEZldGNoZWRSZW1vdGVTaGE6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4sIGxhc3RGZXRjaGVkQ29tbWl0U2hhOiBzdHJpbmd9fG51bGw+IHtcbiAgICAgICAgICAgIGlmIChsb2NhbFVwZGF0ZS5sb2NhbENoYW5nZXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBkaWQgbm90IHVwZGF0ZSByZWZcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29uc3Qge2xvY2FsVHJlZVNoYX0gPSBsb2NhbFVwZGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IHJlbW90ZVRyZWUgPSBhd2FpdCB0aGlzLmZpdC5nZXRUcmVlKGxvY2FsVXBkYXRlLnBhcmVudENvbW1pdFNoYSlcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZUNvbW1pdFJlc3VsdCA9IGF3YWl0IHRoaXMuY3JlYXRlQ29tbWl0RnJvbUxvY2FsVXBkYXRlKGxvY2FsVXBkYXRlLCByZW1vdGVUcmVlKVxuICAgICAgICAgICAgaWYgKCFjcmVhdGVDb21taXRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAvLyBkaWQgbm90IHVwZGF0ZSByZWZcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qge2NyZWF0ZWRDb21taXRTaGEsIHB1c2hlZENoYW5nZXN9ID0gY3JlYXRlQ29tbWl0UmVzdWx0XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkUmVmU2hhID0gYXdhaXQgdGhpcy5maXQudXBkYXRlUmVmKGNyZWF0ZWRDb21taXRTaGEpXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkUmVtb3RlVHJlZVNoYSA9IGF3YWl0IHRoaXMuZml0LmdldFJlbW90ZVRyZWVTaGEodXBkYXRlZFJlZlNoYSlcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcHVzaGVkQ2hhbmdlcyxcbiAgICAgICAgICAgICAgICBsYXN0RmV0Y2hlZFJlbW90ZVNoYTogdXBkYXRlZFJlbW90ZVRyZWVTaGEsXG4gICAgICAgICAgICAgICAgbGFzdEZldGNoZWRDb21taXRTaGE6IGNyZWF0ZWRDb21taXRTaGEsXG4gICAgICAgICAgICB9XG4gICAgfVxufVxuIiwgImltcG9ydCB7IExpc3RlZEZpbGVzLCBURmlsZSwgVEZvbGRlciwgVmF1bHQsIGJhc2U2NFRvQXJyYXlCdWZmZXIgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IEZpbGVPcFJlY29yZCB9IGZyb20gXCIuL2ZpdFR5cGVzXCI7XG5pbXBvcnQgeyBjb25mbGljdFJlc29sdXRpb25Gb2xkZXIgfSBmcm9tIFwiLi9jb25zdFwiO1xuXG50eXBlIEZpbGVzRm9sZGVycyA9IHtcbiAgICBmb2xkZXJzOiBzdHJpbmdbXVxuICAgIGZpbGVzOiBzdHJpbmdbXVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElWYXVsdE9wZXJhdGlvbnMge1xuICAgIHZhdWx0OiBWYXVsdFxuICAgIGRlbGV0ZUZyb21Mb2NhbDogKHBhdGg6IHN0cmluZykgPT4gUHJvbWlzZTxGaWxlT3BSZWNvcmQgfCBudWxsPlxuICAgIHdyaXRlVG9Mb2NhbDogKHBhdGg6IHN0cmluZywgY29udGVudDogc3RyaW5nKSA9PiBQcm9taXNlPEZpbGVPcFJlY29yZD5cbiAgICB1cGRhdGVMb2NhbEZpbGVzOiAoXG4gICAgICAgIGFkZFRvTG9jYWw6IHtwYXRoOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZ31bXSxcbiAgICAgICAgZGVsZXRlRnJvbUxvY2FsOiBBcnJheTxzdHJpbmc+XG4gICAgKSA9PiBQcm9taXNlPEZpbGVPcFJlY29yZFtdPlxuXG4gICAgY3JlYXRlQ29weUluRGlyOiAocGF0aDogc3RyaW5nLCBjb3B5RGlyOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD5cbn1cblxuZXhwb3J0IGNsYXNzIFZhdWx0T3BlcmF0aW9ucyBpbXBsZW1lbnRzIElWYXVsdE9wZXJhdGlvbnMge1xuICAgIHZhdWx0OiBWYXVsdFxuXG4gICAgY29uc3RydWN0b3IodmF1bHQ6IFZhdWx0KSB7XG4gICAgICAgIHRoaXMudmF1bHQgPSB2YXVsdFxuICAgIH1cblxuICAgIGFzeW5jIGdldFRGaWxlKHBhdGg6IHN0cmluZyk6IFByb21pc2U8VEZpbGUgfCBudWxsPiB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwYXRoKVxuICAgICAgICBpZiAoZmlsZSAmJiBmaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWxlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKGBBdHRlbXB0aW5nIHRvIHJlYWQgJHtwYXRofSBmcm9tIGxvY2FsIGRyaXZlIGFzIFRGaWxlIGJ1dCBub3Qgc3VjY2Vzc2Z1bCxcbiAgICAgICAgICAgIC8vIGZpbGUgaXMgb2YgdHlwZSAke3R5cGVvZiBmaWxlfS5gKVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZGVsZXRlRnJvbUxvY2FsKHBhdGg6IHN0cmluZyk6IFByb21pc2U8RmlsZU9wUmVjb3JkIHwgbnVsbD4ge1xuICAgICAgICAvLyBhZG9wdGVkIGdldEFic3RyYWN0RmlsZUJ5UGF0aCBmb3IgbW9iaWxlIGNvbXBhdGlhYmlsaXR5XG4gICAgICAgIC8vIHVzZSBhZGFwdGVyIGZvciBmaWxlcyBpbiB0aGUgLm9ic2lkaWFuXG4gICAgICAgIC8vIGNvbnN0IGZpbGUgPSB0aGlzLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwYXRoKVxuICAgICAgICBjb25zdCBpc0V4aXN0cyA9IGF3YWl0IHRoaXMudmF1bHQuYWRhcHRlci5leGlzdHMocGF0aClcbiAgICAgICAgaWYgKCFpc0V4aXN0cykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQXR0ZW1wdGluZyB0byByZWFkICR7cGF0aH0gZnJvbSBsb2NhbCBkcml2ZSBidXQgbm90IHN1Y2Nlc3NmdWw6XG4gICAgICAgICAgICAgICAgdGhlIGZpbGUgZG9lc24ndCBleGlzdHNgKVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgdGhpcy52YXVsdC5hZGFwdGVyLnJlbW92ZShwYXRoKTtcbiAgICAgICAgcmV0dXJuIHtwYXRoLCBzdGF0dXM6IFwiZGVsZXRlZFwifVxuICAgIH1cblxuICAgIC8vIGlmIGNoZWNraW5nIGEgZm9sZGVyLCByZXF1aXJlIGluY2x1ZGluZyB0aGUgbGFzdCAvIGluIHRoZSBwYXRoIHBhcmFtXG4gICAgYXN5bmMgZW5zdXJlRm9sZGVyRXhpc3RzKHBhdGg6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICAvLyBleHRyYWN0IGZvbGRlciBwYXRoLCByZXR1cm4gZW1wdHkgc3RyaW5nIGlzIG5vIGZvbGRlciBwYXRoIGlzIG1hdGNoZWQgKGV4Y2x1ZGUgdGhlIGxhc3QgLylcbiAgICAgICAgY29uc3QgZm9sZGVyUGF0aCA9IHBhdGgubWF0Y2goL14oLiopXFwvLyk/LlsxXSB8fCAnJztcbiAgICAgICAgaWYgKGZvbGRlclBhdGggPT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAvLyBjb25zdCBmb2xkZXIgPSB0aGlzLnZhdWx0LmFkYXB0ZXIuZXhpc3RzKGZvbGRlclBhdGgpXG4gICAgICAgICAgICAvLyBpZiAoIWZvbGRlcikge1xuICAgICAgICAgICAgLy8gICAgIC8vIFRPRE8gXHUwNDQ3XHUwNDQyXHUwNDNFIFx1MDQzNVx1MDQ0MVx1MDQzQlx1MDQzOCBcdTA0M0RcdTA0MzVcdTA0NDFcdTA0M0FcdTA0M0VcdTA0M0JcdTA0NENcdTA0M0FcdTA0M0UgXHUwNDMyXHUwNDNCXHUwNDNFXHUwNDM2XHUwNDM1XHUwNDNEXHUwNDNEXHUwNDRCXHUwNDQ1IFx1MDQzRlx1MDQzMFx1MDQzRlx1MDQzRVx1MDQzQSAobWtkaXIgLXAgLi4uLilcbiAgICAgICAgICAgIC8vICAgICBhd2FpdCB0aGlzLnZhdWx0LmFkYXB0ZXIubWtkaXIoZm9sZGVyUGF0aClcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJ0cyA9IGZvbGRlclBhdGguc3BsaXQoJy8nKTtcbiAgICAgICAgbGV0IGN1cnJlbnRQYXRoID0gJyc7XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgICAgICAgICAgY3VycmVudFBhdGggKz0gcGFydCArICcvJztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNFeGlzdHMgPSBhd2FpdCB0aGlzLnZhdWx0LmFkYXB0ZXIuZXhpc3RzKGN1cnJlbnRQYXRoLCB0cnVlKVxuXG4gICAgICAgICAgICAgICAgaWYgKGlzRXhpc3RzKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy52YXVsdC5hZGFwdGVyLm1rZGlyKGN1cnJlbnRQYXRoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGFzeW5jIHdyaXRlVG9Mb2NhbChwYXRoOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyk6IFByb21pc2U8RmlsZU9wUmVjb3JkPiB7XG4gICAgICAgIC8vIFRPRE86IGFkZCBjYXBhYmlsaXR5IGZvciBjcmVhdGluZyBmb2xkZXIgZnJvbSByZW1vdGVcbiAgICAgICAgY29uc3QgZmlsZSA9IGF3YWl0IHRoaXMudmF1bHQuYWRhcHRlci5leGlzdHMocGF0aClcblxuICAgICAgICAvLyBUT0RPIHJlZmFjdG9yIGlmIGVsc2VcbiAgICAgICAgaWYgKGZpbGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudmF1bHQuYWRhcHRlci53cml0ZUJpbmFyeShwYXRoLCBiYXNlNjRUb0FycmF5QnVmZmVyKGNvbnRlbnQpKVxuICAgICAgICAgICAgcmV0dXJuIHtwYXRoLCBzdGF0dXM6IFwiY2hhbmdlZFwifVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5lbnN1cmVGb2xkZXJFeGlzdHMocGF0aClcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudmF1bHQuYWRhcHRlci53cml0ZUJpbmFyeShwYXRoLCBiYXNlNjRUb0FycmF5QnVmZmVyKGNvbnRlbnQpKVxuICAgICAgICAgICAgcmV0dXJuIHtwYXRoLCBzdGF0dXM6IFwiY3JlYXRlZFwifVxuICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoYCR7cGF0aH06IHdyaXRlVG9Mb2NhbCBvcGVyYXRpb24gdW5zdWNjZXNzZnVsYCk7XG4gICAgfVxuXG4gICAgYXN5bmMgdXBkYXRlTG9jYWxGaWxlcyhcbiAgICAgICAgYWRkVG9Mb2NhbDoge3BhdGg6IHN0cmluZywgY29udGVudDogc3RyaW5nfVtdLFxuICAgICAgICBkZWxldGVGcm9tTG9jYWw6IEFycmF5PHN0cmluZz4pOiBQcm9taXNlPEZpbGVPcFJlY29yZFtdPlxuICAgIHtcbiAgICAgICAgLy8gUHJvY2VzcyBmaWxlIGFkZGl0aW9ucyBvciB1cGRhdGVzXG4gICAgICAgIGNvbnN0IHdyaXRlT3BlcmF0aW9ucyA9IGFkZFRvTG9jYWwubWFwKGFzeW5jICh7cGF0aCwgY29udGVudH0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLndyaXRlVG9Mb2NhbChwYXRoLCBjb250ZW50KVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBQcm9jZXNzIGZpbGUgZGVsZXRpb25zXG4gICAgICAgIGNvbnN0IGRlbGV0aW9uT3BlcmF0aW9ucyA9IGRlbGV0ZUZyb21Mb2NhbC5tYXAoYXN5bmMgKHBhdGgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmRlbGV0ZUZyb21Mb2NhbChwYXRoKVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZmlsZU9wcyA9IGF3YWl0IFByb21pc2UuYWxsKFsuLi53cml0ZU9wZXJhdGlvbnMsIC4uLmRlbGV0aW9uT3BlcmF0aW9uc10pO1xuXG4gICAgICAgIHJldHVybiBmaWxlT3BzIGFzIEZpbGVPcFJlY29yZFtdXG4gICAgfVxuXG4gICAgLy8gVE9ETyBcdTA0NDVcdTA0M0VcdTA0NDJcdTA0NEYgXHUwNDNEXHUwNDM4XHUwNDMzXHUwNDM0XHUwNDM1IFx1MDQzRFx1MDQzNSBcdTA0MzhcdTA0NDFcdTA0M0ZcdTA0M0VcdTA0M0JcdTA0NENcdTA0MzdcdTA0NDNcdTA0MzVcdTA0NDJcdTA0NDFcdTA0NEYsIFx1MDQzQ1x1MDQzMSBcdTA0NDNcdTA0MzRcdTA0MzBcdTA0M0JcdTA0MzhcdTA0NDJcdTA0NEMgXHUwNDNEXHUwNDMwXHUwNDM0XHUwNDNFXG4gICAgYXN5bmMgY3JlYXRlQ29weUluRGlyKHBhdGg6IHN0cmluZywgY29weURpciA9IGNvbmZsaWN0UmVzb2x1dGlvbkZvbGRlcik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBmaWxlID0gYXdhaXQgdGhpcy52YXVsdC5hZGFwdGVyLmV4aXN0cyhwYXRoKVxuICAgICAgICBpZiAoZmlsZSkge1xuICAgICAgICAgICAgY29uc3QgY29weVBhdGggPSBjb3B5RGlyICsgcGF0aFxuXG4gICAgICAgICAgICBjb25zdCBjb3B5ID0gYXdhaXQgdGhpcy52YXVsdC5hZGFwdGVyLnJlYWRCaW5hcnkocGF0aClcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlRm9sZGVyRXhpc3RzKGNvcHlQYXRoKVxuXG4gICAgICAgICAgICAvLyBjb25zdCBjb3B5RmlsZSA9IGF3YWl0IHRoaXMudmF1bHQuYWRhcHRlci5leGlzdHMocGF0aClcbiAgICAgICAgICAgIC8vIGlmIChjb3B5RmlsZSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudmF1bHQuYWRhcHRlci53cml0ZUJpbmFyeShjb3B5UGF0aCwgY29weSlcbiAgICAgICAgICAgIC8vIH0gZWxzZSBpZiAoIWNvcHlGaWxlKSB7XG4gICAgICAgICAgICAvLyAgICAgYXdhaXQgdGhpcy52YXVsdC5jcmVhdGVCaW5hcnkoY29weVBhdGgsIGNvcHkpXG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gICAgIHRoaXMudmF1bHQuYWRhcHRlci5yZW1vdmUoY29weUZpbGUpIC8vIFRPRE8gYWRkIHdhcm5pbmcgdG8gbGV0IHVzZXIga25vdyBmaWxlcyBpbiBfZml0IHdpbGwgYmUgb3ZlcndyaXR0ZW5cbiAgICAgICAgICAgIC8vICAgICBhd2FpdCB0aGlzLnZhdWx0LmNyZWF0ZUJpbmFyeShjb3B5UGF0aCwgY29weSlcbiAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgYXdhaXQgdGhpcy52YXVsdC5hZGFwdGVyLndyaXRlQmluYXJ5KGNvcHlQYXRoLCBjb3B5KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdHRlbXB0aW5nIHRvIGNyZWF0ZSBjb3B5IG9mICR7cGF0aH0gZnJvbSBsb2NhbCBkcml2ZSBhcyBURmlsZSBidXQgbm90IHN1Y2Nlc3NmdWwsXG4gICAgICAgICAgICBmaWxlIGlzIG9mIHR5cGUgJHt0eXBlb2YgZmlsZX0uYClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGdldEFsbEluT2JzaWRpYW4oKTogUHJvbWlzZTxGaWxlc0ZvbGRlcnM+IHtcbiAgICAgICAgY29uc3Qgcm9vdFBhdGggPSB0aGlzLnZhdWx0LmNvbmZpZ0RpcjtcblxuICAgICAgICBjb25zdCBmb2xkZXJzOiBzdHJpbmdbXSA9IFtyb290UGF0aCArIFwiL1wiXTtcbiAgICAgICAgY29uc3QgZmlsZXM6IHN0cmluZ1tdID0gW107XG5cbiAgICAgICAgY29uc3QgdHJhdmVyc2VEaXJlY3RvcnkgPSBhc3luYyAocGF0aDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICBsZXQgaXRlbXM6IExpc3RlZEZpbGVzXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGl0ZW1zID0gYXdhaXQgdGhpcy52YXVsdC5hZGFwdGVyLmxpc3QocGF0aCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoYEVycm9yIHRyYXZlcnNpbmcgZGlyZWN0b3J5ICR7cGF0aH06YCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgZm9sZGVyIG9mIGl0ZW1zLmZvbGRlcnMpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0cmF2ZXJzZURpcmVjdG9yeShmb2xkZXIpO1xuXG4gICAgICAgICAgICAgICAgbGV0IGZvbGRlclBhdGggPSBmb2xkZXIuc3RhcnRzV2l0aCgnLycpID8gZm9sZGVyLnNsaWNlKDEpIDogZm9sZGVyO1xuICAgICAgICAgICAgICAgIGZvbGRlclBhdGggPSBmb2xkZXJQYXRoID09PSBcIlwiID8gXCJcIiA6IGAke2ZvbGRlclBhdGh9L2A7XG5cbiAgICAgICAgICAgICAgICBmb2xkZXJzLnB1c2goZm9sZGVyUGF0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgZmlsZSBvZiBpdGVtcy5maWxlcykge1xuICAgICAgICAgICAgICAgIGxldCBmaWxlUGF0aCA9IGZpbGUuc3RhcnRzV2l0aCgnLycpID8gZmlsZS5zbGljZSgxKSA6IGZpbGU7XG5cbiAgICAgICAgICAgICAgICBmaWxlcy5wdXNoKGZpbGVQYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBhd2FpdCB0cmF2ZXJzZURpcmVjdG9yeShyb290UGF0aCk7XG5cbiAgICAgICAgcmV0dXJuIHtmb2xkZXJzLCBmaWxlc31cbiAgICB9XG5cbiAgICBhc3luYyBnZXRBbGxJblZhdWx0KCk6IFByb21pc2U8RmlsZXNGb2xkZXJzPiB7XG4gICAgICAgIGNvbnN0IGFsbCA9IHRoaXMudmF1bHQuZ2V0QWxsTG9hZGVkRmlsZXMoKTtcblxuICAgICAgICBjb25zdCBmb2xkZXJzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBjb25zdCBmaWxlczogc3RyaW5nW10gPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBmaWxlIG9mIGFsbCkge1xuICAgICAgICAgICAgaWYgKGZpbGUgaW5zdGFuY2VvZiBURm9sZGVyKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhdGggPSBmaWxlLnBhdGguc3RhcnRzV2l0aCgnLycpID8gZmlsZS5wYXRoLnNsaWNlKDEpIDogZmlsZS5wYXRoO1xuICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoID09IFwiXCIgPyBcIlwiIDogYCR7cGF0aH0vYFxuICAgICAgICAgICAgICAgIGZvbGRlcnMucHVzaChwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSBmaWxlLnBhdGguc3RhcnRzV2l0aCgnLycpID8gZmlsZS5wYXRoLnNsaWNlKDEpIDogZmlsZS5wYXRoO1xuICAgICAgICAgICAgICAgIGZpbGVzLnB1c2gocGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyAub2JzaWRpYW4gZm9sZGVyXG4gICAgICAgIGNvbnN0IG9ic2lkaWFuSXRlbXMgPSBhd2FpdCB0aGlzLmdldEFsbEluT2JzaWRpYW4oKVxuICAgICAgICBjb25zdCBbb2JzaWRpYW5GaWxlcywgb2JzaWRpYW5Gb2xkZXJzXSA9IFtvYnNpZGlhbkl0ZW1zLmZpbGVzLCBvYnNpZGlhbkl0ZW1zLmZvbGRlcnNdXG5cbiAgICAgICAgZm9sZGVycy5wdXNoKC4uLm9ic2lkaWFuRm9sZGVycylcbiAgICAgICAgZmlsZXMucHVzaCguLi5vYnNpZGlhbkZpbGVzKVxuXG4gICAgICAgIHJldHVybiB7Zm9sZGVycywgZmlsZXN9O1xuICAgIH1cblxuICAgIGFzeW5jIGdldEZvbGRlcnNJblZhdWx0KCk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICAgICAgY29uc3Qge2ZvbGRlcnN9ID0gYXdhaXQgdGhpcy5nZXRBbGxJblZhdWx0KClcblxuICAgICAgICByZXR1cm4gZm9sZGVycztcbiAgICB9XG5cbiAgICBhc3luYyBnZXRGaWxlc0luVmF1bHQoKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgICAgICBjb25zdCB7ZmlsZXN9ID0gYXdhaXQgdGhpcy5nZXRBbGxJblZhdWx0KClcblxuICAgICAgICByZXR1cm4gZmlsZXM7XG4gICAgfVxufVxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGlCQUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxtQkFBa0U7OztBQ0FsRSxJQUFNLGdCQUFnQjtBQUVmLElBQU0sMkJBQTJCLGdCQUFnQjtBQUVqRCxJQUFNLFlBQVk7OztBQ0psQixTQUFTLGVBQWU7QUFDN0IsTUFBSSxPQUFPLGNBQWMsWUFBWSxlQUFlLFdBQVc7QUFDN0QsV0FBTyxVQUFVO0FBQUEsRUFDbkI7QUFFQSxNQUFJLE9BQU8sWUFBWSxZQUFZLFFBQVEsWUFBWSxRQUFXO0FBQ2hFLFdBQU8sV0FBVyxRQUFRLFFBQVEsT0FBTyxDQUFDLE1BQU0sUUFBUSxhQUN0RCxRQUFRO0FBQUEsRUFFWjtBQUVBLFNBQU87QUFDVDs7O0FDVk8sU0FBUyxTQUFTLE9BQU8sTUFBTSxRQUFRLFNBQVM7QUFDckQsTUFBSSxPQUFPLFdBQVcsWUFBWTtBQUNoQyxVQUFNLElBQUksTUFBTSwyQ0FBMkM7QUFBQSxFQUM3RDtBQUVBLE1BQUksQ0FBQyxTQUFTO0FBQ1osY0FBVSxDQUFDO0FBQUEsRUFD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R0EsY0FBYyxVQUFrQixVQUFrQjtBQUM5QyxRQUFJLEtBQUssV0FBVztBQUNoQixXQUFLLFVBQVUsTUFBTTtBQUdyQixXQUFLLFVBQVUsU0FBUyxNQUFNLEVBQUUsTUFBTSxxR0FBcUIsQ0FBQztBQUM1RCxXQUFLLFVBQVUsU0FBUyxLQUFLLEVBQUUsTUFBTSxzREFBYyxXQUFXLENBQUM7QUFDL0QsV0FBSyxVQUFVLFNBQVMsS0FBSyxFQUFFLE1BQU0sNkJBQVMsV0FBVyxDQUFDO0FBQzFELFdBQUssVUFBVSxTQUFTLEtBQUs7QUFBQSxRQUN6QixNQUFNO0FBQUEsUUFDTixLQUFLO0FBQUEsTUFDVCxDQUFDO0FBQUEsSUFDTDtBQUFBLEVBQ0o7QUFDSjsiLAogICJuYW1lcyI6IFsiRml0UGx1Z2luIiwgImltcG9ydF9vYnNpZGlhbiIsICJuYW1lIiwgIm1ldGhvZCIsICJob29rIiwgImhvb2siLCAiZ2V0VXNlckFnZW50IiwgImdldFVzZXJBZ2VudCIsICJnZXRVc2VyQWdlbnQiLCAiVkVSU0lPTiIsICJpc1BsYWluT2JqZWN0IiwgIndpdGhEZWZhdWx0cyIsICJnZXRVc2VyQWdlbnQiLCAiZ2V0VXNlckFnZW50IiwgIlZFUlNJT04iLCAid2l0aERlZmF1bHRzIiwgImdldFVzZXJBZ2VudCIsICJyZXF1ZXN0IiwgImVuZHBvaW50IiwgIlZFUlNJT04iLCAiVkVSU0lPTiIsICJob29rIiwgImF1dGgiLCAiaGVhZGluZyIsICJpbXBvcnRfb2JzaWRpYW4iLCAicmVzdWx0IiwgImltcG9ydF9vYnNpZGlhbiIsICJfYSIsICJpbXBvcnRfb2JzaWRpYW4iLCAiX2EiLCAiZm9sZGVycyIsICJpbXBvcnRfb2JzaWRpYW4iLCAicmVtb3RlQ29udGVudCIsICJpbXBvcnRfb2JzaWRpYW4iLCAiRml0UGx1Z2luIl0KfQo=
